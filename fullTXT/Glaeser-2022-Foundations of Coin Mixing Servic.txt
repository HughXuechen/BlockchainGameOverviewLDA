Foundations of Coin Mixing Services
Foundations of Coin Mixing Services
Noemi Glaeser
University of Maryland
College Park, MD, USA
Max Planck Insitute for Security and
Privacy
Bochum, Germany
nglaeser@umd.edu
Matteo Maffei
TU Wien
Christian Doppler Laboratory
Blockchain Technologies for the
Internet of Things
Vienna, Austria
matteo.maffei@tuwien.ac.at
Giulio Malavolta
Max Planck Institute for Security and
Privacy
Bochum, Germany
giulio.malavolta@hotmail.it
Pedro Moreno-Sanchez
IMDEA Software Institute
Madrid, Spain
pedro.moreno@imdea.org
Erkan Tairi
TU Wien
Christian Doppler Laboratory
Blockchain Technologies for the
Internet of Things
Vienna, Austria
erkan.tairi@tuwien.ac.at
Sri AravindaKrishnan
Thyagarajan
Carnegie Mellon University
Pittsburgh, PA, USA
t.srikrishnan@gmail.com
ABSTRACT
Coin mixing services allow users to mix their cryptocurrency coins
and thus enable unlinkable payments in a way that prevents track-
ing of honest usersâ€™ coins by both the service provider and the users
themselves. The easy bootstrapping of new users and backwards
compatibility with cryptocurrencies (such as Bitcoin) with limited
support for scripts are attractive features of this architecture, which
has recently gained considerable attention in both academia and
industry.
A recent work of Tairi et al. [IEEE S&P 2021] formalizes the no-
tion of a coinmixing service and proposes A
2
L, a new cryptographic
protocol that simultaneously achieves high efficiency and interop-
erability. In this work, we identify a gap in their formal model and
substantiate the issue by showing two concrete counterexamples:
we show how to construct two encryption schemes that satisfy
their definitions but lead to a completely insecure system.
To amend this situation, we investigate secure constructions of
coin mixing services. First, we develop the notion of blind condi-
tional signatures (BCS), which acts as the cryptographic core for
coin mixing services. We propose game-based security definitions
for BCS and propose A
2
L
+
, a modified version of the protocol by
Tairi et al. that satisfies our security definitions. Our analysis is in
an idealized model (akin to the algebraic group model) and assumes
the hardness of the one-more discrete logarithm problem. Finally,
we propose A
2
L
UC
, another construction of BCS that achieves the
stronger notion of UC-security (in the standard model), albeit with
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA
Â© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9450-5/22/11. . . $15.00
https://doi.org/10.1145/3548606.3560637
a significant increase in computation cost. This suggests that con-
structing a coin mixing service protocol secure under composi-
tion requires more complex cryptographic machinery than initially
thought.
CCS CONCEPTS
â€¢ Security and privacy â†’ Cryptanalysis and other attacks;
Mathematical foundations of cryptography.
KEYWORDS
blockchain, cryptocurrencies, coin mixing services, cryptanalysis,
game-based security, universal composability
ACM Reference Format:
Noemi Glaeser, Matteo Maffei, Giulio Malavolta, Pedro Moreno-Sanchez,
Erkan Tairi, and Sri AravindaKrishnan Thyagarajan. 2022. Foundations of
Coin Mixing Services. In Proceedings of the 2022 ACM SIGSAC Conference
on Computer and Communications Security (CCS â€™22), November 7â€“11, 2022,
Los Angeles, CA, USA. ACM, New York, NY, USA, 15 pages. https://doi.org/
10.1145/3548606.3560637
1 INTRODUCTION
Bitcoin and cryptocurrencies sharing Bitcoinâ€™s core principles have
attained huge prominence as decentralized and publicly verifiable
payment systems. They have attracted not only cryptocurrency
enthusiasts but also banks [5], leading IT companies (e.g., Face-
book and PayPal), and payment providers such as Visa [20]. At the
same time, the initial perception of payment unlinkability based
on pseudonyms has been refuted in numerous academic research
works [40, 51], and the blockchain surveillance industry [31] demon-
strates this privacy breach in practice. This has led to a large amount
of work devoted to providing a privacy-preserving overlay to Bit-
coin in the form of coin mixing protocols [6, 26].
Decentralized coin mixing protocols such as CoinJoin [1] or
CoinShuffle [45â€“47] allow a set of mutually distrusting users to
mix their coins to achieve unlinkability: that is, the coins cannot
be linked to their initial owners even by malicious participants.
These protocols suffer from a common drawback, the bootstrapping
1259
https://orcid.org/0000-0002-6464-2534
https://orcid.org/0000-0002-2283-4829
https://doi.org/10.1145/3548606.3560637
https://doi.org/10.1145/3548606.3560637
https://doi.org/10.1145/3548606.3560637
http://crossmark.crossref.org/dialog/?doi=10.1145%2F3548606.3560637&domain=pdf&date_stamp=2022-11-07
CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA Noemi Glaeser et al.
problem, i.e., how to find a set of participants to execute the protocol.
In fact, while a high number of participants is desirable to improve
the anonymity guarantees provided by the coin mixing protocol,
such a high number is at the same time undesirable as it results in
poor scalability and makes bootstrapping harder.
An alternative mechanism is one in which a third party, referred
to as the hub, alleviates the bootstrapping problem by connecting
users that want to mix their coins. Moreover, the hub itself can
provide a coin mixing service by acting as a tumbler. In more detail,
users send their coins to the hub, which, after collecting all the
coins, sends them back to the users in a randomized order, thereby
providing unlinkability for an observer of such transfers (e.g., an
observer of the corresponding Bitcoin transactions).
Synchronization Puzzles. There are numerous reported cases
of â€œexit scamsâ€ by mixing services which took in new payments
but stopped providing the mixing service [52]. This has prompted
the design of numerous cryptographic protocols [2, 14, 33, 54] to
remove trust from the hub, providing a trade-off between trust
assumptions, minimum number of transactions, and Bitcoin com-
patibility [32]. Of particular interest is the work by Heilman et
al. [32], which lays the groundwork for the core cryptographic
primitive which can be used to build a mixing service. This primi-
tive, referred to as a synchronization puzzle, enables unlinkability
from even the view of a corrupt hub. However, Heilman et al. only
present informal descriptions of the security and privacy notions
of interest. Furthermore, the protocol proposed (TumbleBit) relies
on hashed time-lock contracts (HTLCs), a smart contract incompat-
ible with major cryptocurrencies such as Monero, Stellar, Ripple,
MimbleWimble, and Zerocash (shielded addresses), lowering the
interoperability of the solution.
The recent work of Tairi et al. [53] attempts to overcome both of
these limitations. It gives formal security notions for a synchroniza-
tion puzzle in the universal composability (UC) framework [16]. It
also provides an instantiation of the synchronization puzzle (called
A
2
L) that is simultaneously more efficient and more interopera-
ble than TumbleBit, requiring only timelocks and digital signature
verification from the underlying cryptocurrencies.
In this work, we identify a gap in their security analysis, and we
substantiate the issue by presenting two concrete counterexamples:
there exist two encryption schemes (secure under standard crypto-
graphic assumptions) that satisfy the prerequisites of their security
notions, yet yield completely insecure systems. This shows that
our understanding of synchronization puzzles as a cryptographic
primitive is still inadequate. Establishing firm foundations for this
important cryptographic primitive requires us to rethink this object
from the ground up.
1.1 Our Contributions
We summarize the contributions of this work below.
Counterexamples. First, we identify a gap in the security model
of the synchronization puzzle protocol A
2
L [53], presenting two
concrete counterexamples (Section 3). Specifically, we show that
there exist underlying cryptographic building blocks that satisfy
the prerequisites stated in A
2
L, yet they allow for:
â€¢ a key recovery attack, in which a user can learn the long-term
secret decryption key of the hub;
â€¢ a one-more signature attack, in which a user can obtain ğ‘› signed
transactions from the hub while only engaging in ğ‘›âˆ’1 successful
instances of signing a transaction which pays the hub. In other
words, the user obtains ğ‘› coins from the hub while the hub
receives only ğ‘› âˆ’ 1 coins.
Both attacks run in polynomial time and succeed with overwhelm-
ing probability.
Definitions. To place the synchronization puzzle on firmer foun-
dations, we propose a new cryptographic notion that we call blind
conditional signatures (BCS). Our new notion intuitively captures
the functionality of a synchronization puzzle from [32, 53]. BCS is a
simple and easy-to-understand tool, and we formalize its security
notions both in the game-based (Section 4.1) and universal compos-
ability (Section 5) setting. The proposed game-based definitions
for BCS are akin to the well-understood standard security notions
for regular blind signatures [19, 48]. We hope that this abstraction
may lay the foundations for further studies on this primitive in all
cryptocurrencies, scriptless or not.
Constructions.We give two constructions, one that satisfies our
game-based security guarantees and one that is UC-secure. Both
require only the same limited functionality as A
2
L from the under-
lying blockchain. In more detail:
â€¢ We give a modified version of A
2
L (Sections 4.2 and 4.3) which we
refer to as A
2
L
+
that satisfies the game-based notions (Section 4.1)
of BCS, albeit in the linear-only encryption (LOE) model [30].
In this model, the attacker does not directly have access to a
homomorphic encryption scheme; instead, it can perform the
legal operations by querying the corresponding oracles. This
is a strong model with a non-falsifiable flavor, similar to the
generic/algebraic group model [24, 38, 50].
â€¢ We then provide a less efficient construction A
2
L
UC
that securely
realizes the UC notion of BCS (Section 5). This scheme signif-
icantly departs from the construction paradigm of A
2
L and is
based on general-purpose cryptographic tools such as secure
two-party computation (2PC).
Our results hint at the fact that achieving UC-security for a syn-
chronization puzzle requires a radical departure from current con-
struction paradigms, and it is likely to lead to less efficient schemes.
On the other hand, we view the game-based definitions (a central
contribution of our work) as a reasonable middle ground between
security and efficiency.
1.2 Technical Overview
To put our work into context, we give a brief overview of A
2
L [53]
recast as a synchronization puzzle (a notion first introduced in [32]),
and discuss how it can be used as a coin mixing protocol. We then
outline the vulnerabilities in A
2
L and discuss how to fix them using
the tools that we develop in this work.
Synchronization Puzzles. A synchronization puzzle protocol is a
protocol between three parties: Alice, Bob, andHub (refer to Figure 1
for a pictorial description). The synchronization puzzle begins with
Hub and Bob executing a puzzle promise protocol (step 1) with
respect to some message,ğ‘šHB such that Bob receives a puzzle ğœ
that contains a signature ğ‘  (at this point still hidden) onğ‘šHB. Bob
wishes to solve the puzzle and obtain the embedded signature. To do
1260
Foundations of Coin Mixing Services CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA
Hub
1. Puzzle Promise
Alice
Bob
3. Puzzle Solve
Alice Bob
2. Send Puzzle
Alice Bob
4. Send Solution
Puzzle Promise
Puzzle Promise
Puzzle Solve
Puzzle Solve
Figure 1: Protocol flowof the synchronizationpuzzle, the un-
derlying cryptographic mechanism of Tumblebit and A2L.
Our approach in Blind Conditional Signatures follows a sim-
ilar execution. Dotted double-edged arrows indicate 2-party
protocols. Solid arrows indicate secure point-to-point com-
munication.
this, he sends the puzzle ğœ privately to Alice (step 2), who executes
a puzzle solve protocol (step 3) with Hub with respect to some
messageğ‘šAH such that, at the end of the protocol, Alice obtains
the signature ğ‘  , whereas Hub obtains a signature ğ‘  â€² onğ‘šAH . Alice
then sends the signature ğ‘  privately to Bob (step 4). Such a protocol
must satisfy the following properties.
Blindness: The puzzle solve protocol does not leak any information
to Hub about ğœ , and Hub blindly helps solve the puzzle. This ensures
that Hub cannot link puzzles across interactions.
Unlockability: If step 3 is successfully completed, then the secret
ğ‘  must be a valid secret for Bobâ€™s puzzle ğœ . This guarantees that
Hub cannot learn a signature onğ‘šAH , without at the same time
revealing a signature onğ‘šHB.
Unforgeability: Bob cannot output a valid signature onğ‘šHB before
Alice interacts with the Hub.
Towards a Coin Mixing Service. As shown in [32, 53], the syn-
chronization puzzle is the cryptographic core of a coin mixing
service. First, Alice and Bob define the messages
ğ‘šAH : (ğ´ ğ‘£âˆ’âˆ’â†’ ğ» ) andğ‘šHB : (ğ» ğ‘£âˆ’âˆ’â†’ ğµ)
where (ğ‘ˆğ‘–
ğ‘£âˆ’âˆ’â†’ ğ‘ˆ ğ‘— ) denotes a cryptocurrency payment (e.g., on-
chain transaction or a payment over payment channels) that trans-
fers ğ‘£ coins from ğ‘ˆğ‘– to ğ‘ˆ ğ‘— . Second, Alice and Bob run the syn-
chronization puzzle protocol with Hub to synchronize the two
aforementioned transfers. Here, the signatures ğ‘  and ğ‘  â€² are the
ones required to validate the transactions defined byğ‘šAH andğ‘šHB.
The anonymity of mixing follows from the fact that multiple pairs
of users are executing the synchronization puzzle simultaneously
with Hub, and Hub cannot link its interaction on the left to the
corresponding interaction on the right. Throughout the rest of this
work, we mainly focus on the synchronization puzzle as a crypto-
graphic primitive. The application of a coin mixing protocol follows
as prescribed in prior works [32, 53].
The A2L System. In A
2
L, the blindness property is achieved by
making use of a re-randomizable linearly homomorphic (CPA-
secure) encryption. The puzzleğœ contains a ciphertext ğ‘ â† Enc(ekğ» ,
ğ‘ ) encrypting the signature ğ‘  under the encryption key ekğ» of Hub.
During the puzzle solve step, Alice first re-randomizes the cipher-
text (and the underlying plaintext)
ğ‘
ğ‘Ÿâˆ’âˆ’â†’ ğ‘ â€² = Enc(ekğ» , ğ‘  + ğ‘Ÿ )
with a random scalar ğ‘Ÿ . Hub then decrypts ğ‘ â€² to obtain ğ‘  + ğ‘Ÿ , which
in turn reveals a signature ğ‘  â€² on ğ‘šAH .
1
Alice can then strip off
the re-randomization factor ğ‘Ÿ and send ğ‘  to Bob later in step 4. In
the analysis, it is argued that the CPA-security of the encryption
scheme ensures unforgeability, whereas the re-randomization pro-
cess guarantees blindness. Unfortunately, we show in this work
that this claim is flawed.
Counterexamples.We observe that the encryption scheme is only
CPA-secure, and the Hub is offering a decryption oracle in disguise.
In these settings, the right notion of security is the stronger CCA-
security, which accounts exactly for this scenario. However, CCA-
security is at odds with blindness, since we require the scheme to
be (i) linearly homomorphic and (ii) publicly re-randomizable.
2
We
then substantiate this concern by showing two counterexamples.
Specifically, we show that there exist two encryption schemes that
satisfy the prerequisites spelled out by A
2
L, but enable two concrete
attacks against the protocol. Depending on the scheme, we can
launch one of the following attacks:
â€¢ A key recovery attack that completely recovers the long-term
secret key of the hub, i.e., the decryption key dkğ» .
â€¢ A one-more signature attack that allows one to obtain ğ‘› + 1
signatures on transactions from Hub to Bob, while only revealing
ğ‘› signatures on transactions from Alice to Hub. Effectively, this
allows one to steal coins from the hub.
We stress that both these schemes are specifically crafted to make
the protocol fail: their purpose is to highlight a gap in the security
model of A
2
L. As such, they do not imply that A
2
L as implemented
is insecure, although we cannot prove it secure either. For a detailed
description of the attacks, we refer the reader to Section 3.2.
Can We Fix This? In light of our attacks, the natural question is
whether we can establish formally rigorous security guarantees for
the (appropriately patched) A
2
L system. While it seems unlikely
that A
2
L can achieve UC-security (more discussion on this later), we
investigate whether it satisfies some weaker, but still meaningful,
notion of security. Our main observation here is that a weak notion
of CCA-security for encryption schemes suffices to provide formal
guarantees for A
2
L. This notion, which we refer to as one-more CCA-
security, (roughly) states that it is hard to recover the plaintexts
of ğ‘› ciphertexts while querying a decryption oracle at most ğ‘› âˆ’ 1
times. Importantly, this notion is, in principle, not in conflict with
1
This is achieved via the notion of adaptor signatures, but for the sake of this overview
we ignore the exact details of this aspect.
2
It is well known that no encryption scheme that satisfies either of these properties
can be CCA-secure.
1261
CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA Noemi Glaeser et al.
the homomorphism/re-randomization requirements, contrary to
standard CCA-security.
Towards establishing a formal analysis of A
2
L, we introduce the
notion of blind conditional signatures (BCS) as the cryptographic
cornerstone of a synchronization puzzle. We propose game-based
definitions (Section 4.1) similar in spirit to the well-established secu-
rity definitions of regular blind signatures [19, 48]. We then prove
that A
2
L
+
, our appropriately modified version of A
2
L, satisfies
these definitions (Section 4.2). Our analysis comes with an impor-
tant caveat: we analyze the security of our scheme in the linear-only
encryption model. This is a model introduced by Groth [30] that
only models adversaries that are restricted to perform â€œlegalâ€ op-
erations on ciphertexts, similarly to the generic/algebraic group
model. While this is far from a complete analysis, it increases our
confidence in the security of the system.
3
UC-Security.The next question thatwe set out to answer is whether
we can construct a synchronization puzzle that satisfies the strong
notion of UC-security. We do not know how to prove that A
2
L (or
A
2
L
+
) is secure under composition, which is why we prove A
2
L
+
secure only in the game-based setting. The technical difficulty in
proving UC-security is that blindness is unconditional, and we lack
a â€œtrapdoor mechanismâ€ that allows the simulator to link adversar-
ial sessions during simulation in the security analysis; the proof
of UC-security in [53] is flawed due to this same reason. Thus,
in Section 5.2 we develop a different protocol (called A
2
L
UC
) that
we can prove UC-secure in the standard model. The scheme relies
on standard general-purpose cryptographic tools, such as 2PC, and
incurs a significant increase in computation costs. We stress that
we view this scheme as a proof-of-concept, and leave further im-
provements for practical efficiency as an open problem. We hope
that the scheme will shed some light on the barriers that need to
be overcome in order to construct a practically efficient UC-secure
synchronization puzzle.
1.3 Related Work
We recall some relevant related work in the literature.
Unlinkable Transactions. CoinJoin [1], Coinshuffle [45â€“47], and
MÃ¶bius [39] are coin mixing protocols that rely on interested users
coming together and making an on-chain transactions to mix their
coins. These proposals suffer from the bootstrapping problem (users
having to find other interested users for the mix) in addition to
requiring custom scripting language support from the underlying
currency and completing the mix with on-chain transactions. Pe-
run [23] andmixEth [49] aremixing solutions that rely on Ethereum
smart contracts to resolve contentions among users. An alternate
design choice is to incorporate coin unlinkability natively in the
currency. Monero [36] and Zcash [10] are the two most popular
examples of currencies that allow for unlinkable transactions with-
out any special coin mixing protocol. This is enabled by complex
on-chain cryptographic mechanisms that are not supported in other
currencies.
3
We resort to the LOE model because of the seemingly inherent conflict between linear
homomorphism and CCA-like security, both of which are needed for our application
(in our setting, the adversary has access to something akin to a decryption oracle).
Indeed, even proving that ElGamal encryption is CCA1-secure in the standard model is
a long-standing open problem, and we believe that the A
2
L approach would inherently
hit this barrier without some additional assumption.
RCCA Security.A security notion related to one-more CCA is that
of re-randomizable Replayable CCA (RCCA) encryption scheme [43].
The notion guarantees security even if the adversary has access to
a decryption oracle, but only for ciphertexts that do not decrypt
to the challenge messages. This is slightly different from what
we require in our setting, since in our application the adversary
will always query the oracle on encryption of new (non-challenge)
messages (because of the plaintext re-randomization). This makes
it challenging to leverage the guarantees provided by this notion
in our analysis.
2 PRELIMINARIES
We denote by ğ‘› âˆˆ N the security parameter and by ğ‘¥ â† A(in; ğ‘Ÿ )
the output of the algorithm A on input in using ğ‘Ÿ â†$ {0, 1}âˆ— as its
randomness. We often omit this randomness and only mention it
explicitly when required. We say that an algorithm is (non-uniform)
PPT if it runs in probabilistic polynomial time. We say that a func-
tion is negligible if it vanishes faster than any polynomial.
Digital Signature. A digital signature scheme Î DS :=
(KGen, Sign,Vf) has a key generation algorithm (vk, sk) â†
KGen(1ğ‘›) that outputs a verification-signing key pair. The owner
of the signing key sk can compute signatures on a messageğ‘š by
running ğœ â† Sign(sk,ğ‘š), which can be publicly verified using the
corresponding verification key vk by running Vf (vk,ğ‘š, ğœ). We re-
quire that the digital signature scheme satisfies the standard notion
of strong existential unforgeability [29].
Hard Relations. We recall the notion of a hard relation ğ‘… with
statement/witness pairs (ğ‘Œ,ğ‘¦). We denote by Lğ‘… the associated
language defined as Lğ‘… := {ğ‘Œ | âˆƒğ‘¦, (ğ‘Œ,ğ‘¦) âˆˆ ğ‘…}. The relation is
called a hard relation if the following holds: (i) There exists a PPT
sampling algorithm GenR(1ğ‘›) that outputs a statement/witness
pair (ğ‘Œ,ğ‘¦) âˆˆ ğ‘…; (ii) The relation is poly-time decidable; (iii) For all
PPT adversaries A the probability of A on input ğ‘Œ outputting a
witnessğ‘¦ is negligible. In this work we use the discrete log language
LDL defined with respect to a group G with generator ğ‘” and order
ğ‘ . The language is defined as LDL := {ğ‘Œ | âˆƒğ‘¦ âˆˆ Zğ‘ , ğ‘Œ = ğ‘”ğ‘¦} with
corresponding hard relation ğ‘…DL.
Adaptor Signatures. Adaptor signatures [3] let users generate a
pre-signature on amessageğ‘šwhich by itself is not a valid signature,
but can later be adapted into a valid signature using knowledge
of some secret value. More precisely, an adaptor signature scheme
Î ADP := (KGen, PreSig, PreVf,Adapt,Vf, Ext) is defined with re-
spect to a signature scheme Î DS and a hard relation ğ‘…. The key
generation algorithm is the same as in Î DS and outputs a key pair
(vk, sk). The pre-signing algorithm PreSig(sk,ğ‘š,ğ‘Œ ) returns a pre-
signature ï¿½Ìƒï¿½ (we sometimes also refer to this as a partial signature).
The pre-signature verification algorithm PreVf (vk,ğ‘š,ğ‘Œ, ï¿½Ìƒï¿½) verifies
if the pre-signature ï¿½Ìƒï¿½ is correctly generated. The adapt algorithm
Adapt(ï¿½Ìƒï¿½, ğ‘¦) transforms a pre-signature ï¿½Ìƒï¿½ into a valid signature ğœ
given the witness ğ‘¦ for the instance ğ‘Œ of the language Lğ‘… . The
verification algorithm Vf is the same as in Î DS. Finally, we have
the extract algorithm Ext(ï¿½Ìƒï¿½, ğœ, ğ‘Œ ) which, given a pre-signature ï¿½Ìƒï¿½ , a
signature ğœ , and an instance ğ‘Œ , outputs the witness ğ‘¦ for ğ‘Œ . This
can be formalized as pre-signature correctness.
Definition 2.1 (Pre-signature Correctness). An adaptor signature
scheme Î ADP satisfies pre-signature correctness if for every ğ‘› âˆˆ
1262
Foundations of Coin Mixing Services CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA
aSigForgeA,Î ADP
(ğ‘›)
Q := âˆ…
(sk, vk) â† KGen(1ğ‘›)
ğ‘š â† AOS (Â·),OpS (Â·,Â·) (vk)
(ğ‘Œ, ğ‘¦) â† GenR(1ğ‘›)
ï¿½Ìƒï¿½ â† PreSig(sk,ğ‘š,ğ‘Œ )
ğœ â† AOS (Â·),OpS (Â·,Â·) (ï¿½Ìƒï¿½, ğ‘Œ )
return (ğ‘š âˆ‰ Q âˆ§ Vf (vk,ğ‘š, ğœ))
OS (ğ‘š)
ğœ â† Sign(sk,ğ‘š)
Q := Q âˆª {ğ‘š}
return ğœ
OpS (ğ‘š,ğ‘Œ )
ï¿½Ìƒï¿½ â† PreSig(sk,ğ‘š,ğ‘Œ )
Q := Q âˆª {ğ‘š}
return ï¿½Ìƒï¿½
Figure 2: Unforgeability experiment of adaptor signatures
N, every messageğ‘š âˆˆ {0, 1}âˆ—, and every statement/witness pair
(ğ‘Œ,ğ‘¦) âˆˆ ğ‘…, the following holds:
Pr
ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
PreVf (vk,ğ‘š,ğ‘Œ, ï¿½Ìƒï¿½) = 1
âˆ§
Vf (vk,ğ‘š, ğœ) = 1
âˆ§
(ğ‘Œ,ğ‘¦â€²) âˆˆ ğ‘…
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
(sk, vk) â† KGen(1ğ‘›)
ï¿½Ìƒï¿½ â† PreSig(sk,ğ‘š,ğ‘Œ )
ğœ := Adapt(ï¿½Ìƒï¿½, ğ‘¦)
ğ‘¦â€² := Ext(ğœ, ï¿½Ìƒï¿½, ğ‘Œ )
ï£¹ï£ºï£ºï£ºï£ºï£ºï£ºï£ºï£ºï£»
= 1.
In terms of security, we want standard unforgeability even when
the adversary is given access to pre-signatures with respect to the
signing key sk.
Definition 2.2 (Unforgeability). An adaptor signature scheme
Î ADP is aEUF-CMA secure if for every PPT adversary A there
exists a negligible function negl such that
Pr
[
aSigForgeA,Î ADP
(ğ‘›) = 1
]
â‰¤ negl(ğ‘›),
where the experiment aSigForgeA,Î ADP
is defined as in Figure 2.
We also require that, given a pre-signature and a witness for
the instance, one can always adapt the pre-signature into a valid
signature (pre-signature adaptability).
Definition 2.3 (Pre-signature Adaptability). An adaptor signature
scheme Î ADP satisfies pre-signature adaptability if for any ğ‘› âˆˆ N,
any messageğ‘š âˆˆ {0, 1}âˆ—, any statement/witness pair (ğ‘Œ,ğ‘¦) âˆˆ ğ‘…,
any key pair (sk, vk) â† KGen(1ğ‘›), and any pre-signature ï¿½Ìƒï¿½ â†
{0, 1}âˆ— with PreVf (vk,ğ‘š,ğ‘Œ, ï¿½Ìƒï¿½) = 1, we have:
Pr[Vf (vk,ğ‘š,Adapt(ï¿½Ìƒï¿½, ğ‘¦)) = 1] = 1.
Finally, we require that, given a valid pre-signature and a signa-
ture with respect to the same instance, one can efficiently extract
the corresponding witness (witness extractability).
Definition 2.4 (Witness Extractability). An adaptor signature
scheme Î ADP is witness extractable if for every PPT adversary
A, there exists a negligible function negl such that
Pr
[
aWitExtA,Î ADP (ğ‘›) = 1
]
â‰¤ negl(ğ‘›),
where the experiment aWitExtA,Î ADP is defined as in Figure 3.
Combining the three properties described above, we can define
a secure adaptor signature scheme as follows.
Definition 2.5 (Secure Adaptor Signature Scheme). An adaptor
signature scheme Î ADP is secure if it is aEUF-CMA secure, pre-
signature adaptable, and witness extractable.
aWitExtA,Î ADP (ğ‘›)
Q := âˆ…
(sk, vk) â† KGen(1ğ‘›)
(ğ‘š,ğ‘Œ ) â† AOS (Â·),OpS (Â·,Â·) (vk)
ï¿½Ìƒï¿½ â† PreSig(sk,ğ‘š,ğ‘Œ )
ğœ â† AOS (Â·),OpS (Â·,Â·) (ï¿½Ìƒï¿½)
ğ‘¦â€² := Ext(ğœ, ï¿½Ìƒï¿½,ğ‘Œ )
return (ğ‘š âˆ‰ Q âˆ§ (ğ‘Œ, ğ‘¦â€²) âˆ‰ ğ‘…
âˆ§ Vf (vk,ğ‘š, ğœ))
OS (ğ‘š)
ğœ â† Sign(sk,ğ‘š)
Q := Q âˆª {ğ‘š}
return ğœ
OpS (ğ‘š,ğ‘Œ )
ï¿½Ìƒï¿½ â† PreSig(sk,ğ‘š,ğ‘Œ )
Q := Q âˆª {ğ‘š}
return ï¿½Ìƒï¿½
Figure 3: Witness extractability experiment for adaptor sig-
natures
OGen (ğ‘–)
ekğ‘– â†$ {0, 1}ğ‘›
Enter (ğ‘–, ekğ‘– ) into table ğ¾
return ekğ‘–
OEnc (ekğ‘– ,ğ‘š)
ğ‘ ğ‘— â†$ {0, 1}ğ‘›
Enter (ğ‘š,ğ‘ ğ‘— ) into tableğ‘€ğ‘–
return ğ‘ ğ‘—
ODec (ekğ‘– , ğ‘)
if ( Â·, ğ‘) âˆ‰ ğ‘€ğ‘– then return âŠ¥
else
Look upğ‘š corresponding to ğ‘ inğ‘€ğ‘–
returnğ‘š
OAdd (ekğ‘– , ğ‘0, ğ‘1)
Look upğ‘š0,ğ‘š1 corresponding to ğ‘0, ğ‘1 in tableğ‘€ğ‘–
ğ‘ â†$ {0, 1}ğ‘›
Enter (ğ‘š0 +ğ‘š1, ğ‘) into tableğ‘€ğ‘–
return ğ‘
Figure 4: Linear-only encryption oracles
Linear-Only Homomorphic Encryption. A public-key encryp-
tion scheme Î E := (KGen, Enc,Dec) allows one to generate a key
pair (ek, dk) â† KGen(1ğ‘›) that allows anyone to encrypt messages
as ğ‘ â† Enc(ek,ğ‘š) and allows only the owner of the decryption
key dk to decrypt ciphertexts asğ‘š â† Dec(dk, ğ‘). We require that
Î E satisfies perfect correctness and the standard notion of CPA-
security [28]. We say that an encryption scheme is linearly homo-
morphic if there exists some efficiently computable operation â—¦
such that Enc(ek,ğ‘š0) â—¦ Enc(ek,ğ‘š1) âˆˆ Enc(ek,ğ‘š0 +ğ‘š1), where
addition is defined over Zğ‘ . The ğ›¼-fold application of â—¦ is denoted
by Enc(ek,ğ‘š)ğ›¼ .
Linear-only encryption (LOE) is an idealized model introduced
by Groth [30] as â€œgeneric homomorphic cryptosystemâ€. Here, homo-
morphic encryption is modeled by giving access to oracles instead
of their corresponding algorithms. A formal description of the ora-
cles is given in Figure 4. We note that although we do not model
such an algorithm explicitly, this model allows for (perfect) cipher-
text re-randomization by homomorphically adding 0 to the desired
ciphertext.
1263
CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA Noemi Glaeser et al.
Non-Interactive Zero-Knowledge. Let R : {0, 1}âˆ— Ã— {0, 1}âˆ— â†’
{0, 1} be an NP-witness-relation with corresponding NP-language
L := {ğ‘¥ | âˆƒğ‘¤ s.t. R(ğ‘¥,ğ‘¤) = 1}. A non-interactive zero-knowledge
proof system NIZK := (Setup, P,V) for the relation R is initialized
with a setup algorithm Setup(1ğ‘›) that, on input the security pa-
rameter, outputs a common reference string crs and a trapdoor td.
A prover can show the validity of a statement ğ‘¥ with a witnessğ‘¤
by invoking P(crs, ğ‘¥,ğ‘¤), which outputs a proof ğœ‹ . The proof ğœ‹ can
be efficiently checked by the verification algorithm V(crs, ğ‘¥, ğœ‹). We
require a NIZK system to be (1) zero-knowledge, i.e., there exists
a simulator ğœ‹ â† Sim(td, ğ‘¥) that computes valid proofs without
the knowledge of the witness, (2) sound, i.e., it is infeasible for an
adversary to output a valid proof for a statement ğ‘¥ âˆ‰ L, and (3) UC-
secure, i.e., one can efficiently extract from the proofs computed by
the adversary a valid witness (with the knowledge of the trapdoor
td), even in the presence of simulated proofs. For formal security
definitions, we refer the reader to [15, 22].
One-More DL.We recall the one-more discrete logarithm (OMDL)
assumption [7, 9].
Definition 2.6 (One-More Discrete Logarithm (OMDL) Assumption).
Let G be a uniformly sampled cyclic group of prime order ğ‘ and ğ‘” a
random generator of G. The one-more discrete logarithm (OMDL)
assumption states that for allğ‘› âˆˆ N there exists a negligible function
negl(ğ‘›) such that for all PPT adversaries A making at most ğ‘ =
poly(ğ‘›) queries to DL(Â·), the following holds:
Pr
ï£®ï£¯ï£¯ï£¯ï£¯ï£° âˆ€ğ‘– : ğ‘¥ğ‘– = ğ‘Ÿğ‘–
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
ğ‘Ÿ1, . . . , ğ‘Ÿğ‘+1 â†$Zğ‘
âˆ€ğ‘– âˆˆ [ğ‘ + 1], â„ğ‘– â† ğ‘”ğ‘Ÿğ‘–
{ğ‘¥ğ‘– }ğ‘–âˆˆ[ğ‘+1] â† ADL( Â·) (â„1, . . . , â„ğ‘+1)
ï£¹ï£ºï£ºï£ºï£ºï£»
â‰¤ negl(ğ‘›),
where the DL(Â·) oracle takes as input an element â„ âˆˆ G and returns
ğ‘¥ such that â„ = ğ‘”ğ‘¥ .
3 COUNTEREXAMPLES OF A2L
In the following, we recall the A
2
L system and present two coun-
terexamples to their main theorem.
3.1 Description of A2L
A
2
L is defined over the following cryptographic schemes:
â€¢ A digital signature scheme Î DS, a hard relation ğ‘…DL for a group
(G, ğ‘”, ğ‘) with generator ğ‘” and prime order ğ‘ , and the correspond-
ing adaptor signature scheme Î ADP.
â€¢ A linearly homomorphic re-randomizable CPA-secure encryption
scheme Î E.
4
â€¢ A NIZK proof system Î NIZK := (Setup, P,V) for the language
L := {(ek, ğ‘Œ , ğ‘) | âˆƒğ‘  s.t. ğ‘ â† Î E .Enc(ek, ğ‘ ) âˆ§ ğ‘Œ = ğ‘”ğ‘  }.
The protocol has three parties: Alice, Bob, and Hub. At the begin-
ning of the system, Hub runs the setup (as described in Figure 9) to
generate its keys, which are the keys for the (CPA-secure) encryp-
tion scheme Î E. The protocol then consists of a promise phase and
a solving phase.
4
Technically, [53] uses a different abstraction called â€œre-randomizable puzzleâ€. However,
it is not hard to see that a re-randomizable linearly homomorphic encryption scheme
satisfies this notion. For completeness, we show this in the full version [27].
Puzzle Promise. In the promise phase (as described in [53]), Hub
generates a pre-signature ï¿½Ìƒï¿½ğ»HB on a common message ğ‘šHB with
respect to a uniformly sampled instance ğ‘Œ := ğ‘”ğ‘  . Hub also encrypts
the witness ğ‘  in the ciphertext ğ‘ â† Î E .Enc(ekğ» , ğ‘ ) under its own
encryption key ekğ» . Hub gives Bob the tuple (ğ‘Œ, ğ‘, ğœ‹, ï¿½Ìƒï¿½ğ»HB), where
ğœ‹ is a NIZK proof that certifies the ciphertext ğ‘ encrypts ğ‘  . Bob
verifies that the NIZK proof and the pre-signature are indeed valid.
If so, he chooses a random ğ‘Ÿ â†$Zğ‘ and re-randomizes the instance
ğ‘Œ to ğ‘Œ â€² := ğ‘Œ Â· ğ‘”ğ‘Ÿ and also re-randomizes the ciphertext ğ‘ as ğ‘ â€² â†
Î E .Rand(ğ‘, ğ‘Ÿ ). The puzzle is set to ğœ := (ğ‘Ÿ,ğ‘šHB, ï¿½Ìƒï¿½
ğ»
HB, (ğ‘Œ, ğ‘), (ğ‘Œ
â€², ğ‘ â€²)).
Puzzle Solve. Bob sends the puzzle ğœ privately to Alice, who now
executes the puzzle solve protocol with Hub (as described in [53]).
Alice samples a random ğ‘Ÿ â€² and further re-randomizes the instance
ğ‘Œ â€² as ğ‘Œ â€²â€² := ğ‘Œ â€² Â· ğ‘”ğ‘Ÿ â€² and the ciphertext ğ‘ â€² as ğ‘ â€²â€² â† Î E .Rand(ğ‘ â€², ğ‘Ÿ â€²).
She then generates a pre-signature ï¿½Ìƒï¿½ğ´AH on a commonmessageğ‘šAH
with respect to the instance ğ‘Œ â€²â€². She sends the tuple (ğ‘Œ â€²â€², ğ‘ â€²â€², ï¿½Ìƒï¿½ğ´AH )
to Hub, who decrypts ğ‘ â€²â€² using the decryption key dkğ» to obtain ğ‘  â€²â€².
Hub then adapts the pre-signature ï¿½Ìƒï¿½ğ´AH to ğœğ´AH using ğ‘  â€²â€² and ensures
its validity. It then sends the signatureğœğ´AH to Alice, who extracts the
witness for ğ‘Œ â€²â€² as ğ‘  â€²â€² â† Î ADP .Ext(ï¿½Ìƒï¿½ğ´AH , ğœ
ğ´
AH , ğ‘Œ
â€²â€²). Alice removes
the re-randomization factor to obtain the solution ğ‘  â€² := ğ‘  â€²â€² âˆ’ ğ‘Ÿ â€² for
the instance ğ‘Œ â€². Alice finally sends ğ‘  â€² privately to Bob, who opens
the puzzle ğœ by computing the witness ğ‘  := ğ‘  â€² âˆ’ ğ‘Ÿ and adapting
the pre-signature ï¿½Ìƒï¿½ğ»HB (given by Hub in the promise phase) to the
signature ğœğ»HB.
3.2 Counterexamples
Next, we describe two cryptographic instantiations of A
2
L that
satisfy the formal definitions, yet enable two attacks. For the pur-
pose of these attacks, it suffices to keep in mind that Hub offers
the sender party (Alice) access to the following oracle, which we
refer to as OA2L
dk,Î E,Î ADP
. On input a verification key vk, a message
ğ‘š, a group element â„, a ciphertext ğ‘ , and a partial signature ï¿½Ìƒï¿½ , the
oracle behaves as follows:
â€¢ Compute ğ‘¥ â† Î E .Dec(dk, ğ‘).
â€¢ Compute ğœ â€² â† Î ADP .Adapt(ï¿½Ìƒï¿½, ğ‘¥).
â€¢ If Î ADP .Vrfy(vk,ğ‘š, ğœ â€²) = 1, return ğœ â€².
â€¢ Else return âŠ¥.
Note that returning ğœ â€² implicitly reveals ğ‘¥ , since
Î ADP .Ext(ï¿½Ìƒï¿½, ğœ â€², â„) = ğ‘¥ . It is also useful to observe that pro-
viding a valid pre-signature to the A
2
L oracle is trivial for an
adversary: generating a pre-signature that is valid when adapted
with a value ğ‘¥ requires only knowledge of the partyâ€™s own signing
key and of a value â„ = ğ‘”ğ‘¥ . The leakage offered by this oracle (and
indeed the existence of this leakage) is not addressed in A
2
Lâ€™s
proof of security.
Key Recovery Attack. In our first attack, we completely recover
the decryption key dk of the hub by simply querying the oracle
OA2L
sk,Î E,Î ADP
ğ‘› times. For this attack, we assume that the encryption
scheme Î E is (in addition to being re-randomizable and CPA-secure
as required by A
2
L):
â€¢ Linearly homomorphic over Zğ‘ .
1264
Foundations of Coin Mixing Services CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA
â€¢ Circular secure for bit encryption, i.e., the scheme is CPA-
secure even given the bitwise encryption of the decryption key
Enc(ek, dk1), . . . , Enc(ek, dkğ‘›).
â€¢ The above-mentioned ciphertexts (ğ‘1, . . . , ğ‘ğ‘›) := (Enc(ek, dk1),
. . . , Enc(ek, dkğ‘›)) are included in the encryption key ek.
Such schemes can be constructed from a variety of standard as-
sumptions [13]. It is easy to see that these additional requirements
do not contradict the initial prerequisites of the scheme.
Algorithm 1 Key Recovery Attack
Input: Hubâ€™s ek along with the cipheretexts (ğ‘1, . . . , ğ‘ğ‘›)
1: Initialize key guess dkâ€² := 0
ğ‘›
2: for ğ‘– âˆˆ 1 . . . ğ‘› do
3: Sample ğ‘¥ â†$Zğ‘ and compute â„ := ğ‘”ğ‘¥
4: Sample a fresh signing key (vk, sk) â† KGen(1ğ‘›)
5: Set ğ‘â€²
ğ‘–
:= Î E .Enc(ek, ğ‘¥) â—¦ ğ‘ğ‘– = Î E .Enc(ek, ğ‘¥ + dkğ‘– )
6: Compute ï¿½Ìƒï¿½ğ‘– â† Î ADP .PreSig(sk,ğ‘š,â„)
7: Query ğ‘¦ â† OA2L
dk,Î E,Î ADP
(vk,ğ‘š,â„, ğ‘â€²
ğ‘–
, ï¿½Ìƒï¿½ğ‘– )
8: If ğ‘¦ = âŠ¥ set dkâ€²ğ‘– := 1
9: end for
10: return dkâ€²
The attack is shown in Algorithm 1. Note that, for a signing key
pair in the ğ‘–-th iteration, if theOA2L
oracle returnsğ‘¦ â‰  âŠ¥, this means
that in the coinmixing layer, the Hub has obtained a validğ‘¦ and thus
obtains Aliceâ€™s (adversaryâ€™s) signature on a transaction. Due to one-
time use of keys in this (cryptocurrency) layer, the attacker therefore
cannot reuse the same signing key pair in another iteration for a
different message (transaction). Therefore, it is necessary that the
attacker (Alice) sample ğ‘› signing keys to account for every iteration
being a non-âŠ¥ query to OA2L
. This is realized in the real world by
the attacker having ğ‘› different sessions (of coin mixing), one for
each vkğ‘– , with Hub.
Observe that the response of the oracle isâŠ¥ if and only if dkğ‘– = 1,
since â„ = ğ‘”ğ‘¥ â‰  ğ‘”ğ‘¥+1. On the other hand, if dkğ‘– = 0, then the
oracle always returns a valid adapted signature ğœ â€². Thus, the attack
succeeds with probability 1.
One-More SignatureAttack.Wepresent a different attack, where
we impose different assumptions on the encryption scheme Î E. We
discuss later in the section why these assumptions do not contradict
the pre-requisites of the A
2
L scheme. Specifically, in addition to
A
2
Lâ€™s requirement that the scheme is perfectly re-randomizable
and CPA-secure, we assume that it is:
â€¢ Linearly homomorphic over Zğ‘ .
â€¢ Supports homomorphic evaluation of the conditional bit flip
(CFlip) function, defined as
Î E .CFlip(ek, ğ‘–, Enc(ek, ğ‘¥)) := Enc(ek, ğ‘¦)
where
{
ğ‘¦ = ğ‘¥ if ğ‘¥ğ‘– = 0
ğ‘¦ = ğ‘¥ âŠ• ğ‘’ğ‘– if ğ‘¥ğ‘– = 1
and ğ‘’ğ‘– is the ğ‘–-th unit vector.
The objective of the attack is to steal coins from the hub in the
coin mixing protocol. Specifically, at the A
2
L level, the attacker
will solve ğ‘ + 1 puzzles by querying the puzzle solver interface
successfully only ğ‘ times. Note that we do not count unsuccessful
(i.e., the oracle returnsâŠ¥) queries, since those non-accepting queries
do not correspond to any payment from Aliceâ€™s side.
Algorithm 2 One-More Signature Attack
Input: Bobâ€™s ciphertexts (ğ‘1, . . . , ğ‘ğ‘+1) and group elements (â„1, . . . , â„ğ‘+1) ,
where ğ‘ ğ‘— = Î E .Enc(ek, ğ‘¥ ğ‘— ) and â„ ğ‘— := ğ‘”
ğ‘¥ ğ‘—
, and Hubâ€™s ek
1: Initialize guess ğ‘¥â€²
1
:= 0
ğ‘›
and a counter ğ‘– := 1
2: for ğ‘– = 1 . . . ğ‘› do
3: Sample a fresh signing key (vk, sk) â† KGen(1ğ‘›)
4: Compute ğ‘â€²
1
â† Î E .CFlip(ek, ğ‘–, ğ‘1)
5: Sample (ğ‘Ÿ (ğ‘– )
1
, . . . , ğ‘Ÿ
(ğ‘– )
ğ‘+1) â†$Z
ğ‘+1
ğ‘
6: Compute ğ‘â€² := (ğ‘â€²
1
)ğ‘Ÿ
(ğ‘– )
1 â—¦ (ğ‘2)ğ‘Ÿ
(ğ‘– )
2 Â· Â· Â· â—¦ (ğ‘ğ‘+1)
ğ‘Ÿ
(ğ‘– )
ğ‘+1
7: Compute â„â€² :=
âˆğ‘+1
ğ‘—=1
â„
ğ‘Ÿ
(ğ‘– )
ğ‘—
ğ‘—
8: Sign ï¿½Ìƒï¿½ â† Î ADP .PreSig(sk,ğ‘š,â„â€²)
9: Query ğ‘¦ğ‘– â† OA2L
dk,Î E,Î ADP
(vk,ğ‘š,â„â€², ğ‘â€², ï¿½Ìƒï¿½)
10: If ğ‘¦ğ‘– = âŠ¥ set ğ‘¥â€²
1,ğ‘–
:= 1
11: end for
12: Continue querying (without updating ğ‘¥â€²
1
) until ğ‘ non-âŠ¥ queries have
been made
13: For all ğ‘– corresponding to a non-âŠ¥ query, set ğ¸ğ‘– to be the equation
ğ‘¦ğ‘– âˆ’ ğ‘Ÿ (ğ‘– )
1
ğ‘¥â€²
1
= ğ‘Ÿ
(ğ‘– )
2
ğ‘¥â€²
2
+ . . . + ğ‘Ÿ (ğ‘– )
ğ‘+1ğ‘¥
â€²
ğ‘+1
14: Solve (ğ¸1, . . . , ğ¸ğ‘) for (ğ‘¥â€²
2
, . . . , ğ‘¥â€²
ğ‘+1)
15: return (ğ‘¥â€²
1
, ğ‘¥â€²
2
, . . . , ğ‘¥â€²
ğ‘+1)
The attack is shown in Algorithm 2.We assume (for convenience)
that ğ‘ â‰¥ ğ‘› and that Zğ‘ â‰¤ 2
ğ‘›
and therefore ğ‘¥ ğ‘— âˆˆ {0, 1}ğ‘› . Observe
that the attack makes at most ğ‘ successful queries to the oracle, so
all we need to show is that the success probability is high enough.
First, we argue that the attack recovers the correct ğ‘¥ â€²
1
= ğ‘¥1 with
probability 1. If the ğ‘–-th bit ğ‘¥1,ğ‘– = 0, then the CFlip operation does
not alter the content of the ciphertext and therefore
ğ‘ â€² = Enc Â©Â­Â«ek,
ğ‘+1âˆ‘
ğ‘—=1
ğ‘Ÿ
(ğ‘–)
ğ‘—
Â· ğ‘¥ ğ‘—
ÂªÂ®Â¬ and â„â€² =
ğ‘+1âˆ
ğ‘—=1
â„
ğ‘Ÿ
(ğ‘– )
ğ‘—
ğ‘—
= ğ‘”
âˆ‘ğ‘+1
ğ‘—=1
ğ‘Ÿ
(ğ‘– )
ğ‘—
Â·ğ‘¥ ğ‘—
so the oracle always returns a non-âŠ¥ response. On the other hand,
if ğ‘¥1,ğ‘– = 1, then the above equality does not hold and therefore
OA2L
sk,Î E,Î ADP
always returns âŠ¥.
This querying strategy is repeated for every bit of ğ‘¥ â€²
1
and con-
tinued on ğ‘¥2, etc., until ğ‘ non-âŠ¥ queries have been made. Because
ğ‘ â‰¥ ğ‘›, the attacker will have learned all ğ‘› bits of ğ‘¥ â€²
1
by this point.
Thus, the set of equations (ğ¸1, . . . , ğ¸ğ‘) has exactly ğ‘ unknowns.
Since the coefficients are uniformly chosen, the equations are, with
all but negligible probability, linearly independent. Since Zğ‘ is a
field, the solution is uniquely determined and can be found effi-
ciently via Gaussian elimination.
N-More Signatures. The described attack is in fact even stronger
than shown. Using this method, an attacker A can use ğ‘ queries,
where âŒŠğ‘âŒ‹ = ğ‘ğ‘›, to recover ğ‘ + ğ‘ plaintexts. A does this by using
ğ‘ğ‘› queries to recover the first ğ‘ plaintexts ğ‘¥1, . . . , ğ‘¥ğ‘ and ğ‘ğ‘›
equations as described previously (once it has flipped all ğ‘› bits
in ğ‘¥1, it starts flipping bits in ğ‘¥2, and so on). Using its remaining
queries, it obtains ğ‘ âˆ’ ğ‘ğ‘› more equations (either by continuing to
flip bits in further ciphertexts, which are however wasted, or by
simply choosing new values ğ‘Ÿğ‘– for the linear combinations) for a
1265
CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA Noemi Glaeser et al.
total of ğ‘ equations. Using Gaussian elimination, it can recover the
remaining ğ‘ plaintexts ğ‘¥ğ‘+1, . . . , ğ‘¥ğ‘+ğ‘ . Taken with the plaintexts
ğ‘¥1, . . . , ğ‘¥ğ‘ that were recovered bit-by-bit, the attacker has learned
ğ‘ + ğ‘ plaintexts.
Instantiations. We now justify our additional assumptions on
the encryption scheme Î E by describing suitable instantiations
that satisfy all the requirements. Clearly, if the scheme is fully-
homomorphic [25] then it supports both linear functions over Zğ‘
and conditional bit flips. However, we show that even a linear ho-
momorphic encryption (over Zğ‘ ) can suffice to mount our attack.
Specifically, given a CPA-secure linearly homomorphic encryp-
tion scheme (KGenâˆ—, Encâˆ—,Decâˆ—), we define a bitwise encryption
scheme (KGen, Enc,Dec) as follows:
â€¢ KGen(1ğ‘›): Return the output of KGenâˆ— (1ğ‘›).
â€¢ Enc(ek, ğ‘¥): Parse ğ‘¥ as (ğ‘¥ (1) , . . . , ğ‘¥ (ğ‘›) ) and return
(Encâˆ— (ek, ğ‘¥ (1) ), . . . , Encâˆ— (ek, ğ‘¥ (ğ‘›) )).
â€¢ Dec(dk, ğ‘): Parse ğ‘ as (ğ‘ (1) , . . . , ğ‘ (ğ‘›) ) and return
âˆ‘ğ‘›
ğ‘–=1 2
ğ‘–âˆ’1 Â·
Decâˆ— (dk, ğ‘ (ğ‘–) ).
It is easy to show that the new scheme is CPA-secure via a standard
hybrid argument.
Next, we argue that one can efficiently implement the conditional
bit flip operation (CFlip) over such ciphertexts. Given a ciphertext
ğ‘ = (ğ‘ (1) , . . . , ğ‘ (ğ‘›) ), we can conditionally flip the ğ‘–-th bit by com-
puting
(ğ‘ (1) , . . . , Encâˆ— (ek, 0)ï¸¸       ï¸·ï¸·       ï¸¸
ğ‘–-th ciphertext
, . . . , ğ‘ (ğ‘›) ).
This is a correctly formed ciphertext, since the conditional bit flip al-
ways sets the ğ‘–-th bit to 0 and leaves the other positions untouched.
Finally, we need to argue that the encryption scheme is still
linearly homomorphic over Zğ‘ . Note that this does not follow im-
mediately from the fact that (KGenâˆ—, Encâˆ—,Decâˆ—) is linearly ho-
momorphic, since the new encryption algorithm decomposes the
inputs bitwise. Nevertheless, we show this indeed holds for the
case of two ciphertexts ğ‘ = (ğ‘ (1) , . . . , ğ‘ (ğ‘›) ) and ğ‘‘ = (ğ‘‘ (1) , . . . , ğ‘‘ (ğ‘›) )
encrypting ğ‘¥ and ğ‘¦, respectively. The general case follows analo-
gously. To homomorphically compute ğ›¼ğ‘¥ + ğ›½ğ‘¦, where (ğ›¼, ğ›½) âˆˆ Z2ğ‘ ,
we compute( (
ğ‘›
âƒ
ğ‘–=1
(ğ‘ (ğ‘–) )2
ğ‘–âˆ’1
)ğ›¼
â—¦
(
ğ‘›
âƒ
ğ‘–=1
(ğ‘‘ (ğ‘–) )2
ğ‘–âˆ’1
)ğ›½
, Encâˆ— (ek, 0),
. . . , Encâˆ— (ek, 0)
)
.
A routine calculation shows that this ciphertext correctly decrypts
to the desired result ğ›¼ğ‘¥ + ğ›½ğ‘¦.
4 BLIND CONDITIONAL SIGNATURES
In the following we formally define and instantiate blind condi-
tional signatures, the central cryptographic notion for coin mixing
services. Our goal here is to give a simple and easy-to-understand
formalization of a synchronization puzzle.
4.1 Definitions
A blind conditional signature (BCS) is executed among users Alice,
Bob, and Hub. The interfaces and associated security properties are
defined below.
Definition 4.1 (Blind Conditional Signature). A blind conditional
signature Î BCS := (Setup, PPromise, PSolver,Open) is defined
with respect to a signature scheme Î DS := (KGen, Sign,Vf) and
consists of the following efficient algorithms.
â€¢ ( Ëœek, Ëœdk) â† Setup(1ğ‘›): The setup algorithm takes as input the
security parameter 1
ğ‘›
and outputs a key pair ( Ëœek, Ëœdk).
â€¢ (âŠ¥, {ğœ,âŠ¥}) â† PPromise
âŒ©
ğ»
(
Ëœdk, skğ» ,ğ‘šHB
)
B
(
Ëœek, vkğ» ,ğ‘šHB
) âŒª: The puzzle
promise algorithm is an interactive protocol between two users
ğ» (with inputs the decryption key
Ëœdk, the signing key skğ» , and
a messageğ‘šHB) and B (with inputs the encryption key
Ëœek, the
verification key vkğ» , and a messageğ‘šHB) and returns âŠ¥ to ğ»
and either a puzzle ğœ or âŠ¥ to ğµ.
â€¢ ({(ğœâˆ—, ğ‘ ),âŠ¥}, {ğœâˆ—,âŠ¥}) â† PSolver
âŒ©
A
(
skğ´, Ëœek,ğ‘šAH , ğœ
)
ğ»
(
Ëœdk, vkğ´,ğ‘šAH
) âŒª
: The
puzzle solving algorithm is an interactive protocol between two
users A (with inputs the signing key skğ´ , the encryption key
Ëœek, a messageğ‘šAH , and a puzzle ğœ) and ğ» (with inputs the de-
cryption key
Ëœdk, the verification key pkğ´ , and a messageğ‘šAH )
and returns to both users either a signature ğœâˆ— (A additionally
receives a secret ğ‘ ) or âŠ¥.
â€¢ {ğœ,âŠ¥} â† Open(ğœ, ğ‘ ): The open algorithm takes as input a puzzle
ğœ and a secret ğ‘  and returns a signature ğœ or âŠ¥.
Next, we define correctness.
Definition 4.2 (Correctness). A blind conditional signature Î BCS
is correct if for all ğ‘› âˆˆ N, all ( Ëœek, Ëœdk) in the support of Setup(1ğ‘›),
all (vkğ» , skğ» ) and (vkğ´, skğ´) in the support of Î DS .KGen(1ğ‘›), and
all pairs of messages (ğ‘šHB,ğ‘šAH ), it holds that
Pr
[
Vf (vkğ» ,ğ‘šHB,Open(ğœ, ğ‘ )) = 1
]
= 1
and
Pr
[
Vf (vkğ´,ğ‘šAH , ğœ
âˆ—) = 1
]
= 1
where
â€¢ ğœ â† PPromise
âŒ©
ğ»
(
Ëœdk, skğ» ,ğ‘šHB
)
B
(
Ëœek, vkğ» ,ğ‘šHB
) âŒª and
â€¢ ((ğœâˆ—, ğ‘ ), ğœâˆ—) â† PSolver
âŒ©
A
(
skğ´, Ëœek,ğ‘šAH , ğœ
)
ğ»
(
Ëœdk, vkğ´,ğ‘šAH
) âŒª
.
We now present the security guarantees of BCS in the game-
based setting. Our definition of blindness is akin to the strong
blindness notion of standard blind signatures [19], in which the
adversary picks the keys (as opposed to the weak version in which
1266
Foundations of Coin Mixing Services CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA
ExpBlndAÎ BCS
(ğ‘›)
( Ëœek, vkğ»
0
, vkğ»
1
, (ğ‘šHB,0,ğ‘šAH ,0), (ğ‘šHB,1,ğ‘šAH ,1)) â† A(1ğ‘›)
(vkğ´
0
, skğ´
0
) â† KGen(1ğ‘›)
(vkğ´
1
, skğ´
1
) â† KGen(1ğ‘›)
ğœ0 â† PPromise
âŒ©
A(vkğ´
0
, vkğ´
1
), B( Ëœek, vkğ»
0
,ğ‘šHB,0)
âŒª
ğœ1 â† PPromise
âŒ©
A(vkğ´
0
, vkğ´
1
), B( Ëœek, vkğ»
1
,ğ‘šHB,1)
âŒª
ğ‘ â† {0, 1}
(ğœâˆ—
0
, ğ‘ 0) â† PSolver
âŒ©
A
(
skğ´
0
, Ëœek,ğ‘šAH ,0, ğœ0âŠ•ğ‘
)
,A
âŒª
(ğœâˆ—
1
, ğ‘ 1) â† PSolver
âŒ©
A
(
skğ´
1
, Ëœek,ğ‘šAH ,1, ğœ1âŠ•ğ‘
)
,A
âŒª
if (ğœâˆ—
0
= âŠ¥) âˆ¨ (ğœâˆ—
1
= âŠ¥) âˆ¨ (ğœ0 = âŠ¥) âˆ¨ (ğœ1 = âŠ¥)
ğœ0 := ğœ1 := âŠ¥
else
ğœ
0âŠ•ğ‘ â† Open(ğœ
0âŠ•ğ‘ , ğ‘ 0)
ğœ
1âŠ•ğ‘ â† Open(ğœ
1âŠ•ğ‘ , ğ‘ 1)
ğ‘â€² â† A(ğœ0, ğœ1)
return (ğ‘ = ğ‘â€²)
Figure 5: Blindness experiment
they are chosen by the experiment)
5
. Roughly speaking, it says that
two promise/solve sessions cannot be linked together by the hub.
6
Definition 4.3 (Blindness). A blind conditional signature Î BCS is
blind if there exists a negligible function negl(ğ‘›) such that for all
ğ‘› âˆˆ N and all PPT adversaries A, the following holds:
Pr
[
ExpBlndAÎ puzzle
(ğ‘›) = 1
]
â‰¤ 1
2
+ negl(ğ‘›)
where ExpBlnd is defined in Figure 5.
7
Next, we define unlockability, which says that it should be hard
for Hub to create a valid signature on Aliceâ€™s message that does
not allow Bob to unlock the full signature in the corresponding
promise session.
Definition 4.4 (Unlockability). A blind conditional signature
Î BCS is unlockable if there exists a negligible function negl(ğ‘›)
such that for all ğ‘› âˆˆ N and all PPT adversaries A, the following
holds:
Pr
[
ExpUnlockAÎ BCS
(ğ‘›) = 1
]
â‰¤ negl(ğ‘›)
where ExpUnlock is defined in Figure 6.
Our definition of unforgeability is inspired by the unforgeabil-
ity of blind signatures [19]. We require that Alice and Bob cannot
recover ğ‘ signatures from Hub while successfully querying the
5
We opt for this stronger version since we want to provide anonymity even in the
case of a fully malicious hub, which can pick its keys adversarially to try to link a
sender/receiver pair.
6
We do not consider the case in which Hub colludes with either Alice or Bob, since
deanonymization is trivial (Alice (resp. Bob) simply reveals the identity of Bob (resp.
Alice) to Hub); this is in line with [53].
7
In previous works, descriptions of unlinkability assume an explicit step for blinding
the puzzle ğœ between PPromise and PSolver. Here, we assume that PSolver performs
this blinding functionality.
ExpUnlockAÎ BCS
(ğ‘›)
( Ëœek, vkğ» ,ğ‘šHB,ğ‘šAH ) â† A(1ğ‘›)
(vkğ´, skğ´) â† KGen(1ğ‘›)
ğœ â† PPromise
âŒ©
A(vkğ´), B( Ëœek, vkğ» ,ğ‘šHB)
âŒª
if ğœ = âŠ¥
(ï¿½Ì‚ï¿½, ï¿½Ì‚ï¿½) â† A
ğ‘0 := (Vf (vkğ´, ï¿½Ì‚ï¿½, ï¿½Ì‚ï¿½) = 1)
if ğœ â‰  âŠ¥
(ğœâˆ—, ğ‘ ) â† PSolver
âŒ©
A
(
skğ´, Ëœek,ğ‘šAH , ğœ
)
,A
âŒª
(ï¿½Ì‚ï¿½, ï¿½Ì‚ï¿½) â† A
ğ‘1 := (Vf (vkğ´, ï¿½Ì‚ï¿½, ï¿½Ì‚ï¿½) = 1) âˆ§ (ï¿½Ì‚ï¿½ â‰ ğ‘šAH )
ğ‘2 := (Vf (vkğ´, ğœâˆ—,ğ‘šAH ) = 1)
ğ‘3 := (Vf (vkğ» ,ğ‘šHB,Open(ğœ, ğ‘ )) â‰  1)
return ğ‘0 âˆ¨ ğ‘1 âˆ¨ (ğ‘2 âˆ§ ğ‘3)
Figure 6: Unlockability experiment
solving oracle at most ğ‘ âˆ’ 1 times. Since each successful query
reveals a signature from Aliceâ€™s key (which in turn corresponds to
a transaction from Alice to Hub), this requirement implicitly cap-
tures the fact that Alice and Bob cannot steal coins from Hub. The
winning condition ğ‘0 captures the scenario where the adversary
forges a signature of the hub on a message previously not used
in any promise oracle query. The remaining conditions ğ‘1, ğ‘2 and
ğ‘3 together capture the scenario in which the adversary outputs ğ‘
valid distinct key-message-signature tuples while having queried
for solve only ğ‘ âˆ’ 1 times. Hence, in the second condition, the at-
tacker manages to complete ğ‘ promise interactions with only ğ‘ âˆ’ 1
solve interactions, whereas in the first winning condition, the ad-
versary computes a fresh signature that is not the completion of any
promise interaction. These conditions are technically incomparable:
an attacker that succeeds under one condition does not imply an
attacker succeeding on the other. It is important to note that this is
different from the unforgeability notion of blind signatures (where
the attacker only has access to a single signing oracle), since in our
case the hub is offering the attacker two oracles: promise and solve.
Definition 4.5 (Unforgeability). A blind conditional signature
Î BCS is unforgeable if there exists a negligible function negl(ğ‘›)
such that for all ğ‘› âˆˆ N and all PPT adversaries A, the following
holds:
Pr
[
ExpUnforgAÎ BCS
(ğ‘›) = 1
]
â‰¤ negl(ğ‘›)
where ExpUnforg is defined in Figure 7.
We define security as the collection of all properties.
Definition 4.6 (Security). A blind conditional signature Î BCS is
secure if it is blind, unlockable, and unforgeable.
1267
CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA Noemi Glaeser et al.
ExpUnforgAÎ BCS
(ğ‘›)
L := âˆ…,ğ‘„ := 0
( Ëœek, Ëœdk) â† Setup(1ğ‘›)
(vkğ»
1
,ğ‘š1, ğœ1), . . . , (vkğ»ğ‘ ,ğ‘šğ‘, ğœğ‘) â† AOPP(Â·),OPS(Â·) ( Ëœek)
ğ‘0 := âˆƒğ‘– âˆˆ [ğ‘ ] s.t. (vkğ»ğ‘– , Â·) âˆˆ L âˆ§ (vkğ»ğ‘– ,ğ‘šğ‘– ) âˆ‰ L
âˆ§ Vf (vkğ»ğ‘– ,ğ‘šğ‘– , ğœğ‘– ) = 1
ğ‘1 := âˆ€ğ‘– âˆˆ [ğ‘ ], (vkğ»ğ‘– ,ğ‘šğ‘– ) âˆˆ L âˆ§ Vf (vkğ»ğ‘– ,ğ‘šğ‘– , ğœğ‘– ) = 1
ğ‘2 :=
âˆ§
ğ‘–,ğ‘—âˆˆ[ğ‘ ],ğ‘–â‰ ğ‘—
(vkğ»ğ‘– ,ğ‘šğ‘– , ğœğ‘– ) â‰  (vkğ»ğ‘— ,ğ‘š ğ‘— , ğœ ğ‘— )
ğ‘3 := (ğ‘„ â‰¤ ğ‘ âˆ’ 1)
return ğ‘0 âˆ¨ (ğ‘1 âˆ§ ğ‘2 âˆ§ ğ‘3)
OPP(ğ‘š)
(vkğ» , skğ» ) â† Î ADP .KGen(1ğ‘›)
L := L âˆª {(vkğ» ,ğ‘š) }
âŠ¥ â† PPromiseâŸ¨ğ» ( Ëœdk, skğ» ,ğ‘š),A(vkğ» ) âŸ©
OPS(vkğ´,ğ‘šâ€²)
ğœâˆ— â† PSolverâŸ¨A, ğ» ( Ëœdk, vkğ´,ğ‘šâ€²) âŸ©
if ğœâˆ— â‰  âŠ¥ thenğ‘„ := ğ‘„ + 1
Figure 7: Unforgeability experiment
4.2 The A2L+ Protocol
In the following we describe our A
2
L
+
construction. Our scheme
is a provable variant of A
2
L (Section 3.1) and therefore we only
describe the differences with respect to the original protocol. The
concrete modifications are as follows:
â€¢ Augment the public key of Hub ekğ» with a NIZK proof that
certifies that ekğ» âˆˆ Supp(Î E .KGen(1ğ‘›)). All parties verify this
proof during their first interaction with Hub.
â€¢ In PSolver (of [53]), Hub additionally checks if vkğ´AH is in the
support of Î ADP .KGen(1ğ‘›) before the decryption (line 6). Fur-
thermore, we replace the condition (line 8) with
Î ADP .PreVf (vkğ´AH ,ğ‘šAH , ğ‘Œ
â€²â€², ï¿½Ìƒï¿½ğ´AH ) â‰  1 âˆ¨ ğ‘”ğ‘ 
â€²â€²
â‰  ğ‘Œ â€²â€².
4.3 Security Analysis
In this section we present our security results and defer the proofs
to the full version [27]. Before proving our main theorem, we define
a property which is going to be useful for our analysis.
Definition 4.7 (OM-CCA-A2L). An encryption scheme Î E is one-
more CCA-A2L-secure (OM-CCA-A2L) if there exists a negligible
function negl(ğ‘›) such that for all ğ‘› âˆˆ N, all polynomials ğ‘ = ğ‘(ğ‘›),
and all PPT adversaries A, the following holds:
Pr
[
OM-CCA-A2L
A
Î E,ğ‘
(ğ‘›) = 1
]
â‰¤ negl(ğ‘›),
where OM-CCA-A2L is defined in Figure 8.
OM-CCA-A2L
A
Î E,ğ‘
ğ‘„ := 0
(ek, dk) â† Î E .KGen(1ğ‘›)
ğ‘Ÿ1, . . . , ğ‘Ÿğ‘+1 â†$ {0, 1}ğ‘›
ğ‘ğ‘– â† Î E .Enc(ek, ğ‘Ÿğ‘– )
(ğ‘Ÿ â€²
1
, . . . , ğ‘Ÿ â€²ğ‘+1) â† A
OA2Ldk,Î E,Î ADP (ek, (ğ‘1, ğ‘”ğ‘Ÿ1 ), . . . , (ğ‘ğ‘+1, ğ‘”ğ‘Ÿğ‘+1 ))
if ğ‘Ÿ â€²ğ‘– = ğ‘Ÿğ‘– âˆ€ğ‘– âˆˆ 1, . . . , ğ‘ + 1 âˆ§ğ‘„ â‰¤ ğ‘ then return 1
else return 0
OA2L
dk,Î E,Î ADP
(vk,ğ‘š,â„, ğ‘, ï¿½Ìƒï¿½)
check if vk âˆˆ Supp(Î ADP .KGen(1ğ‘›))
ï¿½Ìƒï¿½ â† Î E .Dec(dk, ğ‘)
if Î ADP .PreVf (vk,ğ‘š,â„, ï¿½Ìƒï¿½) = 1 and ğ‘”ï¿½Ìƒï¿½ = â„
ğ‘„ := ğ‘„ + 1
return ğœâ€² â† Î ADP .Adapt(ï¿½Ìƒï¿½, ï¿½Ìƒï¿½)
else return âŠ¥
Figure 8: OM-CCA-A2L game
The following technical lemma shows that an LOE scheme satis-
fies this property, assuming the hardness of the OMDL problem. The
formal analysis of the below lemma is deferred to the full version
of the paper [27].
Lemma 4.8. Let Î E be an LOE scheme. Assuming the hardness of
OMDL, Î E is OM-CCA-A2L secure.
Main Theorem. We are now ready to give the main theorem of
this section. The formal analysis is deferred to the full version of
the paper [27].
Theorem 4.9. Let Î E be an LOE scheme, Î ADP a secure adaptor
signature scheme, and Î NIZK a sound NIZK proof system. Assuming
the hardness of OMDL, the A2L+ protocol is a secure blind conditional
signature scheme.
5 UC-SECURE BLIND CONDITIONAL
SIGNATURES
We now model security in the universal composability framework
from Canetti [16] extended to support a global setup [17] in order
to capture concurrent executions. We refer the reader to [16] for a
comprehensive discussion. We consider static corruptions, where
the adversary announces at the beginning which parties it corrupts.
We denote the environment by E. For a real protocol Î  and an
adversary A we write EXECÎ ,A,E to denote the ensemble corre-
sponding to the protocol execution. For an ideal functionality F
and an adversary S we write EXECF,S,E to denote the distribution
ensemble of the ideal world execution.
Definition 5.1 (Universal Composability). A protocol Î  UC-
realizes an ideal functionality F if for any PPT adversary A there
exists a simulatorS such that for any environment E the ensembles
EXECÎ ,A,E â‰ˆ EXECF,S,E are computationally indistinguishable.
1268
Foundations of Coin Mixing Services CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA
In our protocol, we assume the existence of a general-purpose
UC-secure 2-party computation (2PC) protocol [18, 34], where two
parties interact with the ideal functionality to compute a function
ğ‘“ (ğ‘¥,ğ‘¦) over their private inputs ğ‘¥ and ğ‘¦.
5.1 Ideal functionality
We describe the ideal functionality FBCS that captures the function-
ality and security of BCS in the UC framework. We refer the reader
to the full version of the paper [27] for the formal description of
FBCS. The ideal functionality has three routines, namely for puz-
zle promise, puzzle solver, and open, which intuitively capture the
functionality of BCS as discussed in Section 4. On a high level, FBCS
captures blindness by sampling the puzzle identifiers pid and pidâ€²,
which correspond to puzzle promise and puzzle solve interactions,
locally together, but never revealing them together to the hub. FBCS
captures atomicity by returning a successful message (not aborting)
for pid during open if and only if it sent a successful solved mes-
sage during the puzzle solve interaction for the puzzle identifier
pidâ€² (where pid and pidâ€² correspond to each other). Note that the
above atomicity guarantee implies the game-based definitions of
unlockability and unforgeability.
Our functionality FBCS is taken verbatim from the FA2L function-
ality in [53] except that we do not consider user registrations (as
done in FA2L) to tackle griefing attacks [44] in the coin mixing layer.
These attacks are mounted by Bob starting many puzzle promise
operations, each of which requires Hub to lock coins, whereas the
corresponding puzzle solver interactions are never carried out. As a
consequence, all of Hubâ€™s coins are locked and no longer available,
which results in a form of denial of service attack. We argue that
the issue does not concern the functionality or security of BCS as
a cryptographic tool, but only affects the coin mixing protocol at
the transaction layer. We emphasize that griefing attacks can be
thwarted at this layer in both the formal model and the construction
using the same ideas as in [53].
5.2 Our Protocol: A2LUC
We now describe our protocol A
2
L
UC
that realizes the ideal func-
tionality FBCS. We assume the following cryptographic building
blocks:
â€¢ An adaptor signature scheme Î ADP defined with respect to Î DS
and a hard relation ğ‘…DL.
â€¢ A UC-secure NIZK proof system Î NIZK for the language
L := {(ek, ğ‘Œ , ğ‘) | âˆƒğ‘ , s.t. ğ‘ â† Î E .Enc(ek, ğ‘ ) âˆ§ ğ‘Œ = ğ‘”ğ‘  }.
â€¢ A UC-secure 2PC protocol.
â€¢ A CCA-secure [8] encryption scheme Î E := (KGen, Enc,Dec)
with unique decryption keys.
The property of unique decryption keys is formalized below.
Definition 5.2 (Unique Decryption Keys). An encryption scheme
Î E has unique decryption keys if the KGen algorithm is of the
following form:
â€¢ Sample dkâ†$ {0, 1}ğ‘› .
â€¢ Run ekâ† Gen(dk).
Furthermore, for all ek output by KGen, there exists a unique dk
such that ek = Gen(dk). In other words, Gen is injective.
Setup(1ğ‘›)
(ekğ» , dkğ» ) â† Î E .KGen(1ğ‘›)
set Ëœpk := ekğ» , Ëœsk := dkğ»
return ( Ëœpk, Ëœsk)
Open(ğœ, ğ‘ )
parse ğœ := ( Â·, ï¿½Ìƒï¿½, Â·)
ğœ â† Î ADP .Adapt(ï¿½Ìƒï¿½, ğ‘ )
return ğœ
Figure 9: Setup and Open algorithms of our conditional puz-
zle construction
This property is already satisfied by most natural public-key en-
cryption schemes, but it can be generically achieved by augmenting
the encryption key with a perfectly binding commitment com(dk)
to the decryption key dk.
Protocol Description. We assume Alice and Hub have a key pair
for the signature scheme Î DS. Specifically, we have the verification-
signing key pairs (vkğ»HB, sk
ğ»
HB) and (vk
ğ´
AH , sk
ğ´
AH ), belonging to Hub
and Alice, respectively. We then have two messagesğ‘š :=ğ‘šHB and
ğ‘šâ€² :=ğ‘šAH for which the users wish to generate blind conditional
signatures. The setup and open algorithms are formally described
in Figure 9. The puzzle promise and puzzle solver of A
2
L
UC
are
formally described in Figure 10 and Figure 11, respectively. For ease
of understanding, we briefly describe below our A
2
L
UC
protocol in
terms of the differences with the A
2
L protocol (given in [53]).
â€¢ The setup algorithm (Figure 9) of A
2
L
UC
generates the keys of
Hub, which are the keys for the (CCA-secure) encryption scheme
Î E.
â€¢ In PPromise of A2
L
UC
(Figure 10),
â€“ The NIZK proof system is UC-secure.
â€“ Bob no longer re-randomizes the instance or the ciphertext.
Therefore, we drop the re-randomization steps (line 12) of
PPromise in A
2
L ([53, Figure 2]). Simply set the puzzle to
ğœ := (ğ‘šHB, ï¿½Ìƒï¿½
ğ»
HB, (ğ‘Œ, ğ‘)).
â€¢ In PSolver of A2
L
UC
(Figure 11),
â€“ Alice no longer sends the ciphertext to Hub (line 4) of [53,
Figure 3]. We therefore remove the local decryption step (line
5) of [53, Figure 3], and replace it with a 2PC protocol (line 6
of Figure 11).
â€“ At the end of the 2PC protocol, Alice receives âŠ¥, while Hub
receives the value ğ‘§. Hub additionally checks if ğ‘Œ â€² = ğ‘”ğ‘§ (line
7) and uses ğ‘§ to adapt the pre-signature ï¿½Ìƒï¿½ğ´AH to signature ğœğ´AH .
â€“ We add a check for Alice (line 10) that ğœğ´AH is a valid signature
before extracting the witness ğ‘§â€² in line 12.
â€¢ The Open algorithm (Figure 9) is the same as in [53, Figure 4]
of A
2
L, except we skip removing the randomness factor. The
algorithm in Figure 9 now simply adapts a pre-signature ï¿½Ìƒï¿½ to a
valid signature ğœ which it returns as output.
5.3 Security Analysis
We now show that A
2
L
UC
satisfies UC-security. In favor of a simpler
analysis, we assume that the verification keys of all parties are
honestly generated. In practice, this can be enforced by augmenting
keys with NIZKs that certify their validity [12, 37].We state here our
security theorem and defer the formal proof to the full version [27]
due to space constraints.
1269
CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA Noemi Glaeser et al.
Public parameters: group description (G, ğ‘”, ğ‘), messageğ‘šHB
PPromiseâŸ¨ğ» (dkğ» , skğ»HB), Â·âŸ© PPromiseâŸ¨Â·, ğµ (ekğ» , vkğ»HB) âŸ©
1 : ğ‘  â†$Zğ‘ , ğ‘Œ := ğ‘”ğ‘ 
2 : ğ‘ â† Î E .Enc(ekğ» , ğ‘ )
3 : ğœ‹ğ‘  â† NIZK.P( (ekğ» , ğ‘Œ , ğ‘), ğ‘ )
4 : ï¿½Ìƒï¿½ğ»HB â† Î ADP .PreSig(skğ»HB,ğ‘šHB, ğ‘Œ )
5 :
ğ‘Œ, ğ‘, ğœ‹ğ‘  , ï¿½Ìƒï¿½
ğ»
HB
6 : If NIZK.V( (ekğ» , ğ‘Œ , ğ‘), ğœ‹ğ‘  ) â‰  1 then return âŠ¥
7 : If Î ADP .PreVf (vkğ»HB,ğ‘šHB, ğ‘Œ , ï¿½Ìƒï¿½
ğ»
HB) â‰  1 then
8 : return âŠ¥
9 : set ğœ := (ğ‘šHB, ï¿½Ìƒï¿½
ğ»
HB, (ğ‘Œ, ğ‘))
10 : return âŠ¥ return ğœ
Figure 10: Puzzle promise protocol of A2LUC
Public parameters: group description (G, ğ‘”, ğ‘), messageğ‘šAH
PSolverâŸ¨ğ´(skğ´AH , ekğ» , ğœ), Â·âŸ© PSolverâŸ¨Â·, ğ» (dkğ» , vkğ´AH ) âŸ©
1 : parse ğœ := ( Â·, Â·, (ğ‘Œ, ğ‘))
2 : ğ‘Ÿ â†$Zğ‘ , ğ‘Œ
â€²
:= ğ‘Œ Â· ğ‘”ğ‘Ÿ
3 : ï¿½Ìƒï¿½ğ´AH â† Î ADP .PreSig(skğ´AH ,ğ‘šAH , ğ‘Œ
â€²)
4 :
ğ‘Œ â€², ï¿½Ìƒï¿½ğ´AH
5 : If Î ADP .PreVf (vkğ´AH ,ğ‘šAH , ğ‘Œ
â€², ï¿½Ìƒï¿½ğ´AH ) â‰  1 then
return âŠ¥
6 : 2PC( (ğ‘Ÿ, ğ‘), (dkğ» ))
1 : if ekğ» â‰  Î E .Gen(dkğ» )
2 : then abort
3 : ğ‘ âˆ— â† Î E .Dec(dkğ» , ğ‘)
4 : ğ‘§ := ğ‘ âˆ— + ğ‘Ÿ
5 : return ( (âŠ¥), (ğ‘§))
7 : If ğ‘Œ â€² â‰  ğ‘”ğ‘§ then return âŠ¥
8 : ğœğ´AH â† Î ADP .Adapt(ï¿½Ìƒï¿½ğ´AH , ğ‘§)
9 :
ğœğ´AH
10 : If Î ADP .Vf (vkğ´AH ,ğ‘šAH , ğœ
ğ´
AH ) â‰  1 then
11 : return âŠ¥
12 : ğ‘§â€² â† Î ADP .Ext(ï¿½Ìƒï¿½ğ´AH , ğœ
ğ´
AH , ğ‘Œ
â€²)
13 : ğ‘  := ğ‘§â€² âˆ’ ğ‘Ÿ
14 : return (ğœğ´AH , ğ‘ ) return ğœğ´AH
Figure 11: Puzzle solver protocol of A2LUC
Theorem 5.3. Let Î E be a CCA-secure encryption scheme, Î ADP
a secure adaptor signature scheme, 2PC a UC-secure two-party com-
putation protocol, and Î NIZK a UC-secure NIZK for the language L
above. Then the A2LUC protocol UC-realizes FBCS.
6 EFFICIENCY
6.1 A2L+
Recall that we use an encryption scheme Î E in the LOE model.
Below we present an instantiation of such a Î E.
Instantiating Linear-Only Encryption. As shown in [11] it is
not sufficient to instantiate this with any linearly homomorphic
encryption (e.g., ElGamal). Though the scheme may not support
homomorphic operations beyond linear, it may still have obliviously
sampleable ciphertexts, i.e., the ability to sample a ciphertext with-
out knowing the underlying plaintext. Note that this falls outside
the LOE model, since there is no oracle that implements this func-
tionality. Thus, as suggested in [11] we implement an additional
safeguard needed to prevent oblivious sampling. Given a linearly
homomorphic encryption scheme Î âˆ—E := (KGenâˆ—, Encâˆ—,Decâˆ—) over
Zğ‘ , we define a candidate LOE Î E := (KGen, Enc,Dec) as follows:
â€¢ KGen(1ğ‘›): Sample (ekâˆ—, dkâˆ—) â† KGenâˆ— (1ğ‘›) and some ğ›¼ â†$Zğ‘ .
Return dk := (dkâˆ—, ğ›¼) as the decryption key and ek :=
(ekâˆ—, Encâˆ— (ekâˆ—, ğ›¼)) as the encryption key.
â€¢ Enc(ekâˆ—, ğ‘¥): Compute ğ‘ as (Encâˆ— (ekâˆ—, ğ‘¥), Encâˆ— (ekâˆ—, ğ›¼ Â·ğ‘¥)), where
Encâˆ— (ekâˆ—, ğ›¼ Â· ğ‘¥) is computed homomorphically using ek.
â€¢ Dec(dkâˆ—, ğ‘): Parse ğ‘ as (ğ‘0, ğ‘1) and compute ğ‘¥0 â† Decâˆ— (dkâˆ—, ğ‘0)
and ğ‘¥1 â† Decâˆ— (dkâˆ—, ğ‘1). If ğ‘¥1 = ğ›¼ Â· ğ‘¥0 return ğ‘¥0, else return âŠ¥.
We note that the security of Î E follows from the security of Î âˆ—E.
Intuitively, we prevent oblivious ciphertext sampling, since it is
1270
Foundations of Coin Mixing Services CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA
Table 1: Operations in A2L and A2L+ when instantiated with Schnorr or ECDSA adaptor signatures [4]. We give the number group exponen-
tiations (Exp) and group operations (Op) in both class groups (CL) and groups of prime order ğ‘ (G), where logğ‘ = ğ‘›. Group element inversions
(Inv) only occur in class groups. Modular multiplications (Ã—) and additions (+) are performed modulo ğ‘. We denote by #H the number of hash
computations. Decryption of a CL ciphertext also involves solving a discrete logarithm in a class group, which we denote by DLog.
Protocol Signature Exp (CL) Op (CL) Inv (CL) DLog (CL) Exp (G) Op (G) Ã— mod ğ‘ + mod ğ‘ #H
A
2
L Schnorr 18 12 1 1 13 8 4 9 6
(insecure) ECDSA 18 12 1 1 27 8 17 10 11
A
2
L
+
Schnorr 28 20 2 2 14 9 5 9 6
ECDSA 28 20 2 2 32 10 21 12 11
infeasible for an adversary to sample a ciphertext component ğ‘0
that is consistent with ğ‘1 without knowing the plaintext of ğ‘0.
Added Costs. The new consistency check by the hub in PSolver
adds 1 group operation and group exponentiation (Schnorr) or 5
group operations and 2 group exponentiations (ECDSA). The check
on Aliceâ€™s verification key vkğ´AH adds 3 modular multiplications and
2 modular additions in the ECDSA case. Furthermore, applying the
LOE transformation described above to the CL encryption scheme
results in a doubled ciphertext size and a corresponding increase
in the operation count for decryption. We summarize the costs of
A
2
L and A
2
L
+
in Table 1.
6.2 A2LUC
Compared to A
2
L
+
, our A
2
L
UC
protocol removes the check on vkğ´AH ,
adds a signature verification, and moves the re-randomization and
decryption into the 2PC. Additionally, Î E is now required to be
CCA-secure and the NIZK used must be UC-secure. The cost of the
first two changes is minimal (net 1 group exponentiation, 1 group
operation, and 1 hash computation); the most significant overhead
is the result of the 2PC computation and the NIZK.
Assuming the CCA-secure Î E in the 2PC is instantiated with
the (prime-order-based) Cramer-Shoup cryptosystem [21] with
SHA3-256 [42] as the hash function, this incurs an overhead of
11 exponentiations, 9 multiplications, and 1 division in a group of
prime order ğ‘ and
âŒˆ
3ğ‘›
1088
âŒ‰
Â· 38400 binary (AND) operations, where
the security parameter ğ‘› equals logğ‘ . Because the 2PC requires
a mix of arithmetic and binary operations, a mixed-circuit 2PC
protocol as implemented e.g. in [35] could be used. Additionally,
UC security of the NIZK can be achieved by replacing the use
of the Fiat-Shamir transform in A
2
L (and A
2
L
+
) with the Fischlin
transform, incurring a cost of roughlyğ‘‚ (log(ğ‘›)) parallel repetitions
of the base Fiat-Shamir NIZK. We stress that we view A
2
L
UC
as
a proof-of-concept protocol showing the feasibility of achieving
UC-secure blind conditional signatures and leave the problem of
constructing an efficient UC-secure realization as an interesting
direction for future work.
7 CONCLUSIONS
We investigate the notion of synchronization puzzles, the crypto-
graphic building blocks at the core of hub-enabled coin mixing
services. We find that the previous formalization of a synchroniza-
tion puzzle in [53] is flawed. In fact, we identify several issues in its
formal model which can be easily exploited to break the security
of the resultant coin mixing protocol. We conclude that tighter
formalization of the functionality and security of synchronization
puzzles is necessary.
To fill this gap, we introduce the notion of blind conditional
signatures (BCS). Additionally, we provide different security for-
malizations for BCS at varying levels of strength (game-based and
in the UC framework) accompanied by a provably secure variant
of A
2
L called A
2
L
+
and a new provably UC-secure construction
A
2
L
UC
. Our performance evaluation results show an efficiency vs.
security trade-off in the case of our constructions, yet show with
A
2
L
+
that provably secure coin mixing services are practical.
Acknowledgements. This work was partially supported by the
European Research Council (ERC) under the European Unionâ€™s
Horizon 2020 research (grant agreement 771527-BROWSEC), by
the Austrian Science Fund (FWF) through the projects PROFET
(grant agreement P31621) and the project W1255-N23, by the Aus-
trian Research Promotion Agency (FFG) through COMET K1 SBA
and COMET K1 ABC, by the Vienna Business Agency through
the project Vienna Cybersecurity and Privacy Research Center
(VISP), by the Austrian Federal Ministry for Digital and Eco-
nomic Affairs, the National Foundation for Research, Technol-
ogy and Development and the Christian Doppler Research As-
sociation through the Christian Doppler Laboratory Blockchain
Technologies for the Internet of Things (CDL-BOT). This work
has been also partially supported by the Madrid regional govern-
ment as part of the program S2018/TCS-4339 (BLOQUES-CM) co-
funded by EIE Funds of the European Union, by grant IJC2020-
043391-I/MCIN/AEI/10.13039/501100011033 and European Union
NextGenerationEU/PRTR, by SCUM Project (RTI2018-102043-B-
I00) MCIN/AEI/10.13039/501100011033/ERDF A way of making
Europe, and by the project HACrypt. Additionally, this material
is based upon work supported by the National Science Founda-
tion Graduate Research Fellowship Program under Grant No. DGE
1840340. Any opinions, findings, and conclusions or recommen-
dations expressed in this material are those of the author(s) and
do not necessarily reflect the views of the National Science Foun-
dation. The work was also made possible through the support of
the David and Lucile Packard Foundation (award #202071730), SRI
International (award #53978) / Prime: Defense Advanced Research
Projects Agency (award #HR00110C0086), and the National Science
Foundation (award #2212746). G.M. was partially supported by the
German Federal Ministry of Education and Research (BMBF) (grant
16K15K042, project 6GEM).
1271
CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA Noemi Glaeser et al.
REFERENCES
[1] Accessed on May 2022. CoinJoin - Bitcoin Wiki. https://en.bitcoin.it/wiki/CoinJ
oin.
[2] Accessed on May 2022. Coinswap. https://coinswap.space.
[3] Lukas Aumayr, Oguzhan Ersoy, Andreas Erwig, Sebastian Faust, Kristina
Hostakova, Matteo Maffei, Pedro Moreno-Sanchez, and Siavash Riahi. 2020.
Generalized Bitcoin-Compatible Channels. Cryptology ePrint Archive, Report
2020/476. https://eprint.iacr.org/2020/476.
[4] Lukas Aumayr, Oguzhan Ersoy, Andreas Erwig, Sebastian Faust, Kristina
Hostakova, Matteo Maffei, Pedro Moreno-Sanchez, and Siavash Riahi. 2020. Gen-
eralized Channels from Limited Blockchain Scripts and Adaptor Signatures.
Cryptology ePrint Archive, Report 2020/476. https://ia.cr/2020/476.
[5] European Central Bank. 2021. Digital Euro. https://www.ecb.europa.eu/paym/d
igital_euro/html/index.en.html
[6] Simon Barber, Xavier Boyen, Elaine Shi, and Ersin Uzun. 2012. Bitter to Better
â€” How to Make Bitcoin a Better Currency. Advances in Water Resources - ADV
WATER RESOUR 7397. https://doi.org/10.1007/978-3-642-32946-3_29
[7] Balthazar Bauer, Georg Fuchsbauer, and Antoine Plouviez. 2021. The One-More
Discrete Logarithm Assumption in the Generic Group Model. Cryptology ePrint
Archive, Report 2021/866. https://ia.cr/2021/866.
[8] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. 1997. A concrete security
treatment of symmetric encryption. In Proceedings 38th Annual Symposium on
Foundations of Computer Science. 394â€“403. https://doi.org/10.1109/SFCS.1997.64
6128
[9] Mihir Bellare, Chanathip Namprempre, David Pointcheval, and Michael Semanko.
2003. The One-More-RSA-Inversion Problems and the Security of Chaumâ€™s Blind
Signature Scheme. Journal of Cryptology 16, 3 (June 2003), 185â€“215. https:
//doi.org/10.1007/s00145-002-0120-1
[10] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers,
Eran Tromer, and Madars Virza. 2014. Zerocash: Decentralized Anonymous
Payments from Bitcoin. In 2014 IEEE Symposium on Security and Privacy. IEEE
Computer Society Press, 459â€“474. https://doi.org/10.1109/SP.2014.36
[11] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth.
2013. Succinct Non-interactive Arguments via Linear Interactive Proofs. In
TCC 2013 (LNCS, Vol. 7785), Amit Sahai (Ed.). Springer, Heidelberg, 315â€“333.
https://doi.org/10.1007/978-3-642-36594-2_18
[12] Alexandra Boldyreva. 2003. Threshold Signatures, Multisignatures and Blind Sig-
natures Based on the Gap-Diffie-Hellman-Group Signature Scheme. In PKC 2003
(LNCS, Vol. 2567), Yvo Desmedt (Ed.). Springer, Heidelberg, 31â€“46. https:
//doi.org/10.1007/3-540-36288-6_3
[13] Dan Boneh, Shai Halevi, Michael Hamburg, and Rafail Ostrovsky. 2008. Circular-
Secure Encryption from Decision Diffie-Hellman. In CRYPTO 2008 (LNCS,
Vol. 5157), David Wagner (Ed.). Springer, Heidelberg, 108â€“125. https://doi.
org/10.1007/978-3-540-85174-5_7
[14] Joseph Bonneau, Arvind Narayanan, Andrew Miller, Jeremy Clark, Joshua A.
Kroll, and Edward W. Felten. 2014. Mixcoin: Anonymity for Bitcoin with Account-
able Mixes. Technical Report 077.
[15] Jan Camenisch, Stephan Krenn, and Victor Shoup. 2011. A Framework for
Practical Universally Composable Zero-Knowledge Protocols. InASIACRYPT 2011
(LNCS, Vol. 7073), Dong Hoon Lee and XiaoyunWang (Eds.). Springer, Heidelberg,
449â€“467. https://doi.org/10.1007/978-3-642-25385-0_24
[16] Ran Canetti. 2001. Universally composable security: A new paradigm for cryp-
tographic protocols. In Proceedings 42nd IEEE Symposium on Foundations of
Computer Science. IEEE, 136â€“145.
[17] Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish. 2007. Universally
Composable Security with Global Setup. In TCC 2007 (LNCS, Vol. 4392), Salil P.
Vadhan (Ed.). Springer, Heidelberg, 61â€“85. https://doi.org/10.1007/978-3-540-
70936-7_4
[18] Ran Canetti, Yehuda Lindell, Rafail Ostrovsky, and Amit Sahai. 2002. Universally
composable two-party and multi-party secure computation. In 34th ACM STOC.
ACM Press, 494â€“503. https://doi.org/10.1145/509907.509980
[19] David Chaum. 1982. Blind Signatures for Untraceable Payments. In CRYPTOâ€™82,
David Chaum, Ronald L. Rivest, and Alan T. Sherman (Eds.). Plenum Press, New
York, USA, 199â€“203.
[20] Mihai Christodorescu, Erin English, Wanyun Catherine Gu, David Kreissman,
Ranjit Kumaresan, Mohsen Minaei, Srinivasan Raghuraman, Cuy Sheffield, Ar-
juna Wijeyekoon, and Mahdi Zamani. 2021. Universal Payment Channels: An
Interoperability Platform for Digital Currencies. arXiv:2109.12194 [cs] (Sept. 2021).
arXiv:2109.12194 [cs]
[21] Ronald Cramer and Victor Shoup. 1998. A Practical Public Key Cryptosystem
Provably Secure Against Adaptive Chosen Ciphertext Attack. In CRYPTOâ€™98
(LNCS, Vol. 1462), Hugo Krawczyk (Ed.). Springer, Heidelberg, 13â€“25. https:
//doi.org/10.1007/BFb0055717
[22] Alfredo De Santis, Silvio Micali, and Giuseppe Persiano. 1987. Non-interactive
zero-knowledge proof systems. In Conference on the Theory and Application of
Cryptographic Techniques. Springer, 52â€“72.
[23] Stefan Dziembowski, Lisa Eckey, Sebastian Faust, and Daniel Malinowski. 2019.
Perun: Virtual Payment Hubs over Cryptocurrencies. In 2019 IEEE Symposium on
Security and Privacy. IEEE Computer Society Press, 106â€“123. https://doi.org/10
.1109/SP.2019.00020
[24] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. 2018. The Algebraic Group Model
and its Applications. In CRYPTO 2018, Part II (LNCS, Vol. 10992), Hovav Shacham
and Alexandra Boldyreva (Eds.). Springer, Heidelberg, 33â€“62. https://doi.org/10
.1007/978-3-319-96881-0_2
[25] Craig Gentry. 2009. Fully homomorphic encryption using ideal lattices. In 41st
ACM STOC, Michael Mitzenmacher (Ed.). ACM Press, 169â€“178. https://doi.org/
10.1145/1536414.1536440
[26] Simin Ghesmati, Walid Fdhila, and Edgar Weippl. 2021. SoK: How Private Is
Bitcoin? Classification and Evaluation of Bitcoin Mixing Techniques. Technical
Report 629.
[27] Noemi Glaeser, Matteo Maffei, Giulio Malavolta, Pedro Moreno-Sanchez, Erkan
Tairi, and Sri AravindaKrishnan Thyagarajan. 2022. Foundations of Coin Mixing
Services. Cryptology ePrint Archive, Paper 2022/942. https://doi.org/10.1145/35
48606.3560637 https://eprint.iacr.org/2022/942.
[28] Shafi Goldwasser and Silvio Micali. 1984. Probabilistic encryption. J. Comput.
System Sci. 28, 2 (1984), 270â€“299. https://doi.org/10.1016/0022-0000(84)90070-9
[29] Shafi Goldwasser, Silvio Micali, and Ronald L. Rivest. 1988. A Digital Signature
Scheme Secure Against Adaptive Chosen-message Attacks. SIAM J. Comput. 17,
2 (April 1988), 281â€“308.
[30] Jens Groth. 2004. Rerandomizable and Replayable Adaptive Chosen Ciphertext
Attack Secure Cryptosystems. In TCC 2004 (LNCS, Vol. 2951), Moni Naor (Ed.).
Springer, Heidelberg, 152â€“170. https://doi.org/10.1007/978-3-540-24638-1_9
[31] Bernhard Haslhofer, Rainer StÃ¼tz, Matteo Romiti, and Ross King. 2021. Graph-
Sense: A General-Purpose Cryptoasset Analytics Platform. CoRR abs/2102.13613
(2021). arXiv:2102.13613
[32] Ethan Heilman, Leen Alshenibr, Foteini Baldimtsi, Alessandra Scafuro, and
Sharon Goldberg. 2017. TumbleBit: An Untrusted Bitcoin-Compatible Anony-
mous Payment Hub. In NDSS 2017. The Internet Society.
[33] Ethan Heilman, Foteini Baldimtsi, and Sharon Goldberg. 2016. Blindly Signed
Contracts: Anonymous On-Blockchain and Off-Blockchain Bitcoin Transactions.
Technical Report 056.
[34] Omer Horvitz and Jonathan Katz. 2007. Universally-Composable Two-Party
Computation in Two Rounds, See [41], 111â€“129. https://doi.org/10.1007/978-3-
540-74143-5_7
[35] Marcel Keller. 2020. MP-SPDZ: A Versatile Framework for Multi-Party Com-
putation. In Proceedings of the 2020 ACM SIGSAC Conference on Computer and
Communications Security. https://doi.org/10.1145/3372297.3417872
[36] Russell W. F. Lai, Viktoria Ronge, Tim Ruffing, Dominique SchrÃ¶der, Sri Ar-
avinda Krishnan Thyagarajan, and Jiafan Wang. 2019. Omniring: Scaling Private
Payments Without Trusted Setup. In ACM CCS 2019, Lorenzo Cavallaro, Jo-
hannes Kinder, XiaoFeng Wang, and Jonathan Katz (Eds.). ACM Press, 31â€“48.
https://doi.org/10.1145/3319535.3345655
[37] Steve Lu, Rafail Ostrovsky, Amit Sahai, Hovav Shacham, and Brent Waters. 2006.
Sequential Aggregate Signatures and Multisignatures Without Random Oracles.
In EUROCRYPT 2006 (LNCS, Vol. 4004), Serge Vaudenay (Ed.). Springer, Heidelberg,
465â€“485. https://doi.org/10.1007/11761679_28
[38] Ueli M. Maurer. 2005. Abstract Models of Computation in Cryptography (Invited
Paper). In 10th IMA International Conference on Cryptography and Coding (LNCS,
Vol. 3796), Nigel P. Smart (Ed.). Springer, Heidelberg, 1â€“12.
[39] Sarah Meiklejohn and Rebekah Mercer. 2017. MÃ¶bius: Trustless Tumbling for
Transaction Privacy. Proceedings on Privacy Enhancing Technologies 2018 (2017),
105 â€“ 121.
[40] Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, Kirill Levchenko, Damon
McCoy, Geoffrey M. Voelker, and Stefan Savage. 2016. A Fistful of Bitcoins:
Characterizing Payments among Men with No Names. Commun. ACM 59, 4
(March 2016), 86â€“93. https://doi.org/10.1145/2896384
[41] Alfred Menezes (Ed.). 2007. CRYPTO 2007. LNCS, Vol. 4622. Springer, Heidelberg.
[42] National Institute of Standards and Technology. 2015. SHA-3 Standard:
Permutation-Based Hash and Extendable-Output Functions. http://dx.doi
.org/10.6028/NIST.FIPS.202
[43] Manoj Prabhakaran and Mike Rosulek. 2007. Rerandomizable RCCA Encryption,
See [41], 517â€“534. https://doi.org/10.1007/978-3-540-74143-5_29
[44] D. Robinson. 2019. HTLCs considered harmful. https://cbr.stanford.edu/sbc19/.
[45] Tim Ruffing and Pedro Moreno-Sanchez. 2017. ValueShuffle: Mixing Confidential
Transactions for Comprehensive Transaction Privacy in Bitcoin. In Financial
Cryptography and Data Security - FC 2017 International Workshops, WAHC, BIT-
COIN, VOTING, WTSC, and TA, Sliema, Malta, April 7, 2017, Revised Selected Papers
(Lecture Notes in Computer Science, Vol. 10323), Michael Brenner, Kurt Rohloff,
Joseph Bonneau, Andrew Miller, Peter Y. A. Ryan, Vanessa Teague, Andrea Brac-
ciali, Massimiliano Sala, Federico Pintore, and Markus Jakobsson (Eds.). Springer,
133â€“154. https://doi.org/10.1007/978-3-319-70278-0_8
[46] TimRuffing, PedroMoreno-Sanchez, andAniket Kate. 2014. CoinShuffle: Practical
Decentralized Coin Mixing for Bitcoin. In Computer Security - ESORICS 2014 -
19th European Symposium on Research in Computer Security, Wroclaw, Poland,
September 7-11, 2014. Proceedings, Part II (Lecture Notes in Computer Science,
Vol. 8713), Miroslaw Kutylowski and Jaideep Vaidya (Eds.). Springer, 345â€“364.
1272
https://en.bitcoin.it/wiki/CoinJoin
https://en.bitcoin.it/wiki/CoinJoin
https://coinswap.space
https://eprint.iacr.org/2020/476
https://ia.cr/2020/476
https://www.ecb.europa.eu/paym/digital_euro/html/index.en.html
https://www.ecb.europa.eu/paym/digital_euro/html/index.en.html
https://doi.org/10.1007/978-3-642-32946-3_29
https://ia.cr/2021/866
https://doi.org/10.1109/SFCS.1997.646128
https://doi.org/10.1109/SFCS.1997.646128
https://doi.org/10.1007/s00145-002-0120-1
https://doi.org/10.1007/s00145-002-0120-1
https://doi.org/10.1109/SP.2014.36
https://doi.org/10.1007/978-3-642-36594-2_18
https://doi.org/10.1007/3-540-36288-6_3
https://doi.org/10.1007/3-540-36288-6_3
https://doi.org/10.1007/978-3-540-85174-5_7
https://doi.org/10.1007/978-3-540-85174-5_7
https://doi.org/10.1007/978-3-642-25385-0_24
https://doi.org/10.1007/978-3-540-70936-7_4
https://doi.org/10.1007/978-3-540-70936-7_4
https://doi.org/10.1145/509907.509980
https://arxiv.org/abs/2109.12194
https://doi.org/10.1007/BFb0055717
https://doi.org/10.1007/BFb0055717
https://doi.org/10.1109/SP.2019.00020
https://doi.org/10.1109/SP.2019.00020
https://doi.org/10.1007/978-3-319-96881-0_2
https://doi.org/10.1007/978-3-319-96881-0_2
https://doi.org/10.1145/1536414.1536440
https://doi.org/10.1145/1536414.1536440
https://doi.org/10.1145/3548606.3560637
https://doi.org/10.1145/3548606.3560637
https://eprint.iacr.org/2022/942
https://doi.org/10.1016/0022-0000(84)90070-9
https://doi.org/10.1007/978-3-540-24638-1_9
https://arxiv.org/abs/2102.13613
https://doi.org/10.1007/978-3-540-74143-5_7
https://doi.org/10.1007/978-3-540-74143-5_7
https://doi.org/10.1145/3372297.3417872
https://doi.org/10.1145/3319535.3345655
https://doi.org/10.1007/11761679_28
https://doi.org/10.1145/2896384
http://dx.doi.org/10.6028/NIST.FIPS.202
http://dx.doi.org/10.6028/NIST.FIPS.202
https://doi.org/10.1007/978-3-540-74143-5_29
https://cbr.stanford.edu/sbc19/
https://doi.org/10.1007/978-3-319-70278-0_8
Foundations of Coin Mixing Services CCS â€™22, November 7â€“11, 2022, Los Angeles, CA, USA
https://doi.org/10.1007/978-3-319-11212-1_20
[47] Tim Ruffing, Pedro Moreno-Sanchez, and Aniket Kate. 2016. P2P Mixing and
Unlinkable Bitcoin Transactions. Technical Report 824.
[48] Dominique SchrÃ¶der and Dominique Unruh. 2017. Security of Blind Signatures
Revisited. Journal of Cryptology 30, 2 (April 2017), 470â€“494. https://doi.org/10.1
007/s00145-015-9225-1
[49] IstvÃ¡n AndrÃ¡s Seres, DÃ¡niel A. Nagy, Chris Buckland, and PÃ©ter Burcsi. 2019.
MixEth: Efficient, Trustless Coin Mixing Service for Ethereum. In International
Conference on Blockchain Economics, Security and Protocols, Tokenomics, Vol. 71.
13:1â€“13:20.
[50] Victor Shoup. 1997. Lower Bounds for Discrete Logarithms and Related Problems.
In EUROCRYPTâ€™97 (LNCS, Vol. 1233), Walter Fumy (Ed.). Springer, Heidelberg,
256â€“266. https://doi.org/10.1007/3-540-69053-0_18
[51] Johann Stockinger, Bernhard Haslhofer, Pedro Moreno-Sanchez, and Matteo
Maffei. 2021. Pinpointing and Measuring Wasabi and Samourai CoinJoins in the
Bitcoin Ecosystem. arXiv:2109.10229 [cs.CR]
[52] Jeff Stone. Accessed onMay 2022. Evolution Downfall: Insider â€™Exit Scamâ€™ Blamed
For Massive Drug Bazaarâ€™s Sudden Disappearance. https://www.ibtimes.com/
evolution-downfall-insider-exit-scam-blamed-massive-drug-bazaars-sudden-
disappearance-1856190.
[53] E. Tairi, P. Moreno-Sanchez, and M. Maffei. 2021. A2L: Anonymous Atomic Locks
for Scalability in Payment Channel Hubs. In 2021 IEEE Symposium on Security
and Privacy (SP). IEEE Computer Society, Los Alamitos, CA, USA, 1834â€“1851.
https://doi.org/10.1109/SP40001.2021.00111
[54] Luke Valenta and Brendan Rowan. 2015. Blindcoin: Blinded, Accountable Mixes
for Bitcoin. In Financial Cryptography and Data Security (Lecture Notes in Com-
puter Science), Michael Brenner, Nicolas Christin, Benjamin Johnson, and Kurt
Rohloff (Eds.). Springer, Berlin, Heidelberg, 112â€“126. https://doi.org/10.1007/978-
3-662-48051-9_9
1273
https://doi.org/10.1007/978-3-319-11212-1_20
https://doi.org/10.1007/s00145-015-9225-1
https://doi.org/10.1007/s00145-015-9225-1
https://doi.org/10.1007/3-540-69053-0_18
https://arxiv.org/abs/2109.10229
https://www.ibtimes.com/evolution-downfall-insider-exit-scam-blamed-massive-drug-bazaars-sudden-disappearance-1856190
https://www.ibtimes.com/evolution-downfall-insider-exit-scam-blamed-massive-drug-bazaars-sudden-disappearance-1856190
https://www.ibtimes.com/evolution-downfall-insider-exit-scam-blamed-massive-drug-bazaars-sudden-disappearance-1856190
https://doi.org/10.1109/SP40001.2021.00111
https://doi.org/10.1007/978-3-662-48051-9_9
https://doi.org/10.1007/978-3-662-48051-9_9
	Abstract
	1 Introduction
	1.1 Our Contributions
	1.2 Technical Overview
	1.3 Related Work
	2 Preliminaries
	3 Counterexamples of A2L
	3.1 Description of A2L
	3.2 Counterexamples
	4 Blind Conditional Signatures
	4.1 Definitions
	4.2 The A2L+ Protocol
	4.3 Security Analysis
	5 UC-secure blind conditional signatures
	5.1 Ideal functionality
	5.2 Our Protocol: A2LUC
	5.3 Security Analysis
	6 Efficiency
	6.1 A2L+
	6.2 A2LUC
	7 Conclusions
	References