Fair Outsourcing Polynomial Computation Based on the Blockchain
Fair Outsourcing Polynomial Computation
Based on the Blockchain
Yunguo Guan ,, Hui Zheng, Jun Shao , Rongxing Lu , Fellow, IEEE, and Guiyi Wei
Abstract—Due to the big data blowout from the Internet of Things and the rapid development of cloud computing, outsourcing
computation has received considerable attention in recent years. Particularly, many outsourcing computation schemes have been
proposed to dedicate the outsourcing polynomial computation due to its use in numerous fields, such as data analysis and machine
learning. However, none of those schemes are practical enough, as they either require some time-consuming cryptographic operations
to achieve fairness between the user and the worker, or cannot allow the user to outsource arbitrary polynomial to the worker, or need
two non-collusive workers. To tackle these challenges, in this article, we propose a new outsourcing polynomial computation scheme by
employing a variant of Horner’s method and the blockchain technology. Specifically, the former makes the computational cost on the
worker side as low as possible, and the latter guarantees the fairness between the user and the worker if the result from the worker can
be publicly verified. To achieve the public verifiability property, we apply the sampling technique, which is effective in our proposal
according to a game-theoretic analysis. Furthermore, we also implement a prototype of our proposal and run it on an Ethereum test
net. The extensive experimental results demonstrate that our proposal is efficient in terms of computational cost.
Index Terms—Outsourcing computation, polynomial computation, fairness, public verifiablility, blockchain, sampling technique, game theory
Ç
1 INTRODUCTION
AS it is fundamental to the success of intelligent applica-
tions in our daily lives, the Internet of Things (IoT) has
received considerable attention in recent years. For instance,
it has been reported that more than 50 billion IoT devices
would be connected to the Internet in 2020 [1]. The rapid
growth of IoT devices contributes to the blowout of big
data, and the latter further contributes to the increasing
demand to outsource relatively complex computing tasks to
a much more powerful computation service, e.g., cloud
computing [2]. Meanwhile, with the advancement of com-
puter hardware, there would be many idle cycles existing in
many computing devices, and their owners are willing to
sell these surplus computing resources to make some profits
[3]. Therefore, it is fair to say both the demand and supply
of outsourcing computation are prosperous.
However, the advance of outsourcing computation, in
reality, is not so successful as expected. The main obstacle is
the distrust between the two participants of the computing
task, namely, the user and the worker. In particular, the
worker may return a wrong but plausible result without
performing the actual computation for some incentive rea-
son. At the same time, the user may try to obtain the result
without any payment. As a result, this situation intensely
asks for the fairness of the outsourcing computation
scheme. Informally speaking, the fairness guarantees that
the user (resp. worker) can get a valid computing result
(resp. the promised reward) if he/she follows the protocol
exactly. Nevertheless, most of the previously reported out-
sourcing computation schemes [4], [5], [6], [7], [8], [9], [10]
usually focus on guaranteeing that the user can obtain a
valid result before his/her payment while ignoring the
worker’s benefit. When a dispute between the user and
worker happens, a complex process involving a trusted
third party (TTP) would be required [11]. As an ex-post
measure, the TTP ensures that the dispute will be finally
addressed, but it cannot promptly respond to the dispute.
Moreover, TTP-based schemes are weak in scalability and
suffer from a single point of failure. Hence, there is a desire
to design a fair outsourcing computation scheme without
TTP.
Based on the blockchain technology [12], some fair out-
sourcing computation schemes without TTP [13], [14] have
recently been proposed.1 As the blockchain can be used to
build a trust relationship among untrusted entities, it is nat-
ural to introduce the blockchain into the outsourcing com-
putation scenario. However, the existing blockchain-based
solutions require either complex cryptographic primitives
or the involvement of non-collusive workers. The former
requirement may make the resulting scheme inefficient, and
� Yunguo Guan is with the School of Computer and Information Engineer-
ing, Zhejiang Gongshang University, Hangzhou, Zhejiang 310018, China,
and also with the Faculty of Computer Science, University of New Bruns-
wick, Fredericton, NB E3B5A3, Canada. E-mail: guan_yg@163.com.
� Hui Zheng and Jun Shao are with the School of Computer and Information
Engineering, Zhejiang Gongshang University, Hangzhou, Zhejiang
310018, China. E-mail: {zh312934, chn.junshao}@gmail.com.
� Rongxing Lu is with the Faculty of Computer Science, University of New
Brunswick, Fredericton, NB E3B5A3, Canada. E-mail: rlu1@unb.ca.
� Guiyi Wei is with the School of Electronic and Information Engineering,
Hangzhou, Zhejiang 310018, China. E-mail: weigy@zjgsu.edu.cn.
Manuscript received 1 June 2020; revised 18 Jan. 2021; accepted 22 Jan. 2021.
Date of publication 26 Jan. 2021; date of current version 7 Oct. 2022.
(Corresponding author: Jun Shao.)
Digital Object Identifier no. 10.1109/TSC.2021.3054772
1. Note that the blockchain-based solutions do not overturn the
impossibility result on the fair exchange without a trusted third party
[11]. The blockchain in such solutions is essentially the TTP, though it
is a decentralized system.
IEEE TRANSACTIONS ON SERVICES COMPUTING, VOL. 15, NO. 5, SEPTEMBER/OCTOBER 2022 2795
1939-1374 © 2021 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See ht_tps://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
https://orcid.org/0000-0002-3965-3389
https://orcid.org/0000-0002-3965-3389
https://orcid.org/0000-0002-3965-3389
https://orcid.org/0000-0002-3965-3389
https://orcid.org/0000-0002-3965-3389
https://orcid.org/0000-0001-8352-0973
https://orcid.org/0000-0001-8352-0973
https://orcid.org/0000-0001-8352-0973
https://orcid.org/0000-0001-8352-0973
https://orcid.org/0000-0001-8352-0973
https://orcid.org/0000-0001-5720-0941
https://orcid.org/0000-0001-5720-0941
https://orcid.org/0000-0001-5720-0941
https://orcid.org/0000-0001-5720-0941
https://orcid.org/0000-0001-5720-0941
https://orcid.org/0000-0002-0635-2053
https://orcid.org/0000-0002-0635-2053
https://orcid.org/0000-0002-0635-2053
https://orcid.org/0000-0002-0635-2053
https://orcid.org/0000-0002-0635-2053
mailto:guan_yg@163.com
mailto:zh312934@gmail.com
mailto:chn.junshao@gmail.com
mailto:rlu1@unb.ca
mailto:weigy@zjgsu.edu.cn
the latter may not always be true in reality, especially in the
blockchain system.2
Nowadays, the previously reported outsourcing compu-
tation schemes can be roughly classified into two categories:
general and specific. The former can outsource any comput-
ing task, while the latter can only support a specific one.
Generally speaking, schemes in the latter are more efficient
than those in the former, since they can make some targeted
optimizations related to computing tasks [15], [16]. Also,
because the efficiency is always a critical factor for outsourc-
ing computation, schemes in the latter are more attractive
than those in the former from a practical point of view.
Among all particular computing tasks, polynomial compu-
tation, containing only two arithmetic operations, namely,
addition and multiplication, has received considerable
attention. This is mainly because it can be applied in various
scenarios, e.g., data analysis [17], [18], scientific computing
[19], [20], and machine learning [21], [22], and a large
amount of computational tasks can be represented as arith-
metic circuits and further evaluated as polynomials [23]. In
this paper, as a step towards efficient general-purpose fair
outsourced computation, we focus on designing a block-
chain-based fair outsourcing polynomial computation
scheme. Specifically, the contribution of this paper can be
summarized as follows.
� First, based on the blockchain technology [12] and
Horner’s method [24], we propose a new outsourc-
ing polynomial computation scheme. The fairness of
our proposal is demonstrated through game-theo-
retic analyses.
� Second, compared to the previous schemes, our pro-
posal supports arbitrary polynomials and dynamic
coefficients without any complex cryptographic
operations or the involvement of two non-collusive
servers. A detailed comparison with some represen-
tative schemes can be found in Table 1 and will be
further explained in Section 6.
� Third, we also implement a prototype of our pro-
posal and run it on Rinkeby Ethereum Testnet [25].
The experimental results show that our proposal is
efficient in terms of computational cost. The details
of our experiments can be found in Section 5.2.
The remainder of this paper is organized as follows. In
Section 2, we formalize the system model and security
model, and identify our design goals. Then, we give some
preliminaries including blockchain and Horner’s method in
Section 3. In Section 4, we present the details of our pro-
posed scheme, followed by the performance evaluation in
Section 5. Section 6 reviews the related works. In the end,
Section 7 gives the conclusions of our paper.
2 MODELS AND DESIGN GOALS
In this section, we formalize our system model and security
model, and identify our design goals.
2.1 System Model
As shown in Fig. 1, in our system model, we mainly con-
sider a typical blockchain-based outsourcing computation
scenario, which mainly consists of four entities, namely, a
user, a worker, a blockchain system, and Interplanetary File
System (IPFS).
� User: In our system model, we consider the user
needs to evaluate a polynomial fðxÞ with a given x,
but it is incapable in running this computing task
due to its restricted computing and energy resources.
Therefore, he/she tends to outsource the polynomial
computing task to get the value of fðxÞ with as little
overhead as possible.
� Worker: In our system model, the worker could be a
cloud server or even a computing device belonging
to an individual, and it would like to employ its com-
puting power to run polynomial computing tasks for
TABLE 1
The Comparison Between Our Proposal and Previous Schemes
Fig. 1. The system model under consideration.
2. According to the statistics from https://blockchain.com/pools,
more than 15 percent of mining power may come from the same mining
pool.
2796 IEEE TRANSACTIONS ON SERVICES COMPUTING, VOL. 15, NO. 5, SEPTEMBER/OCTOBER 2022
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
https://blockchain.com/pools
others. Assume that the worker can find tasks pub-
lished by the user from the blockchain, which could
be realized by some explorer, like the bitcoin
explorer (https://www.blockchain.com/explorer)
showing everything on Bitcoin.
� Blockchain: Our proposal utilizes a blockchain system
supporting smart contracts, e.g., Ethereum [27], EOS
[28], or NEO [29], to guarantee fairness. As shown in
Fig. 1, the blockchain sits between the user and the
worker to supervise their interactions and takes the
role of verifying the computing result. Moreover, it
is responsible for managing the revenue and deposit,
respectively, from the user and the worker, such that
whoever deviates from the protocol will pay the
price.
� IPFS: As the blockchain is usually designed to han-
dle small-sized data, our proposal employs IPFS to
store the proof of correctness generated by the
worker. Specifically, after conducting the task, the
worker uploads the computing result and proof to
IPFS and submits their addresses to the blockchain.
While handling the verification request from the
user, the blockchain pulls the required parts of data
from IPFS and conducts the verification. In this
work, similar to the approach adopted by many real-
world applications that rely on inputs from the phys-
ical world, we employ a blockchain oracle service
[30], [31], [32] for enabling smart contracts in block-
chain to read data in IPFS.
2.2 Security Model
We assume that both the worker and the user are profit-
driven due to the nature of the outsourcing computation sce-
nario. In particular, the worker is interested in obtaining the
reward with less or none computational cost. At the same
time, the user would like to receive the correct result from
theworkerwithout any payment by claiming to get no result,
or the obtained result is incorrect. On the other hand, based
on the nature of the blockchain and IPFS, they are considered
honest. That is, smart contracts deployed on the blockchain
will be faithfully executed, and IPFS will correctly and
promptly store and serve the data stored in it to smart con-
tracts. Although some attacks, e.g., selfish mining, block
withholding, and pool hopping, are targeting the underlying
blockchain system, those attacks are beyond the scope of this
paper andwill be discussed in our futurework.
Note that we mainly focus on how to efficiently obtain
the fairness property for outsourcing polynomial computa-
tion in this paper. We do not consider the confidentiality of
the input x, the polynomial fð�Þ, and the computing result
fðxÞ, which can be achieved by using (fully) homomorphic
encryption schemes like those in references [4], [5], [6], [7],
[8], [9]. Moreover, in the proposed scheme, we only consider
errors intentionally introduced by workers to increase their
revenue, and unintended errors will be considered in our
future work.
2.3 Design Goal
Our design goal in this paper is to develop a new block-
chain-based fair outsourcing polynomial computation
scheme satisfying the following properties under the above
system model and security model.
� Fairness: The main goal of this work is to design a fair
outsourcing polynomial computation scheme. In
other words, our proposal should guarantee that the
user can obtain a valid computing result if he/she
has paid, and the worker can get the reward if he/
she follows the protocol correctly. The faithful and
automatic execution of smart contracts in block-
chains allows us to realize fairness if the computing
result can be publicly verifiable. In this work, we use
the sampling technique to gain public verifiability,
and we give a game-theoretic analysis to show that
the sampling method works well in our proposal.
� Efficiency: The primary motivation of outsourcing
computation is the efficiency issue; hence, all the
cost on each entity in our protocol should be as low
as possible. 1) User side: Only a small computational
cost on the user side is sufficient for outsourcing the
computation of fðxÞ properly and obtaining the
value of fðxÞ from the blockchain. The efficiency is
also the main reason that the user is willing to out-
source the computing task. 2) Worker side: The cost
on the worker side should be as close as that of the
original computing task. 3) Blockchain side: It is not
free for the miners to do the result verification. No
matter it is paid by the user or worker, there should
be an upper bound for the cost. Ideally, only a
(small) constant computational cost is enough for the
result verification.
� Functionality: 1) Arbitrary polynomial support: It
would be convenient and useful for engineering
practice if the proposal can support all kinds of poly-
nomials. No matter how many variables of the input,
or how large the coefficients or orders of the polyno-
mial are.3 2) Reusability: To further reduce resource
usage of the user, he/she does not need to re-upload
the polynomial for different inputs. Furthermore, it
is only a small computational cost for the user to
support polynomials with changeable coefficients.
3 PRELIMINARIES
In this section, we briefly review the basic knowledge
related to our proposal, including the blockchain, IPFS, and
Horner’s method.
3.1 Blockchain and Smart Contract
The blockchain technology, the famous essential tool for
realizing cryptocurrencies, was invented in 2008 by Naka-
moto [12]. It enables a group of distrusted entities to trust a
public ledger maintained by these distrusted entities in a
decentralized way. This building-trust functionality is
mainly achieved by combining the underlying crypto-
graphic primitives (such as hash functions and digital signa-
tures) and consensus protocols (such as PoW [12] and
DPoS [28]). Besides realizing cryptocurrencies, blockchain
3. Of course, it should be restricted by the limitation of the current
information technology.
GUAN ETAL.: FAIR OUTSOURCING POLYNOMIALCOMPUTATION BASED ON THE BLOCKCHAIN 2797
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
https://www.blockchain.com/explorer
technology is also the only viable platform to implement
smart contracts. The smart contract concept was proposed
by Szabo [33], who considered the smart contract as a pro-
gram executed faithfully and automatically.
The smart contract in the blockchain usually proceeds as
follows. First, the creator deploys a smart contract in the
blockchain. Second, anyone who satisfies the predefined
conditions in the smart contract can invoke it. Finally, the
smart contract is executed by a set of participants (usually
called miners) in the blockchain, and the internal state of
the smart contract is also updated accordingly. Moreover,
the underlying consensus protocol enforces that the miners
will faithfully run the smart contract. As a result, the smart
contract is executed automatically from the view of others
(not the miners). In many blockchain systems [27], [29], the
miners will not execute smart contracts for free, and they
will charge the one who invokes the smart contract. The fee
is usually termed Gas.
It is worth mentioning that not every blockchain system,
such as Bitcoin, supports the smart contract. However, in
this paper, we assume that the blockchain in our system sup-
ports it. For evaluating the performance of our proposal, we
will use Ethereum [27] as the underlying blockchain system.
3.2 IPFS
Inter-Planetary File System (IPFS) is proposed by Benet [34]
and developed by Protocol Labs [35]. It aims to provide
users a resilient peer-to-peer file system for big file storage
and sharing similar to BitTorrent. Meanwhile, it addition-
ally supports content-addressing and version-controlling
properties by using distributed hash tables and git, respec-
tively. With the former property, users can obtain and verify
the data easily and quickly. The latter property enables
users to review the old version of the data.
Combination of Blockchain and IPFS. As blockchain is origi-
nally designed to be a public ledger to record transactions,
most blockchain systems adopted many approaches to
encourage the transaction size to be small to ensure the net-
work performance. Consequently, it is either impossible or
expensive to store big files directly in blockchain systems.
Hence, as a distributed file system, IPFS has become a popu-
lar solution for data and resource storage in blockchain-
based distributed applications (DApps) [36], [37], [38]. Spe-
cifically, the DApp can store data into IPFS and keep the
corresponding addresses in the blockchain. Then, users can
retrieve the corresponding data or files from IPFS with the
addresses obtained from the DApp. On the other hand,
when the DApp needs to read a block of data from IPFS, it
can request through Oracle services. Currently, there are
many centralized oracle services, e.g., Provable [30]; many
works [39], [40] focus on decentralized oracle services; and
several application-specific decentralized oracle services are
operating, e.g., Chainlink [31], Origin Sport [41]. However,
as we mainly focus on fair outsourcing polynomial compu-
tation, these works are beyond this paper’s scope. Hence, in
this paper, we consider a decentralized oracle service pro-
viding IPFS data for smart contracts.
3.3 Horner’s Method
Horner’s method [24] (or Horner’s rule) is a polynomial
evaluation method that aims to simplify the calculation of
polynomials. It transfers a polynomial of degree n to n lin-
ear functions, and it could be expressed by:
fðxÞ ¼ a0 þ a1 � xþ a2 � x2 þ � � � þ an � xn
¼ a0 þ xða1 þ xða2 þ � � � þ xðan�1 þ xanÞÞÞÞ: (1)
Hence, it only requires n multiplications and n additions
for computing fðxÞ, and the resulting time complexity is
only OðnÞ. By contrast, the normal evaluation of fðxÞ needs
nðnþ 1Þ=2 multiplications and n additions, resulting in the
time complexity Oðn2Þ. It is believed that Horner’s method
is the best way to compute polynomials of a high order,
which is the main reason that we apply Horner’s method in
our proposal.
4 OUR PROPOSED OUTSOURCING POLYNOMIAL
COMPUTATION SCHEMES
In this section, to make a clear introduction to our protocol,
we start from our basic scheme for regular univariate poly-
nomials. Then, we show how to get better performance on
sparse polynomials and how to support multivariate poly-
nomials. The fairness of each scheme will be also analyzed
in this section.
4.1 Basic Scheme for Univariate Polynomials
In this subsection,wewill show how to outsource the compu-
tation of fðxÞ ¼ Pn
i¼0 aix
i in a fair way. We have fiv e phases
in this basic scheme, namely, outsourcing, claiming, comput-
ing, verifying, and closing phases. In the first phase, the user
uploads the specification of fðxÞ to the blockchain. After that,
the worker would claim the computing task and performs it
in the second phase and third phase, respectively. In the
fourth phase, the miners in the blockchain would verify
the validity of the result output by the worker and decide the
money transfer flow according to the verification result. If the
outsourcing process does not go as well as expected, the user
or the worker will execute the closing phase. The details of
these phases can be found in the following.
4.1.1 The Description
Outsourcing phase: In this phase, as shown in Fig. 2, the user
uploads the coefficients ~aa (i.e., fa0; a1; . . . ; ang) of the poly-
nomial fð�Þ and the input x to IPFS and deploys a smart con-
tract in the blockchain based on a given template.
The smart contract contains a constructor and five func-
tions, including functions PAYREWARD, CLAIM, UPLOADRESULT,
VERIFY, and TERMINATE as shown in Fig. 3. The function
PAYREWARD and the function VERIFY can only be invoked by
the user, the function UPLOADRESULT can only be invoked by
Fig. 2. Outsourcing phase of the basic scheme.
2798 IEEE TRANSACTIONS ON SERVICES COMPUTING, VOL. 15, NO. 5, SEPTEMBER/OCTOBER 2022
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
the worker who has successfully invoked the function
CLAIM, and the function TERMINATE can be invoked by the
user or the worker. These restrictions on the invoker of the
smart contract can be realized by the built-in variable msg.
sender which is derived from the invoker’s signature. Fur-
thermore, the modifier PAYABLE after the function name
shows that the function can be invoked with a certain
amount of coins as shown at line 8 in Fig. 2, the value
attached to an invocation can be obtained by the built-in
variable, msg.value.
Moreover, the smart contract has the following fields:
~aa addr, x addr, tw, tu, w, d, user addr, worker addr, and
rr addr. The meanings of these fields are listed in Table 2,
and they are initialized as follows.
� The user directly sets the first six values. Note that
the values of w and d will affect the fairness, which
will be detailed in the fairness analysis later.
� The field user addr is set as the built-in variable msg.
sender mentioned above. Hence, this field stands
for the address of the invoker of the constructor (the
user).
� The rest of the fields including worker addr and
rr addr will be set to empty (denoted by ?) and will
be initialized in the next phases.
After deploying the smart contract, the user needs to
transfer the reward w to it by invoking the function PAYRE-
WARD. This reward will be transferred to someone according
to the conditions specified in the smart contract automati-
cally. The other functions in the smart contract will be
invoked in the next phases.
Claiming Phase. When a worker finds a computing task
he/she is interested in from the blockchain, he/she would
claim the task by invoking the function CLAIM in the corre-
sponding smart contract with the amount d coins attached.
The field worker addr in the smart contract will be accord-
ingly set to msg.sender. By doing so, the worker addr will
be the address of the worker who has successfully invoked
this function, and the address cannot be forged since it is
derived based on its signature as mentioned before. If the
worker wants to unlink his/her two different computing
tasks, he/she will use different addresses. Note that the
function CLAIM in each smart contract could have only one
successful invocation.
Computing Phase. Once the worker claims the computing
task successfully, he/she would first download ~aa and x
from IPFS according to~aa addr and x addr in the smart con-
tract. After that, the worker computes fðxÞ by Horner’s
method, particularly, calculating the recursion defined in:
r0 ¼ an;
ri ¼ an�i þ x� ri�1:
(2)
Before closing the phase, the worker should upload ~rr ¼
½r0; r1; . . . ; rn� to IPFS and submit the corresponding add-
ress rr addr to the smart contract by invoking the function
UPLOADRESULT through the address he/she used to claim this
task. The high-level description of this phase can be found
in Fig. 4.
Verifying Phase. When the result output by the worker is
recorded in the blockchain, the user will receive an event.
To respond it, an honest user will invoke the function VERIFY
in the smart contract with several randomly selected ind-
exes from f0; . . . ; ng. According to the function VERIFY, the
miners download x,~aa and~rr from IPFS and check the valid-
ity of ri’s corresponding to selected indexes by using Eq. (2)
(See line 20–line 27 in Fig. 3). As shown in lines 21-24, the
verification algorithm directly gets ri�1 from worker’s out-
put or the original polynomial. Thus, the mismatch of ri
will not propagate, and the algorithm rejects if any of the
Fig. 3. Functions in the smart contract of the basic scheme.
TABLE 2
Notations Used in the Smart Contract
Notations Description
~aa addr The address of~aa in IPFS.
x addr The address of x in IPFS when fðxÞ is univariate.
user_addr One of the addresses the user uses to receive coins.
worker_addr One of the addresses the worker uses to receive coins.
w; d The reward and deposit of the computing task,
respectively.
tw The latest time the worker should return the
computing result based on how long ago the
computing task is recorded in the blockchain.
tu The latest time the user should launch the verifying
process based on how long ago the computing result is
recorded in the blockchain.
GUAN ETAL.: FAIR OUTSOURCING POLYNOMIALCOMPUTATION BASED ON THE BLOCKCHAIN 2799
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
selected indexes satisfies ri 6¼ an�i�1 þ x� ri�1. If the output
cannot pass the verification, w and d in the smart contract
would be transferred to user_addr; otherwise, the funds are
transferred to the worker, and the user gets rn as the result
of polynomial fðxÞ.
Although the computation phase and the verification
phase are the same for one iteration of Horner’s method, the
verification phase only verifies some steps. Therefore, the
computation cost for the verification phase is less than that
of the computation phase. Moreover, only verification-
related data will be uploaded to the blockchain. Thus, the
gas consumption can be significantly reduced compared to
uploading all data to the blockchain. Also, as the coefficients
and variables are submitted to IPFS as separated files, the
user can use different coefficient addresses to enjoy the fea-
ture of dynamic coefficients.
Closing Phase. If no worker responded to the computing
task, or the worker has not returned the computing result
until tw, the user would invoke the function TERMINATE to
get funds w and d (if there exists). If the worker returned the
computing result before tw, while the user has not invoked
the verifying phase until tu, then the worker would invoke
the function TERMINATE to get funds w and d.
Note: At first glimpse, our scheme cannot guarantee that
the result the user obtained is valid with 100 percent due to
the use of the sampling technique. However, according to
the game-theoretic analysis below, the worker will not devi-
ate the steps in our scheme if he/she is profit-driven.
4.1.2 Fairness of the Basic Scheme
Our proposal should provide the following two properties:
1) If the worker executes correctly, then the user would pay,
and vice versa; and 2) the party who deviated the underly-
ing scheme would get punished. As rational parties, the
action decisions of the worker and the user are based on
their utilities. Based on the analysis of the utilities below,
we have that the worker will execute the task faithfully, and
the user will get the correct answer and pay the reward in
time. In other words, fairness holds.
Worker’s Utility. According to the description of the
basic scheme, the utility of the worker can be expressed as
follows.
uw ¼ w � ð1� Pr½failure�Þ � ððn� iÞ � cw þ d � Pr½failure�Þ;
where Pr½failure� is the probability of verification failure, i
is the number of ri’s mismatching Eq. (2), and cw is the cost
for the worker to execute one multiplication operation.
According to Lemma 1, the worker’s utility is uw �
ðcw � wþd
n Þ � iþ w� n � cw. The inequality n � cw < wþ d usu-
ally holds since the reward w is larger than the cost n � cw in
most cases. Hence, the worker would get the largest utility
when i ¼ 0, i.e., the worker gets the largest utility when he/
she follows our proposal.
On the other hand, Horner’s method is considered as the
most efficient method for univariate dense polynomials,
and the vector~rr is the set of intermediate values of calculat-
ing fðxÞ using Horner’s method. In other words, when the
worker generates ~rr as specified, cw reaches the smallest
value.
Lemma 1. The probability of verification failure increases as the
number of ri’s to be verified increases. In particular,
Pr½failure� � i
n . The equality holds when only one ri in~rr is
selected to be verified.
Proof. Let k be the number of ri’s selected to be verified.
Here, we only consider the case that kþ i � n, since one of
the invalid ri’s will be selected to be verified if kþ i > n.
The probability of verification failure can be expressed as
Pr½failure� ¼1� ðn� iÞ! � ðn� kÞ!
ðn� i� kÞ! � n!
¼1� ðn� iÞðn� i� 1Þ � � � ðn� i� kþ 1Þ
nðn� 1Þ � � � ðn� kþ 1Þ
Let F ðkÞ ¼ ðn�iÞðn�i�1Þ���ðn�i�kþ1Þ
nðn�1Þ���ðn�kþ1Þ , we have that
F ðkþ 1Þ
F ðkÞ ¼ n� i� k
n� k
� 1:
From the above inequality, we have that Pr½failure�
increases as k increases. Furthermore, when k ¼ 1, F ðkÞ
reaches the maximum value F ð1Þ ¼ 1� i
n � 1, and
Pr½failure� gets the minimum value i
n . Note that the
cheating action cannot be detected when k < 1; hence, k
must be 1 at least. tu
As a result, rational workers will calculate polynomials
exactly following the scheme, since cheating will not
increase the utility.
User’s Utility. Since the miners execute the verification,
the user cannot refuse to pay by pretending that the answer
is incorrect or it is not received. As a result, the user will fol-
low the proposed scheme. In this case, his/her utility can be
expressed as follows.
uu ¼ d � Pr½failure� � ðk � cu þ w � ð1� Pr½failure�ÞÞ
¼ d� ðdþ wÞ � F ðkÞ � k � cu;
where cu is the cost for the user to pay the miners to calcu-
late one multiplication, like the gas in Ethereum. That is, the
overall cost for the verification phase is linear to the number
of multiplication operations in this phase.
According to the analysis in the proof of Lemma 1,
F ðkÞ � 1 and F ðkÞ will decrease when k increases. Further-
more, ðdþ wÞ is usually larger than cu. Hence, uu will first
increase and then decrease when k increases from 1 to n,
and it will reach the largest value when k satisfies the fol-
lowing inequalities.
Fig. 4. Computing phase in the basic scheme.
2800 IEEE TRANSACTIONS ON SERVICES COMPUTING, VOL. 15, NO. 5, SEPTEMBER/OCTOBER 2022
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
F ðk� 1Þ � F ðkÞ < cu
dþw
;
F ðkÞ � F ðkþ 1Þ � cu
dþw
:
�
Since the user does not know the value of i, he/she cannot
choose the optimal k for largest uu. Fortunately, as analyzed
for the worker’s utility, k ¼ 1 is enough for the verification
if the worker is rational.
4.2 Enhancing Performance for Sparse Polynomials
In the previous subsection, we proposed an outsourced uni-
variate polynomial computation scheme based on Horner’s
method and illustrated that the rational worker and user
would not deviate from the scheme. However, the solution is
not quite efficient or effective as expected for sparse polyno-
mials. For instance, we have a sparse polynomial fðxÞ ¼
anx
n, and there exists only one ri. To verify the result, the
miners should compute fðxÞ ¼ anx
n again, which is not
acceptable for the blockchain or the user. To solve this prob-
lem, we make use of the binary exponentiation technique,
which can provide enough ri’s to be sampled. In the rest of
this subsection, we will show how we extend our basic
scheme to get better performance on evaluating sparse poly-
nomials and analyze the fairness of the resulting scheme.
Note that, we use the gray background color to highlight the
differences with that in the basic scheme in Figs. 5, 6, and 8.
The claiming phase and closing phase are the same as those
in the basic scheme, andwe omit them in the description.
4.2.1 The Description
Outsourcing phase: To get better performance, we need to
modify the data structure of the vector ~aa. In particular, the
element in~aa changes ð�ai; diÞ as follows.
Assume the outsourced sparse univariate polynomial is
fðxÞ ¼ Pn
i¼0 ai � xi. We rewrite it as fðxÞ ¼ Pm
i¼0 aci � xci
with c0 ¼ 0, and aci 6¼ 0 and ci 2 ½1; n� for i 2 ½1; m�. Without
loss of generalization, we assume that ci < ciþ1 always
holds. Note that ac0ð¼ a0Þ could be zero and cm ¼ n. The
pairs ð�ai; diÞ can be computed as follows.
�ai ¼ aci ; di ¼ ciþ1 � ci for i 2 ½0;m�;
where cmþ1 ¼ n.
For clarification, let us take the following toy example.
Assume we have polynomial 2x3 þ 5x23, then �a0 ¼ a0 ¼ 0,
d0 ¼ c1 � c0 ¼ 3� 0 ¼ 3, �a1 ¼ ac1 ¼ 2, d1 ¼ c2 � c1 ¼
23� 3 ¼ 20, �a2 ¼ ac2 ¼ 5, and d2 ¼ c3 � c2 ¼ 23� 23 ¼ 0.
The rest part of this phase is the same as that in the basic
scheme. We give a high-level description in Fig. 5. Note that
the smart contract built in this phase is almost the same as
that in the basic scheme, the only difference is the function
VERIFY that is given in Fig. 6. The description of function GET-
POWER used in Fig. 7 will be given in the computing phase.
Computing Phase: With the new vector ~aa ¼ ½ð�a0; d0Þ;
ð�a1; d1Þ; . . . ; ð�am; dmÞ�, the recursion in Horner’s method is
accordingly evolved as follows.
r0 ¼ �am
ri ¼ �am�i þ xdm�i � ri�1
(3)
Note that theworker can compute xdm�i by anymethod he/she
wants. Here, we give a method called GETPOWER that is more
Fig. 5. Outsourcing phase for the sparse polynomial.
Fig. 6. The function VERIFY for the sparse polynomial.
Fig. 7. Function for evaluating the power of x.
Fig. 8. Computing phase for the sparse polynomial.
GUAN ETAL.: FAIR OUTSOURCING POLYNOMIALCOMPUTATION BASED ON THE BLOCKCHAIN 2801
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
efficient than the one simply applying the binary exponentia-
tion technique repeatedly for computing many xdm�i ’s. The
main idea in the function GETPOWER is to make use of the inter-
mediate values generated from the process of computing previ-
ous xdm�i ’s. Assume we have the intermediate values
ðxp0 ; xp1 ; . . . ; xpjÞ, and we aim to compute xp. We first find p0
that is the biggest value not larger than p in fp0; p1; . . . ; pjg.
Then, we have that xp ¼ xp0 � xp�p0 . Since we already have xp0 ,
we only need to compute xp�p0 to obtain the value of xp. It is
easy to see that xp�p0 can be further computed as above. The
details of the function GETPOWER can be found in Fig. 7, whereL
is the list used to record the previous intermediate values.
For clarification, let us take the following toy example.
Assume we need to compute x13 and x8. If we just repeat-
edly use the binary exponentiation technique, we need to
compute the intermediate values ðx2; x3; x6; x12; x13Þ and
ðx2; x4; x8Þ, respectively. However, by using our GETPOWER
function, x8 can be computed by using x2 � x6 if x13 was
computed before, or x13 can be computed by using x8 � x4 � x
if x8 was computed before.
The rest part of this phase is the same as that in the basic
scheme.Ahigh-level description of this phase is given in Fig. 8.
Verifying Phase. Similar with the one in the basic scheme,
the user invokes the function VERIFY (as shown in Fig. 6) in
the smart contract with several randomly selected indexes
from f0; . . . ;mg. According to the function VERIFY, the min-
ers would download x,~aa,~rr from IPFS, and check the valid-
ity of ri’s corresponding to selected indexes by using
Eq. (3). The rest of this phase is the same with the one in the
basic scheme.
4.2.2 Fairness in the Scheme for Sparse Polynomials
With the similar analysis as that in the basic scheme, we
have the following result.
� The worker’s utility is uw � c0w � wþd
m
� � � iþ w� n � c0w,
where c0w is the worker’s cost for computing one ri.
The inequality m � c0w < wþ d usually holds since
the reward w is larger than the cost m � c0w in most
cases. Hence, the worker would get the largest utility
when i ¼ 0.
� The user’s utility uu ¼ d� ðdþ wÞ � F 0ðkÞ � k � c0u will
reach the largest value when k satisfies the following
inequalities,
F 0ðk� 1Þ � F 0ðkÞ <
c0u
dþw
;
F 0ðkÞ � F 0ðkþ 1Þ � c0u
dþw
;
(
where F 0ðkÞ ¼ ðm�iÞ!�ðm�kÞ!
m!�ðm�i�kÞ! , and c0u is the user’s aver-
age cost for employing miners to compute one ri.
Note that, for different polynomials, c0u varies
according to their degrees and numbers of terms.
Hence, the worker will execute the task faithfully, and
the user will get the correct answer and pay the reward in
time. In other words, the property of fairness holds.
4.3 Supporting Multivariate Polynomials
Now, we can present our final scheme that additionally sup-
ports multivariate polynomials. In the final scheme, the
worker first transforms a general multivariate polynomial
into Horner’s method format, and then it follows the previ-
ous methods in Section 4.2 to finish the outsourced compu-
tation. Similarly, we also use the gray background color to
highlight the differences in Figs. 9, 10, and 13. Moreover,
similar to the scheme for the sparse polynomial, the claim-
ing phase and closing phase are the same as those in the
basic scheme, and we omit them in the description.
4.3.1 Description
Outsourcing Phase. Similar to the previous schemes, the user
needs to upload the data related to the underlying multivar-
iate polynomial, i.e., the vector ~aa and the input ~xx ¼
½x1; . . . ; x~n�. The vector~aa is different from the one in the pre-
vious schemes and obtained as follows.
Let fð~xxÞ ¼ PN
i¼1 Ai be a multivariate polynomial, where
~xx ¼ ½x1; . . . ; x~n�, Ai ¼ ai �
Q~n
j¼1 x
pij
j , ai 6¼ 0, and 0 � pij � n
for 1 � j � ~n and 1 � i � N . For each Ai, we have one ele-
ment in ~aa, i.e., ðai; fðj; pijÞgj2½1;~n�
pij 6¼0
Þ. The rest of this phase is
almost the same as the one for the basic scheme (see Fig. 9),
except that the VERIFY function is changed as shown in
Fig. 10. The explanations on the input nodes in Fig. 10 will
be given in the verifying phase.
Computing Phase. In this phase, the worker also needs to
compute a vector~rr for the underlying multivariate polyno-
mial fðx1; . . . ; x~nÞ ¼
PN
i¼1ðai �
Q~n
j¼1 x
pij
j Þ. First, the worker
builds a binary tree BTree corresponding to the polynomial
as follows.
� Find the most-occurring variable x‘, and denote A0
as the set of Ai’s containing x‘. If there exist several
x‘’s, then compute the biggest p‘ for each x‘ that
8Ai 2 A0 contains x
p‘
‘ . The final x‘ is the one whose
Fig. 9. Outsourcing phase for the multivariate polynomial.
Fig. 10. The function VERIFY for the multivariate polynomial.
2802 IEEE TRANSACTIONS ON SERVICES COMPUTING, VOL. 15, NO. 5, SEPTEMBER/OCTOBER 2022
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
p‘ is the largest. If there still exist several x‘’s, then
choose any of them as the final x‘.
� Compute the biggest p‘ that 8Ai 2 A0 contains x
p‘
‘ .
This step will be skipped if p‘ was computed before.
� Record ð‘; p‘Þ as the root node of the current tree.
� Repeat the above steps to build the left-child subtree
and right-child subtree of node ð‘; p‘Þ with polyno-
mials
Q
Ai2A0 Ai=x
p‘
‘ and
Q
Ai2A=A0 Ai, respectively.
A high-level description of the above steps is given in
Figs. 11 and 12 gives a toy example of a polynomial
fðx1; x2; x3Þ ¼ 5x31 þ 6x2
1x2 þ 7x3 ¼ x21ð5x1 þ 6x2Þ þ 7x3.
After obtaining the binary tree, the worker computes r
for every node in the binary tree starting from leaf nodes by
using Eq. (4) (the process can be also found in lines 6–12 in
Fig. 13).
node:r ¼ node:rightchild:r þ
node:x‘
node:p‘ � node:leftchild:r:
(4)
Then the worker records r’s into ~rr. The rest part of this
phase is the same as that in the basic scheme. A high-level
description can be found in Fig. 13.
Verifying Phase: Similar to the one in the basic scheme, the
user invokes the function VERIFY (as shown in Fig. 10) in the
smart contract with several randomly selected nodes from
the underlying BTree. According to the function VERIFY, the
miners would download ~xx, ~aa, ~rr from IPFS, and check the
validity of ri’s corresponding to selected nodes by using
Eq. (4). The rest of this phase is the same as that of the basic
scheme.
4.3.2 Fairness in the Scheme
Since the scheme has a similar procedure for computing and
verifying, the probability of verification failure will not
change. Hence, the utilities and actions of both parties are
similar to the analysis in the previous subsection. As a
result, the fairness will not lose in the multivariate setting.
5 ANALYSIS OF OUR PROPOSAL
As shown in the previous section, our proposal holds the
fairness. In this section, we will examine the functionality of
our proposal one by one as listed in Section 2.3, and show
the efficiency by experiments.
5.1 Functionality
In this subsection, we analyze the functionality of our pro-
posed scheme in the following two aspects, namely, arbi-
trary polynomial support and reusability.
Arbitrary Polynomial Support. Based on the description of
our last scheme in Section 4.3, to outsource a polynomial,
the user only needs to upload ~aa and ~xx, i.e., the vectors of
terms and values of variables. Then, the worker needs to
compute the polynomial according to our modified
Horner’s method. Furthermore, the miners can verify the
result by using the sampling technique. Hence, our proposal
can support arbitrary polynomials.
Reusability. In our final scheme, as it points to the polyno-
mial and the input separately, the reusability consists of
two parts, namely, reusing inputs and reusing polynomials.
To evaluate the same polynomial on different inputs, the
user can directly reuse the address to the original ~aa and
only upload the new inputs~xx to IPFS. On the other hand, to
reuse the input, the only thing the user needs to do is to
upload the new ~aa to replace the old one. After that, the
worker can evaluate the new polynomial as before.
5.2 Efficiency
We implemented our scheme in Java and Solidity.4 First, to
demonstrate its actual executing time of the computing
phase and the verifying phase, we test the Java implementa-
tion with a Debian 10 platform equipped with an Intel (R)
Xeon (R) CPU and 26GB RAM. Then, to evaluate the gas
consumption of the verification phase, we test the Solidity
implementation on Rinkeby Ethereum Testnet [25], and we
simulate an oracle service to feed data for the smart con-
tract. Note that, in real-world systems, the values of polyno-
mials are usually bounded. Therefore, in the following
experiments, we randomly generate a prime modulus for
each polynomial and show the performance of our
Fig. 11. Building a binary tree for a multivariate polynomial.
Fig. 12. A binary tree for polynomial fðx1; x2; x3Þ ¼ 5x31 þ 6x21x2 þ 7x3.
Fig. 13. Computing phase for the multivariate polynomial.
4. The source code of our implementation can be found at https://
github.com/guanyg/polyOutsourcing
GUAN ETAL.: FAIR OUTSOURCING POLYNOMIALCOMPUTATION BASED ON THE BLOCKCHAIN 2803
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
https://github.com/guanyg/polyOutsourcing
https://github.com/guanyg/polyOutsourcing
proposed scheme with different bit-lengths of moduli
b ¼ 1024; 2048; 4096; 8192.
5.2.1 Univariate Polynomials
In the computing phase, upon receiving the array of the nþ 1
coefficients in the polynomial and the value of the variable,
the worker computes n multiplications according to
Horner’s method. In the verifying phase, the miners verify
the result according to the position chosen by the user. As
analyzed in Section 4, one position is enough for deterring
the rational worker from deviating. Therefore, the comp-
utational complexities for computing and verifying the uni-
variate polynomials are OðnÞ and Oð1Þ, respectively. As
illustrated in Fig. 14a, the computation time increases as the
degree of the polynomials increases, and the average time
used for computing and verification increases with the bit-
length of moduli b. Also, the verification phase is very effi-
cient. Specifically, the average time for the verifying phase
remains 4.3 ms if only one position is chosen. As shown in
Fig. 14b, the gas consumption for verifying univariate poly-
nomials increases with the degree of polynomials and the
bit-length of moduli, and for the case where bit-length of
moduli b ¼ 8192, the gas consumption is lower than 400,000.
As the current gas price in the Ethereummainnet is 11 gwei,
the average cost for running the verification is less than
0.0044 ETH (about 0.88 USD).
5.2.2 Sparse Polynomials
For sparse polynomials, the time consumption in different
phases depends on not only their degrees but also the num-
ber of non-zero terms in them. Thus, we ran experiments
with varying degrees (i.e., 100, 1000, and 10000) and differ-
ent non-zero terms. As shown in Figs. 14c and 14d, the aver-
age time for the computing phase increases with the degree
n and the number of non-zero terms, but the time consump-
tion for outsourcing polynomials decreases as the number
of terms increases. This is mainly because that as the num-
ber of terms increase, the cost for computing the power of
variables becomes lower. Also, Fig. 14e shows that the aver-
age gas consumption for verifying sparse univariate poly-
nomials decreases as the number of terms increases, and it
increases with the bit-length of moduli b, and it is lower
than 300,000 (about 0.66 USD in the current Ethereum
mainnet).
5.2.3 Multivariate Polynomials
To evaluate the performance of our multivariate polyno-
mials scheme, we generated a series of polynomials with
different degrees, different numbers of non-zero terms, dif-
ferent numbers of variables, and different bit-lengths of
moduli. Since the user uploads the multivariate polynomial
in the outsourcing phase, here we focused on the perfor-
mance of the computing phase and the verifying phase. As
shown in Figs. 14f, 14g, 14h, 14j and 14k, the computation
time increases with the number of variables, while the veri-
fication time decreases as the number of variables increases.
This is mainly because that, as the number of variables
increases, the cost for constructing the binary tree increases
while the cost for computing the power of variables
decreases. Also, Figs. 14f and 14k show that the computa-
tion time for multivariate polynomials increases with the
degree of polynomials and the number of terms. As illus-
trated in Figs. 14h and 14k, the average gas consumption for
verifying multivariate polynomials is lower than 550,000
(about 1.21 USD in the current Ethereum mainnet).
5.2.4 Performance Comparison
Currently, there are many works focusing on verifiable out-
sourcing polynomial computation as detailed in Section 6,
and these schemes usually spend heavy computational
costs to achieve verifiability of computation results. Differ-
ent from the existing schemes, we build our fair outsourcing
polynomial computation scheme based on the rationality
assumption, i.e., all participants are rational actors. Thereby,
our proposed scheme can deter rational workers from sub-
mitting incorrect results and enforce the fairness between
users and workers. To further demonstrate the efficiency of
our proposed scheme, we compare our scheme with two
schemes, namely, Song et al.’s scheme [8] (improved by
Wang et al. [42]) and Zhang et al.’s scheme [26]. In specific,
we implement our scheme and Song et al.’s scheme, and
compare them with the open-source implementation5 of
Zhang et al.’s scheme [26]. Since the implementation of
Zhang et al.’s scheme only supports computation over
64 bits integers, we mainly compare the computation and
proof generation time (“Proof” in Fig. 14l) and verification
time (“Verification” in Fig. 14l) of the three schemes han-
dling polynomials with varied number of variables. In these
polynomials, the bit-lengths of the coefficients and variables
are respectively chosen to be 16 and 4. As shown in Fig. 14l,
our proposed scheme is much efficient than the compared
schemes.
6 RELATED WORK
Since the polynomial computation is very common in many
applications, many outsourcing polynomial computation
schemes have been proposed. The existing schemes can be
roughly divided into three types, namely crypto-based [5],
[6], [7], [8], [43], [44], [45], [46], [47], [48], replica-based [10],
[49], [50], and blockchain-based schemes [13], [14], [51],
[52], [53]. However, none of them can outsource arbitrary
polynomials fairly and efficiently.
6.1 Crypto-Based Outsourcing
Polynomial Computation
In the cryptography community, outsourcing polynomial
computation is studied under the name of verifiable compu-
tation. The first formal security model of verifiable compu-
tation was proposed by Gennaro et al. [4] at CRYPTO 2010,
and a concrete scheme was also present in the same work.
Based on Gennaro et al.’s model, Benabbas et al. [43] pro-
posed another outsourcing polynomial scheme by using the
CFE-PRF (Closed-form Efficiency Pseudorandom Func-
tions). However, their scheme only supports private verifi-
cation as [4]. To solve this problem, Fiore et al. [5] gave a
new outsourcing polynomial computation scheme based on
5. https://github.com/sunblaze-ucb/Virgo
2804 IEEE TRANSACTIONS ON SERVICES COMPUTING, VOL. 15, NO. 5, SEPTEMBER/OCTOBER 2022
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
https://github.com/sunblaze-ucb/Virgo
the bilinear map, while the verification of the resulting
scheme is not efficient as expected. Later on, Catalano et al.
[44], Backes et al. [45], Fiore et al. [46], and Zhang et al. [47]
present new schemes with more efficient verification by
using different techniques, such as homomorphic hash
function and homomorphic message authentic codes.
Fig. 14. The experimental results of our schemes.
GUAN ETAL.: FAIR OUTSOURCING POLYNOMIALCOMPUTATION BASED ON THE BLOCKCHAIN 2805
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
Nevertheless, all the above schemes can only outsource
some special polynomials. At EUROCRYPT 2011, Boneh
et al. [54] constructed a homomorphic signature scheme
which supported multivariate polynomials of constant
degree. Following this, Catalano et al. [55] proposed a more
efficient scheme with the help of graded encoding schemes,
and it obtained a higher security level. By using the arithme-
tic circuit, Parno et al. [56] built a system named Pinocchio,
but this system cannot offer public verifiability. Papaman-
thou et al. [6] proposed the signatures of correct computa-
tion model (SCC), the worker would produce a succinct
signature to vouch for the correctness of the result, and it
could be verified efficiently. This protocol supports the
dynamic update of coefficients, but it cannot support arbi-
trary polynomial. Zhang et al. [48] proposed batch verifiable
computation of polynomials, but it cannot support public
verifiability. Sun et al. [57] solved this problem. Elkhiyaoui
et al. [7] proposed a publicly verifiable computation of poly-
nomial based on the concept of the euclidean division.
However, it is only suitable for univariate polynomials.
Song et al. [8], amended by Want et al. [42], used homomor-
phic verifiable computation tags to design an outsourcing
polynomial computation program. The efficiency of this
program is independent of the size of input data or the
highest degree of the polynomial. However, this scheme
also has restrictions on the type of polynomials. Zhang et al.
[58] employed a linearly homomorphic private-key encryp-
tion scheme to achieve public verifiability. However, since
polynomials are represented as matrices, it is inefficient for
the scheme to handle sparse and multivariate polynomials.
Based on lightweight cryptographic primitives, Zhang et al.
[26] proposed a succinct zero knowledge argument scheme
for layered arithmetic circuits, which can support polyno-
mial delegation and other arithmetic circuits.
Although crypto-based schemes are accurate and of
high-security levels, they suffer from one of the following
disadvantages, at least. 1) Most of the crypto-based schemes
focus on how the user verifies the result from the worker,
and there is a process for the worker to ensure that the
worker can get the promised reward. In other words, fair-
ness cannot be guaranteed. 2) The proof generation costs in
most of the crypto-based schemes are 3-6 orders of magni-
tude higher than the original task [8]. 3) Most of the crypto-
based schemes cannot support general polynomials, and
they are always with the constraint of coefficients, the num-
ber of variants, or the degree of the polynomials.
Unlike the crypto-based outsourcing polynomial compu-
tation schemes, our proposed scheme focuses on enforcing
result correctness for rational workers. Based on our game-
theoretic analysis, when the workers are rational, which is
reasonable in most applications, they will not deviate from
the protocol by submitting incorrect computational results.
Therefore, our proposed scheme can achieve a similar accu-
racy and a trade-off between security and efficiency without
employing cryptographic operations compared with the
crypto-based schemes. Moreover, comparing with most of
these schemes, the proposed scheme has the feature of
dynamic coefficients as the variables and coefficients are
separately uploaded to IPFS. Furthermore, different from
our proposed scheme, the existing crypto-based schemes
cannot support fairness because they are not integrated
with payment channel and cannot programmatically trans-
fer funds based on the results’ correctness.
6.2 Replica-Based Outsourcing Computation
The basic idea of the replica-based schemes is to outsource a
computing task to two or more workers, and the workers
compute independently. The user will crosscheck the
results after all servers have returned the results so that the
user could verify the results quickly. Based on refereed
games [59], Canetti et al. [49] constructed an interactive veri-
fiable computation scheme on multiple servers. Based on
this scheme, they continually improved efficiency and secu-
rity in [50] and [10]. All the schemes work correctly only if
the workers do not collude with each other, while this
assumption would not always hold in reality. Furthermore,
like the crypto-based schemes, replica-based schemes do
not consider the workers’ profits.
6.3 Blockchain-Based Outsourcing Computation
Blockchain is a technology allowing entities to establish
trust relationships even if they distrusted each other before.
Hence, it is natural to apply blockchain in outsourcing com-
putation, and many attempts have happened in industry
and academia.
In industry, Golem [60], SONM [61] and iExec [62] are
three notable projects. Golem can only provide result verifi-
ability but it cannot guarantee that the worker will get the
promised reward. SONM obtains fairness according to the
reputation system. iExec uses proof of contribution, majority
voting, and reputation score to ensure fairness. In other
words, SONMand IExec cannot support result verifiability.
In academia, Kumaresan et al. [13] proposed a model to
motivate correct computing in the Bitcoin network. In their
system, the worker should pay a deposit that would be lost if
the result cannot pass the verification. Their scheme mainly
focused on the timely delivery of the results and the fairness
of the payment. Campanelli et al. [51] realized the zero-
knowledge payment of services based on blockchain, but
their scheme lacks design details, and its efficiency is not so
good as expected. Based on game theory and smart contract,
Dong et al. [14] proposed an efficient verifiable outsourcing
computing solution. However, their scheme only works
when the workers do not collude with each other. This
assumption is a little bit strong in the blockchain system. For
example, more than 15 percent of mining power may come
from the same mining pool in Bitcoin. In other words, there
is more than 15 percent chance that the twoworkers are from
the same organization. Huang et al. [52] proposed a block-
chain-based outsourcing computation scheme based on com-
mitment-based sampling technology, but it requires a
trusted third-party. Krol et al. [53] proposed an efficient and
secure blockchain-based outsourcing computation solution
by using trusted hardware that would increase the user’s
cost. Lin et al. [63] studied how to use blockchain to secure
outsourcing bilinear pairings. Zhang et al. [64] employed a
challenge-and-proof manner to build a fair payment frame-
work for outsourcing service, but it did not discuss the
approach of constructing correctness proof for specific
computational tasks. Cui et al. [65] proposed an outsourced
decryption scheme for a functional encryption scheme, in
2806 IEEE TRANSACTIONS ON SERVICES COMPUTING, VOL. 15, NO. 5, SEPTEMBER/OCTOBER 2022
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
which a decrypted result is first verified by the user and fur-
ther verified byminers if the user rejects the result. It is fair to
say that none of the existing blockchain-based schemes can
outsource all kinds of polynomials fairly and efficiently.
7 CONCLUSION
By using Horner’s method and the blockchain, we have pro-
posed an outsourcing polynomial computation scheme sup-
porting arbitrary polynomials and dynamic coefficients.
Horner’s method allows the worker to perform polynomial
computation as efficient as possible. The blockchain can guar-
antee fairness between the user and worker when the miners
can verify the result from the worker. We obtained the public
verifiability of the result by using the sampling technique.
With the assumption that both user and worker are rational,
our game-theoretic analysis shows that our verification process
works well. By running the extensive experiments, our pro-
posal is indicated as efficient in terms of computational cost.
ACKNOWLEDGMENTS
This work was supported by the Natural Science Founda-
tion of Zhejiang Province under Grant LZ18F020003, the
National Natural Science Foundation of China under Grant
U1709217, NSERC Discovery under Grants 04009, and
LMCRF-S-2020-03.
REFERENCES
[1] K. Mekki, E. Bajic, F. Chaxel, and F. Meyer, “A comparative study
of LPWAN technologies for large-scale IoT deployment,” ICT
Express, vol. 5, no. 1, pp. 1–7, 2019.
[2] Y. Guan, J. Shao, G. Wei, andM. Xie, “Data security and privacy in
fog computing,” IEEE Netw., vol. 32, no. 5, pp. 106–111, 2018.
[3] J. Shao and G. Wei, “Secure outsourced computation in connected
vehicular cloud computing,” IEEE Netw., vol. 32, no. 3, pp. 36–41,
May/Jun. 2018.
[4] R. Gennaro, C. Gentry, and B. Parno, “Non-interactive verifiable
computing: Outsourcing computation to untrusted workers,” in
Proc. Annu. Cryptology Conf., 2010, pp. 465–482.
[5] D. Fiore and R. Gennaro, “Publicly verifiable delegation of large
polynomials and matrix computations, with applications,” in
Proc. ACM Conf. Comput. Commun. Secur., 2012, pp. 501–512.
[6] C. Papamanthou, E. Shi, and R. Tamassia, “Signatures of correct
computation,” in Proc. Theory Cryptogr. Conf., 2013, pp. 222–242.
[7] K. Elkhiyaoui, M. €Onen, M. Azraoui, and R. Molva, “Efficient tech-
niques for publicly verifiable delegation of computation,” in Proc.
11th ACMAsia Conf. Comput. Commun. Secur., 2016, pp. 119–128.
[8] W. Song, B. Wang, Q. Wang, C. Shi, W. Lou, and Z. Peng,
“Publicly verifiable computation of polynomials over outsourced
data with multiple sources,” IEEE Trans. Inf. Forensics Security,
vol. 12, no. 10, pp. 2334–2347, Oct. 2017.
[9] J. Sun, B. Zhu, J. Qin, J. Hu, and J. Ma, “Confidentiality-preserving
publicly verifiable computation schemes for polynomial evalua-
tion and matrix-vector multiplication,” Secur. Commun. Netw.,
vol. 2018, pp. 5 275 132:1–5 275 132:15, 2018.
[10] R. Canetti, B. Riva, and G. N. Rothblum, “Refereed delegation of
computation,” Inf. Comput., vol. 226, pp. 16–36, 2013.
[11] H. Pagnia and F. C. G€artner, “On the impossibility of fair
exchange without a trusted third party,” Darmstadt Univ. Tech-
nol., Darmstadt, Germany, Tech. Rep. TUD-BS-1999–02, 1999.
[12] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” 2008.
[Online]. Available: https://bitcoin.org/en/bitcoin-paper
[13] R. Kumaresan and I. Bentov, “How to use bitcoin to incentivize
correct computations,” in Proc. ACM SIGSAC Conf. Comput. Com-
mun. Secur., 2014, pp. 30–41.
[14] C. Dong, Y. Wang, A. Aldweesh, P. McCorry, and A. van Moorsel,
“Betrayal, distrust, and rationality: Smart counter-collusion con-
tracts for verifiable cloud computing,” in Proc. ACM SIGSAC Conf.
Comput. Commun. Secur., 2017, pp. 211–227.
[15] C. Wang, K. Ren, J. Wang, and Q. Wang, “Harnessing the cloud for
securely outsourcing large-scale systems of linear equations,” IEEE
Trans. Parallel Distrib. Syst., vol. 24, no. 6, pp. 1172–1181, Jun. 2013.
[16] X. Chen, X. Huang, J. Li, J. Ma, W. Lou, and D. S. Wong, “New algo-
rithms for secure outsourcing of large-scale systems of linear equa-
tions,” IEEE Trans. Inf. Forensics Security, vol. 10, no. 1, pp. 69–78, Jan.
2015.
[17] H. S. Ahn andY.H. Lim, “Distributed coordination for optimal energy
flow in smart grid networks: High-order polynomial approach,” in
Proc. 16th Int. Conf. Control Automat. Syst., 2016, pp. 660–665.
[18] C. Richter, A. Bry, and N. Roy, “Polynomial trajectory planning
for aggressive quadrotor flight in dense indoor environments,” in
Robotics Research, Berlin, Germany: Springer, 2016, pp. 649–666.
[19] R. Archibald, A. Gelb, and R. B. Platte, “Image reconstruction
from undersampled fourier data using the polynomial annihila-
tion transform,” J. Sci. Comput., vol. 67, no. 2, pp. 432–452, 2016.
[20] J. A. de la O Serna, “Synchrophasor measurement with polyno-
mial phase-locked-loop taylor–fourier filters,” IEEE Trans. Ins-
trum. Meas., vol. 64, no. 2, pp. 328–337, Feb. 2015.
[21] M. Blondel, M. Ishihata, A. Fujino, and N. Ueda, “Polynomial net-
works and factorization machines: New insights and efficient
training algorithms,” in Proc. 33nd Int. Conf. Mach. Learn., 2016,
pp. 850–858.
[22] M. Sznaier and O. I. Camps, “SOS-RSC: A sum-of-squares poly-
nomial approach to robustifying subspace clustering algorithms,”
in Proc. IEEE/CVF Conf. Comput. Vis. Pattern Recognit., 2018,
pp. 8033–8041.
[23] A. Shpilka and A. Yehudayoff, “Arithmetic circuits: A survey of
recent results and open questions,” Found. Trends Theor. Comput.
Sci., vol. 5, no. 3–4, pp. 207–388, 2010.
[24] “Horner’s method,” 2020. [Online]. Available: https://en.
wikipedia.org/wiki/Horner%27s_method
[25] “Rinkeby: Ethereum testnet.” Accessed: Jan. 2021. [Online]. Avail-
able: https://www.rinkeby.io
[26] J. Zhang, T. Xie, Y. Zhang, and D. Song, “Transparent polynomial
delegation and its applications to zero knowledge proof,” in Proc.
IEEE Symp. Secur. Privacy, 2020, pp. 859–876.
[27] “Ethereum.” Accessed: Jan. 2021. [Online]. Available: https://
ethereum.org/
[28] “Eosio - fast, flexible, and forward-driven.” Accessed: Jan. 2021.
[Online]. Available: https://eos.io/
[29] “Neo smart economy.” Accessed: Jan. 2021. [Online]. Available:
https://neo.org/
[30] “Provable - blockchain oracle service, enabling data-rich smart
contracts.” Accessed: Jan. 2021. [Online]. Available: https://
provable.xyz/
[31] “Chainlink.” Accessed: Jan. 2021. [Online]. Available: https://
chain.link/
[32] “DOS network.” Accessed: Jan. 2021. [Online]. Available: https://
dos.network/
[33] S. Nick, “Formalizing and securing relationships on public
networks,” First Monday 2(9), 1997. [Online]. Available: https://
doi.org/10.5210/fm.v2i9.548
[34] J. Benet, “IPFS-content addressed, versioned, P2P file system,”
2014. [Online]. Available: https://arxiv.org/abs/1407.3561
[35] “Protocol labs.” Accessed: Jan. 2021. [Online]. Available: https://
protocol.ai/
[36] M. A. P. Chamikara, P. Bert�ok, I. Khalil, D. Liu, S. Camtepe, and
M. Atiquzzaman, “A trustworthy privacy preserving framework
for machine learning in industrial IoT systems,” IEEE Trans. Ind.
Inform., vol. 16, no. 9, pp. 6092–6102, Sep. 2020.
[37] M. Li et al., “Crowdbc: A blockchain-based decentralized frame-
work for crowdsourcing,” IEEE Trans. Parallel Distrib. Syst.,
vol. 30, no. 6, pp. 1251–1266, Jun. 2019.
[38] S. S. Arslan and T. Goker, “Compress-store on blockchain: A
decentralized data processing and immutable storage for multi-
media streaming,” CoRR, vol. abs/1905.10458, 2019. [Online].
Available: http://arxiv.org/abs/1905.10458
[39] D. Middleton and S. Amundson, “Distributed blockchain oracle,”
US Patent 16/234,157, May 2, 2019.
[40] S. Woo, J. Song, and S. Park, “A distributed oracle using intel SGX
for blockchain-based IoT applications,” Sensors, vol. 20, no. 9,
2020, Art. no. 2725.
[41] “Origin sport whitepaper,” Mar. 2018. [Online]. Available:
https://www.originsport.io/Origin_Whitepaper_EN.pdf
[42] X. A. Wang, K.-K. R. Choo, J. Weng, and J. Ma, “Comments on
“publicly verifiable computation of polynomials over outsourced
data with multiple sources”,” IEEE Trans. Inf. Forensics Security,
vol. 15, pp. 1586–1588, Aug. 22, 2020.
GUAN ETAL.: FAIR OUTSOURCING POLYNOMIALCOMPUTATION BASED ON THE BLOCKCHAIN 2807
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
https://bitcoin.org/en/bitcoin-paper
https://en.wikipedia.org/wiki/Horner%27s_method
https://en.wikipedia.org/wiki/Horner%27s_method
https://www.rinkeby.io
https://ethereum.org/
https://ethereum.org/
https://eos.io/
https://neo.org/
https://provable.xyz/
https://provable.xyz/
https://chain.link/
https://chain.link/
https://dos.network/
https://dos.network/
https://doi.org/10.5210/fm.v2i9.548
https://doi.org/10.5210/fm.v2i9.548
https://arxiv.org/abs/1407.3561
https://protocol.ai/
https://protocol.ai/
http://arxiv.org/abs/1905.10458
https://www.originsport.io/Origin_Whitepaper_EN.pdf
[43] S. Benabbas, R. Gennaro, and Y. Vahlis, “Verifiable delegation of
computation over large datasets,” in Proc. Annu. Cryptol. Conf.,
2011, pp. 111–131.
[44] D. Catalano, D. Fiore, R. Gennaro, and K. Vamvourellis,
“Algebraic (trapdoor) one-way functions and their applications,”
in Proc. Theory Cryptogr. Conf., 2013, pp. 680–699.
[45] M. Backes, D. Fiore, and R. M. Reischuk, “Verifiable delegation of
computation on outsourced data,” in Proc. ACM SIGSAC Conf.
Comput. Commun. Secur., 2013, pp. 863–874.
[46] D. Fiore, R. Gennaro, and V. Pastro, “Efficiently verifiable compu-
tation on encrypted data,” in Proc. ACM SIGSAC Conf. Comput.
Commun. Secur., 2014, pp. 844–855.
[47] L. F. Zhang and R. Safavi-Naini, “Generalized homomorphic
MACs with efficient verification,” in Proc. 2nd ACM Workshop
ASIA Public-Key Cryptography, 2014, pp. 3–12.
[48] L. F. Zhang and R. Safavi-Naini, “Batch verifiable computation of
polynomials on outsourced data,” in Proc. Eur. Symp. Res. Comput.
Secur., 2015, pp. 167–185.
[49] R. Canetti, B. Riva, and G. N. Rothblum, “Practical delegation of
computation using multiple servers,” in Proc. 18th ACM Conf.
Comput. Commun. Secur., 2011, pp. 445–454.
[50] R. Canetti, B. Riva, and G. N. Rothblum, “Two protocols for dele-
gation of computation,” in Proc. Int. Conf. Inf. Theoretic Secur.,
2012, pp. 37–61.
[51] M. Campanelli, R. Gennaro, S. Goldfeder, and L. Nizzardo, “Zero-
knowledge contingent payments revisited: Attacks and payments
for services,” in Proc. ACM SIGSAC Conf. Comput. Commun. Secur.,
2017, pp. 229–243.
[52] H. Huang, X. Chen, Q. Wu, X. Huang, and J. Shen, “Bitcoin-based
fair payments for outsourcing computations of fog devices,”
Future Gener. Comput. Syst., vol. 78, pp. 850–858, 2018.
[53] M. Kr�ol and I. Psaras, “SPOC: Secure payments for outsourced
computations,” CoRR, vol. abs/1807.06462, 2018. [Online].
Available: http://arxiv.org/abs/1807.06462
[54] D. Boneh and D. M. Freeman, “Homomorphic signatures for poly-
nomial functions,” in Proc. Annu. Int. Conf. Theory Appl. Cryptogr.
Techn., 2011, pp. 149–168.
[55] D. Catalano, D. Fiore, and B. Warinschi, “Homomorphic signa-
tures with efficient verification for polynomial functions,” in Proc.
Annu. Cryptol. Conf., 2014, pp. 371–389.
[56] B. Parno, J. Howell, C. Gentry, and M. Raykova, “Pinocchio:
Nearly practical verifiable computation,” in Proc. IEEE Symp.
Secur. Privacy, 2013, pp. 238–252.
[57] Y. Sun, Y. Yu, X. Li, K. Zhang, H. Qian, and Y. Zhou, “Batch verifi-
able computation with public verifiability for outsourcing polyno-
mials and matrix computations,” in Proc. Australas. Conf. Inf.
Secur. Privacy, 2016, pp. 293–309.
[58] L. F. Zhang and R. Safavi-Naini, “Protecting data privacy in pub-
licly verifiable delegation of matrix and polynomial functions,”
Des. Codes Cryptogr., vol. 88, no. 4, pp. 677–709, 2020.
[59] U. Feige and J. Kilian, “Making games short,” in Proc. 29th Annu.
ACM Symp. Theory Comput., 1997, pp. 506–516.
[60] “Golem.” Accessed: Jan. 2021. [Online]. Available: https://golem.
network/
[61] “Sonm — decentralized fog computing platform.”Accessed: Jan.
2021. [Online]. Available: https://sonm.com/
[62] “iexec blockchain-based decentralized cloud computing.”
Accessed: Jan. 2021. [Online]. Available: https://iex.ec/
[63] C. Lin, D. He, X. Huang, X. Xie, and K.-K. R. Choo, “Blockchain-
based system for secure outsourcing of bilinear pairings,” Inf. Sci.,
vol. 527, pp. 590–601, 2018.
[64] Y. Zhang, R. Deng, X. Liu, and D. Zheng, “Outsourcing service
fair payment based on blockchain and its applications in cloud
computing,” IEEE Trans. Services Comput., to be published,
doi: 10.1109/TSC.2018.2864191.
[65] H. Cui, Z. Wan, X. Wei, S. Nepal, and X. Yi, “Pay as you decrypt:
Decryption outsourcing for functional encryption using blockchain,”
IEEETrans. Inf. Forensics Security, vol. 15, pp. 3227–3238, Feb. 2020.
Yunguo Guan is currently working toward the
PhD degree with the Faculty of Computer Sci-
ence, University of New Brunswick, Canada. His
research interests include applied cryptography
and game theory.
Hui Zheng received the master’s degree from the
School of Computer and Information Engineer-
ing, Zhejiang Gongshang University, China. Her
research interests include applied cryptography
and blockchain.
Jun Shao received the PhD degree from the
Department of Computer Science and Engineer-
ing, Shanghai Jiao Tong University, Shanghai,
China, in 2008. He was a postdoc with the School
of Information Sciences and Technology, Penn-
sylvania State University, from May 2008 to April
2010. He was also a visiting professor with the
Faculty of Computer Science, University of New
Brunswick, Canada from October 2017 to March
2018. He is currently a professor with the School
of Computer and Information Engineering, Zhe-
jiang Gongshang University, Hangzhou, China. His research interests
include network security and applied cryptography.
Rongxing Lu (Fellow, IEEE) received the first
PhD degree from Shanghai Jiao Tong University,
China, in 2006, and the PhD degree from the
Department of Electrical and Computer Engineer-
ing, University of Waterloo, Canada, in 2012. He
is currently an associate professor with the Fac-
ulty of Computer Science (FCS), University of
New Brunswick (UNB), Canada. Before that, he
worked as an assistant professor with the School
of Electrical and Electronic Engineering, Nanyang
Technological University (NTU), Singapore from
April 2013 to August 2016. He worked as a postdoctoral fellow with the
University of Waterloo from May 2012 to April 2013. He was awarded
the most prestigious “Governor General’s Gold Medal” and won the 8th
IEEE Communications Society (ComSoc) Asia Pacific (AP) Outstanding
Young Researcher Award, in 2013. His research interests include
applied cryptography, privacy enhancing technologies, and IoT-Big Data
security and privacy. He has published extensively in his areas of exper-
tise (with H-index 72 from Google Scholar as of November 2020), and
was the recipient of nine best (student) paper awards from some reputa-
ble journals and conferences. Currently, he serves as the vice-chair
(Conferences) of the IEEE ComSoc CIS-TC (Communications and Infor-
mation Security Technical Committee). He is the Winner of 2016-17
Excellence in Teaching Award, FCS, UNB.
Guiyi Wei received the PhD degree from
Zhejiang University, in December 2006. He is cur-
rently a professor with the School of Electronic
and Information Engineering, Zhejiang Gong-
shang University. He was advised by Cheung
Kong chair professor Yao Zheng. His research
interests include wireless networks, mobile com-
puting, cloud computing, social networks and net-
work security.
" For more information on this or any other computing topic,
please visit our Digital Library at www.computer.org/csdl.
2808 IEEE TRANSACTIONS ON SERVICES COMPUTING, VOL. 15, NO. 5, SEPTEMBER/OCTOBER 2022
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:37:08 UTC from IEEE Xplore.  Restrictions apply. 
http://arxiv.org/abs/1807.06462
https://golem.network/
https://golem.network/
https://sonm.com/
https://iex.ec/
http://dx.doi.org/10.1109/TSC.2018.2864191
<<
  /ASCII85EncodePages false
  /AllowTransparency false
  /AutoPositionEPSFiles true
  /AutoRotatePages /None
  /Binding /Left
  /CalGrayProfile (Gray Gamma 2.2)
  /CalRGBProfile (sRGB IEC61966-2.1)
  /CalCMYKProfile (U.S. Web Coated \050SWOP\051 v2)
  /sRGBProfile (sRGB IEC61966-2.1)
  /CannotEmbedFontPolicy /Warning
  /CompatibilityLevel 1.4
  /CompressObjects /Off
  /CompressPages true
  /ConvertImagesToIndexed true
  /PassThroughJPEGImages true
  /CreateJobTicket false
  /DefaultRenderingIntent /Default
  /DetectBlends true
  /DetectCurves 0.0000
  /ColorConversionStrategy /sRGB
  /DoThumbnails true
  /EmbedAllFonts true
  /EmbedOpenType false
  /ParseICCProfilesInComments true
  /EmbedJobOptions true
  /DSCReportingLevel 0
  /EmitDSCWarnings false
  /EndPage -1
  /ImageMemory 1048576
  /LockDistillerParams true
  /MaxSubsetPct 100
  /Optimize true
  /OPM 0
  /ParseDSCComments false
  /ParseDSCCommentsForDocInfo true
  /PreserveCopyPage true
  /PreserveDICMYKValues true
  /PreserveEPSInfo false
  /PreserveFlatness true
  /PreserveHalftoneInfo true
  /PreserveOPIComments false
  /PreserveOverprintSettings true
  /StartPage 1
  /SubsetFonts false
  /TransferFunctionInfo /Remove
  /UCRandBGInfo /Preserve
  /UsePrologue false
  /ColorSettingsFile ()
  /AlwaysEmbed [ true
    /Algerian
    /Arial-Black
    /Arial-BlackItalic
    /Arial-BoldItalicMT
    /Arial-BoldMT
    /Arial-ItalicMT
    /ArialMT
    /ArialNarrow
    /ArialNarrow-Bold
    /ArialNarrow-BoldItalic
    /ArialNarrow-Italic
    /ArialUnicodeMS
    /BaskOldFace
    /Batang
    /Bauhaus93
    /BellMT
    /BellMTBold
    /BellMTItalic
    /BerlinSansFB-Bold
    /BerlinSansFBDemi-Bold
    /BerlinSansFB-Reg
    /BernardMT-Condensed
    /BodoniMTPosterCompressed
    /BookAntiqua
    /BookAntiqua-Bold
    /BookAntiqua-BoldItalic
    /BookAntiqua-Italic
    /BookmanOldStyle
    /BookmanOldStyle-Bold
    /BookmanOldStyle-BoldItalic
    /BookmanOldStyle-Italic
    /BookshelfSymbolSeven
    /BritannicBold
    /Broadway
    /BrushScriptMT
    /CalifornianFB-Bold
    /CalifornianFB-Italic
    /CalifornianFB-Reg
    /Centaur
    /Century
    /CenturyGothic
    /CenturyGothic-Bold
    /CenturyGothic-BoldItalic
    /CenturyGothic-Italic
    /CenturySchoolbook
    /CenturySchoolbook-Bold
    /CenturySchoolbook-BoldItalic
    /CenturySchoolbook-Italic
    /Chiller-Regular
    /ColonnaMT
    /ComicSansMS
    /ComicSansMS-Bold
    /CooperBlack
    /CourierNewPS-BoldItalicMT
    /CourierNewPS-BoldMT
    /CourierNewPS-ItalicMT
    /CourierNewPSMT
    /EstrangeloEdessa
    /FootlightMTLight
    /FreestyleScript-Regular
    /Garamond
    /Garamond-Bold
    /Garamond-Italic
    /Georgia
    /Georgia-Bold
    /Georgia-BoldItalic
    /Georgia-Italic
    /Haettenschweiler
    /HarlowSolid
    /Harrington
    /HighTowerText-Italic
    /HighTowerText-Reg
    /Impact
    /InformalRoman-Regular
    /Jokerman-Regular
    /JuiceITC-Regular
    /KristenITC-Regular
    /KuenstlerScript-Black
    /KuenstlerScript-Medium
    /KuenstlerScript-TwoBold
    /KunstlerScript
    /LatinWide
    /LetterGothicMT
    /LetterGothicMT-Bold
    /LetterGothicMT-BoldOblique
    /LetterGothicMT-Oblique
    /LucidaBright
    /LucidaBright-Demi
    /LucidaBright-DemiItalic
    /LucidaBright-Italic
    /LucidaCalligraphy-Italic
    /LucidaConsole
    /LucidaFax
    /LucidaFax-Demi
    /LucidaFax-DemiItalic
    /LucidaFax-Italic
    /LucidaHandwriting-Italic
    /LucidaSansUnicode
    /Magneto-Bold
    /MaturaMTScriptCapitals
    /MediciScriptLTStd
    /MicrosoftSansSerif
    /Mistral
    /Modern-Regular
    /MonotypeCorsiva
    /MS-Mincho
    /MSReferenceSansSerif
    /MSReferenceSpecialty
    /NiagaraEngraved-Reg
    /NiagaraSolid-Reg
    /NuptialScript
    /OldEnglishTextMT
    /Onyx
    /PalatinoLinotype-Bold
    /PalatinoLinotype-BoldItalic
    /PalatinoLinotype-Italic
    /PalatinoLinotype-Roman
    /Parchment-Regular
    /Playbill
    /PMingLiU
    /PoorRichard-Regular
    /Ravie
    /ShowcardGothic-Reg
    /SimSun
    /SnapITC-Regular
    /Stencil
    /SymbolMT
    /Tahoma
    /Tahoma-Bold
    /TempusSansITC
    /TimesNewRomanMT-ExtraBold
    /TimesNewRomanMTStd
    /TimesNewRomanMTStd-Bold
    /TimesNewRomanMTStd-BoldCond
    /TimesNewRomanMTStd-BoldIt
    /TimesNewRomanMTStd-Cond
    /TimesNewRomanMTStd-CondIt
    /TimesNewRomanMTStd-Italic
    /TimesNewRomanPS-BoldItalicMT
    /TimesNewRomanPS-BoldMT
    /TimesNewRomanPS-ItalicMT
    /TimesNewRomanPSMT
    /Times-Roman
    /Trebuchet-BoldItalic
    /TrebuchetMS
    /TrebuchetMS-Bold
    /TrebuchetMS-Italic
    /Verdana
    /Verdana-Bold
    /Verdana-BoldItalic
    /Verdana-Italic
    /VinerHandITC
    /Vivaldii
    /VladimirScript
    /Webdings
    /Wingdings2
    /Wingdings3
    /Wingdings-Regular
    /ZapfChanceryStd-Demi
    /ZWAdobeF
  ]
  /NeverEmbed [ true
  ]
  /AntiAliasColorImages false
  /CropColorImages true
  /ColorImageMinResolution 150
  /ColorImageMinResolutionPolicy /OK
  /DownsampleColorImages true
  /ColorImageDownsampleType /Bicubic
  /ColorImageResolution 150
  /ColorImageDepth -1
  /ColorImageMinDownsampleDepth 1
  /ColorImageDownsampleThreshold 1.50000
  /EncodeColorImages true
  /ColorImageFilter /DCTEncode
  /AutoFilterColorImages false
  /ColorImageAutoFilterStrategy /JPEG
  /ColorACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /ColorImageDict <<
    /QFactor 0.40
    /HSamples [1 1 1 1] /VSamples [1 1 1 1]
  >>
  /JPEG2000ColorACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000ColorImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasGrayImages false
  /CropGrayImages true
  /GrayImageMinResolution 150
  /GrayImageMinResolutionPolicy /OK
  /DownsampleGrayImages true
  /GrayImageDownsampleType /Bicubic
  /GrayImageResolution 300
  /GrayImageDepth -1
  /GrayImageMinDownsampleDepth 2
  /GrayImageDownsampleThreshold 1.50000
  /EncodeGrayImages true
  /GrayImageFilter /DCTEncode
  /AutoFilterGrayImages false
  /GrayImageAutoFilterStrategy /JPEG
  /GrayACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /GrayImageDict <<
    /QFactor 0.40
    /HSamples [1 1 1 1] /VSamples [1 1 1 1]
  >>
  /JPEG2000GrayACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000GrayImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasMonoImages false
  /CropMonoImages true
  /MonoImageMinResolution 1200
  /MonoImageMinResolutionPolicy /OK
  /DownsampleMonoImages true
  /MonoImageDownsampleType /Bicubic
  /MonoImageResolution 600
  /MonoImageDepth -1
  /MonoImageDownsampleThreshold 1.50000
  /EncodeMonoImages true
  /MonoImageFilter /CCITTFaxEncode
  /MonoImageDict <<
    /K -1
  >>
  /AllowPSXObjects false
  /CheckCompliance [
    /None
  ]
  /PDFX1aCheck false
  /PDFX3Check false
  /PDFXCompliantPDFOnly false
  /PDFXNoTrimBoxError true
  /PDFXTrimBoxToMediaBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXSetBleedBoxToMediaBox true
  /PDFXBleedBoxToTrimBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXOutputIntentProfile (None)
  /PDFXOutputConditionIdentifier ()
  /PDFXOutputCondition ()
  /PDFXRegistryName ()
  /PDFXTrapped /False
  /CreateJDFFile false
  /Description <<
    /CHS <FEFF4f7f75288fd94e9b8bbe5b9a521b5efa7684002000410064006f006200650020005000440046002065876863900275284e8e55464e1a65876863768467e5770b548c62535370300260a853ef4ee54f7f75280020004100630072006f0062006100740020548c002000410064006f00620065002000520065006100640065007200200035002e003000204ee553ca66f49ad87248672c676562535f00521b5efa768400200050004400460020658768633002>
    /CHT <FEFF4f7f752890194e9b8a2d7f6e5efa7acb7684002000410064006f006200650020005000440046002065874ef69069752865bc666e901a554652d965874ef6768467e5770b548c52175370300260a853ef4ee54f7f75280020004100630072006f0062006100740020548c002000410064006f00620065002000520065006100640065007200200035002e003000204ee553ca66f49ad87248672c4f86958b555f5df25efa7acb76840020005000440046002065874ef63002>
    /DAN <FEFF004200720075006700200069006e0064007300740069006c006c0069006e006700650072006e0065002000740069006c0020006100740020006f007000720065007400740065002000410064006f006200650020005000440046002d0064006f006b0075006d0065006e007400650072002c0020006400650072002000650067006e006500720020007300690067002000740069006c00200064006500740061006c006a006500720065007400200073006b00e60072006d007600690073006e0069006e00670020006f00670020007500640073006b007200690076006e0069006e006700200061006600200066006f0072007200650074006e0069006e006700730064006f006b0075006d0065006e007400650072002e0020004400650020006f007000720065007400740065006400650020005000440046002d0064006f006b0075006d0065006e0074006500720020006b0061006e002000e50062006e00650073002000690020004100630072006f00620061007400200065006c006c006500720020004100630072006f006200610074002000520065006100640065007200200035002e00300020006f00670020006e0079006500720065002e>
    /DEU <FEFF00560065007200770065006e00640065006e0020005300690065002000640069006500730065002000450069006e007300740065006c006c0075006e00670065006e0020007a0075006d002000450072007300740065006c006c0065006e00200076006f006e002000410064006f006200650020005000440046002d0044006f006b0075006d0065006e00740065006e002c00200075006d002000650069006e00650020007a0075007600650072006c00e40073007300690067006500200041006e007a006500690067006500200075006e00640020004100750073006700610062006500200076006f006e00200047006500730063006800e40066007400730064006f006b0075006d0065006e00740065006e0020007a0075002000650072007a00690065006c0065006e002e00200044006900650020005000440046002d0044006f006b0075006d0065006e007400650020006b00f6006e006e0065006e0020006d006900740020004100630072006f00620061007400200075006e0064002000520065006100640065007200200035002e003000200075006e00640020006800f600680065007200200067006500f600660066006e00650074002000770065007200640065006e002e>
    /ESP <FEFF005500740069006c0069006300650020006500730074006100200063006f006e0066006900670075007200610063006900f3006e0020007000610072006100200063007200650061007200200064006f00630075006d0065006e0074006f0073002000640065002000410064006f00620065002000500044004600200061006400650063007500610064006f007300200070006100720061002000760069007300750061006c0069007a00610063006900f3006e0020006500200069006d0070007200650073006900f3006e00200064006500200063006f006e006600690061006e007a006100200064006500200064006f00630075006d0065006e0074006f007300200063006f006d00650072006300690061006c00650073002e002000530065002000700075006500640065006e00200061006200720069007200200064006f00630075006d0065006e0074006f00730020005000440046002000630072006500610064006f007300200063006f006e0020004100630072006f006200610074002c002000410064006f00620065002000520065006100640065007200200035002e003000200079002000760065007200730069006f006e0065007300200070006f00730074006500720069006f007200650073002e>
    /FRA <FEFF005500740069006c006900730065007a00200063006500730020006f007000740069006f006e00730020006100660069006e00200064006500200063007200e900650072002000640065007300200064006f00630075006d0065006e00740073002000410064006f006200650020005000440046002000700072006f00660065007300730069006f006e006e0065006c007300200066006900610062006c0065007300200070006f007500720020006c0061002000760069007300750061006c00690073006100740069006f006e0020006500740020006c00270069006d007000720065007300730069006f006e002e0020004c0065007300200064006f00630075006d0065006e00740073002000500044004600200063007200e900e90073002000700065007500760065006e0074002000ea0074007200650020006f007500760065007200740073002000640061006e00730020004100630072006f006200610074002c002000610069006e00730069002000710075002700410064006f00620065002000520065006100640065007200200035002e0030002000650074002000760065007200730069006f006e007300200075006c007400e90072006900650075007200650073002e>
    /ITA (Utilizzare queste impostazioni per creare documenti Adobe PDF adatti per visualizzare e stampare documenti aziendali in modo affidabile. I documenti PDF creati possono essere aperti con Acrobat e Adobe Reader 5.0 e versioni successive.)
    /JPN <FEFF30d330b830cd30b9658766f8306e8868793a304a3088307353705237306b90693057305f002000410064006f0062006500200050004400460020658766f8306e4f5c6210306b4f7f75283057307e305930023053306e8a2d5b9a30674f5c62103055308c305f0020005000440046002030d530a130a430eb306f3001004100630072006f0062006100740020304a30883073002000410064006f00620065002000520065006100640065007200200035002e003000204ee5964d3067958b304f30533068304c3067304d307e305930023053306e8a2d5b9a3067306f30d530a930f330c8306e57cb30818fbc307f3092884c3044307e30593002>
    /KOR <FEFFc7740020c124c815c7440020c0acc6a9d558c5ec0020be44c988b2c8c2a40020bb38c11cb97c0020c548c815c801c73cb85c0020bcf4ace00020c778c1c4d558b2940020b3700020ac00c7a50020c801d569d55c002000410064006f0062006500200050004400460020bb38c11cb97c0020c791c131d569b2c8b2e4002e0020c774b807ac8c0020c791c131b41c00200050004400460020bb38c11cb2940020004100630072006f0062006100740020bc0f002000410064006f00620065002000520065006100640065007200200035002e00300020c774c0c1c5d0c11c0020c5f40020c2180020c788c2b5b2c8b2e4002e>
    /NLD (Gebruik deze instellingen om Adobe PDF-documenten te maken waarmee zakelijke documenten betrouwbaar kunnen worden weergegeven en afgedrukt. De gemaakte PDF-documenten kunnen worden geopend met Acrobat en Adobe Reader 5.0 en hoger.)
    /NOR <FEFF004200720075006b00200064006900730073006500200069006e006e007300740069006c006c0069006e00670065006e0065002000740069006c002000e50020006f0070007000720065007400740065002000410064006f006200650020005000440046002d0064006f006b0075006d0065006e00740065007200200073006f006d002000650072002000650067006e0065007400200066006f00720020007000e5006c006900740065006c006900670020007600690073006e0069006e00670020006f00670020007500740073006b007200690066007400200061007600200066006f0072007200650074006e0069006e006700730064006f006b0075006d0065006e007400650072002e0020005000440046002d0064006f006b0075006d0065006e00740065006e00650020006b0061006e002000e50070006e00650073002000690020004100630072006f00620061007400200065006c006c00650072002000410064006f00620065002000520065006100640065007200200035002e003000200065006c006c00650072002e>
    /PTB <FEFF005500740069006c0069007a006500200065007300730061007300200063006f006e00660069006700750072006100e700f50065007300200064006500200066006f0072006d00610020006100200063007200690061007200200064006f00630075006d0065006e0074006f0073002000410064006f00620065002000500044004600200061006400650071007500610064006f00730020007000610072006100200061002000760069007300750061006c0069007a006100e700e3006f002000650020006100200069006d0070007200650073007300e3006f00200063006f006e0066006900e1007600650069007300200064006500200064006f00630075006d0065006e0074006f007300200063006f006d0065007200630069006100690073002e0020004f007300200064006f00630075006d0065006e0074006f00730020005000440046002000630072006900610064006f007300200070006f00640065006d0020007300650072002000610062006500720074006f007300200063006f006d0020006f0020004100630072006f006200610074002000650020006f002000410064006f00620065002000520065006100640065007200200035002e0030002000650020007600650072007300f50065007300200070006f00730074006500720069006f007200650073002e>
    /SUO <FEFF004b00e40079007400e40020006e00e40069007400e4002000610073006500740075006b007300690061002c0020006b0075006e0020006c0075006f0074002000410064006f0062006500200050004400460020002d0064006f006b0075006d0065006e007400740065006a0061002c0020006a006f0074006b006100200073006f0070006900760061007400200079007200690074007900730061007300690061006b00690072006a006f006a0065006e0020006c0075006f00740065007400740061007600610061006e0020006e00e400790074007400e4006d0069007300650065006e0020006a0061002000740075006c006f007300740061006d0069007300650065006e002e0020004c0075006f0064007500740020005000440046002d0064006f006b0075006d0065006e00740069007400200076006f0069006400610061006e0020006100760061007400610020004100630072006f0062006100740069006c006c00610020006a0061002000410064006f00620065002000520065006100640065007200200035002e0030003a006c006c00610020006a006100200075007500640065006d006d0069006c006c0061002e>
    /SVE <FEFF0041006e007600e4006e00640020006400650020006800e4007200200069006e0073007400e4006c006c006e0069006e006700610072006e00610020006f006d002000640075002000760069006c006c00200073006b006100700061002000410064006f006200650020005000440046002d0064006f006b0075006d0065006e007400200073006f006d00200070006100730073006100720020006600f60072002000740069006c006c006600f60072006c00690074006c006900670020007600690073006e0069006e00670020006f006300680020007500740073006b007200690066007400650072002000610076002000610066006600e4007200730064006f006b0075006d0065006e0074002e002000200053006b006100700061006400650020005000440046002d0064006f006b0075006d0065006e00740020006b0061006e002000f600700070006e00610073002000690020004100630072006f0062006100740020006f00630068002000410064006f00620065002000520065006100640065007200200035002e00300020006f00630068002000730065006e006100720065002e>
    /ENU (Use these settings to create PDFs that match the "Suggested"  settings for PDF Specification 4.0)
  >>
>> setdistillerparams
<<
  /HWResolution [600 600]
  /PageSize [612.000 792.000]
>> setpagedevice