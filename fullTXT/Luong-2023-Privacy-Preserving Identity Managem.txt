Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
Received 2 December 2022, accepted 31 December 2022, date of publication 3 January 2023, date of current version 6 January 2023.
Digital Object Identifier 10.1109/ACCESS.2022.3233828
Privacy-Preserving Identity Management System
on Blockchain Using Zk-SNARK
DUC ANH LUONG AND JONG HWAN PARK
Department of Computer Science, Sangmyung University, Seoul 03016, South Korea
Corresponding author: Jong Hwan Park (jhpark@smu.ac.kr)
This work was supported by the Institute of Information & Communications Technology Planning & Evaluation (IITP) funded by the
Korean Government (MSIT) through the Blockchain Privacy Preserving Techniques Based on Data Encryption under Grant 2021-0-00518.
ABSTRACT Privacy plays a crucial role in the internet era, where many applications allow people to
communicate and use their services through the internet. Privacy-preserving Identity Management (PPIdM)
system is a scheme that helps manage users’ identities and protects users’ privacy by enabling users to
authenticate themselves without disclosing their real identities. The PPIdM system also allows users to reveal
some minor identity attributes while others remain secret selectively. However, anonymity also encourages
malicious users to break the system’s policy and commit crimes since their real identities are anonymous.
Existing PPIdM systems use the identity provider (IP) as a medium to verify users’ identity attributes, record
all users’ real identities, and ensure that malicious users’ identities are traceable. Therefore, users’ identities
are hidden from all entities but the IP. However, the user’s privacy is vulnerable because there is nothing to
guarantee that the IP is always honest and not curious about their users’ activities and private information.
This paper proposes a PPIdM system on the blockchain that helps users manage their identity attributes
and keeps their real identities secret from all entities, including the IP. Still, the system’s consensus can
trace malicious users’ real identities if they violate the system’s policy. The PPIdM’s security requirements
are analyzed and proved informally using the game-based proof scheme. The main idea of this study is to
combine zk-SNARK, a type of zero-knowledge proof (ZKP), Shamir’s secret sharing (SSS), and several
other cryptographic techniques.
INDEX TERMS Identity management, decentralized identifier, blockchain, anonymity, authentication,
secret-sharing, zk-SNARK.
I. INTRODUCTION
In the internet era, using online services from a service
provider (SP) or communicating with other users in an online
community sometimes requires users to have specific IAs,
like age, gender, and additional information. In these cases,
users must prove that their IAs are valid, and an IdM sys-
tem [1], [2] is necessary. The IdM system is a system that
helps users manage their IAs. There are two types of IAs: pri-
mary identity attributes (PIAs) and minor identity attributes
(MIAs). A PIA is a unique attribute that can identify a user.
Driver licenses, citizen identity, and passport numbers are
typical types of PIA. On the other hand, MIAs are common
attributes that do not specify a user. They are date of birth,
gender, workplace, or other additional information.
The associate editor coordinating the review of this manuscript and
approving it for publication was Wei Huang .
Using the IdM system, a usermust register and ask a trusted
IP to verify his IAs. After verifying the IAs, the IP will issue a
certificate indicating the user’s IAs are valid. Afterward, the
user can manage his verified IAs and use his certificate to
prove the validity of the IAs when using the SP’s services.
Because each user is identified by a PIA and the PIA must
be shown in the certificate, the SP can track all their user’s
activities. Hence, this type of system lacks privacy. A PPIdM
system does not include the user’s PIA in the certificate.
Instead, the IP will issue each user a pseudonym (PS) and
have this PS in the user’s certificate. Because a PS does not
reveal any information about the user’s PIA and only the IP
and the PS’s owner know to whom the PS belongs, the SP and
other entities cannot track users’ activities and service history.
Fig. 1 describes this system.
Nevertheless, if the IP is malicious, it can collude with
the SP to track all the user’s activities and service history.
1840 This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/ VOLUME 11, 2023
https://orcid.org/0000-0003-2742-6119
https://orcid.org/0000-0003-0586-090X
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
FIGURE 1. PPIdM system. The ownership is the relation between the PIA
and the PS. Only the user and the IP know this relation.
Therefore, this system is only ideal with an assumption: the
IP is always honest and is not curious about the user’s private
information and activities.
A solution to the above issue is to keep the PS away from
the IP. In other words, the certificate still comprises the PS
instead of the PIA, but the IP does not knowwho the PS owner
is. Therefore, there must be a method for the IP to verify a
user’s IAs and issue the user a certificate without knowing the
user’s PS. Anonymous authentication using zk-SNARK [3]
is a good solution to this problem. However, if only the
user knows the PS, this PPIdM system will lack traceability.
It will encourage malicious users to commit crimes because
there is no way for the IP to trace their PIAs. In addition,
the zk-SNARK scheme is vulnerable to collusion attacks,
in which multiple users can simultaneously use a certifi-
cate as the zk-SNARK’s witness. Collusion attacks enable
unregistered users to join the system by reusing other users’
certificates. Therefore, an ideal PPIdM system should provide
anonymity for honest users and traceability for malicious
users. It should also prevent a user from sharing his certificate
with other users. With this idea, we introduce a novel PPIdM
system with the following contributions.
• We employ the public blockchain, the ElGamal encryp-
tion, the hash-based commitment scheme, and the
zk-SNARK scheme to provide IAs-selective disclosure,
anonymity, and unforgeability and counter the collu-
sion attacks. We use the Shamir Secret Sharing (SSS)
scheme [4] and the blockchain’s consensus to provide
traceability.
• We analyze the security of the proposed system based
on essential requirements for a PPIdM system.
• We calculate the time complexity and the gas cost of the
proposed system.
II. RELATED WORK
To date, several blockchain-based IdM systems [5], [6], [7],
[8], [9], [10], [11], [12], [13] have focused on protecting
users’ privacy and providing anonymity. In this section,
we review the articles related to our study. Table 1 sum-
marizes the comparison between the proposed system and
others.
ElGayyar et al. [5] introduced a robust automatic
blockchain-based federated IdM. Smart contracts automat-
ically generate identities and audits for users. Users can
control their identities and store them on the blockchain.
However, this system’s anonymity is entirely based on the
anonymity of the blockchain. In addition, because this system
employs smart contracts to encrypt and decrypt users’ data
or identities, users’ identities may be visible to the public
because of the transparent property of the public blockchain.
The system of Gao et al. [6] also allows users to hide their
real identities from the public. First, a user authenticates him-
self by bringing a smartphone with a biometric authentication
mechanism and his real identity to the IP. The IP generates
a pair of asymmetric keys and embeds the secret key in
the smartphone. It issues a certificate comprising the user’s
information and the public key to the user. Afterward, the user
uploads this certificate to the blockchain network using his
PS. Any transactions from the user must be signed by the
secret key embedded in the smartphone, which is unlocked
only by the user’s biometric. This system is similar to ElGay-
yar et al. [5]. Users’ identities are stored on the blockchain
and visible to other users or SPs. The system’s anonymity is
based on the anonymous addresses of the blockchain.
Xu et al. [7] have the same approach as Gao et al. [6] for
building an IdM system for mobile devices. A user must first
provide his identity and public key to the IP. After the IP
authenticates his identity and gives him a verifiable claim,
he sends his authenticated identity and the verifiable claim
to the network operator. The network operator will verify this
claim and upload his identity and public key to the blockchain
network. Afterward, all the blockchain network members can
verify this user by querying his public key on the blockchain.
Unlike Gao et al. [6], their scheme employs the consortium
blockchain instead of a public blockchain.
Besides the above system, schemes [8] and [9] have the
same overall architecture. However, these systems have a
low privacy level as users’ identities are visible to everyone
because they are stored in the blockchain network. The fol-
lowing systems can solve these problems.
In the system of Kassem et al. [10], storing the user’s IAs
in a permissioned ledger can prevent unauthorized SPs from
accessing the user’s IAs without a user’s consent. Each user
has an Ethereum account that maps to their IAs, verified by
specified smart contracts. The SPs must gain the user’s con-
sent to access his permissioned ledger to verify his IAs. In the
system of Faber et al. [11], each user has a personal off-chain
database to store their identities instead of keeping them in
the blockchain. The hashes of these data are uploaded to the
blockchain as the addresses of their IAs. Service providers
must have the user’s consent to access a user’s personal
database to verify the user’s IAs. However, users must use the
same account for consuming on-chain services and receiving
IAs and data from IPs.
Nevertheless, the above researches have a common prob-
lem that decreases privacy. Although the users’ real identities
are hidden from the public, they must be visible to the IPs
VOLUME 11, 2023 1841
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
to trace the real identities of malicious users. In other words,
the privacy of these systems strongly relies on the IPs. There
is nothing to guarantee that the IPs will not collude with the
service providers to link their real identities with the corre-
sponding private data from the service providers. Similarly,
the scheme [12] also has this problem.
To eliminate this disadvantage, Zhuang et al. [13] intro-
duced a blockchain-based PPIdM system that enables users
to hide their IAs from both the public and the IP but still
allows the IP to trace their real identities if the users violate
the system’s policy based on the blockchain’s consensus
and SSS. This system works similarly to the scheme of Xu
et al. [7] to achieve this goal, except that it divides the user’s
PIA into k shares using SSS instead of directly storing it
in the blockchain network. A valid user can use his user
identity (UID) to communicate with service providers. The
service providers can verify if the user is valid by querying his
UID on the blockchain. Notably, this UID does not disclose
information about the user’s PIA. If the user violates the
system policy, the system can reconstruct his PIA based on
k shares using SSS. However, this system strongly assumes
that the IPsmust delete the user’s PIA and the associatedUID.
Otherwise, SSS is meaningless because the IPs can always
map the UID to the corresponding PIA.
Based on the above literature, we can see that these sys-
tems’ privacy is low or moderate. In addition, none of them
support selective disclosure. Therefore, we addressed their
existing problems by designing a privacy-preserved IdM sys-
tem on the blockchain that enables users to hide their IAs
from the public and the IP. The proposed system ensures
that no single party can trace a user’s PIA. When malicious
users violate the system policy, it requires the agreement of a
pre-defined number of parties to open the user’s PIA.
III. PRELIMINARIES
A. SHAMIR SECRET SHARING
Shamir Secret Sharing (SSS) [4] is an algorithm for pro-
tecting a secret in a distributed way based on polynomial
interpolation over finite fields. Given a secret s0, SSS is a
perfect (k, n)-threshold scheme that satisfies two following
properties.
• The secret s0 can be reconstructed using at least k shares
with probability 1.
• The secret s0 is information-theoretically hidden when
trying to reconstruct the share using at most k−1 shares.
Let G = (g, q) be a group of order q, where g is a generator
of G. The (k, n)-threshold SSS in a group G can be presented
with two following functions.
• SharesGen(G,Pk−1, s0)→ Sn, where Pk−1 is a set of
k − 1 numbers from p1 to pk−1 randomly chosen in Zq
and s0 ← gw is the secret for a random w ∈ Zq. Then,
Sn is a set of n points si = (xi, yi) for i = 1, . . . , n, which
are generated as follows.
s0← gw,
gf (x) := s0
∏k−1
i=1 g
pixi ,
s1 = (1, gf (1)),
s2 = (2, gf (2)),
...
sn = (n, gf (n)),
Sn = {s1, s2, . . . , sn}.

• Reconstruct(Sk ) → s0, where Sk is a set of arbitrary
k shares si = (xi, yi) for s1 to sk . The secret s0 is
reconstructed as follows.
s0 =
k∏
j=1
y
1j
j , where 1j =
k∏
m=1,m6=j
xm
xm − xj
∈ Zq.
B. ZK-SNARK
Our proposed system employs the zk-SNARK scheme of
Parno et al. [14]. We briefly recall it as follows.
• KeyGen(C)→ {PK ,VK }: this function takes an arith-
metic circuit C and creates a pair of a proving key PK ,
and a verification key VK .
• Proof(Ew, Ex,PK ) → π : this function creates a proof
string π (that consists of eight elliptic curve points) by
taking as input a public input Ex, a witness Ew, and the
proving key PK .
• Verify(π, Ex,VK ) → b: this function takes the proof
string π , a public input Ex, and the verification key VK
to verify that π is valid or not, and outputs a decision bit
b.
The zk-SNARK scheme of Parno et al. also satisfies the
following properties.
• Completeness: If the prover generates a correct proof
string π using a witness Ew, the verifier always accepts
π .
• Succinctness:The size of the proofπ is short, regardless
of the size of the witness Ew and the public input Ex, and
also π is efficiently verified.
• Zero-knowledge: There exists an efficient simulator
that takes a proving key PK and a public input Ex, and
outputs a simulated proof that is indistinguishable from
a real proof (generated with a witness Ew).
• Soundness: Given a proving key PK , a verification key
VK , and a public input Ex (but not the associated witness
Ew), it is infeasible to generate a correct proof string to be
successfully verified.
C. DIGITAL SIGNATURE
We recall the Edward-curve digital signature algorithm
(EdDSA) [15]. EdDSA is a variant of the Schnorr signature
based on performance-optimized twisted Edwards curves.
Let G = (g, q) be a group (over an Edwards curve) of order
q, where g is a generator of G. Then, EdDSA consists of the
following three algorithms.
1842 VOLUME 11, 2023
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
TABLE 1. System comparison.
• KeyGensig(λ,G)→ {SKsig,PKsig}, where λ is a secu-
rity parameter, SKsig ∈ Zq is the secret key, andPKsig←
gSKsig ∈ G is the public key.
• Signsig(m, SKsig)→ {R, s}, where m is a message to be
signed. Given a hash function H : {0, 1}∗ → Zq, {R, s}
is a signature that is calculated as follows.
r ← H(H(SKsig),m) (mod q),
R← gr ,
h← H(R,PKsig,m) (mod q),
s← r + PKsig · h (mod q).

• Verifysig(m,PKsig, {R, s})→ b, where b is the decision
bit and is decided as follows.h← H(R,PKsig,m) (mod q),
P1← gs
P2← R · PK h
sig

If P1 = P2 then b = 1 (valid), else b = 0 (invalid).
Since EdDSA is a variant of the Schnorr signature, it is eas-
ily shown (and well-known) that EdDSA is also unforgeable
against chosen-message attacks based on the hardness of a
discrete logarithm problem in G, assuming that H is modeled
as a random oracle.
D. ElGamal ENCRYPTION
We briefly describe the ElGamal encryption scheme as fol-
lows. Let G = (g, q) be a group (over an Edwards curve) of
order q, where g is a generator of G. The ElGamal encryption
consists of the following algorithms.
• KeyGenElGamal(λ)→ {PK , SK }, where λ is a security
parameter. The secret key SK is randomly chosen in Zq,
and PK ← gSK ∈ G is the corresponding public key.
• ENC(m,PK ; r)→ c, where m ∈ G is a message and r
is a random number in Zq. The ciphertext c = {c1, c2}
is generated as follows:(
c1← gr ∈ G,
c2← m · PK r
∈ G.
)
• DEC(SK , c)→ m. The decryption process is as follows.(
s← cSK1 ∈ G,
m← c2 · s−1 ∈ G.
)
The ElGamal encryption is known to be correct and secure
against chosen-plaintext attacks, assuming the decisional
Diffie-Hellman problem holds in G.
E. HASH FUNCTION
A (cryptographic) hash function H : {0, 1}∗ → Zq has the
following properties.
• Onewayness. It is computationally infeasible to com-
pute a preimage from a hash value given.
• Collision-resistance. Finding two distinct preimages
mapped into the same hash value is computationally
infeasible.
F. COMMITMENT
A commitment scheme allows a committer to commit a value
to keep it hidden from others and reveal the committed value
later. A commitment scheme for our system is a simple and
well-known commitment scheme based on a hash function.
Suppose that a committer A wants to commit a value x to
B. The hash-based commitment scheme can be represented
as follows.
• A sends C ← H(x, q) to B, where C is the commitment,
x is the committed value, and q is chosen randomly from
{0, 1}l for some integer l.
• A reveals his commitment by sending {x, q} to B. B
then verifies A’s commitment by checking whether C =
H(x, q).
The above hash-based commitment scheme satisfies the
following two properties.
• Hiding. The commitment C should give no information
about the committed value x.
• Binding. The committer A cannot change the committed
value x once the commitment C is sent to B.
G. BLOCKCHAIN
Blockchain is a decentralized data structure implemented
in a peer-to-peer network. Instead of storing data in one
VOLUME 11, 2023 1843
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
FIGURE 2. System overview and the relations of all entities. (1) The user
registers his IAs to the IP. The IP issues the user a certificate. (2) The user
uses his PS and the certificate to anonymously authenticate himself,
distribute his encrypted SSS shares to validators, and commit his IAs to
the SC. (3) The user uses his PS to send his IAs to the SP and receive
services from the SP. (3.1) The SP verifies the PS’s IAs by querying them in
the blockchain. (4) The validators reveal the PS’s SSS shares in plaintext.
(4.1) The IP queries for the PS’s SSS shares and uses them to reconstruct
the PS’s PIA.
centralized database, the system keeps the replicated data
in numerous peers (nodes). Each time new data are added,
all nodes in the system update their replicated data. In the
blockchain, data are sent and received in transactions.
Blockchain has the following three main properties.
• Immutability: Once transactions are added, no single
entity can alter these transactions.
• Decentralized: Data are stored in numerous nodes
instead of a single node.
• Consensus: Transactions must be verified by more than
half the number of nodes to be added to the blockchain.
Basically, there are three types of blockchains as follows.
• Public blockchain: users are free to join and quit this
system. Transactions in this system are truly transparent
and visible to all nodes.
• Private blockchain: this system is managed by an
entity. Users must have the permission of the manager
to participate into. Transactions in this system are visible
only to its members.
• Hybrid blockchain: this system combines public and
private blockchain. Instead of one entity managing the
system, all members manage the system and decide who
can participate in the blockchain. They also determine
which transactions are public or private.
There are two types of consensus algorithms, Proof of
Work (PoW) [16] and Proof of Stake (PoS) [17]. PoW allows
all nodes in the blockchain to generate and verify transac-
tions. It reduces the risk of blocks generated by malicious
nodes by asking block miners to solve a hash puzzle [18].
On the other hand, PoS only allows some specific nodes
(validators) to create and verify transactions. PoS reduces
the risk of malicious validators by asking them to delegate
an amount of money as a stake before joining the validating
process. Malicious validators may lose their stake if they are
detected based on the system policy.
The consensus algorithm is crucial in the blockchain.
It decides which block will be added to the main chain among
several blocks. A bad consensus algorithm will result in an
insecure blockchain that is vulnerable to 51% attacks [19]
and censorship attacks [20]. The typical consensus algorithm
in most blockchain networks is Byzantine Fault Tolerance
(BFT) [21]. To date, there have beenmany other BFT versions
that improve and optimize the BFT’s performance [22].
One of the most-used applications of the blockchain is
smart contracts [23]. A smart contract (SC) is a program
stored in the blockchain that runs when the predetermined
conditions are met. Because the SC’s programming language
is Turing-complete in most blockchain networks, the SC can
be used to implement various logical operations and applica-
tions. The proposed system uses an SC as the zk-SNARK’s
verifier and controls all the system’s processes.
IV. PROPOSED SYSTEM
A. MAIN ENTITIES
There are six main entities in the proposed system: an identity
provider (IP), validators, users, pseudonyms (PSs), an SC,
and service providers (SPs). Fig 2 briefly shows the relations
of these entities in the proposed system. We describe these
entities as follows.
IP. This entity can be a centralized or decentralized orga-
nization that issues user certificates. The IP is responsible for
tracing the malicious users’ PIAs.
SPs. These entities provide services for users. They can
require users to have some specific IAs to use their services.
Validators. These entities are responsible for collecting,
verifying, and wrapping transactions into a block and adding
blocks to the blockchain. They are also responsible for keep-
ing users’ SSS shares and the PIA-opening process.
Users. The IP validates these entities and their IAs. Users
use their PSs tomanage their IAs, communicate anonymously
in the proposed system, and use the services provided by the
SPs.
PSs. They are public blockchain accounts (addresses) of
users, validators, SPs, and the IP. These entities can use their
PSs to sign and send transactions.
SC. The SC in the proposed system acts as a zk-SNARK
verifier and helps store and query users’ committed IAs.
There are two communication channels in the proposed
system: the on-chain channel and the off-chain channel.
We describe them as follows.
On-chain channel. This is the public blockchain network,
where all messages are sent and received under the transac-
tion form. In the proposed system, the public blockchain uses
the PoS consensus algorithm. Validators collect transactions,
verify them and add them to the blockchain. Communication
on this channel is transparent and secure against several types
of attacks.
Off-chain channel. This channel refers to all chan-
nels unrelated to the public blockchain network. In our
1844 VOLUME 11, 2023
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
TABLE 2. Notations in the proposed system.
construction, this off-chain channel includes communications
with which users initially register them to the IP or users later
have access to the SP.
B. ASSUMPTIONS
We assume the following statements to ensure that this paper
is within our scope and focuses on our contributions.
• The off-chain channel is secure to the extent that the
channel achieves its goal. For instance, attackers can-
not gain information about users from communications
between users and the IP.
• The public keys PKIP (for the IP), PKVn (for a set of
validatorsVn), and the zk-SNARK’s proving key PK are
public and shared in advance by all entities in the system.
• All entities use the same elliptic curve for zk-SNARK
and the same group G = (g, q) based on a certain
Edwards curve for the SSS, the ElGamal encryption,
and the EdDSA signature schemes. These parameters
are shared in advance.
• When working with the (k, n)-threshold SSS, it is
assumed that at least k number of validators are honest
and k > n
2 .
• The SPs are audited entities. Their public keys and
addresses on the blockchain are verified.
C. CIRCUITS AND SMART CONTRACT
This section describes arithmetic circuits, the SC, and the pro-
posed system. We present all notations used in the proposed
system in Table 2 for ease of reading.
1) ARITHMETIC CIRCUIT
The arithmetic circuit is the core of zk-SNARK. It describes
the relationship between the prover’s witnesses Ew and the
verifier’s pre-defined constraint Ex (as the arithmetic circuit’s
public inputs). We design two arithmetic circuits C and D.
Circuit C is responsible for anonymous authentication, SSS
distribution, and selective disclosure processes. The previous
work [24] designed an anonymous authentication technique
that supports a fixed number of users in their arithmetic
circuit. In our proposed system, however, we enhance their
technique by using EdDSA to support an unlimited number of
users in a single arithmetic circuit. The details for the circuit C
are described in Algorithm 1. Algorithm 2 represents circuit
D for verifying the correctness of the ElGamal encryption,
which is necessary for the PIA-opening process.
In an arithmetic circuit, the private inputs correspond to zk-
SNARK’s witnesses Ew. They are hidden, and the proof string
π exposes no information about them. The set of public inputs
Ex is visible to everyone. The verifier uses Ex and π to verify the
relations between Ew and Ex declared in the arithmetic circuit.
Algorithm 1 Arithmetic Circuit C
Private inputs: mi, r,Pk−1,Qt ,Xt , certi
Public inputs: ĥi,PKIP,Cn,PKVn ,Yt
Output: Decision bit bC
1. Calculate hi← H(mi)
2. Compute rooti← H(Xt , hi)
3. Check Verifysig(rooti, certi,PKIP)
4. Check if ĥi = H(mi + 1)
5. Calculate ei← gPIA
6. Compute Sn← SharesGen(Pk−1, ei)
7. Check if ci = ENC(si,PKvi; r) for i = 1, . . . , n
8. Check if yi = H(xi, qi) for i = 1, . . . , t
9. If lines 3, 4, 7, and 8 are true then bC = 1, else
bC = 0
a: CIRCUIT C
As in Algorithm 1, the circuit C has ExC = {ĥi,PKIP,
Cn,PKVn ,Yt , bC } and EwC = {mi, r,Pk−1,Qt ,Xt , certi},
where mi and r are two random numbers, Pk−1 is a set of
k − 1 random numbers for the (k, n)-threshold SSS (line 6,
Algorithm 1), and Qt is another set of t random numbers for
computing the commitment of Xt (line 8, Algorithm 1).
Pk−1 = {p1, p2, . . . , pk−1},
Qt = {q1, q2, . . . , qt }.
PSi, as a prover, needs to convince the verifier that the fol-
lowing statements are true.
• PSi is the owner of a certificate certi provided by the IP.
This statement is proven without revealing the identity
of Ui. Line 1 computes hi from mi that Ui has selected.
Because only Ui knows mi, this line allows Ui to prove
the ownership of hi, and thus Xt . Line 2 computes the
hash value of {Xt , hi}. We call this hash value rooti.
VOLUME 11, 2023 1845
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
Algorithm 2 Arithmetic Circuit D
Private inputs: SKvi
Public inputs: ci, si,PKvi
Output: Decision bit bD
1. Check if PKvi = gSKvi
2. Check if si = DEC(SKvi , ci)
3. If lines 1 and 2 are true then bD = 1, else bD = 0
Because rooti is a hash value, it is fixed-sized, and any
changes in Xt or hi will result in a different rooti. Line
3 verifies whether certi is the EdDSA signature of rooti.
PSi needs to pass this verification to prove that he is the
owner of certi.
• mi has never been used before. This statement aims to
enhance the above anonymous authentication by remov-
ing the threat of collusion attacks where Ui shares mi
with other users. Each πC will be identified by ĥi ←
H(mi + 1). The verifier records the list of ĥi. Any πC
with a pre-used ĥi will be rejected. Line 4 implements
this statement.
• Ui correctly generates Sn from his PIA and then encrypts
Sn using PKVn . This statement allows Ui to convince
the verifier that he distributes the correct SSS shares
in ciphertext generated from his PIA. These ciphertexts
can be decrypted using SKVn . Because the ElGamal
encryptionworkswith an Edwards curve, line 5maps the
PIA to an elliptic curve point ei. Line 6 usesSharesGen
to generate Sn from Pk−1 and ei. Line 7 encrypts si using
the ElGamal encryption algorithm,ENC, and shows that
the result is identical to ci, which will be issued to a
validator vi for i = 1, . . . , n.
• The prover commits correct IAs which the IP verified.
PSi must convince the verifier that Yt is the set of cor-
rect commitments generated from Xt . Later, the public
Yt values are used to selectively disclose some of IAs
related toUi. Line 8 computes the commitment of {xi, qi}
and compares it with yi for i = 1, . . . , t , which will be
stored on the blockchain.
b: CIRCUIT D
Because reconstructing PIA requires Sk from Vk using the
(k, n)-SSS, there must be a way to prove that vi honestly sent
its share si without disclosing SKvi . We design circuit D to
verify that validators honestly submit their SSS shares.
As in Algorithm 2, circuit D requires vi to enter SKvi as
the private input (EwD = SKvi ), and {ci, si,PKvi} as public
inputs (ExD = {ci, si,PKvi , bD}). The circuit D describes the
following statement: vi owns SKvi corresponds to PKvi (line
1), and si is derived by decrypting ci using SKvi (line 2). If the
above statements are true then bD = 1, else bD = 0.
2) SMART CONTRACT
We design an SC to implement zk-SNARK’s function Verify
of circuits C and D and other functions for the proposed
system. Algorithm 3 describes the details of the SC.
Algorithm 3 SC
Define: Table1,Table2,Table3
1: Function authentication(πC , ExC ):
2: Require bC = 1.
3: Require PKVn to be correct.
4: Require Verify(πC , ExC ,VKC ) to return 1.
5: Require ĥi not to be in Table1.
6: Add {PSi, ĥi,Cn} to Table1.
7: Add {PSi,Yt } to Table2.
8: Function queryPS(PSi):
9: If PSi is in Table1: return true.
10: Else: return false.
11: Function openPIA(πD, ExD):
12: Require bD = 1.
13: Require Verify(πD, ExD,VKD) to return 1.
14: Require ci to be in Table1.
15: Add si to Table3.
16: Function queryPIA(PSi):
17: Require PSi to be in Table3.
18: Return Sk .
19: Function queryMIA(PSi, yi):
20: Require PSi to be in Table2.
21: If: PSi has yi: return true.
22: Else: return false.
FIGURE 3. Structure of the SC’s Table2.
As shown in Algorithm 3, the SC has three tables described
in Fig. 3 and Fig. 8. The SC’s functions are as follows.
• authentication(πC , ExC ): this function takes as inputs
πC and ExC , where ExC = {ĥi,Cn,PKVn ,PKIP,Yt , bC }.
It requires that (1) bC = 1, (2) PKVn are correct, (3)
the zk-SNARK’s function Verify outputs 1, and (4) ĥi
has not been used before. If all these conditions hold,
this function adds {PSi, ĥi,Cn} to Table1 and {PSi,Yt }
to Table2.
• queryPS(PSi): this function takes as input a PS and
checks if it is authenticated. If the queried PS is in
Table1, it returns true and vice versa.
• openPIA(πD, ExD): vi calls this function when opening
the PIA of a target PS. This function takes as inputs πD
and ExD, where ExD = {ci, si,PKvi , bD}. First, it requires
bD = 1. Afterward, it checks if the zk-SNARK’s verifi-
cationVerify on πD and ExD is valid. If the proof is correct
and ci is in Table1, this function appends si to Table3 as
the associated share with the target PS.
• queryPIA(PSi): this function takes as input a PS and
returns the corresponding Sk if the PS is in Table3. The
1846 VOLUME 11, 2023
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
FIGURE 4. Sequence diagram of Step 1.
IP can call this function to reconstruct the PIA of the
target PS.
• queryMIA(PSi, yi): this function receives a PS and yi.
If the PS is in Table2 and associated with yi, it returns
true and vice versa.
D. SYSTEM DESCRIPTION
Step 0. System initialization. The IP initializes the system
as follows.
In the off-chain channel:
• Create the circuits C and D described in Algorithms 1
and 2.
• Generate zk-SNARK key pairs {PKC ,VKC } and
{PKD,VKD}, where
{PKC ,VKC } ← KeyGen(C),
{PKD,VKD} ← KeyGen(D).
• Distribute {PKC ,VKC } and {PKD,VKD} to users.
In the on-chain channel:
• Construct and deploy the SC described in Algorithm 3
to the public blockchain.
Step 1. User registration. In this step, the IP verifies that
Ui’s IAs are valid, and the PIA identifies Ui. Afterward, the
IP issues Ui a certificate certi. Fig. 4 describes the details of
this step.
In the off-chain channel:
• Ui chooses a random number mi and compute hi ←
H(mi).
• Ui prepares Xt = {x1, x2, . . . , xt }, where x1 is the PIA
and {x2, x3, . . . , xt } is the set of MIAs.
• Ui sends {Xt , hi} to the IP.
• The IP verifies {Xt , hi} to ensure that Xt is valid with
respect to Ui and hi has never been used before. After-
ward, the IP computes rooti and certi.
rooti ← H(Xt , hi),
certi ← Signsig(rooti, SKIP).
• The IP computes ei← gPIA ∈ G.
• The IP stores ei and the PIA to its data storage.
• The IP sends certi to Ui.
FIGURE 5. Sequence diagram of Step 2.
Step 2. Anonymous authentication, distribution of SSS
shares, and IAs commitment. In this step, PSi authenticates
himself to the SC, distributes Cn to Vn, and stores Yt to the
blockchain storage. Fig 5 describes the overview of this step.
In the off-chain channel:
• Ui chooses a random number r for the ElGamal
encryption and two sets of random numbers Pk−1 =
{p1, p2, . . . , pk−1} for the (k, n)-threshold SSS and
Qt = {q1, q2, . . . , qt } for the commitment of Xt .
• Ui computes ĥi, Sn, Cn, and Yt such that:
ĥi ← H(mi + 1),
Sn ← SharesGen(Pk−1, ei),
Cn = {c1, . . . , cn},
where ci = ENC(si,PKvi; r) for i = 1, . . . , n,
Yt = {y1, . . . , yt },
where yi = H(xi, qi) for i = 1, . . . , t.
• Ui uses the circuit C and zk-SNARK’s function Proof to
generate πC .
πC ← Proof(EwC , ExC ,PKC ),
where EwC = {mi, r,Pk−1,Qt ,Xt , certi} and ExC =
{ĥi,Cn,PKVn ,PKIP,Yt , bC }.
In the on-chain channel:
• PSi sends πC and ExC to the SC by calling the SC’s
function authentication(πC , ExC ).
• After verifying πC and ExC , the SC adds {PSi, ĥi,Cn} to
Table1 and {PSi,Yt } to Table2. All the PSs in Table1 are
meant to be authorized users. They can selectively dis-
close their committed IAs stored in Table2.
• vi takes ci from ExC , and decrypts ci to get si in the
off-chain channel as follows.
si← DEC(ci, SKvi ).
Step 3. Selective disclosure. If the SP requires an addi-
tional MIA from the PSi, PSi can disclose the MIA xi from
Xt . Fig 6 describes the overview of this step.
• PSi sends {xi, qi} to the SP, where qi is a random number
in Qt which is used to generate Yt .
VOLUME 11, 2023 1847
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
FIGURE 6. Sequence diagram of Step 3.
• The SP computes yi← H(xi, qi).
• In the on-chain channel, the SP calls the SC’s function
queryAtt(PSi, yi). If PSi has the commitment yi, the
function will return true, and the SP can verify that PSi
has xi.
Step 4. PIA-opening. In case PSi is malicious and violates
the system’s policy, the IP can ask vi to send si and reconstruct
PSi’s ei to find the PIA associated with PSi. Fig. 7 describes
the overview of this step, and particularly Fig. 8 describes the
structure of the PIA-opening process.
In the on-chain channel:
• vi sends πD ← Proof(EwD, ExD,PKD) and ExD to the SC
by calling the function openPIA(πD, ExD), where ExD =
{ci, si,PKvi , bD} and EwD = SKvi .
• The SC adds si to Table2 if the zk-SNARK’s function
Verify(πD, ExD) returns true.
• After openPIA() is called k times by Vk , the IP can call
the function queryPIA(PSi) to get Sk .
In the off-chain channel:
• The IP reconstructs ei using Sk and the SSS
Reconstruct algorithm as
ei← Reconstruct(Sk ).
• The IP finds the PIA in its data storage associated with
ei.
V. SECURITY
This section defines security requirements for PPIdM system,
and proves that the proposed system satisfies them.
A. SECURITY REQUIREMENTS
Referring to security models of group signatures [25],
we define security requirements for a PPIdM system as fol-
lows.
Unforgeability. Unforgeability captures that the system
should prevent attacker A from (1) changing the registered
IAs, (2) passing the authentication process by using incorrect
witnesses, or (3) reusing another user’s witnesses.
Anonymity. Recall that Ui’s identity is associated with
his mi and PIA. Anonymity means that the proposed system
FIGURE 7. Sequence diagram of Step 4.
should prevent A from finding information about mi and the
PIA associated with Ui.
Traceability. Traceability implies that A cannot (1) stop
the PIA-opening process once triggered or (2) cheat the
PIA-opening process to trace back another user instead of the
target user.
B. SECURITY ANALYSIS
This section analyzes the security of the proposed system and
proves that it satisfies the security requirements mentioned
above.
1) UNFORGEABILITY
Theorem 1. If the hash function H is collision-resistant,
EdDSA is unforgeable against chosen-message attacks, zk-
SNARK satisfies soundness property, the public blockchain is
immutable, and the commitment scheme is binding, then the
proposed system provides unforgeability.
Proof. We use the game-based proof strategy to create a
series of games and prove that the real game is indistinguish-
able from the final game, where the probability that adversary
A succeeds in breaking unforgeability becomes negligible.
•Game0 is the real game whereA tries to join the system
without registering his IAs to the IP or masquerading as other
users.
• Game1 is identical to Game0, except that no collision
on the hash function occurs. Because H is collision-resistant,
Game1 is indistinguishable from Game0.
•Game2 is the same as Game1, exceptA can generate an
EdDSA signature without SKIP. Because EdDSA is unforge-
able against chosen-message attacks, the probability of forg-
ing an EdDSA signature is negligible. This means A cannot
use an invalid EdDSA signature to convince the SC that the
IP has verified him. Therefore, Game2 is indistinguishable
from Game1.
•Game3 is identical to Game2, except thatA succeeds at
generating πC without satisfying lines 3, 4, 7, and 8 in Algo-
rithm 1. Because zk-SNARK satisfies the soundness prop-
erty, the probability of generating πC from invalid witnesses
1848 VOLUME 11, 2023
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
FIGURE 8. PIA-opening architecture. (1) After verifying πD of vi , the SC checks whether ci is in Table 1, associated with
the target PS. (2) If it is false, the process stops. (3) If it is true, si will be associated to the target PS in Table 3. (4) If the
target PS is in Table 3 has Sk , the IP will query for it and reconstruct ei from Sk . (5) Afterward, it finds the corresponding
PIA in its data storage.
is negligible. Therefore Game3 is indistinguishable from
Game2.
• Game4 is identical to Game3, except that A suc-
ceeds at modifying the blockchain data. Because the public
blockchain is immutable,A cannot change his registered IAs
stored in the blockchain. Therefore, Game4 is indistinguish-
able from Game3.
• GameF is identical to Game4, except that A succeeds
at changing his committed value when verifying his commit-
ment. Because the commitment scheme is binding,A cannot
change his committed IAs when revealing them to the SP.
Therefore, GameF is indistinguishable from Game4.
We can observe that, in GameF, A cannot use invalid
witnesses or collude with other users to reuse their witnesses.
Also, once A’s IAs are on the blockchain, A cannot change
them due to the blockchain’s immutable property. Finally, the
binding property of the commitment scheme does not allow
A to change his committed IAs in the commitment-revealing
process. Hence, under these assumptions of Theorem 1, the
proposed system provides the unforgeability property. �
2) ANONYMITY
Theorem 2. If the hash function H is oneway, the pub-
lic blockchain is anonymous, zk-SNARK satisfies the zero-
knowledge property, the ElGamal encryption is secure
against chosen-plaintext attacks, the commitment scheme is
hiding, and the (k, n)-threshold SSS satisfies the correctness
property, then the proposed system provides anonymity.
Proof.Wecreate a series of games fromGame0 toGameF
as follows.
• Game0 is a real game where A tries to find the PIA
associated with PSi.
•Game1 is identical to Game0, except thatA succeeds at
finding the preimage of ĥi ← H(mi + 1), which is public on
the blockchain. Because H satisfies the onewayness property,
it is infeasible to discover the preimage of a given hash value.
Hence, Game1 is indistinguishable from Game0.
• Game2 is identical to Game1, except that A succeeds
at finding the owner of a PS by analyzing the PS on the
public blockchain. Because the public blockchain is anony-
mous, generating a PS does not require information about the
owner’s identity. Therefore,A cannot gain information about
the PS’s owner, and thus Game2 is indistinguishable from
Game1.
• Game3 is the same as Game2, except πC is simulated
without the correct witnesses. Because zk-SNARK is zero-
knowledge, πC only shows that it is associated with a PS
without revealing information about its witnesses. Therefore,
Game3 is indistinguishable from Game2.
• Game4 is identical to Game3, except that A succeeds
at decrypting Ck = {c1, . . . , ck} without the corresponding
SKVk = {SKv1 , . . . , SKvk }, where ci ← ENC(si,PKvi ) for
i = 1, . . . , k . However, because the ElGamal encryption
is secure against chosen-ciphertext attacks, it is infeasible
for A to decrypt Cn without corresponding SKVn . Therefore,
Game4 is indistinguishable from Game3.
•Game5 is identical to Game4, except thatA succeeds at
finding the committed value from the commitment. Because
the commitment scheme is hiding, Game5 is indistinguish-
able from Game4. In this case,A cannot find the committed
xi from commitment yi, which is public in the blockchain and
associated with the target PS.
• GameF is identical to Game5, except that A succeeds
at reconstructing the secret generated by the (k, n)-threshold
SSS using less than k shares. Because the (k, n)-threshold
VOLUME 11, 2023 1849
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
SSS satisfies the correctness property, A cannot reconstruct
the secret ei ← gPIA using Sl , where l < k . Therefore,
GameF is indistinguishable from Game5.
We can see that GameF is the final game where A cannot
gain information about the PS’s PIA or mi even when A can
obtain the PS’sπC , ĥi,Cn,Yt , and Sl , where l < k . Therefore,
the proposed system provides the anonymity property. �
3) TRACEABILITY
Theorem 3. If the system satisfies the unforgeability property,
zk-SNARK is sound, the ElGamal encryption is correct, the
public blockchain is immutable, and the (k, n)-threshold SSS
is correct, the proposed system provides traceability.
Proof. We also create a series of games from Game0 to
GameF.
• Game0 is a real game where A tries to prevent the IP
and validators from finding the PS’s PIA.
•Game1 is identical to Game0, except thatA succeeds at
masquerading as another user or joining the system without
registering A’s IAs to the IP. Because the proposed system
satisfies the unforgeability property, Game1 is indistinguish-
able from Game0.
• Game2 is the same as Game1, except that A suc-
ceeds at generating πC without correct witnesses. Because
zk-SNARK satisfies the soundness property, Game2 is
indistinguishable from Game1. This means that A cannot
omit Cn when generating πC or calling the SC’s function
authentication(πC , ExC ) in Step 2.
•Game3 is identical to Game2, except thatA succeeds at
breaking the correctness property of the ElGamal encryption.
Because the ElGamal encryption is correct, DEC(ci, SKvi )
always returns si if ci is generated using ENC(si,PKvi; r).
Therefore, Game3 is indistinguishable from Game2.
• Game4 is identical to Game3, except that A suc-
ceeds at deleting data on the blockchain. Because blockchain
is immutable, Game4 is indistinguishable from Game3.
Therefore, A cannot delete its Cn or Yt once they are stored
in the blockchain.
• Game5 is identical to Game4, except that A succeeds
at generating πD without si and SKvi in terms of validator vi.
As before, because zk-SNARK satisfies the soundness prop-
erty, Game5 is indistinguishable from Game4. A cannot
upload incorrect s′i to the SC because A cannot generate πD
using s′i.
• GameF is identical to Game5, except A succeeds at
breaking the correctness property of the (k, n)-threshold SSS.
Because the SSS is correct, GameF is indistinguishable from
Game5.
We can see that, in GameF, A cannot break the PIA-
opening process. As a validator, A cannot send invalid s′i to
the SC to break the PIA-opening process. As an user, A can-
not masquerade as another user or join the systemwith invalid
witnesses because of the system’s unforgeable property. The
correctness property of the SSS and the ElGamal encryption
ensures thatA can neither generate nor distribute invalid SSS
shares to validators in the authentication process. Hence, the
TABLE 3. Parameters for off-chain simulation’s environment.
only way forA to join the system is honestly using his PIA to
generate and distribute SSS shares. In addition, because the
SC keeps his Cn and Yt in the blockchain storage, A cannot
delete them. Hence, A’s secret is always reconstructable in
GameF, and both the requirements (1) and (2) of the trace-
ability property are satisfied. Therefore, the proposed system
provides traceability. �
VI. PERFORMANCE EVALUATION
This section shows the simulation results of the proposed
system in terms of performance times and transaction costs.
We simulate the proposed system according to the off-chain
and on-chain tasks that each entity has to perform. Table 3
presents the parameters for the off-chain simulation, and
Table 6 shows the parameters for the on-chain simulation.
A. OFF-CHAIN SIMULATION
1) SIMULATION TOOLS FOR ZK-SNARK
In this simulation, we employ Zokrates [26], a tool that sup-
ports implementing zk-SNARK. Essentially, three algorithms
of zk-SNARK described in Section III can be represented by
five Zokrates tasks.
• Compile(C) → P, where C is the arithmetic circuit C,
and P is a set of polynomials. This function uses the
quadratic arithmetic program (QAP) to transform the
circuit C into polynomials P.
• Setup(P)→ (PK ,VK ), where PK and VK are a prov-
ing key and a verification key, respectively. This function
creates a pair of keys (PK ,VK ) by implementing zk-
SNARK’s KeyGen.
• Compute− witness(P, a) → Ew, where a is a set of
inputs to the circuit C (both private and public), and Ew
is the witness.
• Generate− proof(Ew,PK ) → {π, Ex}, where π is the
proof string and Ex is the set of public inputs. This func-
tion implements zk-SNARK’s Proof.
• Verify(π, Ex) → b, where b is a decision bit which is
decided after running zk-SNARK’s Verify with π and Ex
as inputs.
2) SIMULATION RESULT
We divide the off-chain simulation into two parts. The first
part is the simulation of circuit C, in which anonymous
authentication, SSS distribution, and selective disclosure
1850 VOLUME 11, 2023
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
processes are implemented. The second part is the simulation
of circuit D, which implements the PIA-opening process.
Table 4 presents the time complexity, space complexity and
the frequency of the two parts’ processes. We summarize the
total results in Table 5.
a: CIRCUIT C AND THE ANONYMOUS AUTHENTICATION,
SSS DISTRIBUTION, AND SELECTIVE DISCLOSURE
PROCESSES
First, we create circuit C according to Algorithm 1. In Step
0, we initialize the zk-SNARK protocol using circuit C and
run two tasks Compile and Setup to generate a pair of
keys {PKC ,VKC } in terms of the IP. Afterward, we compute
{rooti, certi, ei} for i = 1, ..,m, where m is the number
of users. The total time complexity of these processes for
the IP is timeIP = 106.24 + 0.44m, where 106.24 is the
time for running Compile and Setup, 0.44 is the time for
generating {rooti, certi, ei}. The size of PKC is 1,536,047,032
bits (192 Mb), and VKC is 51,976 bits (6.5 Mb). The size of
certi is 1,274 bits. Other parameters have the same 254-bit
size.
In Steps 1 and 2, we create {hi, ĥi,Yt ,Sn,Cn}, where
t = 9 and n = 10 in terms of Ui. Afterward, we run two
Zokrates tasks Compute− witness and Generate− proof
to generate πC . The total time complexity of these processes
is timeUi = 38.04. Because vi only needs to decrypt ci to get
si in Step 2, the time complexity for vi is timevi = 0.032m.
Because generating πC requires PKC , the total space for
generating πC is 1,536,047,032 + 4,528 = 1,536,051,560 bits,
where 4,528 is πC ’s size in the JSON format. Other param-
eters have the same 254-bit size. Notably, Sn and Cn require
2,540 bits because n = 10.
In Step 3, we generate yi← H(xi, qi) to verify xi and qi in
terms of the SP. The time complexity for the SP is timeSP =
0.01j, where 0.01 is the time for generating yi and j is the
number of times time the SP verifies an MIA. The size of a
single commitment is 254 bits.
b: CIRCUIT D AND PIA-OPENING PROCESS
In this simulation, we create circuit D according to Algo-
rithm 2. In terms of the IP, we execute two tasks Compile
and Setup in Step 0 to generate PKD and VKD. Afterward,
we reconstruct a secret share using function Reconstruct.
Because opening a PS’s PIA requires the IP to run func-
tion Reconstruct once, the time complexity for the IP is
timeIP = 2.83 + 0.55z, where 2.83 is the time for running
Compile and Setup, 0.55 is the time for running function
Reconstruct, and z is the number of times the IP implements
the PIA-opening process. In terms of vi, we decrypt ci to
get si in Step 2. Afterward, we run Compute− witness
and Generate− proof to generate πD and ExD as in Step 4.
Because each time opening a PS’s PIA also requires vi to
send si once, the time complexity for vi is timevi = 1.58z.
The size of PKD is 31,169,120 bits (38.9 Mb) and VKD is
27,048 bits (3.4 Mb). Because generating πD requires PKD,
the total space for generating πD is 31,169,120 + 4,528 =
TABLE 4. The time complexity, space complexity, and the frequency of
processes in the off-chain simulation, where m is the total number of
users, z is the number of times the IP implements the PIA-opening
process, and j is the number of times the SP verifies an MIA.
TABLE 5. The total time complexity and space complexity of the off-chain
simulation, where m is the total number of users, z is the number of
times the IP implements the PIA-opening process, and j is the number of
times the SP verifies an MIA. (unit: s).
31,173,648 bits, where 4,528 is πD’s size in the JSON format.
The size of ci is 254 bits.
Although the time complexity and space complexity are
large, most resources are spent for generating {PKC ,VKC },
{PKD,VKD}, πC , and πD. Because these processes are imple-
mented once (excluding πD), the computational burden for
the IP and users is acceptable. Generating πD is a compu-
tational burden (1.58 seconds and 38.9 Mb) for validators
because they must do this process m times, where m is the
number of malicious users. However, this burden can be
migrated tomalicious users after their PIA is opened, and they
must pay for their PIA-opening fees.
B. ON-CHAIN SIMULATION
In this simulation, we evaluate the SC performance by inter-
acting with its functions and showing the transaction cost.
Our target is to decrease the transaction cost as much as
possible.
1) SIMULATION RESULTS
Under the parameters given in Table 6, we construct the
SC according to Algorithm 3, using the Solidity program-
ming language. We deploy the SC to the Ropsten Testnet
and interact with the SC using Remix IDE and MetaMask.
Each function’s interaction is implemented in the form of a
VOLUME 11, 2023 1851
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
TABLE 6. On-chain simulation environment parameters.
TABLE 7. SC’s transaction cost.
transaction. The cost of calling SC’s functions is summarized
in Table 7. The details of the simulation are as follows.
The IP is responsible for creating and deploying the SC
to the blockchain network. This deployment is implemented
once. In addition, when a user violates the system’s policy,
the IP needs to query the user’s SSS shares and reconstruct
the user’s PIA. Therefore, the cost for the IP in this process
is costIP = 3,977,797 + 32,696d , where 3,977,797 is the
SC’s deployment cost, 32,696 is the cost of calling function
queryPIA(), and d is the number of times the PIA-opening
process is implemented.
Ui needs to run function authentication() to authenticate
its PSi, distribute Cn to Vn, and add Yt to the blockchain.
Because the function is implemented once, the total cost for
Ui is costUi = 1,852,354.
vi needs to call function openPIA() to send si to the SC.
The total cost for vi is costvi = 961,035d , where 961,035
is function openPIA()’s cost and d is the number of times
the PIA-opening process is implemented. Because we use
the (k, n)-threshold SSS, where k = 6 and n = 10 in this
simulation, the total cost for opening a PIA is 6× 961,035 =
5,766,210.
In terms of the SP, we run the function queryPs() and
queryMIA() to check whether PSi is authenticated by the IP.
The cost for the SP is costSP = 26,008a + 51,941b, where
26,008 is the cost of function QueryPS(), a is the number
of queries the SP issues to check a PS, 51,941 is the cost of
function queryMIA(), and b is the number of queries the SP
TABLE 8. Total cost of the on-chain simulation, where d is the number of
times the PIA-opening process is implemented, a and b are the number
of times functions queryMIA() and queryPS() are invoked, respectively.
FIGURE 9. Comparison of transaction fees between the proposed system
and Ethereum’s token transferring transaction (unit: gas).
issues to check a PS’s MIA. Putting them all together, Table 8
shows the total cost of our on-chain simulation.
Compared with Ethereum’s basic and most used transac-
tion (token-transferring transaction), which costs 21000 gas,
Fig. 9 illustrates how high the proposed system’s transaction
fees are.
VII. LIMITATIONS AND FUTURE WORKS
The first limitation is the computational power required
for working with zk-SNARK. Our experiments show that
resource-constrained devices (less than 4 Gb of RAM) cannot
run zk-SNARK for the (k, n)-threshold SSS, especially when
n is bigger than 15. The second limitation is that the decreas-
ing number of validators can prevent the (k, n)-threshold
SSS scheme from working normally. The increasing number
of validators does not affect the (k, n)-threshold SSS with
respect to previously joined users. However, if the number
of validators that left the system is too large so that n < k ,
the (k, n)-threshold SSS and thus the PIA-opening process
cannot work. The third limitation is from the fact that at least
k malicious validators can collude to do the PIA-opening
process in off-chain actions. Indeed, such malicious off-chain
actions cannot be detected.
Based on the above limitations, future works can follow the
direction of designing an efficient system using zk-SNARK-
friendly hash functions and operations in the arithmetic cir-
cuit. Another direction would be to consider a novel mech-
anism for detecting off-chain actions of malicious validators
using zk-SNARK and blockchain techniques.
1852 VOLUME 11, 2023
D. A. Luong, J. H. Park: Privacy-Preserving Identity Management System on Blockchain Using Zk-SNARK
VIII. CONCLUSION
This paper combines several cryptographic techniques to
introduce a novel PPIdM system based on blockchain. Users’
activities and service history are entirely hidden from all
external entities. The proposed scheme provides anonymity
by allowing users to authenticate themselves using zk-
SNARK anonymously. The system’s identity traceability uti-
lizes the blockchain’s consensus and the SSS algorithm.
Selective disclosure is provided by using zk-SNARK and
the hash-based commitment scheme. We calculated the per-
formance of the proposed system by measuring the time
complexity and space complexity in the off-chain channel and
the computational power (gas cost) in the on-chain channel to
show that the proposed system is efficient and realistic.
REFERENCES
[1] V. Kumar and A. Bhardwaj, ‘‘Identity management systems: A compara-
tive analysis,’’ Int. J. Strategic Decis. Sci., vol. 9, no. 1, pp. 63–78, 2018.
[2] Y. Liu, D. He, M. S. Obaidat, N. Kumar, M. K. Khan, and K.-K. R. Choo,
‘‘Blockchain-based identity management systems: A review,’’ J. Netw.
Comput. Appl., vol. 166, Sep. 2020, Art. no. 102731.
[3] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer, ‘‘From extractable
collision resistance to succinct non-interactive arguments of knowledge,
and back again,’’ in Proc. 3rd Innov. Theor. Comput. Sci. Conf. (ITCS),
2012, pp. 326–349.
[4] A. Shamir, ‘‘How to share a secret,’’ Commun. ACM, vol. 22, no. 11,
pp. 612–613, Nov. 1979.
[5] M. M. ElGayyar, H. F. ElYamany, K. Grolinger, M. A. Capretz, and S. Mir,
‘‘Blockchain-based federated identity and auditing,’’ Int. J. Blockchains
Cryptocurrencies, vol. 1, no. 2, pp. 179–205, 2020.
[6] S. Gao, Q. Su, R. Zhang, J. Zhu, Z. Sui, and J.Wang, ‘‘A privacy-preserving
identity authentication scheme based on the blockchain,’’ Secur. Commun.
Netw., vol. 2021, pp. 1–10, Jun. 2021.
[7] J. Xu, K. Xue, H. Tian, J. Hong, D. S. L. Wei, and P. Hong, ‘‘An identity
management and authentication scheme based on redactable blockchain
for mobile networks,’’ IEEE Trans. Veh. Technol., vol. 69, no. 6,
pp. 6688–6698, Jun. 2020.
[8] P. Mell, J. Dray, and J. Shook, ‘‘Smart contract federated iden-
tity management without third party authentication services,’’ 2019,
arXiv:1906.11057.
[9] Y. Ren, F. Zhu, J. Qi, J. Wang, and A. K. Sangaiah, ‘‘Identity management
and access control based on blockchain under edge computing for the
industrial Internet of Things,’’ Appl. Sci., vol. 9, no. 10, p. 2058, May 2019.
[10] J. Alsayed Kassem, S. Sayeed, H. Marco-Gisbert, Z. Pervez, and K. Dahal,
‘‘DNS-IdM: A blockchain identity management system to secure personal
data sharing in a network,’’ Appl. Sci., vol. 9, no. 15, p. 2953, Jul. 2019.
[11] B. Faber, G. C. Michelet, N.Weidmann, R. R. Mukkamala, and R. Vatrapu,
‘‘BPDIMS: A blockchain-based personal data and identity management
system,’’ in Proc. 52nd Annu. Hawaii Int. Conf. Syst. Sci., 2019, pp. 1–10.
[12] M. Westerkamp, S. Gondor, and A. Kupper, ‘‘Tawki: Towards self-
sovereign social communication,’’ in Proc. IEEE Int. Conf. Decentralized
Appl. Infrastructures (DAPPCON), Apr. 2019, pp. 29–38.
[13] C. Zhuang, Q. Dai, and Y. Zhang, ‘‘BCPPT: A blockchain-based privacy-
preserving and traceability identity management scheme for intellectual
property,’’ Peer Peer Netw. Appl., vol. 15, pp. 724–738, Jan. 2022.
[14] B. Parno, J. Howell, C. Gentry, and M. Raykova, ‘‘Pinocchio: Nearly
practical verifiable computation,’’ in Proc. IEEE Symp. Secur. Privacy,
May 2013, pp. 238–252.
[15] D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, and B. Y. Yang, ‘‘High-
speed high-security signatures,’’ J. Cryptogr. Eng., vol. 2, no. 2, pp. 77–89,
2012.
[16] M. Jakobsson and A. Juels, ‘‘Proofs of work and bread pudding proto-
cols,’’ in Secure Information Networks: Communications and Multimedia
Security, IFIP TC6/TC11 Joint Working Conference on Communications
and Multimedia Security (CMS), vol. 152, B. Preneel, Ed. Alphen aan den
Rijn, The Netherlands: Kluwer, 1999, pp. 258–272.
[17] F. Saleh, ‘‘Blockchain without waste: Proof-of-stake,’’ Rev. Financial
Stud., vol. 34, no. 3, pp. 1156–1190, 2021.
[18] A. Jules and J. Brainard, ‘‘Client-puzzles: A cryptographic defense against
connection depletion,’’ in Proc. Netw. Distrib. Syst. Secur. Symp. (NDSS),
1999, pp. 151–165.
[19] C. Ye, G. Li, H. Cai, Y. Gu, and A. Fukuda, ‘‘Analysis of security in
blockchain: Case study in 51%-attack detecting,’’ in Proc. 5th Int. Conf.
Dependable Syst. Their Appl. (DSA), Sep. 2018, pp. 15–24.
[20] W. Y. Maung Maung Thin, N. Dong, G. Bai, and J. S. Dong, ‘‘Formal
analysis of a proof-of-stake blockchain,’’ in Proc. 23rd Int. Conf. Eng.
Complex Comput. Syst. (ICECCS), Dec. 2018, pp. 197–200.
[21] M. Castro and B. Liskov, ‘‘Practical Byzantine fault tolerance,’’ in Proc.
OSDI, vol. 99, Feb. 1999, pp. 173–186.
[22] S. Gao, T. Yu, J. Zhu, and W. Cai, ‘‘T-PBFT: An eigentrust-based practical
Byzantine fault tolerance consensus algorithm,’’ China Commun., vol. 16,
no. 12, pp. 111–123, Dec. 2019.
[23] A. Savelyev, ‘‘Contract law 2.0: ‘Smart’ contracts as the beginning of the
end of classic contract law,’’ Inf. Commun. Technol. Law, vol. 26, no. 2,
pp. 116–134, May 2017.
[24] D. A. Luong and J. H. Park, ‘‘Privacy-preserving blockchain-based health-
care system for IoT devices using zk-SNARK,’’ IEEE Access, vol. 10,
pp. 55739–55752, 2022.
[25] M. Bellare, H. Shi, and C. Zhang, ‘‘Foundations of group signatures:
The case of dynamic groups,’’ in Topics in Cryptology (Lecture Notes in
Computer Science), vol. 3376, A. Menezes, Ed. San Francisco, CA, USA:
Springer, 2005, pp. 136–153.
[26] J. Eberhardt and S. Tai, ‘‘ZoKrates–scalable privacy-preserving off-chain
computations,’’ in Proc. IEEE Int. Conf. Internet Things (iThings) IEEE
Green Comput. Commun. (GreenCom) IEEE Cyber, Phys. Social Comput.
(CPSCom) IEEE Smart Data (SmartData), Jul. 2018, pp. 1084–1091.
[27] M. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen, ‘‘MiMC:
Efficient encryption and cryptographic hashing with minimal multiplica-
tive complexity,’’ in Proc. Int. Conf. Theory Appl. Cryptol. Inf. Secur.
Berlin, Germany: Springer, 2016, pp. 191–219.
[28] C. Reitwiessner, ‘‘EIP-196: Precompiled contracts for addition and
scalar multiplication on the elliptic curve alt_bn128,’’ Ethereum
Improvement Proposals, no. 196, Feb. 2017. [Online]. Available:
https://eips.ethereum.org/EIPS/eip-196
[29] B. WhiteHat, M. Bellés, and J. Baylina, ‘‘EIP-2494: Baby jubjub elliptic
curve,’’ Ethereum Improvement Proposals, vol. 2494, pp. 1–7, Jan. 2020.
[30] C. Dannen, Introducing Ethereum and Solidity, vol. 1. Berkeley, CA, USA:
Springer, 2017.
DUC ANH LUONG received the bachelor’s degree
in computer science from Sangmyung University,
Seoul, South Korea, in 2020, where he is currently
pursuing the M.S. degree in computer science. His
research interests include blockchain technology,
cryptography, the IoT, and information security.
JONG HWAN PARK received the B.S. degree
from the Department of Mathematics, Korea Uni-
versity, Seoul, South Korea, in 1999, and the
M.S. and Ph.D. degrees from the Graduate School
of Information Security, Korea University, in
2004 and 2008, respectively.
He was a Research Professor at Kyung Hee
University, from 2009 to 2011, and a Research
Professor at Korea University, from 2011 to 2013.
Since 2013, he has been an Assistant Professor
with the Department of Computer Science, Sangmyung University, Seoul.
His research interests include functional encryption, broadcast encryption,
authenticated encryption, and various cryptographic protocols.
VOLUME 11, 2023 1853