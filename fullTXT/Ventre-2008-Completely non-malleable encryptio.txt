Title
Completely Non-malleable Encryption Revisited
Carmine Ventre and Ivan Visconti
Dipartimento di Informatica ed Applicazioni
Università di Salerno, 84084 Fisciano (SA), Italy
{ventre,visconti}@dia.unisa.it
Abstract. Several security notions for public-key encryption schemes
have been proposed so far, in particular considering the powerful adver-
sary that can play a so called “man-in-the-middle” attack.
In this paper we extend the notion of completely non-malleable en-
cryption introduced in [Fischlin, ICALP 05]. This notion immunizes a
scheme from adversaries that can generate related ciphertexts under new
public keys. This notion is motivated by its powerful features when en-
cryption schemes are used as subprotocols. While in [Fischlin, ICALP 05]
the only notion of simulation-based completely non-malleable encryption
with respect to CCA2 adversaries was given, we present new game-based
definitions for completely non-malleable encryption that follow the stan-
dard separations among NM-CPA, NM-CCA1 and NM-CCA2 security
given in [Bellare et al., CRYPTO 98]. This is motivated by the fact that in
several cases, the simplest notion we introduce (i.e., NM-CPA*) in several
cases suffices for the main application that motivated the introduction
of the notion of NM-CCA2* security, i.e., the design of non-malleable
commitment schemes. Further the game-based definition of NM-CPA*
security actually implies the simulation-based one.
We then focus on constructing encryption schemes that satisfy these
strong security notions and show: 1) an NM-CCA2* secure encryption
scheme in the shared random string model; 2) an NM-CCA2* secure
encryption scheme in the plain model; for this second result, we use
interaction and non-black-box techniques to overcome an impossibility
result.
Our results clarify the importance of these stronger notions of encryp-
tion schemes and show how to construct them without requiring random
oracles.
1 Introduction
The study of the relations among security notions for public-key encryption is a
central question in Cryptography. Several notions for encryption schemes have
been defined in order to construct schemes that are secure against strong adver-
saries. One of the most general and accepted concept is that of non-malleability
formalized with the notion of adaptive chosen ciphertext security (shortly re-
ferred to as CCA2). Intuitively, a man-in-the-middle adversary should not be
able given a public key pk and a ciphertext c, relative to a message m sam-
pled from a distribution of its choice, to output a relation R and a ciphertext
R. Cramer (Ed.): PKC 2008, LNCS 4939, pp. 65–84, 2008.
c© International Association for Cryptologic Research 2008
66 C. Ventre and I. Visconti
c′ whose plaintext m′ is related through R with m. This task has to be hard
even in case that the adversary has access to a decryption oracle. Important
constructions (see [1,2]) as well as relations among security notions [3] cur-
rently clarify the power of CCA2 security with respect to the weaker notions
of CCA1 (where the decryption oracles can be accessed only before the chal-
lenge is received) and CPA (where no access to a decryption oracle is possible)
security.
Recently, Fischlin presented in [4] a new security notion for public-key en-
cryption, referred to as complete non-malleability. This notion, requires that
non-malleability has to be preserved even in case that the man-in-the-middle
adversary can also choose a new public key (that thus could be related to the
original one). The goal of the adversary is to compute a ciphertext (under the
new public key) that corresponds to a plaintext that is related to the original
plaintext. Notice that in this more general case the relation considers also the
new public key.
The main motivation for considering this new notion is that encryption
schemes are often used as building blocks for larger protocols and in [4] it is
stressed that completely non-malleable security has much more applications than
the standard non-complete security notions for public-key encryption schemes.
In particular, in [4] Fischlin discusses possible approaches for the design of non-
malleable commitment schemes on top of completely non-malleable encryption
schemes.
This new security notion is strong but unfortunately also impossible to achieve
in the standard model when non-interactive encryption with simulation-based
black-box security is considered (see [4]). Constructions are instead possible [4]
in the random oracle model.
1.1 Our Results
In this paper we revisit the study of the concept of completely non-malleable
encryption schemes initiated in [4]. First we notice that the idea behind com-
plete non-malleability can be extended also to the notions of CPA and CCA1
security, while the original notion of Fischlin only considered CCA2 security.
In order to motivate these new definitions, we present separating examples (see
Theorem 1) showing that such notions seem to capture more than what the
older non-complete definitions actually do. We will refer to these new notions
of security for encryption schemes as NM-CPA∗, NM-CCA1∗ and NM-CCA2∗
respectively.
The importance of the new definitions (and thus of our study of the relations
among the different notions) follows from the following observation. The main
motivation given in [4] for NM-CCA2* security concerned the possibility of con-
structing non-malleable commitments on top of NM-CCA2* secure encryption
schemes1. This could be done (under some additional assumption that however
1 Additionally, in [4] similar powerful attacks are discussed with respect to signature
schemes.
Completely Non-malleable Encryption Revisited 67
we do not stress here) by assuming that the committer selects a public key, en-
crypts the message and sends the encryption as commitment. Then the opening
is performed by sending the randomness used for the encryption. Obviously a
man-in-the-middle could select a related public key in order to compute a re-
lated encryption and thus a related commitment. NM-CCA2* security should
guarantee the failure of the above attack of the man-in-the-middle.
We observe that the role of a decryption oracle is not clear in this context
and in particular could not be required in many applications. Indeed, for non-
malleable commitments, the man-in-the-middle A does not have access to or-
acles that can open challenge commitments, therefore the NM-CCA2* security
requirement in some cases can be relaxed to NM-CPA* security. Therefore, in
this work we consider the possible variants for complete non-malleability, con-
sidering also the potential presences of a decryption oracle.
We stress that while the definitions of [4] follow the simulation-based approach
already used in [1], we give definitions that follow the game-based approach of [3].
The choice of this formulation follows from the fact that the game-based defini-
tion of NM-CPA* security (our motivating notion) implies its simulation-based
variant. Thus, we give a simpler formulation for NM-CPA* security and also show
that for a large set of relations, the game-based formulations of NM-CCA1* and
NM-CCA2* security imply the simulation-based ones. This implication shows
that the impossibility result proved by Fischlin [4] about the design (in the plain
model) of public-key encryption schemes that are completely non-malleable can
be adapted to the game-based version of the definition of NM-CCA2* security.
We next focus on feasibility results with the goal of overcoming known im-
possibility results as well as improving the assumptions needed by previous
constructions.
1. We first consider the shared random string model. By starting from any IND-
CPA secure encryption scheme and by using the non-malleable NIZK proof
of knowledge of [5] we obtain an NM-CCA2∗ secure encryption schemes in
the shared random string model. In this construction we enrich the known
technique due to [2] in which every ciphertext of the underlying IND-CPA
secure encryption scheme is augmented with a NIZK proof of knowledge of
the corresponding plaintext. In our construction we also need a proof that
the new public key is indeed valid (i.e., the output of the honest key genera-
tion algorithm of the underlying encryption scheme). We stress that such a
construction improves the assumption (i.e., the existence of random oracles)
needed by Fischlin’s constructions. Moreover we show that by using robust
NIZK [5] (thus strengthening the non-malleable NIZK proof of knowledge),
the construction also satisfies the simulation-based notion of NM-CCA2∗
security.
2. We show a construction of an interactive non-black-box completely non-
malleable encryption scheme that works by assuming that oracle queries
are asked sequentially. We stress that even this second construction satisfies
the simulation-based notion of NM-CCA2∗ security. Since the impossibility
68 C. Ventre and I. Visconti
results proved by Fischlin in [4] only concerned black-box adversaries and
non-interactive encryption, the possibility of further improving our construc-
tion by relaxing either the non-black-box requirement or the interactiveness
of the encryption or the concurrency issue for oracle queries is an interest-
ing open problem. The techniques of [1,6] would potentially avoid the non-
black-box techniques, but would produce a non-constant round complexity.
We finally stress that the potential drawback due to the interaction could
not be an issue when encryption is used as subprotocol in an interactive
protocol.
The motivation behind the constructions we present in this work is the proved
failure of the random oracle proved in several papers [7,8,9,10]. We therefore
show (constructively) that without a random oracle complete non-malleability
is achievable in at least two settings.
2 New Definitions for Encryption Schemes
In this section we give the first contribution of this work by giving new definitions
for completely non-malleable encryption schemes.
2.1 Completely Non-malleable Encryption
We define stronger notions of security against man-in-the-middle attacks follow-
ing the lead of [4]. Indeed, Fischlin in [4] defined complete non-malleability as
a stronger notion of NM-CCA2 security. We will refer to these stronger encryp-
tion schemes as NM-CCA2* secure encryption schemes. We here generalize that
notion with respect to all the three main variants of security: namely NM-CPA,
NM-CCA1 and NM-CCA2.
An important ingredient that we take from the framework introduced in [4] is
that of a complete relation. A complete relation R is a (probabilistic) algorithm
that takes as inputs: a public key pk, a message m, a public key pk∗, a ciphertext
vector (under pk∗) c∗ and a plaintext vector m∗ (the decryption of c∗). R returns
either false or true.
In our definition we will use the notation introduced in [3] based on indistin-
guishability rather than on the simulation paradigm (used in [4]) as the game-
based paradigm simplifies the task of working with non-malleability, moreover
it implies the simulation-based approach for the case of NM-CPA* security.
Definition 1 (NM-CPA*, NM-CCA1*, NM-CCA2*). Let PE = (G,
E , D) be a public-key encryption scheme, let A = (A1, A2) be an adversary.
For atk ∈ {cpa, cca1, cca2} and k ∈ N let
Advnm−atk∗
PE, A (k) =
∣
∣
∣Prob
[
Exptnm−atk∗
PE, A (k)
]
− Prob
[
Exptnm−atk∗
PE, A, $(k)
]∣
∣
∣
Completely Non-malleable Encryption Revisited 69
where, the experiments Exptnm−atk∗
PE, A (k), and Exptnm−atk∗
PE, A, $(k) are defined as
follows:
Exptnm−atk∗
PE, A (k): Exptnm−atk∗
PE, A, $(k):
(pk, sk) ← G(r) where r ← {0, 1}k (pk, sk) ← G(r) where r ← {0, 1}k
(M, s) ← AO1
1 (pk) (M, s) ← AO1
1 (pk)
x ← M x, x̃ ← M
c = Epk(x) c = Epk(x)
(R, pk∗, c∗) ← AO2
2 (M, pk, s, c) (R, pk∗, c∗) ← AO2
2 (M, pk, s, c)
return true iff ∃ m∗ such that return true iff ∃ m∗ such that
(c∗ = Epk∗(m∗)) ∧ (c∗ = Epk∗(m∗)) ∧
(c �∈ c∗ ∨ pk �= pk∗) ∧ (c �∈ c∗ ∨ pk �= pk∗) ∧
(m∗ �= ⊥) ∧ (m∗ �= ⊥) ∧
(R(x,m∗, pk, pk∗, c∗) = true) (R(x̃,m∗, pk, pk∗, c∗) = true)
Above
if atk = cpa then O1(·) = ε and O2(·) = ε,
if atk = cca1 then O1(·) = Dsk(·) and O2(·) = ε,
if atk = cca2 then O1(·) = Dsk(·) and O2(·) = D(c)
sk(·),
with D(c)
sk(·) meaning that the oracle decrypts any ciphertext except c. We insist,
above, that the message space M is valid: |x| = |x′| for any x, x′ with non-zero
probability in the message space M . Moreover, we let m∗ �=⊥ meaning that at
least one of the ciphertexts in c∗ is valid, i.e., in m∗ there is at least one message
that is different from a special symbol ⊥.
We say that PE is NM-ATK∗ secure if for every probabilistic polynomial-time
adversary A, Advnm−atk∗
PE, A (·) is negligible.
In the definition above we assume (as in [4,3]) that any a priori information of
the adversary, i.e. the history, is in the message space M .
Insecurity of known schemes with respect to complete non-malleability. In order
to motivate his definitions Fischlin showed in [4] that two encryption schemes,
namely Cramer-Shoup [11] and RSA-OAEP [12,13], are not NM-CCA2* secure
though they are NM-CCA2 secure. We first note that both separations trivially
work also under our game-based definitions and further motivate both our defini-
tions and Fischlin’s security notion by providing the next two theorems. Below,
we let ATK ∈ {cpa, cca1, cca2}.
Theorem 1. For any NM-ATK secure encryption scheme PE = (G, E , D) there
exists an NM-ATK secure encryption scheme PE ′ = (G′, E ′, D′) which is not
NM-ATK∗ secure.
The proof of above result is based on the following simple observation. A bit is
appended to the public key of an NM-ATK secure encryption scheme and it is
70 C. Ventre and I. Visconti
ignored by the encryption and decryption algorithms. Obviously the resulting
scheme is still NM-ATK secure but it is not NM-ATK∗ secure as the adversary
can simply change the appended bit of the public key, thus obtaining a new en-
cryption of the same message with respect to a new public key. It is also possible
to show that the NM-CCA2 secure encryption schemes known in literature [2,5]
are not NM-CCA2* secure even under our game-based definition.
Game-Based vs Simulation-Based Definitions. We next study the relation be-
tween the game-based definitions and the simulation-based ones. We start by
giving the simulation-based definition for NM-CCA2* [4] security.
Definition 2 (SNM-CCA2*). ([4]) Let PE = (G, E , D) be a public key en-
cryption scheme, let R be a complete relation, let A = (A1, A2) be an adversary
and let S = (S1, S2) be a pair of algorithms that we call simulator. For k ∈ N
we define
Advsnm−cca2∗
PE, A, S, R(k) =
∣
∣
∣Prob
[
Exptsnm−cca2∗
PE, A, R (k)
]
− Prob
[
Exptsnm−cca2∗
PE, S, R (k)
]∣
∣
∣
where, the experiments Exptsnm−cca2∗
PE, A, R (k), and Exptsnm−cca2∗
PE, S, R (k) are defined as
follows:
Exptsnm−cca2∗
PE, A, R (k): Exptsnm−cca2∗
PE, S,R (k):
(pk, sk) ← G(1k) (pk, sk) ← G(1k)
(M, s) ← A
Dsk(·)
1 (pk) (M, s) ← S1(pk)
m ← M ; c = Epk(m) m ← M
(pk∗, c∗) ← A
D(c)
sk(·)
2 (c, s) (pk′, c′) ← S2(s)
return true iff ∃ m∗ such that return true iff ∃m′ such that
(c∗ = Epk∗(m∗)) ∧ (c′ = Epk′(m′)) ∧
((pk, c) �= (pk∗, c∗)) ∧
(R(m, m∗, pk, pk∗, c∗) = true) (R(m, m′, pk, pk′, c′) = true)
where D(c)
sk(·) means the oracle that decrypts any ciphertext except c. We insist,
above, that the message space M is valid: |x| = |x′| for any x, x′ with non-zero
probability in the message space M .
We say that PE is SNM-CCA2* secure if for every probabilistic polynomial-
time adversary A and complete relation R computable in polynomial time, there
exists a polynomial-time simulator S such that Advsnm−cca2∗
PE, A, S, R(·) is negligible.
We remark that if we remove both oracle accesses to the adversary A in the above
definition then we have a simulation-based definition of NM-CPA* security (we
refer to this notion as SNM-CPA*). To be consistent with Fischlin’s definition
we slightly change our game-based definitions by not asking for the condition
m∗ �=⊥ (see Definition 1). We are now in the position to show that our game-
based definition of NM-CPA* security implies the corresponding simulation-
based one (see Definition 2).
Completely Non-malleable Encryption Revisited 71
Theorem 2. If an encryption scheme PE = (G, E , D) is NM-CPA* secure ac-
cording to the game-based definition then PE is SNM-CPA* secure according to
simulation-based definition.
Proof. We next show that given a relation R and an adversary A = (A1, A2) we
are able to construct a simulator S = (S1, S2). The simulator simply runs the
adversary A. More formally:
S1(pk): S2(s̃) where s̃ = (M, s, pk):
x←M
(M, s) ← A1(pk) c ← Epk(x)
s̃ ← (M, s, pk) (pk∗, c∗) ← A2(c, s)
return (M, s̃) return (pk∗, c∗)
A key point is that the simulator can indeed run A as A has not oracle access
(and therefore S does not need to know the secret key corresponding to pk).
Now we want to show that Advsnm−cpa∗
PE, A, S, R(·) is negligible. We do this using the
hypothesis that PE is secure in the sense of NM-CPA*. To that end, we consider
the following adversary B = (B1, B2) attacking PE in the sense of NM-CPA*
security:
B1(pk): B2(M, pk, s, c):
(M, s) ← A1(pk) (pk∗, c∗) ← A2(c, s)
return (M, s) return (R, pk∗, c∗)
It is clear from the definition of B that
Prob
[
Exptnm−cpa∗
PE, B (k)
]
= Prob
[
Exptsnm−cpa∗
PE, A, R (k)
]
for all k ∈ N. Now, let us expand the definition of Exptsnm−cpa∗
PE, S, R (k), substituting
in the definition of S given above.
Exptsnm−cpa∗
PE, S, R (k):
(pk, sk) ← G(1k)
(M, s) ← A1(pk)
s̃ ← (M, s, pk)
m ← M
x←M
c ← Epk(x)
(pk∗, c∗) ← A2(c, s)
return true iff there exists m∗ such that
(c∗ = Epk∗(m∗)) ∧
(R(m, m∗, pk, pk∗, c∗) = true)
72 C. Ventre and I. Visconti
Examining the code above we notice that we can drop instructions s̃ ←
(M, s, pk) (as s̃ is never referred to). The resulting code is equivalent to that
of Exptnm−cpa∗
PE, B, $ (k) so that:
Prob
[
Exptnm−cpa∗
PE, B, $ (k)
]
= Prob
[
Exptsnm−cpa∗
PE, S, R (k)
]
for all k ∈ N. Thus for all k ∈ N we have:
Advsnm−cpa∗
PE, A, S, R = Advnm−cpa∗
PE, B .
But PE is assumed to be secure in the sense of NM-CPA*, so Advnm−cpa∗
PE, B is
negligible. The above implies that Advsnm−cpa∗
PE, A, S, R is negligible too. Therefore,
PE is secure in the sense of SNM-CPA*. 	
Using the same technique we can show that the game-based definitions of NM-
CCA1* and NM-CCA2* security imply the corresponding simulation-based def-
initions for a large set of relations. Below we just present discussion for the
NM-CCA2* security notion.
We say that an encryption scheme is (S)NM-CCA2* secure with respect to
a set of complete relations R if in Definitions 1 and 2 we require R ∈ R (we
require that the scheme is resistant to a set of relations – and not to all relations
as demanded by the definition). Further, we call a relation R lacking if R is a
complete relation that ignores the input of the challenge public key: R is lacking
if and only if R(m, m∗, pk, pk∗, c∗) = R(m, m∗, pk∗, c∗) where pk is the challenge
public key.
Theorem 3. Let R be the set of lacking relations. If an encryption scheme
PE = (G, E , D) is NM-CCA2* secure (Definition 1) with respect to R then PE
is SNM-CCA2* secure with respect to R (Definition 2).
The proof is similar in spirit to that we gave above (and to the one in [14] where it is
shown that the game-based formulation of [3] implies the simulation-based formu-
lation of [1]). However, there is the following technical problem. The proof in [14]
consists in designing a simulator that on input a challenge public key pk, runs an
adversary A of the simulation-based notion. The simulator generates a new pair
of public and private keys and runs A on input the new public key. The simulator
computes an encryption of a randomly chosen message and uses it as challenge
for the adversary A. The simulator uses the secret key to answer to all decryption
queries of A and can decrypt the final ciphertext produced by A. The plaintext
obtained is then encrypted under the challenge public key pk and returned by the
simulator. The assumption that the original encryption scheme is secure under
the game-based notion is crucially used in [14] as it is possible to show that the
simulator has the same probability of succeeding as the adversary A.
In our case, when A is a completely non-malleable adversary it generates the
final ciphertexts under a new public key. Moreover, A’s success depends also on
this new public key and the fake public key generated by the simulator (i.e., the
Completely Non-malleable Encryption Revisited 73
outcome of complete relations does not depend just on plaintexts). This means
that such a success of A does not seem to be easily reproducible by the simulator
with respect to the challenge public key pk. Thus the technique exploited in [14]
fails, in our case, because we are considering complete relations. Therefore, if we
restrict R to relations that ignore the challenge public key pk, the simulator can
use his own pair of keys. Consequently, it can answer to decryption queries of the
underlying adversary A (knowing the secret key) and can return the new public
key and ciphertexts given in output by A. If the relation ignores the challenge
public key pk in input to the simulator (as we assume) then such a simulator is
successful whenever A is.
Theorem 6 in [15] shows the impossibility result for simulation-based black-
box NM-CCA2* security with respect to a set of relation that contains relations
Rmsg−eq : R ∈ Rmsg−eq means that R(m, m∗, pk, pk∗, c∗) = 1 if and only if m =
m∗. Since Rmsg−eq is lacking, we have the following corollary.
Corollary 1. Encryption schemes which are game-based NM-CCA2* secure ac-
cording to black-box adversaries do not exist.
3 NM-CCA2∗ Secure Encryption with Shared Random
Strings
In this section we show an NM-CCA2* secure encryption scheme in the shared
random string model.
We stress that the NM-CCA2∗ security definition easily adapts to the shared
random string model by simply feeding each algorithm (and the relation) with
the shared random string Σ as extra input. We remark that such a string is not
under the control of the adversary and is known to all players in the game.
IND-CPA Secure Encryption Schemes. In our construction we will make use of
encryption scheme satisfying the following classical security notions (see [3]).
Definition 3 (IND-CPA). Let PE = (G, E , D) be a public-key encryption
scheme, let A = (A1, A2) be an adversary. For k ∈ N let
Advind−cpa
PE, A (k) =
∣
∣
∣Prob
[
Exptindcpa−0
PE, A (k) = 0
]
− Prob
[
Exptindcpa−1
PE, A (k) = 0
]∣
∣
∣
where, for b ∈ {0, 1},
Exptindcpa−b
PE, A (k):
(pk, sk) ← G(r) where r ← {0, 1}k
(x0, x1, s) ← A1(pk)
c = Epk(xb)
d ← A2(x0, x1, s, c)
return d
74 C. Ventre and I. Visconti
Above it is mandatory that |x0| = |x1|. We say that PE is IND-CPA secure if A
being polynomial-time implies Advind−cpa
PE, A (·) is negligible.
Non-Malleable NIZK proof of knowledge. An important tool of our construction
is the following notion defined in [5].
Definition 4 (Non-Malleable NIZK). Let Π = (�, P , V , S) be an unbounded
NIZK proof system for the NP language L with witness relation W . We say that
Π is a non-malleable (in the explicit witness sense) NIZK proof system for L if
there exists a probabilistic polynomial-time oracle machine M = (M0, M1, M2)
such that:
For all non-uniform probabilistic polynomial-time adversaries A and for all
non-uniform polynomial-time relations R, there exists a negligible function ν(k)
such that ∣
∣
∣Prob
[
ExptSA,R(k)
]
− Prob
[
Expt′A,R(k)
]∣
∣
∣ ≤ ν(k)
where ExptSA,R(k) and Expt′A,R are the following experiments:
ExptSA,R(k): Expt′A,R(k)
(Σ, τ) ← S1(1k)
(x, π, aux) ← AS2(·,Σ,τ)(Σ)
Let Q be list of pairs (x, π) given by S2 above (x, w, aux) ← MA(1k)
return true iff
((x, π) �∈ Q) ∧ return true iff
(V(x, π, Σ) = true) ∧ ((x, w) ∈ W ) ∧
(R(x, aux) = true) (R(x, aux) = true)
We focus our attention to the construction given in [5] and thus we can rewrite
the non-malleability machine M of the non-malleable NIZK proof of knowledge
of [5] as follows. We can state that M is actually composed of three different
algorithms (GΣ , M1, M2). In particular we can rewrite Expt′A,R(k) above as
follows:
Expt′A,R(k)
Make reference string Σ
(Σ, τ) ← GΣ(1k)
Interact with A(Σ). When asked for a proof of x, do:
πx ← M1(Σ, x, τ)
Extract witness from some proof π
(x, w, aux) ← M2(Σ, τ, x, π)
return true iff ((x, w) ∈ W ) ∧ (R(x, aux) = true)
Completely Non-malleable Encryption Revisited 75
Ingredients of the Construction. Our scheme (G′, E ′, D′) is based on:
1. Any IND-CPA secure encryption scheme PE = (G, E , D) in the standard
model.
2. A non-malleable NIZK proof of knowledge Π = (�, P , V , S) for the following
languages:
L1 = {pk : ∃ r s.t. |r| = k, (pk, sk) ← G(r)},
L2 = {(c, pk) : ∃ r, m s.t. c = Epk(m; r)}.
We observe that both languages are in NP . Indeed, for L1, r witnesses the
membership in the language, and further, the length of r is polynomial in
the size of pk. For L2, r and m witness the membership in the language; the
size of r and m is polynomial in the sizes of c and pk.
Construction 4. The scheme (G′, E ′, D′) is defined as follows:
– G′(1k): randomly pick r ← {0, 1}∗, call G(r) to obtain a valid pair of keys
(pk, sk). Use P , r and Σ to generate a proof of knowledge π1 that pk ∈ L1
using r as witness. The public key is PK = (pk, π1). The private key is
SK = sk.
– E ′
PK(m): Use V to verify the correctness of the proof π1 in PK. If π1 is
valid then compute (using randomness r) c = Epk(m). Use P , r, m and Σ
to generate a proof of knowledge π2 that (c, pk) ∈ L2 using r and m as
witnesses. Output (c, π2).
– D′
SK(c): Use V to verify the correctness of the proof π2 in c. If π2 is valid
then output Dsk(c).
We next give an informal argument supporting the complete non-malleability of
our scheme. Since the component encryption scheme is IND-CPA in the standard
model then every IND-CPA adversary for PE has a negligible advantage. We
define one of such IND-CPA adversaries A in the standard model by means of
an NM-CCA2* adversary B in the shared random string model. The adversary A,
on input the challenge ciphertext c, starts by creating a random string using the
algorithm GΣ (thus allowing A to know a trapdoor for Σ). B, with such a random
string and on input the challenge c returns a relation R, a new public key PK∗
(i.e., a component public key pk∗ and the proof of knowledge of a corresponding
secret key sk∗) and a vector of ciphertexts c∗ under the new public key PK∗.
If B is a winning adversary then the probability that the plaintext encrypted
in c, the ciphertext vector c∗ and the corresponding plaintexts are in relation R
is noticeable. The adversary A then uses the trapdoor to extract the secret key
sk∗ and then evaluates the relation R. This leads to a noticeable advantage for A
distinguishing the plaintext behind the challenge c contradicting the IND-CPA
security of PE . Since we augmented the encryption of a message m by a proof of
knowledge of m, A can answer the decryption queries the NM-CCA2* adversary
B will ask for, due to the fact that A knows the trapdoor for Σ.
76 C. Ventre and I. Visconti
Theorem 5. The encryption scheme (G′, E ′, D′) above is NM-CCA2* secure in
the shared random string model.
Proof. The main idea is to transform a strong NM-CCA2* attack against the
new encryption scheme PE ′ = (G′, E ′, D′) into an IND-CPA attack against the
component encryption scheme PE . In particular, let B = (B1, B2) be an NM-
CCA2* adversary attacking the new encryption scheme. We must show that
Advnm−cca2∗
PE′,B (·) is negligible. Towards this end we describe an IND-CPA adver-
sary A = (A1, A2) attacking the component encryption scheme PE .
A1(pk):
(Σ, τ) ← GΣ(1k)
π ← M1(Σ, pk, τ)
Run B
Dsk(·)
1 on input ((pk, π), Σ):
When B1 asks Dsk(·) for a ciphertext (c′, π′), do:
If V((c′, pk), π′, Σ) = false return ⊥ to B1
(r, m) ← M2(Σ, τ, (c′, pk), π′)
return m to B1
Let (M, s) the output of B1
x0, x1 ← M
return (x0, x1, (s, τ, (pk, π), Σ, M))
A2(x0, x1, s
′, c): where s′ = (s, τ, PK, Σ, M)
Run B
D(c)
sk(·)
2 on input (M, PK, s, c, Σ):
When B2 asks D(c)
sk(·) for a ciphertext (c′, π′), do:
If V((c′, pk), π′, Σ) = false return ⊥ to B2
(r, m) ← M2(Σ, τ, (c′, pk), π′)
return m to B2
Let (R, (pk∗, π∗), c∗) the output of B2
r∗ ← M2(Σ, τ, pk∗, π∗)
(pk∗, sk∗) ← G(r∗); x = Dsk∗(c∗)
f = (c �∈ c∗ ∨ pk �= pk∗)
if (f ∧ (x �=⊥) ∧ R(x0,x, (pk, π), (pk∗, π∗), c∗, Σ)) then d ← 0
else d ← {0, 1}
return d
Notice A is polynomial time given that the running time of B, the time to
compute R, the time to sample from M and the running time of M are all
bounded by a fixed polynomial.
Observe that in the adversary above we use three different kind of proofs:
π is the (non-malleable NIZK) proof (of knowledge) that pk ∈ L1, π′ is the
(non-malleable NIZK) proof (of knowledge) that the ciphertext c′ for which Bj
Completely Non-malleable Encryption Revisited 77
(j = 1, 2) is asking for the decryption is valid – i.e., (c′, pk) ∈ L2 –, and π∗ is the
(non-malleable NIZK) proof (of knowledge) that pk∗ ∈ L1. We use the proofs
π′ along with the trapdoor τ to allow A to answer to the decryption queries.
Indeed, up to a negligible factor, M2 extracts the witnesses r, m and therefore
A can correctly return m to the NM-CCA2* adversary.
Moreover, observe that since we are using a non-malleable NIZK PoK proof
system then M2(·, ·, ·, ·) must extract (up to a negligible factor) the plaintext
used by B2(·, ·, ·, ·) in the proof π∗. If it was not the case, then we could use
B2(·, ·, ·, ·) to break the properties of the non-malleable NIZK proof system. Thus
the operation of using the output of M2(·, ·, ·, ·) to generate the secret key sk∗
corresponding to pk∗ is well defined. The decryption with sk∗ will thus give the
actual plaintext vector behind c∗.
The advantage of A is given by Advind−cpa
PE, A (k) = |pk(0) − pk(1)| where, for
b ∈ {0, 1}, we let
pk(b) = Prob
[
(pk, sk) ← G(1k); (x0, x1, s
′) ← A1(pk); c ← Epk(xb) :
A2(x0, x1, s
′, c) = 0
]
.
Also for b ∈ {0, 1} we let2
p′k(b) = Prob
[
(pk, sk) ← G(1k); (Σ, τ) ← GΣ(1k); π ← M1(Σ, pk, τ);
(M, s) ← BDsk(·)
1 ((pk, π), Σ); x0, x1 ← M ; c ← Epk(xb);
(R, (pk∗, π∗), c∗) ← B
D(c)
sk(·)
2 (M, PK, s, c, Σ); r∗ ← M2(Σ, τ, pk∗, π∗);
(pk∗, sk∗) ← G(r∗);x = Dsk∗(c∗); f = (c �∈ c∗ ∨ pk �= pk∗) :
f ∧ (x �=⊥) ∧ R(x0,x, (pk, π), (pk∗, π∗), c∗, Σ)
]
.
Now observe that A2 may return 0 either when x is R-related to x0 or as a result
of the coin flip. Thus we have:
Advind−cpa
PE, A (k) = |pk(0) − pk(1)| =
1
2
∣
∣
∣
∣
p′k(0) − p′k(1)
∣
∣
∣
∣
.
We now observe that the experiment of B2 being given a ciphertext of x1 and
R-relating x to x0 is exactly Exptnm−cca2∗
PE′, B, $ (k). On the other hand, in the case
in which B2 works on the ciphertext of x0, we are looking at the experiment
Exptnm−cca2∗
PE′, B (k) = 1. Therefore we obtain the following.
Advnm−cca2∗
PE′, B (k) = |p′k(0) − p′k(1)| = 2 · Advind−cpa
PE, A (k).
2 To simplify our notation, in the definition of p′
k(b) we do not specify that the decryption
queries of B are replied as in the description of the IND-CPA adversary A.
78 C. Ventre and I. Visconti
Since PE is IND-CPA secure then Advind−cpa
PE, A (·) is negligible. It follows that
Advnm−cca2∗
PE′, B (·) is negligible. 	
We stress that we cannot use just one of the two languages above. Indeed, L2 is
needed because it allows an IND-CPAadversary to answer to the queries of an NM-
CCA2∗ adversary. Moreover, we need L1 to enforce the NM-CCA2∗ adversary to
output a valid new public key pk∗ (i.e., pk∗ is the output of the key generation algo-
rithm of PE) for the component IND-CPA secure encryption scheme. One would
be tempted to use the proof of knowledge contained in c∗ – the ciphertext output
of the NM-CCA2∗ adversary – to extract the corresponding plaintext and use it
to evaluate the relation. This approach fails when pk∗ is not valid since the NM-
NIZK PoK extractor returns one of the messages for which c∗ is the corresponding
encryption but not necessarily the one that satisfies the relation.
Simulation-based NM-CCA2* security. We now discuss that our construction
can be adapted to achieve the simulation-based notion of NM-CCA2* security.
In particular, we will consider the following tool. We start by giving the definition
of same-string ZK.
Definition 5 (Same-String Zero Knowledge). We say that an NIZK argu-
ment system is same-string NIZK if the (unbounded) zero knowledge requirement
above is replaced with the following requirement: there exists a negligible function
ν such that for all k the following property holds.
Same-string Zero Knowledge: For all non-uniform probabilistic polynomial-
time adversaries A we have that
|Prob [ X = 1 ] − Prob [ Y = 1 ]| ≤ ν(k), where X and Y are as defined in (and
all probabilities are taken over) the experiment Expt(k) below:
Expt(k) :
(Σ, τ) ← S1(1k)
X ← AP(·,·,Σ)(Σ)
Y ← AS′(·,·,Σ,τ)(Σ)
where S′(x, w, Σ, τ) def= S2(x, Σ, τ). The distribution on Σ produced by S1(1k)
is the uniform distribution over {0, 1}�(k).
We refer to NIZK arguments that are both non-malleable and same-string as
robust NIZK (as in [5]). We denote a robust NIZK Π as the following tuple:
Π = (�, P , V , S). We remark that the authors of [5] give a construction of a
robust NIZK starting from a same-string NIZK proof of knowledge given that
one-way functions exist.
The construction. We now show that in the above scheme by simply replacing the
non-malleable NIZK proof of knowledge Π = (�, P , V , S) by a robust NIZK Π ′ =
(�′, P ′, V ′, S′) we obtain a scheme that satisfies the simulation-based definition
of [4] (see Definition 2) adapted to the shared random string model.
Completely Non-malleable Encryption Revisited 79
First of all we argue why Construction 4 does not seem to be sufficient. The
simulator S receives as input a pair (pk = (pk′, π), Σ) generates a fake SRS Σ′
along with a trapdoor τ ′, and computes a new proof π′ so that pk′′ = (pk′, π′) is
a valid public key with respect to Σ′. Then S runs A on input (pk′′, Σ′) and can
obviously answer to all its queries since knowledge of τ ′ allows S to decrypt all
valid ciphertexts. Moreover S feeds to A the encryption c of a random message m
as challenge. Finally A outputs a pair (c�, pk�) that corresponds to the encryption
of a messages m̃ related to m. However, the relation R receives as input also the
public keys pk′′, pk� and Σ′. S could obviously decrypt the message m̃ encrypted
in c� and could compute an encryption of m̃ with respect to a new public key p̃k
and shared random string Σ (notice that S can not simply output the pair (c�, pk�)
since this is valid only with respect to Σ′ while S needs to output a valid pair with
respect to Σ). However even though the same message has been encrypted, the
relation could not be satisfied as Σ �= Σ′ and pk� �= p̃k.
We fix this problem by strengthening the ingredient that we use in the con-
struction: we replace the non-malleable NIZK by a robust NIZK. Robust NIZK
considers non-malleable zero-knowledge arguments (i.e., computationally sound
proofs) of knowledge where the simulator works using the same shared random
string of the real game, still having a trapdoor that will allow it to compute
simulated proofs and to extract witnesses from accepting proofs.
Concretely, S will run A precisely on input (pk, Σ) and will feed it the en-
cryption c of a random message m. S decrypts A’s queries by using τ and finally
outputs the pair (c�, pk�) given in output by A. The indistinguishability of the
output of the stand-alone S with respect to the man-in-the-middle A can be
proved by using standard hybrid arguments.
We finally stress that the above simulator does not require access to a decryp-
tion oracle, therefore it satisfies the stronger notion of stand-alone simulation
discussed in [4].
4 Interactive Non-black-box Complete Non-malleability
In this section we present a completely non-malleable encryption scheme using
interaction and non-black-box techniques. Our construction can be compared to
Fischlin’s impossibility result. Indeed, that impossibility proof holds for black-box
non-interactive encryption schemes, therefore it is still possible to relax either the
need of interaction or the need of non-black-box techniques3. The construction we
give is NM-CCA2∗ secure under both our game-based definition and under the
simulation-based definition. Moreover, it is stand-alone (i.e., the simulator does
not access to a decryption oracle) and requires sequential decryption queries (i.e.,
the decryption oracle sends its answers one-by-one, sequentially). We construct
a non-black-box constant-round interactive completely non-malleable encryption
scheme in the standard model using the recent technique by Pass and Rosen [16,17]
that produced a constant-round NMZK argument of knowledge in the standard
3 We stress that the techniques of [1,6] would potentially avoid the non-black-box tech-
niques, but would produce a non-constant round complexity.
80 C. Ventre and I. Visconti
model. On top of this tool they showed also how to construct constant-round
concurrent non-malleable commitments in the standard model by composing a
commitment scheme with the NMZK argument of knowledge of the committed
message. The same approach has been recently used in [18] where non-malleable
witness indistinguishable argument systems are achieved by committing to an NP
witness and then using the NMZK argument of knowledge to prove that the com-
mitted message satisfies an NP relation. We notice that by following the same
approach, it is possible to first encrypt a message using an IND-CPA encryption
scheme and then prove knowledge of the encrypted message with the NMZK ar-
gument of knowledge. While this gives NM-CPA∗ security, extra work is required
to claim NM-CCA1∗ and NM-CCA2∗ security as in these last two cases, queries
to a decryption oracle have to be taken into account.
Definitions for interactive encryption. The definitions for NM-ATK∗-secure en-
cryption for ATK ∈ {CPA, CCA1, CCA2} given in Section 2 assume that an
encryption and a decryption (oracle answer) is computed non-interactively by
an efficient algorithm. An interactive encryption is instead a two-party protocol.
Therefore, in order to recycle all the previous definitions we have to specify the
role of the parties in all the steps described in Definition 1.
An interactive encryption is a protocol played between a sender sen and a
receiver rec. At the end of the protocol, if both parties behave correctly, the
exchanged transcript corresponds to an encryption of a message computed by
sen for rec under a public key pk.
Non-malleable interactive encryption concerns a man-in-the-middle adversary
A that controls the communication between sen and rec (e.g., he can delay, dis-
card, scramble, and update the messages, as defined for non-malleable protocols
in [1]). A aims at computing encryptions for rec of messages that are related to
the message encrypted by sen. The goal of a non-malleable interactive encryp-
tion scheme is to preserve security against such man-in-the-middle attacks, thus
making useless the attack of A. Different definitions of interactive non-malleable
encryption can be given by possibly giving to A access to decryption oracles, thus
producing the variations CPA, CCA1 and CCA2. In order to have a definition
of interactive encryption following the standard non-interactive Definition 1, we
consider the framework used by Katz in [19,20]. We sketch here the setting on
which we base our protocol, more details can be in the full version of the paper.
A has access to an encryption oracle OE = Epk(·) that plays as sender while
A plays as receiver. The goal of A is to produce the description of a relation R,
a new public key pk∗ and encryptions of messages that are related through R to
the message encrypted by OE . In order to do that, A plays the protocol with
honest receivers potentially interleaving (even concurrently) these interactions
and the one with OE .
The above sketched discussion only concerns NM-CPA∗ security given in Def-
inition 1 but adapted for interactive encryption. Instead, for the notions of NM-
CCA1∗ and NM-CCA2∗ security the adversary A has to include the capability
of accessing to a decryption oracle. Such accesses (e.g., oracle queries) are in-
teractive encryptions where the adversary acts as a sender and the decryption
Completely Non-malleable Encryption Revisited 81
oracle OD = Dsk(·) plays the role of a receiver. Indeed, an oracle query is an
encryption sent by the adversary (and thus the interactive encryption protocol
is played) plus an answer of the oracle. Each time a given interactive encryption
with OD is completed, the decryption oracle computes the decryption (using the
secret key) and sends the resulting message (or a special symbol, if the transcript
was invalid) to the adversary.
The definition of NM-CCA1∗ security assumes that A has first access to the
decryption oracle OD and then, once all interactions with OD have been com-
pleted, A starts the game above, choosing the messages distribution M and
receiving an encryption from OE while computing encryptions for honest re-
ceivers. For the case of NM-CCA1* security we therefore assume a time barrier
between all decryption queries and the remaining protocols. These accesses to
OD correspond to queries to O1 in Definition 1.
Thedefinition ofNM-CCA2∗ security instead allowsA to rundecryption queries
even during and/or after receiving the challenge encryption from OE . Obviously
some limitations must be placed on the adversary access to the decryption oracle
or else the adversarymay simply forward messages between OE and OD and there-
fore trivially succeeds in computing encryptions of messages that are related to the
challenge plaintext. We therefore require that the transcript of the encryptions of
OE must be different from the ones of the decryption queries. These additional
accesses to OD correspond to queries to O2 in Definition 1.
The above definition gives to the adversary A the power of controlling the
communication channel and thus of deciding the schedule of the messages of
different interactions involving different parties (different honest receivers, the
encryption oracle and the decryption oracle). It is therefore obvious to assume
that interactions with different parties can be run concurrently. The only restric-
tion we have is on the interactions with the decryption oracle that we required
to be sequential. Notice that this is also applicable in practice since OD is a
stateful algorithm that can simply manage a queue of requests to satisfies them
one by one.
We finally say that an encryption scheme is self-certifiable, if there exists an
efficient algorithm that on input a public key outputs 1 if it holds that any valid
ciphertext corresponds to only one plaintext and 0 otherwise.
Theorem 6. Under the assumption that there exists a family of claw-free per-
mutations and that self-certifiable IND-CPA secure encryption schemes exist,
there exists an interactive (constant-round) non-black-box NM-CCA2* secure
encryption scheme with sequential decryption queries.
For lack of space we show the construction in Fig. 1 (where we let Πtag =
〈Ptag, Vtag〉 be the tag-based constant-round one-left many-right concurrent non-
malleable statistical zero-knowledge argument of knowledge of [16,17] and SS =
(SG, Sig, SVer) be a one-time secure signature scheme of [21]). The proof can be
found in the full version of the paper, where we also show in a separate theorem
that the same protocol also satisfies the simulation-based notion of complete
non-malleability. We remark that the proof exploits the power of the simulator
and the extractor of the statistical non-malleable zero knowledge argument of
82 C. Ventre and I. Visconti
knowledge of [17,16]. In particular the extractor will be used for answering to
the decryption queries, and, since it requires rewinds, we assume that decryption
queries are answered sequentially, so that we do not need to face the known
problems of concurrent zero knowledge [22].
We stress that a public key of our scheme is the public key of a self-certifiable
IND-CPA secure encryption scheme.
1. sen sets c ← Epk(w) where w is the k-bit message to encrypt.
2. sen sets (ssk, spk) ← SG(1n).
3. sen sends the pair (c, spk) to rec.
4. sen and rec run protocol Πspk = 〈Pspk, Vspk〉 where sen proves knowledge
of w such that c ← Epk(w).
5. sen computes a signature τ ← Sig(pk ◦ trans, ssk) where trans is the tran-
script exchanged so far and sends it to rec.
6. rec accepts the encryption iff SVer(pk ◦ trans, τ, spk) = 1 and Vspk outputs
1.
Fig. 1. Constant-Round Completely Non-Malleable Encryption
We now only give an intuition of the proof.
Proof’s sketch. Assume by contradiction that an adversary A succeeds in com-
puting encryptions of related messages under a new public and a new relation
of its choice. Therefore A has non-negligible success of generating an encryp-
tion c�
0 of a message m�
0 related to m0 on input an encryption c0 of m0 and an
encryption c�
1 of a message m�
1 related to m1 on input an encryption c1 of m1.
Let Expt0 and Expt3 the two above experiments, we can consider two hybrid
experiments Expt1, Expt2 where instead of running A, we run the simulator S
associated to the statistical non-malleable zero knowledge argument of knowl-
edge of [17,16] giving it access to A and c0 in Expt1 and access to A and c1 in
Expt2.
By the statistical zero-knowledge property of this tool, we have that experi-
ment Expt1 in indistinguishable with respect to Expt0.
A distinguisher between Expt1 and Expt2 can be used for breaking the seman-
tic security of the (non-interactive) encryption scheme used as subprotocol. This
can be done by feeding to A a challenge c that can be either an encryption of m0
or an encryption of m1 under the encryption scheme used as subprotocol. Then
the extractor of [17,16] obtains the encrypted message and can therefore be used
to break with non-negligible advantage the semantic security of the encryption
scheme.
Finally, Expt2 and Expt3 are indistinguishable for the same reason that make
indistinguishable Expt0 and Expt1.
The full proof considers other issues as concurrency and adaptiveness. More-
over it is shown that the protocol satisfies also the simulation-based definition,
Completely Non-malleable Encryption Revisited 83
as a simulator can be designed by simply sending an encryption of any message
(say 0k) and then using the simulator of the NMZK argument of knowledge. �
Concluding Remarks. In this paper we explored the notion of complete non-
malleability for public-key encryption schemes. We have given new definitions
and proved relations among these notions. Finally, we have shown new construc-
tions that achieve these security notions without using random oracles.
Acknowledgments
We wish to thank Alex Dent for his useful comments on an early draft of this pa-
per. Moreover we thank the anonymous reviewers for their accurate suggestions
and Pino Persiano for useful discussions about non-malleability.
The work of the authors has been supported in part through the FP6 program
under contract FP6-1596 AEOLUS and in part by the European Commission
through the IST program under Contract IST-2002-507932 ECRYPT.
References
1. Dolev, D., Dwork, C., Naor, M.: Non-malleable cryptography. In: Proc. of STOC,
pp. 542–552 (1991)
2. Sahai, A.: Non-Malleable Non-Interactive Zero Knowledge and Adaptive Chosen-
Ciphertext Security. In: 40th Symposium on Foundations of Computer Science
(FOCS 1999), 1109 Spring Street, Suite 300, Silver Spring, MD 20910, USA, pp.
543–553. IEEE Computer Society Press, Los Alamitos (1999)
3. Bellare, M., Desai, A., Pointcheval, D., Rogaway, P.: Relations among notions of
security for public-key encryption schemes. In: Krawczyk, H. (ed.) CRYPTO 1998.
LNCS, vol. 1462, pp. 26–45. Springer, Heidelberg (1998)
4. Fischlin, M.: Completely non-malleable schemes. In: Caires, L., et al. (eds.) ICALP
2005. LNCS, vol. 3580, pp. 779–790. Springer, Heidelberg (2005)
5. De Santis, A., Di Crescenzo, G., Ostrovsky, R., Persiano, G., Sahai, A.: Robust non-
interactive zero knowledge. In: Kilian, J. (ed.) CRYPTO 2001. LNCS, vol. 2139,
pp. 566–598. Springer, Heidelberg (2001)
6. Barak, B., Prabhakaran, M., Sahai, A.: Concurrent non-malleable zero knowledge.
In: 47th, IEEE Computer Society Press, Los Alamitos (2006)
7. Bellare, M., Boldyreva, A., Palacio, A.: An uninstantiable random-oracle-model
scheme for a hybrid-encryption problem. In: Cachin, C., Camenisch, J.L. (eds.)
EUROCRYPT 2004. LNCS, vol. 3027, pp. 171–188. Springer, Heidelberg (2004)
8. Canetti, R., Goldreich, O., Halevi, S.: The random oracle methodology, revisited
(preliminary version). In: STOC, pp. 209–218 (1998)
9. Nielsen, J.B.: Separating random oracle proofs from complexity theoretic proofs:
The non-committing encryption case. In: Yung, M. (ed.) CRYPTO 2002. LNCS,
vol. 2442, pp. 111–126. Springer, Heidelberg (2002)
10. Goldwasser, S., Kalai, Y.T.: On the (in)security of the fiat-shamir paradigm. In:
FOCS (2003)
11. Cramer, R., Shoup, V.: A Practical Public-Key Cryptosystem Provably Secure
Against Adaptive Chosen Ciphertext Attack. In: Krawczyk, H. (ed.) CRYPTO
1998. LNCS, vol. 1462, pp. 13–25. Springer, Heidelberg (1998)
84 C. Ventre and I. Visconti
12. Bellare, M., Rogaway, P.: Optimal asymmetric encryption. In: Helleseth, T. (ed.)
EUROCRYPT 1993. LNCS, vol. 765, pp. 92–111. Springer, Heidelberg (1994)
13. Fujisaki, E., Okamoto, T., Pointcheval, D., Stern, J.: Rsa-oaep is secure under the
rsa assumption. In: Kilian, J. (ed.) CRYPTO 2001. LNCS, vol. 2139, pp. 260–274.
Springer, Heidelberg (2001)
14. Bellare, M., Sahai, A.: Non-malleable encryption: Equivalence between two no-
tions, and an indistinguishability-based characterization. In: Wiener, M.J. (ed.)
CRYPTO 1999. LNCS, vol. 1666, pp. 519–536. Springer, Heidelberg (1999)
15. Fischlin, M.: Completely non-malleable schemes. Technical report, Full version of
[4] (2005)
16. Pass, R., Rosen, A.: New and improved constructions of non-malleable crypto-
graphic protocols. In: Proc. of STOC, pp. 533–542 (2005)
17. Pass, R., Rosen, A.: Concurrent non-malleable commitments. In: Proc. of FOCS,
pp. 563–572 (2005)
18. Ostrovsky, R., Persiano, G., Visconti, I.: Concurrent non-malleable witness indis-
tinguishability and its applications. Technical Report TR06-095, ECCC (2006)
19. Katz, J.: Efficient Cryptographic Protocols Preventing Man-in-the-Middel Attacks,
Ph.D. Thesis. Columbia University (2002)
20. Katz, J.: Efficient and Non-Malleable Proofs of Plaintext Knowledge and Appli-
cations. In: Biham, E. (ed.) EUROCRYPT 2003. LNCS, vol. 2656, pp. 211–228.
Springer, Heidelberg (2003)
21. Rompel, J.: One-way functions are necessary and sufficient for secure signatures.
In: Proc. of STOC, pp. 387–394 (1990)
22. Dwork, C., Naor, M., Sahai, A.: Concurrent Zero-Knowledge. In: 30th ACM Sym-
posium on Theory of Computing (STOC 1998), pp. 409–418. ACM Press, New
York (1998)
	Completely Non-malleable Encryption Revisited
	Introduction
	Our Results
	New Definitions for Encryption Schemes
	Completely Non-malleable Encryption
	NM-CCA2* Secure Encryption with Shared Random Strings
	Interactive Non-black-box Complete Non-malleability
<<
  /ASCII85EncodePages false
  /AllowTransparency false
  /AutoPositionEPSFiles true
  /AutoRotatePages /None
  /Binding /Left
  /CalGrayProfile (Gray Gamma 2.2)
  /CalRGBProfile (sRGB IEC61966-2.1)
  /CalCMYKProfile (ISO Coated)
  /sRGBProfile (sRGB IEC61966-2.1)
  /CannotEmbedFontPolicy /Error
  /CompatibilityLevel 1.3
  /CompressObjects /Off
  /CompressPages true
  /ConvertImagesToIndexed true
  /PassThroughJPEGImages true
  /CreateJDFFile false
  /CreateJobTicket false
  /DefaultRenderingIntent /Default
  /DetectBlends true
  /DetectCurves 0.1000
  /ColorConversionStrategy /sRGB
  /DoThumbnails true
  /EmbedAllFonts true
  /EmbedOpenType false
  /ParseICCProfilesInComments true
  /EmbedJobOptions true
  /DSCReportingLevel 0
  /EmitDSCWarnings false
  /EndPage -1
  /ImageMemory 524288
  /LockDistillerParams true
  /MaxSubsetPct 100
  /Optimize true
  /OPM 1
  /ParseDSCComments true
  /ParseDSCCommentsForDocInfo true
  /PreserveCopyPage true
  /PreserveDICMYKValues true
  /PreserveEPSInfo true
  /PreserveFlatness true
  /PreserveHalftoneInfo false
  /PreserveOPIComments false
  /PreserveOverprintSettings true
  /StartPage 1
  /SubsetFonts false
  /TransferFunctionInfo /Remove
  /UCRandBGInfo /Preserve
  /UsePrologue false
  /ColorSettingsFile ()
  /AlwaysEmbed [ true
  ]
  /NeverEmbed [ true
  ]
  /AntiAliasColorImages false
  /CropColorImages true
  /ColorImageMinResolution 150
  /ColorImageMinResolutionPolicy /OK
  /DownsampleColorImages true
  /ColorImageDownsampleType /Bicubic
  /ColorImageResolution 600
  /ColorImageDepth 8
  /ColorImageMinDownsampleDepth 1
  /ColorImageDownsampleThreshold 1.01667
  /EncodeColorImages true
  /ColorImageFilter /FlateEncode
  /AutoFilterColorImages false
  /ColorImageAutoFilterStrategy /JPEG
  /ColorACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /ColorImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /JPEG2000ColorACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000ColorImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasGrayImages false
  /CropGrayImages true
  /GrayImageMinResolution 150
  /GrayImageMinResolutionPolicy /OK
  /DownsampleGrayImages true
  /GrayImageDownsampleType /Bicubic
  /GrayImageResolution 600
  /GrayImageDepth 8
  /GrayImageMinDownsampleDepth 2
  /GrayImageDownsampleThreshold 1.01667
  /EncodeGrayImages true
  /GrayImageFilter /FlateEncode
  /AutoFilterGrayImages false
  /GrayImageAutoFilterStrategy /JPEG
  /GrayACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /GrayImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /JPEG2000GrayACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000GrayImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasMonoImages false
  /CropMonoImages true
  /MonoImageMinResolution 1200
  /MonoImageMinResolutionPolicy /OK
  /DownsampleMonoImages true
  /MonoImageDownsampleType /Bicubic
  /MonoImageResolution 1200
  /MonoImageDepth -1
  /MonoImageDownsampleThreshold 2.00000
  /EncodeMonoImages true
  /MonoImageFilter /CCITTFaxEncode
  /MonoImageDict <<
    /K -1
  >>
  /AllowPSXObjects false
  /CheckCompliance [
    /None
  ]
  /PDFX1aCheck false
  /PDFX3Check false
  /PDFXCompliantPDFOnly false
  /PDFXNoTrimBoxError true
  /PDFXTrimBoxToMediaBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXSetBleedBoxToMediaBox true
  /PDFXBleedBoxToTrimBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXOutputIntentProfile (None)
  /PDFXOutputConditionIdentifier ()
  /PDFXOutputCondition ()
  /PDFXRegistryName (http://www.color.org)
  /PDFXTrapped /False
  /SyntheticBoldness 1.000000
  /Description <<
    /DEU ()
  >>
>> setdistillerparams
<<
  /HWResolution [2400 2400]
  /PageSize [595.000 842.000]
>> setpagedevice