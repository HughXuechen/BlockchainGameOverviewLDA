Chosen-Ciphertext Secure Key Encapsulation Mechanism in the Standard Model
Received December 22, 2020, accepted January 8, 2021, date of publication January 12, 2021, date of current version January 25, 2021.
Digital Object Identifier 10.1109/ACCESS.2021.3051047
Chosen-Ciphertext Secure Key Encapsulation
Mechanism in the Standard Model
SHENGFENG XU 1 AND XIANGXUE LI 2,3,4
1Department of Computer Science and Technology, East China Normal University, Shanghai 200062, China
2School of Software Engineering, East China Normal University, Shanghai 200062, China
3Shanghai Key Laboratory of Trustworthy Computing, East China Normal University, Shanghai 200062, China
4Westone Cryptologic Research Center, Beijing 100070, China
Corresponding author: Xiangxue Li (xxli@cs.ecnu.edu.cn)
This work was supported in part by the National Natural Science Foundation of China under Grant 61971192 and Grant 6191101004, and
in part by the National Cryptography Development Fund under Grant MMJJ20180106.
ABSTRACT Key Encapsulation Mechanism (KEM) is a foundational cryptography primitive, which can
provide secure symmetric cryptographic key material for transmission by using public key algorithms. Until
now, many Chosen-Ciphertext (IND-CCA) secure KEM schemes are constructed from Chosen-Plaintext
(IND-CPA) or One-Way (OW-CPA) secure PKE via the generic Fujisaki-Okamoto (FO) transformations
(TCC 2017). However, the security relies on the RandomOracleModel (ROM). To the best of our knowledge,
there are no IND-CCA secure KEM schemes based on Learning Parity with Noise (LPN) assumption that
can against post quantum attacks in the standard model. In this work, we propose the first direct construction
of LPN-based KEM, which is secure in the standard model. In particular, we use double-trapdoor technique
to answer adversary’s decryption queries correctly and a Target Collision Resistant (TCR) hash function to
check the validity of the ciphertext. The encapsulated key is determined by a special LPN problem (with no
random oracle required). The scheme is IND-CCA secure against post-quantum attacks under the low-noise
LPN assumptions by a series of games and the security reduction is tight. Compared with previous schemes
on 128-bit security level, our CCA-secure scheme only holds 50.78MB public keys, 62.50MB secret keys
and 4.54KB ciphertexts, which is more efficient than the schemes of Döttling et al. (ASIACRYPT 2012),
Kiltz et al. (PKC 2014) and Yu et al. (CRYPTO 2016) ((7.27GB, 7.24GB, 7.03KB), (80.89MB, 46.23MB,
6.80KB) and (70.95MB, 70.65MB, 86.50KB) respectively).
INDEX TERMS Key encapsulation mechanism, learning parity with noise, standard model, FO-like
transformations.
I. INTRODUCTION
Learning Parity with Noise (LPN) problem is a significant
researching area in cryptography academia. The computa-
tional version of LPN assumption with secret size n ∈ N
and noise rate 0 < µ < 1
2 postulates that given any m =
2(n) (number of queries), it is computationally infeasible for
any probabilistic polynomial-time (PPT) algorithm to recover
the random secret x ← {0, 1}n given (A,A · x + e), where
A ∈ {0, 1}m×n is chosen uniformly at random, e ∈ {0, 1}m is
distributed to Bmµ (the concatenation of m independent copies
of Bµ), Bµ denotes the Bernoulli distribution with parameter
µ (i.e., Pr[Bµ = 1] = µ,Pr[Bµ = 0] = 1 − µ), ‘‘·’’
denotes matrix vector multiplication over GF(2) and ‘‘+’’
The associate editor coordinating the review of this manuscript and
approving it for publication was S. K. Hafizul Islam .
denotes the XOR operation. The decisional version of LPN
simply assumes that (A,A · x + e) is pseudorandom. The two
versions of LPN have been pointed out to be polynomially
equivalent in [1]–[4]. LPN enjoys simplicity and suitability
for weak-power devices (e.g.RFID tags) than other quantum-
secure candidates such as Learning with Errors (LWE) [5].
The first cryptographic application of LPN is lightweight
authentication [6]–[8].
LPN Hardness LPN has also been extensively stud-
ied in learning theory [9]–[11]. Under a constant noise
rate, the most famous algorithms [7], [12] for solv-
ing LPN problem require 22(n/ log n) time and samples.
If one is restricted to m = 2(n) samples, then the
most famous attack [13] requires 22(n) time. The best
known solvers [14] for solving LPN problem need to
use only m = n1+ε LPN samples when needed only
VOLUME 9, 2021 This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see https://creativecommons.org/licenses/by/4.0/ 13683
https://orcid.org/0000-0003-4030-4837
https://orcid.org/0000-0002-1779-6178
https://orcid.org/0000-0002-2703-0213
S. Xu, X. Li: Chosen-Ciphertext Secure Key Encapsulation Mechanism in the Standard Model
22(n/ log log n) time. Under a low noise rate µ = 2( 1
√
n ),
if one is restricted to m = 2(n) samples, then the best attack
has exponential complexity 22(
√
n) [2], [15]–[17].
Key Encapsulation Mechanism From Low-Noise LPN: In
Lepton, a Round-1 algorithm, Yu et al. [18] introduced two
variants (the compact learning parity with noise problem and
the ring variant of compact learning parity with noise prob-
lem) which are hard as standard LPN problem and proposed
an IND-CPA secure key encapsulation mechanism from the
ring variant of compact learning parity with noise problem.
Yu et al. [18] constructed an IND-CCA secure key encap-
sulation mechanism by using FO transformation [19]–[21]
to the IND-CPA secure key encapsulation mechanism.
In [22], Cheng et al. constructed a multiple-recipient Key-
Encapsulation Mechanism (mKEM) scheme in the Random
Oracle Model (ROM) from low-noise LPN.
Key Encapsulation Mechanism With CCA Security: Intu-
itively, the KEM scheme can be simply regarded as the PKE
scheme encrypting a random, except that the security models
of the two schemes are different. There are many trans-
formations (CHK transformation [23]–[25], FO transforma-
tion [19], [20] and so on) to construct an IND-CCA secure
PKE scheme or an IND-CCA secure KEM scheme. In MP
[23], the IND-CCA secure PKE scheme can be constructed
via relatively generic transformations using either strongly
unforgeable one-time signatures, or a message authentica-
tion code and weak form of commitment (BCHK [24]).
In [25], Canetti et al. constructed an IND-CCA secure PKE
scheme from any IND-CPA secure identity-based encryp-
tion (IBE) scheme by using CHK transformation. The
CHK-transformation needs one-time signature increasing the
ciphertext length.
For FO transformation, Fujisaki and Okamoto [19] pro-
posed this transformation which turns any IND-CPA secure
public-key encryption scheme into IND-CCA secure scheme
in the random oracle model. Unfortunately, there are several
drawbacks (e.g., non-tight security reduction and the need for
a perfectly correct scheme) for the FO transformation. In [20],
Hofheinz et al. provided a fine-grained andmodular toolkit of
FO transformations for turning IND-CPA secure schemes or
One-Way (OW-CPA) secure schemes into IND-CCA secure
public-key encryption schemes. Hofheinz et al. analyzed six
different transformations U⊥, U⊥m , U
6⊥, U6⊥m , QU
6⊥
m and QU⊥m ,
where ⊥ ( 6⊥) means explicit (implicit) rejection, m (without
m) means K = H (m) (K = H (m, c)) and Q means adding an
additional hash valueH ′(m) to the ciphertext. QU 6⊥m and QU⊥m
(U 6⊥, U6⊥m , U⊥ and U⊥m) all are in quantum random oracle
model (in random oracle model (ROM)). These six transfor-
mations in [20] are robust against schemes with correctness
errors and some transformations which are added an addi-
tional hash value to the ciphertext be analyzed in the Quan-
tum Random Oracle Model (QROM). For two widely used
generic transformations FO6⊥ and FO6⊥m , Jiang et al. showed
QROM security reductions without adding any ciphertext
overhead in [26].
TABLE 1. Transformation and correctness error of IND-CCA secure
schemes.
In addition, there are many IND-CCA secure KEM
schemes. Park et al. [27] constructed an IND-CCA
secure KEM by using FO transformation [20], [26] from
an IND-CCA secure PKE scheme. In July 2020, the
National Institute of Standards and Technology (NIST)
announced 15 Round-3 algorithms, which includes 7 Round-
3 finalists and 8 Round-3 alternate candidates. Among
these 15 Round-3 algorithms, there are 7 Round-3 algo-
rithms (i.e., CRYSTALS-Kyber, Classic McEliece, SABER,
NTRU-HRSS-KEM, FrodoKEM, HQC and SIKE [18]) for
KEM constructions. From Table 1, we noticed that there
are eight schemes using some conventional transformations
(e.g., U⊥, QU⊥m , QU
6⊥
m , DDN and BCHK ) and six schemes
have correctness errors. These 7 Round-3 algorithms are
constructed by using generic transformations from IND-CPA
secure schemes or OW-CPA secure schemes.
A. OUR CONTRIBUTION
In this work, we construct the first IND-CCA secure KEM
scheme based on variants of low-noise LPN assumption [10],
[30] in the standard model, the main techniques are a target
collision resistant hash function and a double-trapdoor func-
tion. The target collision resistant hash function is used to
check the validity of the ciphertext and the double-trapdoor
technique is used to answer adversary’s decryption queries
correctly, so that our scheme can satisfy CCA security. Our
construction does not rely on generic FO transformations, and
the encapsulated key in our construction is determined by the
LPN problem in [30] rather than a hash function.
The scheme is IND-CCA secure in the standard model
under the low-noise LPN assumptions and the security
reduction is tight. Compared with some lattice-based KEM
schemes (e.g., CRYSTALS-Kyber, FrodoKEM [18] and so
on), our scheme only involves operations over GF(2) (not
GF(q)), which could be much faster when implemented using
hardware. In addition, compared with the work [31], our con-
struction based on low-noise LPN problem is secure against
post-quantum attacks in standard model. Consider the per-
formance on 128-bit security level, our CCA-secure scheme
only holds 50.78MB public keys, 62.50MB secret keys and
4.54KB ciphertexts, which is more efficient than the schemes
of Döttling et al. [10], Kiltz et al. [32] and Yu et al. [13]
((7.27GB, 7.24GB, 7.03KB), (80.89MB, 46.23MB, 6.80KB)
and (70.95MB, 70.65MB, 86.50KB) respectively).
13684 VOLUME 9, 2021
S. Xu, X. Li: Chosen-Ciphertext Secure Key Encapsulation Mechanism in the Standard Model
II. PRELIMINARIES
We denote that the column vector is s, and the row vector that
can be regarded as the transpose of the column vector is rep-
resented by the lowercase letter sT. The matrix is represented
by capital letters A, and |s| refers to the Hamming weight of
the column vector s. Bµ denotes the Bernoulli distribution
with parameter µ (i.e., Pr[Bµ = 1] = µ,Pr[Bµ = 0] =
1 − µ) and Bmµ denotes the concatenation of m independent
copies of Bµ. Bq×mµ denotes a matrix distribution whose
every column is i.i.d. to Bqµ. x
$
←− χ means sampling x
from distribution χ uniformly at random, and x ←− χ means
sampling x according to distribution χ . We use Um to denote
a uniform distribution over {0, 1}m. Let negl(n) denotes a
negligible function in n.
Definition 1 (Learning Parity with Noise): For n ∈ N,
m = 2(n), 0 < µ < 1
2 , the decisional (n, µ)-LPN problem
is hard if for every PPT algorithm D we have
|Pr[D(A,Ax+e)=1]− Pr[D(A,Um)=1]|=negl(n), (1)
where A
$
←− {0, 1}m×n, e
$
←− Bmµ and x
$
←− {0, 1}n. The
computational (n, µ)-LPN problem with the same n and µ is
hard if for every PPT algorithm D we have
Pr[D(A,Ax + e) = x] = negl(n), (2)
where A
$
←− {0, 1}m×n, e
$
←− Bmµ and x
$
←− {0, 1}n.
In some scenarios such as PKE, the problems further put a
constraint on the number of samples, m, and thus might be
written as (n, µ,m)-LPN problems.
Concrete Hardness: For T := T (n), we say that the deci-
sional/computational (n, µ,m)-LPN is T -hard if every proba-
bilistic adversary of running time T the distinguishing (resp.,
inverting) advantage in (1) (resp., (2)) is upper bounded
by 1/T . For (n, µ)-LPN problem (whose m is unspecified),
animplicit constraint is m ≤ T .
Lemma 1 (Lemma 2.10 from [30]): For l ∈ N, n =
2l, c > 0, µ =
√
c
n , (A, y
TA) is computationally indistin-
guishable from (A, r) where A
$
←− {0, 1}n×(l+1), y
$
←− Bnµ
and r
$
←− {0, 1}(l+1).
Proof: Under the decisional (n, µ)-LPN assumption,
(A, yTA) is computationally indistinguishable from (A, r).
This reduction can be refernced to [30].
Definition 2 (VLPN [10]): For n ∈ N, m = 2(n), c >
0, µ =
√
c
n , the decisional (n, µ)-VLPN problem is hard if
for every PPT algorithm D we have
|Pr[D(A,Ax + e) = 1]− Pr[D(A,Um) = 1]| = negl(n),
where A
$
←− {0, 1}m×n, e
$
←− Bmµ and x
$
←− Bnµ. The
computational (n, µ)-VLPN problem with the same n and µ
is hard if for every PPT algorithm D we have
Pr[D(A,Ax + e) = x] = negl(n),
where A
$
←− {0, 1}m×n, e
$
←− Bmµ and x
$
←− Bnµ.
The decisional (n, µ)-VLPN problem to decisional (n, µ)-
LPN problem reduction can be referenced to [10]. As on can
see, a matrix-version of the decisional (n, µ)-VLPN problem
is also hard by using a simple hybrid argument technique.
Definition 3 (KLPN [33]): For n ∈ N, c > 0, µ =
√
c
n
and n < m, the decisional (n, µ)-KLPN problem is hard if
for every PPT algorithm D we have
|Pr[D(A,GA ) = 1]− Pr[D(A,Un×m) = 1]| = negl(n),
where A
$
←− {0, 1}m×n and G
$
←− Bm×mµ .
The decisional (n, µ)-KLPN problem is hard as the decisional
(n, µ)-LPN problem in [32].
Definition 4 (Target Collision Resistant Hash Functions):
For n ∈ N, m = 2(n), s = 2(n) and m > n, a family of
functions H = {hk : {0, 1}m −→ {0, 1}n, k ∈ {0, 1}s} is a
target collision resistant hash function (TCR) if for every PPT
adversary A, it holds that
Pr
hk (x ′) = hk (x) ∧ x ′ 6= x :
k
$
←− {0, 1}s
x
$
←− {0, 1}m
x ′←− A(k, x)
 = negl(n).
Noted that target collision resistant hash function (TCR) is a
weaker notion than collision resistant function, so that any
practical collision resistant function can be used to construct
TCR.
Lemma 2 (Chernoff Bound [10]): If d
$
←− Bmµ and δ > 0,
it holds that
Pr[|d | > (1+ δ)µm] ≤ e
−min(δ,δ2)
3 µm.
Lemma 3: For constants 0 < c < 1
12 , 12c < α < 1
and k ∈ N, let n = 2(k2), m = 2n, µ =
√
c/n, s
$
←−
Bnµ, e
$
←− Bmµ , S
$
←− Bm×mµ and E
$
←− Bn×mµ , we have
Pr[|STe| > α
3m | |e| ≤ 2µm] < 2−2(m) and Pr[|ETs| >
α
6m | |s| ≤ 2µn] < 2−2(m).
Proof: Assuming that the Hamming weight of e does
not exceed 2µm, we analyze the inner product sTe. It’s not
difficult to see that a necessary condition for sTe = 1 is that
s[i] = 1 for at least one of the i’s where e[i] = 1. We use this
in the second step (eq. (4)), and the union bound in the third
step (eq. (5)). So it holds that
µ′ : = Pr[sTe = 1 | |e| ≤ 2µm] (3)
≤ Pr[∃i : (e[i] = 1) ∧ (s[i] = 1) | |e| ≤ 2µm] (4)
≤ µ · 2µm = 4c <
1
3
α. (5)
We have with δ := α
3µ′ − 1 (note that µ′ ≤ 4c < 1
3α, (1+
δ)µ′ = 1
3α )
Pr[|STe| >
1
3
αm | |e| ≤ 2µm] < e−min(δ,δ2)µ′m/3
by using the Chernoff bound.
VOLUME 9, 2021 13685
S. Xu, X. Li: Chosen-Ciphertext Secure Key Encapsulation Mechanism in the Standard Model
Next, δ = α
3µ′ − 1 ≥ α
12c − 1 > 0 and δµ′ = 1
3α − µ
′ >
4c− µ′ ≥ 0 are lower bounded by constants and therefore
Pr[|STe| >
1
3
αm | |e| ≤ 2µm] < e−min(δ,δ2)µ′m/3
= 2−2(m).
Obviously, we can also prove that Pr[|ETs| > 1
6αm | |s| ≤
2µn] < 2−2(m) in a similar way. We omit these details.
III. KEY ENCAPSULATION MECHANISM
A key encapsulation mechanism consists of three algorithms
KEM=(Gen,Encaps,Decaps). The key generation algorithm
Gen(1k ) takes the security parameter 1k as input and returns
a pair of public key pk and private key sk . On input a public
key pk , the key encapsulation algorithm Encaps(pk) returns
a ciphertext C and a key k , where k is contained in the key
space K. On input a ciphertext C and the private key sk , the
deterministic decapsulation algorithm Decaps(sk,C) returns
a key k := Decaps(sk,C) or a failure symbol ⊥. We say that
the KEM scheme is correct, if for all public key pk , it holds
that
Pr
[
Decaps(sk,C) 6= k :
(pk, sk)←− Gen(1k )
(k,C)←− Encaps(pk)
]
≤negl(k).
We recall the IND-CCA secure notions for KEM. Let A
denotes a PPT adversary.
Definition 5 (IND-CCA KEM [20], [26]): AKEM scheme
KEM is IND-CCA secure, if for any PPT adversary A, the
advantage of A is negligible in the experiment defined as
below:
1. Generate a pair of keys (pk, sk) ←− Gen(1k ). The
public key pk is given to A.
2. b∗ ∈ {0, 1} is sampled randomly, and a pair of chal-
lenge ciphertext and key (C∗, k∗1 )←− Encaps(pk) are
generated. The key k∗0 ∈ K is sampled at random. A
gets (C∗, k∗b ) and computes its computation access to the
decapsulation-oracle Decaps (sk, ·).
3. Finally, A outputs a guessing b′. The advantage of A is
defined as Advind−ccaKEM ,A (1k ) := |Pr[b′ = b∗]− 1/2|.
IV. CCA SECURE KEM FROM LOW-NOISE LPN
In this section, we directly construct an IND-CCA secure key
encapsulation mechanism scheme from low-noise LPN.
A. OUR CONSTRUCTION
Our construction follows the general structure of previous
works in [5], [32]. Let k be the security parameter, let 0 < c <
1
12 , l = 2(k2), n = 2l, m = 4l be any constants, let α be a
constant with 12c < α < 1 and letµ =
√
c
n denotes the noise
rate. An error correction code ECC : {0, 1}n −→ {0, 1}m
can encode n bit message and has an efficient decoding
algorithm ECC−1, which can correct up to αm bit errors.
The error correction code can be constructed [33], [34]. Let
H : {0, 1}3m+n −→ {0, 1}(l+1) is a family of target collision
resistant hash functions. We show the construction of our
KEM as follows:
Gen(1k ): On input a security parameter k , it uni-
formly chooses matrices A
$
←− Um×n, S0, S1
$
←−
Bm×mµ , E0,E1
$
←− Bn×mµ and F
$
←− U(l+1)×n, and com-
putes B = ST0 A + E
T
0 ,D = ST1 A + E
T
1 . It returns (pk, sk) =
((A,B,D,F), (S0, S1)).
Encaps(pk): On input the public key pk = (A,B,D,F),
it samples matrices S ′0, S
′
1
$
←− Bm×mµ , E ′0,E
′
1
$
←−
Bn×mµ , s
$
←− Bnµ and e
$
←− Bmµ . Then, it outputs (k, C :=
(c0, c1, c2)), where
c0 := As+ e ∈ {0, 1}m
c1 := Bs+ (S ′0)
Te− (E ′0)
Ts+ ECC(s) ∈ {0, 1}m
c2 := Ds+ (S ′1)
Te− (E ′1)
Ts+ ECC(s) ∈ {0, 1}m
t := H(c0, c1, c2, s) ∈ {0, 1}(l+1)
k := Fs+ t ∈ {0, 1}(l+1).
Decaps(sk,C): On input the secret key sk = (S0, S1) and
a ciphertext (c0, c1, c2), it computes c1 − ST0 c0 = ECC(s) +
(S ′0 − S0)
Te + (E0 − E ′0)
Ts and uses the decoding algorithm
ECC−1 to reconstruct s. If it holds that
|s| ≤ 2µn
∧ |c0 − As| ≤ 2µm
∧ |c1 − Bs− ECC(s)| ≤
1
2
αm
∧ |c2 − Ds− ECC(s)| ≤
1
2
αm, (6)
then it computes t := H(c0, c1, c2, s) and sets k := Fs + t ,
else it lets k :=⊥. Finally, the output is k .
Remark 1: As one can see, the matrix S1 in the secret key
sk = (S0, S1) can also be used to decrypt the ciphertext.
we can also use the decoding algorithmECC−1 to reconstruct
s from c2 − ST1 c0. if it holds that
|s| ≤ 2µn
∧ |c0 − As| ≤ 2µm
∧ |c1 − Bs− ECC(s)| ≤
1
2
αm
∧ |c2 − Ds− ECC(s)| ≤
1
2
αm,
then it computes t := H(c0, c1, c2, s) and lets k := Fs + t ,
else it sets k =⊥. At last, it returns k.
Theorem 1 (Correctness and Equivalence of the Secret
Keys S0, S1): The KEM is correct since we choose appro-
priate choice of parameters. The secret keys S0 and S1 are
equivalent during decapsulation phase.
Proof: For e
$
←− Bmµ and s
$
←− Bnµ, it holds that
Pr[|e| ≤ 2µm] ≥ 1− 2−2(
√
m) (7)
Pr[|s| ≤ 2µn] ≥ 1− 2−2(
√
n) (8)
by using Chernoff bound.
As C is a properly generated ciphertext, it holds that
|s| ≤ 2µn
13686 VOLUME 9, 2021
S. Xu, X. Li: Chosen-Ciphertext Secure Key Encapsulation Mechanism in the Standard Model
∧ |e| ≤ 2µm
∧ |ET
1 s| ≤
1
6αm
∧ |ET
0 s| ≤
1
6αm
∧ |ST0 e| ≤
1
3αm
∧ |ST1 e| ≤
1
3αm
with overwhelming probability 1 − 2−2(
√
n) by using Equa-
tions (7),(8), Lemma 3 and union bound, where S0, S1
$
←−
Bm×mµ , E0,E1
$
←− Bn×mµ , s
$
←− Bnµ and e
$
←− Bmµ . We can
decode the correct s from c1 − ST0 c0 by using the decod-
ing algorithm ECC−1, where the error term satisfies |(S ′0 −
S0)Te + (E0 − E ′0)
Ts| ≤ αm. The consistency check Equa-
tions (6) will pass. Then it computes t := H(c0, c1, c2, s) and
returns the correct key k := Fs+ t . In the following lemma,
we will show that S0 and S1 have the same decapsulation
ability with overwhelming probability.
Lemma 4: Defined Decaps(sk,C)S1 as a decapsulation
algorithm that decapsulation using the secret key S1 to
reconstruct s. Let Decaps(sk,C)S0 := Decaps(sk,C).
Decaps(sk,C)S1 and Decaps(sk,C)S0 return the same k with
overwhelming probability over the choice of parameters.
Then, we get
Pr
pk,sk
[∀C : Decaps(sk,C)S1 6= Decaps(sk,C)S0 ] < 2−2(m).
Proof: If k =: Decaps(sk,C)S0 , we can reconstruct s.
By the consistency check Equations (6), we get
|s| ≤ 2µn
∧ |c0 − As| ≤ 2µm
∧ |c1 − Bs− ECC(s)| ≤
1
2
αm
∧ |c2 − Ds− ECC(s)| ≤
1
2
αm.
We know that Decaps(sk,C)S1 reconstructs the same s by
using the decoding algorithm ECC−1, where the error term
satisfies |(S ′1 − S1)Te + (E1 − E ′1)
Ts| ≤ αm. We know
that |S ′1
Te − E ′1
Ts| ≤ 1
2αm. If |E
T
1 s − ST1 e| ≤
1
2αm, then
the decoding algorithm ECC−1 can construct the same s by
using triangle inequality. If the same e and s satisfying |e| ≤
2µm, |s| ≤ 2µn at random, then we have
Pr
e,|e|≤2µm,S1
[|S1e| ≤
1
3
αm] ≥ 1− 2−2(m)
Pr
s,|s|≤2µn,E1
[|E1s| ≤
1
6
αm] ≥ 1− 2−2(m)
by using Lemma 3. We can get |ET
1 s− S
T
1 e| ≤
1
2αm by using
triangle inequality. We notice that e and s are not a randomly
chosen one. Taking the union bound over all 2log(m)ω(
√
m)
possible e satisfying |e| ≤ 2µm, we have
Pr
S1
[|S1e| ≤
1
3
αm] ≥ 1− 2−2(m)+log(m)ω(
√
m)
= 1− 2−2(m).
In the similar way, taking the union bound over all 2log(n)ω(
√
n)
possible s satisfying |s| ≤ 2µn, we have
Pr
E1
[|E1s| ≤
1
6
αm] ≥ 1− 2−2(m)+log(n)ω(
√
n)
= 1− 2−2(m).
This shows that the same k is returned by Decaps(sk,C)S1
with overwhelming probability over the choice of S1 and
E1. Decaps(sk,C)S0 return the same k with overwhelming
probability over the choice of parameters.
Theorem 2 (Security): Assume thatH is a target collision
resistant hash function. If the decisional (n, µ)-VLPN prob-
lem is hard, ourKEM is IND-CCA secure by using Lemma 1.
Proof: Assumed that A is a PPT adversary against the
IND-CCA security of our scheme. by defining a sequence of
games and showing adjacent games indistinguishable, we can
prove that the advantage Advind−ccaKEM ,A (1k ) is negligible in k .
We use Pr[Ri] to denote the probability of a particular event
that the adversary A wins in Game i.
Game 0: This is the IND-CCA security experiment for the
KEM scheme. The challenger C honestly runs the adversary
A with the security parameter k . The challenger C simulates
the IND-CCA security game for A as follows:
Gen: The challenger C uniformly chooses matrices A
$
←−
Um×n, S0, S1
$
←− Bm×mµ , E0,E1
$
←− Bn×mµ and F
$
←−
U(l+1)×n, and computes B = ST0 A + ET
0 ,D = ST1 A + ET
1 .
The challenger C sends pk = (A,B,D,F) to the adversary
A, and keeps sk = (S0, S1) to itself.
Challenge: The challenger C chooses matrices S ′0, S
′
1
$
←−
Bm×mµ , E ′0,E
′
1
$
←− Bn×mµ , s
$
←− Bnµ, e
$
←− Bmµ and k∗0
$
←−
K, and chooses a bit b∗ ∈ {0, 1} at random. The challenger C
sends (k∗b∗ , (c
∗
0, c
∗
1, c
∗
2)) to the adversary A, where
c∗0 := As+ e ∈ {0, 1}m
c∗1 := Bs+ (S ′0)
Te− (E ′0)
Ts+ ECC(s) ∈ {0, 1}m
c∗2 := Ds+ (S ′1)
Te− (E ′1)
Ts+ ECC(s) ∈ {0, 1}m
t∗ := H(c∗0, c
∗
1, c
∗
2, s) ∈ {0, 1}(l+1)
k∗1 := Fs+ t∗ ∈ {0, 1}(l+1).
Phase 1: When challenger gets a decapsulation query
(c0, c1, c2) from the adversary, the challenger returns ⊥ to
the adversary if (c0, c1, c2) = (c∗0, c
∗
1, c
∗
2). Otherwise, the
challenger firstly computes c1 − ST0 c0 = ECC(s) + (S ′0 −
S0)Te+ (E0−E ′0)
Ts and uses the decoding algorithm ECC−1
to reconstruct s. Let t := H(c0, c1, c2, s). If it holds that
|s| ≤ 2µn
∧ |c0 − As| ≤ 2µm
∧ |c1 − Bs− ECC(s)| ≤ 1
2αm
∧ |c2 − Ds− ECC(s)| ≤ 1
2αm,
then there are two different cases as follows:
Case 1: t = t∗ and (c0, c1, c2, s) 6= (c∗0, c
∗
1, c
∗
2, s): In
this case, the challenger C found a collision (c0, c1, c2, s) 6=
(c∗0, c
∗
1, c
∗
2, s) that satisfiesH(c0, c1, c2, s) = H(c∗0, c
∗
1, c
∗
2, s).
The challenger C sends ⊥ to the adversary A.
VOLUME 9, 2021 13687
S. Xu, X. Li: Chosen-Ciphertext Secure Key Encapsulation Mechanism in the Standard Model
Case 2: t 6= t∗: In this case, the challenger C computes
k := Fs+ t and returns k to the adversary A.
Otherwise, it sets k :=⊥. The challenger C sends k to the
adversary A.
Guess: Eventually, the adversary A outputs a guess b′.
If b′ = b∗, the challenger C outputs 1, otherwise it outputs
0.
Lemma 5: |Pr[R0]− 1
2 | = Advind−ccaKEM ,A (1k ).
Proof: The challenger C honestly runs the adversaryA,
and outputs 1 if and only if b′ = b∗.
Game 1: It is the same as Game 0, except that, the chal-
lenger C changes the key generation phase as follows:
KeyGen: The challenger C uniformly choose matrices
A
$
←− Um×n, S0, S1
$
←− Bm×mµ , E0,E1
$
←− Bn×mµ , F
$
←−
U(l+1)×n and D′
$
←− Um×n, and computes B = ST0 A +
ET
0 ,D = ST1 A + ET
1 . The challenger C returns pk =
(A,B,D′,F) to the adversary A, and keeps sk = (S0, S1) to
itself.
Lemma 6: |Pr[R1]− Pr[R0]| ≤ negl(n).
Proof: It is different that the challenger C replaces D =
ST1 A + ET
1 in public key in Game 0 with D′
$
←− Um×n in
public key in Game 1. Under the matrix-version of the deci-
sional (n, µ)-VLPN assumption, pk = (A,B,D) in Game 0 is
computationally indistinguishable from pk = (A,B,D′) in
Game 1. Consequently, we have that |Pr[R1] − Pr[R0]| ≤
negl(n).
Game 2: It is the same as game 1, except that, the chal-
lenger C changes the Challenge phase as follows:
Challenge: The challenger C chooses S ′0, S
′
1
$
←−
Bm×mµ , E ′0,E
′
1
$
←− Bn×mµ , s
$
←− Bnµ, e
$
←− Bmµ and
k∗0
$
←− K, and samples a bit b∗ ∈ {0, 1} at random. Finally,
the challenger C sends (k∗b∗ , (c
∗
0, c
∗
1, c
∗
2)) to the adversary A,
where
c∗0 := As+ e ∈ {0, 1}m
c∗1 := Bs+ (S ′0)
Te− (E ′0)
Ts+ ECC(s) ∈ {0, 1}m
c∗2 := Ds+ ST1 e− E
T
1 s+ ECC(s) ∈ {0, 1}m
t∗ := H(c∗0, c
∗
1, c
∗
2, s) ∈ {0, 1}(l+1)
k∗1 := Fs+ t∗ ∈ {0, 1}(l+1).
Lemma 7: Pr[R2] = Pr[R1].
Proof: It is different that S1 and E1 in the key generation
phase are sampled from the same distribution as S ′1 and E ′1
in the challenge phase respectively. Noted that D = ST1 A +
ET
1 is not included in the public key, so the adversary has
not obtained any information about S1 and E1 before the
challenge phase. The challenge ciphertext in Game 1 has the
same distribution as the challenge ciphertext inGame 2. In all,
Game 1 and Game 2 are identical from the adversary’s view.
So, we have that Pr[R2] = Pr[R1].
Game 3: It is the same as Game 2, except that, the chal-
lenger C changes the key generation phase as follows:
KeyGen: The challenger C uniformly chooses matrices
A
$
←− Um×n, S0, S1
$
←− Bm×mµ , E0,E1
$
←− Bn×mµ and
F
$
←− U(l+1)×n, and computes B = ST0 A + ET
0 ,D =
ST1 A + E
T
1 . The challenger C sends pk = (A,B,D,F) to the
adversary A, and keeps sk = (S0, S1) to itself.
Lemma 8: |Pr[R3]− Pr[R2]| ≤ negl(n).
Proof: It is different that the challenger C replaces
D′
$
←− Um×n in public key in Game 2 withD = ST1 A+E
T
1 in
public key in Game 3. Under the matrix-version of the deci-
sional (n, µ)-VLPN assumption, pk = (A,B,D′) in Game 2 is
computationally indistinguishable from pk = (A,B,D) in
Game 3. So, we have that |Pr[R3]− Pr[R2]| ≤ negl(n).
Note that c∗2 in target ciphertext (c∗0, c
∗
1, c
∗
2) is equal to
ST1 c
∗
0 + ECC(s).
Game 4: It is the same as Game 3, except that, the chal-
lenger C answers decapsulation queries for any (c0, c1, c2) by
using S1 instead of S0.
Lemma 9: |Pr[R4]− Pr[R3]| ≤ negl(n).
Proof: As one can see, S1 and S0 have equivalent
decryption ability except with negligible probability by using
Lemma 4.
Game 5: It is the same as Game 4, except that, the chal-
lenger C changes the challenge phase as follows:
Challenge: The challenger C chooses s
$
←− Bnµ, e
$
←−
Bmµ and k∗0
$
←− K. The challenger chooses a bit b∗ ∈ {0, 1}
at random. At last, it returns (k∗b∗ , (c
∗
0, c
∗
1, c
∗
2)) to the adversary
A, where
c∗0 := As+ e ∈ {0, 1}m
c∗1 := Bs+ ST0 e− E
T
0 s+ ECC(s) ∈ {0, 1}m
c∗2 := Ds+ ST1 e− E
T
1 s+ ECC(s) ∈ {0, 1}m
t∗ := H(c∗0, c
∗
1, c
∗
2, s) ∈ {0, 1}(l+1)
k∗1 := Fs+ t∗ ∈ {0, 1}(l+1).
Note that c∗1 in target ciphertext (c∗0, c
∗
1, c
∗
2) is equal to
ST0 c
∗
0 + ECC(s).
Lemma 10: |Pr[R5]− Pr[R4]| ≤ negl(n).
Proof: We prove this lemma by using similar proofs
from Lemma 6 to Lemma 8. We omit these details.
Game 6: It is the same as Game 5, except that, the chal-
lenger C changes the challenge phase as follows:
Challenge: The challenger C chooses v
$
←− Um, s
$
←−
Bnµ and k∗0
$
←− K, and randomly samples a bit b∗ ∈ {0, 1}.
Finally, it returns (k∗b∗ , (c
∗
0, c
∗
1, c
∗
2)) to the adversaryA, where
c∗0 := v ∈ {0, 1}m
c∗1 := ST0 v+ ECC(s) ∈ {0, 1}m
c∗2 := ST1 v+ ECC(s) ∈ {0, 1}m
t∗ := H(c∗0, c
∗
1, c
∗
2, s) ∈ {0, 1}(l+1)
k∗1 := Fs+ t∗ ∈ {0, 1}(l+1).
Lemma 11: Under the decisional (n, µ)-VLPN assump-
tion, we have that |Pr[R6]− Pr[R5]| ≤ negl(n).
Proof: It is different that the challenger C replaces c∗ =
v in Game 6 with c∗ = As + e in Game 5, where v
$
←− Um.
Under the decisional (n, µ)-VLPN assumption, the challenge
13688 VOLUME 9, 2021
S. Xu, X. Li: Chosen-Ciphertext Secure Key Encapsulation Mechanism in the Standard Model
ciphertext (c∗0, c
∗
1, c
∗
2) in Game 6 is computationally indistin-
guishable from the challenge ciphertext (c∗0, c
∗
1, c
∗
2) in Game
5. So, we have that |Pr[R6]− Pr[R5]| ≤ negl(n).
Game 7: It is the same as Game 6, except that, the chal-
lenger C changes the challenge phase as follows:
Challenge: The challenger C chooses v
$
←− Um, w
$
←−
Um, s
$
←− Bnµ, w′
$
←− Um and k∗0
$
←− K, and randomly
samples a bit b∗ ∈ {0, 1}. Finally, it returns (k∗b∗ , (c
∗
0, c
∗
1, c
∗
2))
to the adversary A, where
c∗0 := v ∈ {0, 1}m
c∗1 := w+ ECC(s) ∈ {0, 1}m
c∗2 := w′ + ECC(s) ∈ {0, 1}m
t∗ := H(c∗0, c
∗
1, c
∗
2, s) ∈ {0, 1}(l+1)
k∗1 := Fs+ t∗ ∈ {0, 1}(l+1).
Lemma 12: |Pr[R7]− Pr[R6]| ≤ negl(n).
Proof: It is different that the challenger C replaces
c∗1 = w + ECC(s) and c∗2 = w′ + ECC(s) in Game 7 with
c∗1 = ST0 v + ECC(s) and c∗2 = ST1 v + ECC(s) in Game 6,
where v
$
←− Um, w
$
←− Um and w′
$
←− Um. Under the
decisional (n, µ)-KLPN problem, the challenge ciphertext
(c∗0, c
∗
1, c
∗
2) in Game 7 is computationally indistinguishable
from the challenge ciphertext (c∗0, c
∗
1, c
∗
2) in Game 6. So,
we have that |Pr[R7]− Pr[R6]| ≤ negl(n).
Game 8: It is the same as Game 7, except that, the chal-
lenger C changes the challenge phase as follows:
Challenge: The challenger C chooses v
$
←− Um, w
$
←−
Um, s
$
←− Bnµ, w′
$
←− Um, z
$
←− U(l+1) and k∗0
$
←− K,
and randomly samples a bit b∗ ∈ {0, 1}. At last, it returns
(k∗b∗ , (c
∗
0, c
∗
1, c
∗
2)) to the adversary A, where
c∗0 := v ∈ {0, 1}m
c∗1 := w+ ECC(s) ∈ {0, 1}m
c∗2 := w′ + ECC(s) ∈ {0, 1}m
t∗ := H(c∗0, c
∗
1, c
∗
2, s) ∈ {0, 1}(l+1)
k∗1 := z+ t∗ ∈ {0, 1}(l+1).
Lemma 13: |Pr[R8]− Pr[R7]| ≤ negl(n).
Proof: It is different that the challenger C replaces k∗1 =
z + t∗ in Game 8 with k∗1 = Fs + t∗ in Game 7, where
z
$
←− U(l+1). By using Lemma 1, the challenge ciphertext
(c∗0, c
∗
1, c
∗
2) in Game 8 is computationally indistinguishable
from the challenge ciphertext (c∗0, c
∗
1, c
∗
2) in Game 7. So,
we have that |Pr[R8]− Pr[R7]| ≤ negl(n).
Lemma 14: |Pr[R8]− 1
2 ]| = 0.
Proof: Note that the challenge ciphertext (c∗0, c
∗
1, c
∗
2) and
k∗1 in Game 8 perfectly hide the information of s. The key k∗1
is perfectly indistinguishable from k∗0 in view of the adversary
A.
In all, we prove that our KEM is IND-CCA secure by
using Lemma 6 - Lemma 14. In other words, we have that
Advind−ccaKEM ,A (1k ) = |Pr[R0]− 1
2 ]| ≤ negl(n).
TABLE 2. Assumption of schemes.
V. COMPARISONS
In this section, we provide some comparisons with several
schemes in two tables. In Table 2, the schemes CRYSTALS-
Kyber, Classic McEliece, SABER, NTRU-HRSS-KEM,
FrodoKEM [18], MP [23] and NewHope [35] are based on
lattices, while the schemes DMN [10], KMP [32] andYZ [13]
are based on LPNs. The underlying assumption of PW [29] is
DDH or LWE. In addition, as KEM can be simply regarded
as the PKE scheme encrypting a random, we implement our
IND-CCA secureKEM scheme from theVLPN, and compare
several CCA secure PKE schemes (i.e., DMN [10], KMP [32]
and YZ [13]) in Table 3.
We provide specific parameters for our KEM based
on the VLPN assumption. We assume that the decisional
(n, µ)-VLPN problem can be solved in time about 24µn
and our KEM (from matrix version VLPN) has security
(2n + m + 1) · 24µn+1. Let n = 11449, c = 1
16 , µ =
0.00234, ourKEM achieves about 128-bit security.We show
the sizes of the public key, secret key and ciphertext with
several IND-CCA secure PKE schemes and our KEM in
Table 3. Our KEM is more efficient than DMN [10], KMP
[32] and YZ [13] in terms of key sizes and ciphertext over-
head on 128-bit security. Compared with CRYSTALS-Kyber,
NTRU-HRSS-KEM and FrodoKEM [18], the sizes of key
and ciphertext of our scheme have no advantage. However,
these lattice-based schemes involve operations over GF(q).
In contrast, our scheme only involves operations over GF(2),
which has an obvious advantage when implemented using
hardware.
TABLE 3. Specific parameters on 128-bit security.
VI. CONCLUSION AND FUTURE WORK
In this work, by using double-trapdoor technique and a target
collision resistant hash function, we directly construct the
first IND-CCA secure KEM scheme from the low-noise LPN.
For the sizes of public key, secret key and ciphertext, our
scheme is more efficient than DMN [10], KMP [32] and
YZ [13]. Compared with CRYSTALS-Kyber, NTRU-HRSS-
KEM and FrodoKEM [18], the sizes of key and ciphertext of
our scheme (based on low-noise LPN) have no advantage. It is
future work to improve the efficiency of the scheme (based on
Ring-LPN).
VOLUME 9, 2021 13689
S. Xu, X. Li: Chosen-Ciphertext Secure Key Encapsulation Mechanism in the Standard Model
REFERENCES
[1] A. Blum,M. Furst, M. Kearns, and R. J. Lipton, ‘‘Cryptographic primitives
based on hard learning problems,’’ in Advances in Cryptology—CRYPTO.
Berlin, Germany: Springer, 1994, pp. 278–291.
[2] J. Katz and J. S. Shin, ‘‘Parallel and concurrent security of the hb and hb +
protocols,’’ in Advances in Cryptology—EUROCRYPT. Berlin, Germany:
Springer, 2006, pp. 73–87.
[3] B. Applebaum, Y. Ishai, and E. Kushilevitz, ‘‘Cryptography with constant
input locality,’’ J. Cryptol., vol. 22, no. 4, pp. 429–469, Oct. 2009, doi:
10.1007/s00145-009-9039-0.
[4] J. Stern, ‘‘A method for finding codewords of small weight,’’ in Coding
Theory and Applications. Berlin, Germany: Springer, 1989, pp. 106–113.
[5] G. Valiant, ‘‘Finding correlations in subquadratic time, with applications
to learning parities and juntas,’’ in Proc. IEEE 53rd Annu. Symp. Found.
Comput. Sci., Oct. 2012, pp. 11–20.
[6] A. Blum, A. Kalai, and H. Wasserman, ‘‘Noise-tolerant learning, the
parity problem, and the statistical query model,’’ J. ACM, vol. 50, no. 4,
pp. 506–519, Jul. 2003, doi: 10.1145/792538.792543.
[7] A. Jain, S. Krenn, K. Pietrzak, and A. Tentes, ‘‘Commitments and efficient
zero-knowledge proofs from learning parity with noise,’’ in Advances in
Cryptology—ASIACRYPT. Berlin, Germany: Springer, 2012, pp. 663–680.
[8] A. Juels and S. A. Weis, ‘‘Authenticating pervasive devices with human
protocols,’’ in Proc. Annu. Int. Cryptol. Conf. in Lecture Notes in Com-
puter Science, vol. 3621, Santa Barbara, CA, USA: Springer, Aug. 2005,
pp. 293–308, doi: 10.1007/11535218_18.
[9] E. Berlekamp, R. McEliece, and H. van Tilborg, ‘‘On the inherent
intractability of certain coding problems (Corresp.),’’ IEEE Trans. Inf.
Theory, vol. 24, no. 3, pp. 384–386, May 1978.
[10] N. Döttling, J.Müller-Quade, andA. C. A. Nascimento, ‘‘IND-CCA secure
cryptography based on a variant of the LPN problem,’’ in Advances in
Cryptology—ASIACRYPT. Berlin, Germany: Springer, 2012, pp. 485–503.
[11] H. Cheng, X. Li, H. Qian, and D. Yan, ‘‘Simpler CCA secure PKE from
LPN problem without double-trapdoor,’’ in nformation and Communica-
tions Security. Cham, Switzerland: Springer, 2018, pp. 756–766.
[12] E. Levieil and P. Fouque, ‘‘An improved LPN algorithm,’’ in Proc. Int.
Conf. Secur. Cryptogr. Netw. in Lecture Notes in Computer Science,
vol. 4116. Maiori, Italy: Springer, Sep. 2006, pp. 348–359, doi: 10.1007/
11832072_24.
[13] Y. Yu and J. Zhang, ‘‘Cryptography with auxiliary input and trapdoor
from constant-noise LPN,’’ in Advances in Cryptology—CRYPTO. Berlin,
Germany: Springer, 2016, pp. 214–243.
[14] V. Lyubashevsky, ‘‘The parity problem in the presence of noise, decoding
random linear codes, and the subset sum problem,’’ in Proc. Int. Work-
shop Approximation Algorithms Combinat. Optim. in Lecture Notes in
Computer Science, vol. 3624. Berkeley, CA, USA: Springer, Aug. 2005,
pp. 378–389, doi: 10.1007/11538462_32.
[15] A. Becker, A. Joux, A. May, and A. Meurer, ‘‘Decoding random binary
linear codes in 2n/20: How 1 + 1 = 0 improves information set decoding,’’
in Advances in Cryptology—EUROCRYPT. Berlin, Germany: Springer,
2012, pp. 520–536.
[16] D. J. Bernstein, T. Lange, and C. Peters, ‘‘Smaller decoding exponents:
Ball-collision decoding,’’ in Proc. Annu. Cryptol. Conf. in Lecture Notes
in Computer Science, vol. 6841. Santa Barbara, CA, USA: Springer,
Aug. 2011, pp. 743–760, doi: 10.1007/978-3-642-22792-9_42.
[17] P. Kirchner, ‘‘Improved generalized birthday attack,’’ IACR Cryptol.
ePrint Arch., vol. 2011, no. 2011/377, p. 377, 2011. [Online]. Available:
http://eprint.iacr.org/2011/377
[18] NIST. (2017). National Institute for Standards and Technology. [Online].
Available: https://csrc.nist.gov/projects/post-quantum-cryptography/
round-1-submis%sions
[19] E. Fujisaki and T. Okamoto, ‘‘Secure integration of asymmetric and sym-
metric encryption schemes,’’ in Proc. 19th Annu. Int. Cryptol. Conf. in
Lecture Notes in Computer Science, vol. 1666. Santa Barbara, CA, USA:
Springer, Aug. 1999, pp. 537–554, doi: 10.1007/3-540-48405-1_34.
[20] D. Hofheinz, K. Hövelmanns, and E. Kiltz, ‘‘A modular analysis of the
Fujisaki-Okamoto transformation,’’ in Proc. Theory Cryptogr. Conf. in
Lecture Notes in Computer Science, vol. 10677. Baltimore, MD, USA:
Springer, Nov. 2017, pp. 341–371, doi: 10.1007/978-3-319-70500-2_12.
[21] E. E. Targhi and D. Unruh, ‘‘Post-quantum security of the Fujisaki-
Okamoto and OAEP transforms,’’ in Proc. Theory Cryptogr. Conf. in
Lecture Notes in Computer Science, vol. 9986. Beijing, China: Springer,
Oct. 2016, pp. 192–216, doi: 10.1007/978-3-662-53644-5_8.
[22] H. Cheng, X. Li, H. Qian, and D. Yan, ‘‘CCA secure multi-recipient
KEM from LPN,’’ in Proc. Int. Conf. Inf. Commun. Secur. in Lecture
Notes in Computer Science, vol. 11149. Lille, France: Springer, Oct. 2018,
pp. 513–529, doi: 10.1007/978-3-030-01950-1_30.
[23] D. Micciancio and C. Peikert, ‘‘Trapdoors for lattices: Simpler, tighter,
faster, smaller,’’ in Proc. 31st Annu. Int. Conf. Theory Appl. Cryp-
tograph. Techn. in Lecture Notes in Computer Science, vol. 7237,
D. Pointcheval and T. Johansson, Eds. Cambridge, U.K.: Springer,
Aug. 2012, pp. 700–718, doi: 10.1007/978-3-642-29011-4_41.
[24] D. Boneh, R. Canetti, S. Halevi, and J. Katz, ‘‘Chosen-Ciphertext secu-
rity from identity-based encryption,’’ SIAM J. Comput., vol. 36, no. 5,
pp. 1301–1328, Jan. 2007, doi: 10.1137/S009753970544713X.
[25] R. Canetti, S. Halevi, and J. Katz, ‘‘Chosen-ciphertext security from
identity-based encryption,’’ in Proc. Int. Conf. Theory Appl. Cryptograph.
Techn. Berlin, Germany: Springer, 2004, pp. 207–222.
[26] H. Jiang, Z. Zhang, L. Chen, H. Wang, and Z. Ma, ‘‘IND-CCA-secure key
encapsulation mechanism in the quantum random oracle model, revisited,’’
in Proc. 38th Annu. Int. Cryptol. Conf. in Lecture Notes in Computer
Science, vol. 10993. Santa Barbara, CA, USA: Springer, Aug. 2018,
pp. 96–125, doi: 10.1007/978-3-319-96878-0_4.
[27] S. H. Park, S. Kim, D. H. Lee, and J. H. Park, ‘‘Improved ring LWR-based
key encapsulation mechanism using cyclotomic trinomials,’’ IEEE Access,
vol. 8, pp. 112585–112597, 2020, doi: 10.1109/ACCESS.2020.3002223.
[28] D. Dolev, C. Dwork, and M. Naor, ‘‘Nonmalleable cryptography,’’
SIAM J. Comput., vol. 30, no. 2, pp. 391–437, Jan. 2000, doi: 10.1137/
S0097539795291562.
[29] C. Peikert and B. Waters, ‘‘Lossy trapdoor functions and their applica-
tions,’’ in Proc. 14th Annu. ACM Symp. Theory Comput. - STOC, 2008,
pp. 187–196, doi: 10.1145/1374376.1374406.
[30] S. Park, ‘‘How practical is public-key encryption based on LPN and ring-
LPN,’’ Cryptol. ePrint Arch., Tech. Rep. 2012/699, 2012.
[31] E. Kiltz, ‘‘Chosen-ciphertext secure key-encapsulation based on gap
hashed diffie-hellman,’’ in Proc. 10th Int. Conf. Pract. Theory Public-Key
Cryptogr. in Lecture Notes in Computer Science, vol. 4450. Beijing, China:
Springer, Aug. 2007, pp. 282–297, doi: 10.1007/978-3-540-71677-8_19.
[32] E. Kiltz, D. Masny, and K. Pietrzak, ‘‘Simple chosen-ciphertext secu-
rity from low-noise LPN,’’ in Public-Key Cryptography—PKC. Berlin,
Germany: Springer, 2014, pp. 1–18.
[33] D. Micciancio and P. Mol, ‘‘Pseudorandom knapsacks and the sample
complexity of LWE search-to-decision reductions,’’ in Proc. 31st Annu.
Cryptol. Conf. in Lecture Notes in Computer Science, vol. 6841, P. Rog-
away, Ed. Santa Barbara, CA, USA: Springer, Aug. 2011, pp. 465–484,
doi: 10.1007/978-3-642-22792-9_26.
[34] G. Zemor, ‘‘On expander codes,’’ IEEE Trans. Inf. Theory, vol. 47, no. 2,
pp. 835–837, Nov. 2001, doi: 10.1109/18.910593.
[35] E. Alkim, L. Ducas, T. Pöppelmann, and P. Schwabe, ‘‘Post-
quantum key exchange - A new hope,’’ in Proc. 25th USENIX
Secur. Symp., USENIX Secur., T. Holz and S. Savage, Eds. Austin,
TX, USA: USENIX Association, Aug. 2016, pp. 327–343. [Online].
Available: https://www.usenix.org/conference/usenixsecurity16/technical-
sessions/p%resentation/alkim
SHENGFENG XU is currently pursuing the M.S.
degree with the Department of Computer Science,
East China Normal University, Shanghai, China.
His research interests include post-quantum cryp-
tography and learning parity with noise.
XIANGXUE LI received the Ph.D. degree from
Shanghai Jiao Tong University, in 2006. He was
with the School of Information Security Engineer-
ing, Shanghai Jiao TongUniversity. He is currently
a Professor with the School of Software Engi-
neering, East China Normal University. He has
authored three books and has authored or coau-
thored more than 70 articles. His research interests
include lightweight protocol design, anonymity,
and pseudorandom sequence.
13690 VOLUME 9, 2021
http://dx.doi.org/10.1007/s00145-009-9039-0
http://dx.doi.org/10.1145/792538.792543
http://dx.doi.org/10.1007/11535218_18
http://dx.doi.org/10.1007/11832072_24
http://dx.doi.org/10.1007/11832072_24
http://dx.doi.org/10.1007/11538462_32
http://dx.doi.org/10.1007/978-3-642-22792-9_42
http://dx.doi.org/10.1007/3-540-48405-1_34
http://dx.doi.org/10.1007/978-3-319-70500-2_12
http://dx.doi.org/10.1007/978-3-662-53644-5_8
http://dx.doi.org/10.1007/978-3-030-01950-1_30
http://dx.doi.org/10.1007/978-3-642-29011-4_41
http://dx.doi.org/10.1137/S009753970544713X
http://dx.doi.org/10.1007/978-3-319-96878-0_4
http://dx.doi.org/10.1109/ACCESS.2020.3002223
http://dx.doi.org/10.1137/S0097539795291562
http://dx.doi.org/10.1137/S0097539795291562
http://dx.doi.org/10.1145/1374376.1374406
http://dx.doi.org/10.1007/978-3-540-71677-8_19
http://dx.doi.org/10.1007/978-3-642-22792-9_26
http://dx.doi.org/10.1109/18.910593