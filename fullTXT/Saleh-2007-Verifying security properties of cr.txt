Verifying Security Properties of Cryptoprotocols: A Novel Approach
Mohamed Saleh Mourad Debbabi
Concordia Institute for Information Systems Engineering
Concordia University
Montreal, Quebec, Canada
{m saleh, debbabi}@ ciise.concordia.ca
Abstract
We model security protocols as a game tree using con-
cepts of game semantics. Using this model we ascribe se-
mantics to protocols written in the standard simple arrow
notation. According to the semantics, a protocol is inter-
preted as a set of strategies over a game tree that represents
the type of the protocol. Moreover, in order to specify prop-
erties of the model, a logic that deals with games and strate-
gies is developed. A tableau-based proof system is given for
the logic, which can serve as a basis for a model check-
ing algorithm. This approach allows us to model a wide
range of security protocol types and verify different prop-
erties instead of using a variety of methods as is currently
the practice. Furthermore, the analyzed protocols are spec-
ified using only the simple arrow notation heavily used by
protocol designers and by practitioners.
1. Introduction
Cryptoprotocols are a special type of communication
protocols, they are used whenever the communicating
agents (also called principals) would like to achieve a cer-
tain security-related objective. A basic assumption about
cryptoprotocols is the presence of a malicious intruder that
will use all its capabilities in order to break the protocol se-
curity. A protocol is said to be secure if it satisfies certain
security properties. Examples of security properties are [1]:
Secrecy, authentication, integrity, non-repudiation, fairness,
money atomicity, and good atomicity. The problem of as-
suring that a certain protocol design actually satisfies its in-
tended security property (or properties) is by no means triv-
ial or easy. Formal specification, modeling and verification
methods have been extensively used to tackle this problem.
Techniques from logic [13], process calculi [4], rewrite sys-
tems [14], model checking [15], and theorem proving [24]
have been developed in order to verify security properties.
The work most related to this paper is the one using
algebraic symbolic modeling and analysis of cryptoproto-
cols. Several research efforts exist in this direction and we
can cite [12] that contains an excellent overview and links
to many references. We can break down the basic ideas
into modeling and analysis. The modeling part involves
the modeling of exchanged messages (the data), the mod-
eling of computation and communication operations (the
algorithms) and finally a model of the intruder. The anal-
ysis part is concerned with the development of verification
techniques which can ensure that the required security prop-
erties are satisfied. Messages are modeled as terms of a
term algebra having a signature Σ. Computation and com-
munication operations done on messages by honest agents
are expressed by modeling agents as processes running in
parallel while sending and receiving messages to/from the
environment. In this approach, a number of process calculi
have been used in the literature, e.g., [4] and [3]. There exist
several variations of this framework such as modeling mes-
sage computations by rewrite rules [14] or using the idea of
strand spaces [19]. The model used for the intruder is in
most cases that of Dolev Yao [18], which basically means
that the intruder has total control over the environment and
can block, create, send and receive messages. However, the
computational capabilities of the intruder are limited to for-
mal algebraic operations, i.e, the intruder does not perform
cryptanalysis. Lately however, and in the direction of in-
creasing the intruder powers, research efforts [2], [5] [10],
and [17] investigated the idea of enriching the algebra of
messages with an equational theory. This means the in-
truder would be capable of doing some sort of cryptanaly-
sis. Concerning verification, several techniques are used for
specifying security properties and verify them under some
assumptions, the two most important of which are the bound
on the number of protocol sessions and the bound on mes-
sage size [12]. Several decidability results for verification
have been published under various versions of these two as-
sumptions [17].
In this paper we introduce a new model for crytpoproto-
cols based on game semantics. A protocol is viewed as a
Fifth IEEE International Conference on Software Engineering and Formal Methods
0-7695-2884-8/07 $25.00 © 2007 IEEE
DOI 10.1109/SEFM.2007.34
349
Fifth IEEE International Conference on Software Engineering and Formal Methods
0-7695-2884-8/07 $25.00 © 2007 IEEE
DOI 10.1109/SEFM.2007.34
349
Fifth IEEE International Conference on Software Engineering and Formal Methods
0-7695-2884-8/07 $25.00 © 2007 IEEE
DOI 10.1109/SEFM.2007.34
357
Fifth IEEE International Conference on Software Engineering and Formal Methods
0-7695-2884-8/07 $25.00 © 2007 IEEE
DOI 10.1109/SEFM.2007.34
349
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:46:01 UTC from IEEE Xplore.  Restrictions apply. 
game between honest agents and the intruder. Interleaved
runs of the protocol form a game tree. Moves of the de-
fined games are protocol messages which are constructed
as terms of a term algebra with signature Σ. Moreover,
the algebra is equipped with an equational theory E to en-
rich the analysis by inducing equivalences between terms.
Computation steps of the protocol are expressed as abstract
computations [25] based on Σ. We find that this simplifies
the model as opposed to using a process calculus. Commu-
nication steps are modeled implicitly via the interaction in
each game between the intruder and an honest agent. In our
model, the intruder has total control over the network and
can block, create, send and receive messages. We provide
rules for the intruder knowledge that make use of the equa-
tional theory defined over the message algebra. To verify
the model, a logic is defined based on the ideas from [8]
and [9] in order to specify security properties over the game
tree. Semantics of the logic is defined in terms of game
strategies as opposed to simple traces, and a tableau-based
proof system is provided. Our contribution can be summa-
rized in the following:
• We can express malicious behavior of the intruder in
addition to dishonest behavior of agents who do not
follow protocol rules. The latter situation is used in
the analysis of fair exchange protocols.
• Our model is built directly from the standard arrow no-
tation commonly used in specifying protocols. Also
we ascribe formal semantics to such a notation.
• Reasoning in terms of game strategies allows us to
specify a wide range of properties such as secrecy, au-
thentication, fairness, etc. using a unified approach.
This paper contains five sections starting with the intro-
duction. In Section 2, we introduce game semantics and
some basic concepts. Section 3 contains the definitions of
our protocol games. In Section 4, we introduce our logic
and present its semantics. Finally, Section 5 concludes the
paper.
2 Basic Concepts
2.1 Game Semantics
The idea of using games in logic specifications dates
back to Lorenzen [23] who viewed a logic proposition as a
game between two players one trying to assert it (the propo-
nent) and the other trying to attack it (the opponent). Further
development was done by Andeas Blass [11], who used it to
give semantics to linear logic. Game semantics [7] and [20]
is an approach to the semantics of programming languages
that makes explicit the interaction with the environment in
each computation step. This interaction is modeled by a
game in which the players are the environment (the oppo-
nent) and the system (the proponent). Any computational
step done by the system can be modeled by a possible se-
quence of moves over the game that describes the system.
Here, we make the distinction between the program type
(e.g. function signature) and the algorithm (e.g. function
definition) this program implements. A program of a certain
type is modeled by a certain game, whereas the algorithm
specifies the rules according to which the game should be
played. So, any particular run of the program (execution of
the algorithm) represents a ceratin sequence of moves over
the game that describes the program. In this case, the game-
semantics specification of the program is the set of all such
sequences. In game semantics, each move takes the form
of a question Q or an answer A. For instance, the environ-
ment can ask for a value (question), and the system sup-
plies this value (answer) directly, or asks the environment
for more detail (question), and so on. We adopt the con-
vention that the opponent always makes the first move then
the game proceeds as alternating moves between player and
opponent. Formally a game G is a structure (MG, λG, PG)
where [6]:
MG Set of game moves
λG : MG → {P,O} × {Q,A} Labeling function signature
λG = 〈λPOG , λQAG Labeling function definition
λPOG : MG → {P,O} Labeling proponent/opponent moves
λQAG : MG → {Q,A} Labeling question/answer moves
PG ⊆nepref Malt
G Non-empty, prefix closed set of sequences
(1)
We write M∗
G for the set of finite sequences over MG.
A sequence s = s1.s2 . . . sn has length |s| = n. Then,
Malt
G is a subset of M∗
G containing sequences s such that
for even i, λPOG (si) = P , and for odd i, λPOG (si) = O. The
domain PG (the game tree) is a set of sequences, each of
these sequences represents a path in the game tree. The do-
mains P evenG and P oddG are the sets of even- and odd- length
sequences respectively. For any two sequences s and t, s
is called a prefix of t if t = s.u where u is any sequence,
len(s) is a natural number that indicates the length (number
of moves) of s and , by function overloading, pref(s, i) is
the sequence t such that t is a prefix of s and len(t) = i.
For a set of sequences PG, Pref(PG) = {pref(s, i) | s ∈
PG ∧i ≤ len(s)}. A set of sequences is prefix closed when
Pref(PG) = PG. A deterministic strategy σ on a game G
is a subset σ ⊆ P evenG satisfying: ε ∈ σ, sab ∈ σ ⇒ s ∈ σ,
and sab ∈ σ ∧ sac ∈ σ ⇒ b = c. Here s, t, u, . . . repre-
sent sequences, and a, b, c, . . . represent single moves. In-
tuitively, a strategy is a set of even-length paths of the game
tree that represent a certain “plan” P follows in response to
O’s moves.
For any two setsX and Y , let the set Z = X�Y be their
disjoint union. If the sequence s ∈ Z∗, then s � X ∈ X∗,
which means s � X is the sequence obtained by removing
all the elements not in X from s. For any two games G
and H , the tensor product G ⊗ H defines a game whose
350350358350
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:46:01 UTC from IEEE Xplore.  Restrictions apply. 
set of moves is MG⊗H = MG � MH , the labeling func-
tion is then defined to be λG⊗H = [λG, λH ]. The game
tree is: PG⊗H = {s ∈ Malt
G⊗H | (s � MG ∈ PG) ∧ (s �
MH ∈ PH)}. As previously mentioned, all games start by
O making a move. Here O can decide to make a move in
G or H . The way the tensor product is defined enforces
the rule that for any two consecutive moves si and si+1 if
si+1 is a move of a subgame different than that of si, then
λPOG⊗H(si) = P and λPOG⊗H(si+1) = O. This is called the
switching condition [6]. For any game G, its dual G⊥ is
obtained by interchanging the roles of the two players (P
and O). The set of moves remains the same for both games,
just the labeling function is changed, i.e., moves of O be-
come those of P and vice versa. For any two games G and
H , the game G � H is defined as G⊥ ⊗ H . In this case,
the first move (by O) will always be in H . The switching
condition in G � H states that for any two consecutive
moves si and si+1 if si+1 is a move of a subgame different
than that of si, then λPOG⊗H(si) = O and λPOG⊗H(si+1) = P
[6]. An enabling relation is defined over the set MG ∪ {�}.
The enabling relation means that a move cannot be played
unless it was enabled (justified) by another move. The first
move in the game is justified by �. The enabling relation:
m �G m′ means that m′ cannot be played unless m was
played first. It is important to note that this relation is not
transitive.
2.2 Protocols
A cryptoprotocol specifies a number of steps in which
agents are exchanging messages. The structure of a mes-
sage represents the computations that must be done by the
agent sending the message. Moreover, some messages are
stored in the agent knowledge and are persistent in all proto-
col executions, while other are freshly created by the agent
in each protocol run such as nonces. Taking these facts
into account, the syntax we use to specify protocols con-
sists mainly of two parts: Declaration, and communication
as shown in the table below:
Prot ::= Decl . Comm | ε
Decl ::= κA � m .Decl | νA � m .Decl | ε
Comm ::= step i � A→ B : m . Comm | ε
Here A,B are communicating agents, m is a certain
message, κA � m means m is part of the initial persistent
knowledge ofA, and νA�mmeansm is freshly produced by
A for a certain protocol session. As for step i�A→ B : m,
it means that message m is sent by agent A and is intended
to be received by agent B. Structures of messages are pre-
sented in the next section.
2.3 Messages
Given a signature Σ of operation symbols, we denote by
TΣ and TΣ(X) the sets of ground terms and terms with vari-
ables over Σ. The set M of messages is a proper subset of
TΣ and is defined by a grammar, all operation symbols (of
arity one or higher) in this grammar are called constructors.
An example is shown below:
Constants (names) include agent names, keys, and text
Constructors: {< , >, { } }
Destructors: {fst( ), snd( ), dec( , )}
Messages m ::= a | c | k | < m,m > | {m}k
In the example above, constructors represent the pair-
ing and encryption operations. Destructors represent pro-
jection operations to obtain the first and second elements
of a pair and the decryption operation. Valid messages are
given by the BNF grammar shown in the example, where
a represents agent names, c represents constant (text) mes-
sages, and k represents cryptographic keys. All previous
messages are called atomic. The term < m,m > repre-
sents concatenated messages and {m}k denotes encrypted
messages, where k is the encryption key. We equip the alge-
bra of messages with an equational theory E that is chosen
according to the specific properties of the protocol and its
underlying cryptosystem. In this case, the congruence in-
duced by the equational theory is used to define equivalence
classes between messages. We write m =E n to say that m
is congruent to n under the equational theory E. We focus
our attention to equational theories for which there exists
a convergent (complete) term rewriting system. For these
systems, each term has a unique normal form. Therefore,
the problem of determining whether m =E n for any two
closed terms m and n is decidable by rewriting both m and
n and checking if they have the same normal form. As an
example, in the Dolev Yao model, E will contain:
dec({x}y, y) = x fst(< x, y >) = x
snd(< x, y >) = y
2.4 Frames and Computation
During one session of a protocol, an agent A receives
a number of messages, we follow [3] and [2], with differ-
ent interpretation, and organize these messages into a frame
νC � θf , where C is a set of names (constants), ν binds the
names in C to the frame, and θf is a partial mapping from
a finite set {0, . . . , n} to sets of messages. The number of
messages received by A in one protocol session is n since
θf (0) is the set containing atomic messages that are initially
known to A and θf (i), 0 < i ≤ n is the set containing the
message expected by A at step i of the protocol. A frame
encapsulates three pieces of information: The new names
in C which are created in a protocol session such as nonces,
351351359351
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:46:01 UTC from IEEE Xplore.  Restrictions apply. 
the order in which the messages is received, and the struc-
ture of each message. We define a function φ (of type Frm)
that maps agents names to frames, φ(A) is the frame of mes-
sages received by agent A. For a frame φ(A) = νC � θf ,
the function size(φ(A)) is defined to be |dom(θf )|; the car-
dinality of the domain of the substitution, moreover for any
0 < i ≤ size(φ(A)), trunc(φ(A), i), i ∈ dom(θf ) is the
new frame obtained by restricting the domain of θf to the
set {0, . . . , i}, i.e., it is the frame ofA just after the i-th step
of the protocol. The function frame that parses the protocol
and constructs the frame is defined below:
frame : Prot→ Frm → Frm
frame[[ νA � m.D.C ]](φ) = frame[[ D.C ]](φ † [A �→ νC ∪m � θf ])
frame[[ κA � m.D.C ]](φ) =
frame[[ D.C ]](φ † [A �→ νC � θf [0 �→ θf (0) ∪ {m}]])
frame[[ ε.C ]](φ) = frame[[ C ]](φ)
frame[[ step i � B → A : m.C ]](φ) =
frame[[ C ]](φ † [A �→ νC � θf [i �→ m]])
frame[[ ε ]](φ) = φ
Intuitively, the frame φ(A) = νC � θf is constructed as fol-
lows:(1) The set of all fresh names for an agent A is added
to C, (2) all atomic terms that are initially known to agent
A are added to the set θf (0), and (3) for each message mi
received at step i of the protocol run, θf is augmented by
the mapping i 
→ mi. To simplify the notation, the message
received by an agent A at step k of the protocol is denoted
by rA(k), i.e., ∀k > 0 � rA(k) ∈ θf (k). A term m ∈ TΣ is
deducible by agent A from a frame φ(A) = νC �θf , written
φ(A) � m, if it can be obtained by the application of one or
more of the following rules:
(rcv)
φ(A) � m ∃i ∈ dom(θf ) �m ∈ θf (i)
(new)
φ(A) � m m ∈ C
(apl)
φ(A) � m1 . . . φ(A) � mn
φ(A) � f(m1, . . .mn)
(eqn)
φ(A) � m m =E m′
φ(A) � m′
We define the set deduce(φ(A)) = {m ∈ M | φ(A) �
m}, this definition is necessary to avoid terms that
are not messages, e.g., fst({m}k). Moreover, the set
deduce(φ(A)) can be expressed as
⋃
d≥0 deduced(φ(A)),
where:
deduce0(φ(A)) =
�
i∈dom(θf ) θf (i) ∪ C
deduced+1(φ(A)) = deduced(φ(A)) ∪ X
d+1
apl ∪ X
d+1
eqn
X
d+1
apl = {m= f(t1, . . . , tn) | f ∈ Σ∧
t1, . . . , tn ∈ deduced(φ(A))}
X
d+1
eqn = {m =E m′ |m′ ∈ deduced(φ(A)}
In the two equations above, deduced+1(φ(A)) is ob-
tained by application of the rules (apl) and (eqn) to the
messages in deduced(φ(A)). Given a frame φ(A) = νC�θf
that belongs to a certain agent A, and a message mj that
this agent is supposed to send at a certain communication
step j, we would like to find the abstract computation pro-
cedure that should be followed to get mj , we call this pro-
cedure out(φ(A), j). In other words, out(φ(A), j) is the
algorithm followed by agent A, having a frame φ(A) in
order to compute the message mj that he is supposed to
send at step j of the protocol, i.e., according to protocol
specification. We define below an algorithm Proc such that
out(φ(A), j) = Proc(φ(A),m, d), where m is the message
mj such that m ∈ deduced(φ(A)):
Proc(φ(A),m, d)
case m ∈ Xdapl ⇒
f(Proc(φ(A), t1, d− 1), . . . ,Proc(φ(A), tn, d− 1))
m=f(t1, . . . , tn)
case m ∈ Xdeqn ⇒
Proc(φ(A),m′, d− 1)
m′ =E m
case m ∈ deduced−1(φ(A)) ⇒
Proc(φ(A),m, d− 1)
Proc(φ(A),m, 0)
case m = n, n ∈ θf (0) ⇒ n
case m ∈ θf (k), k > 0 ⇒ rA(k)
case m = c, c ∈ C ⇒ c
We say that the algorithm out(φ(A), j) is feasible if
¬∃i ≥ j � θf (i) � out(φ(A), j), where � is the sub-
term relation defined over TΣ(X), i.e., x � y if x = y
or y = f(t1, . . . tn) ∧ ∃i � x � ti. In other words, the algo-
rithm is feasible if it constructs the message that is supposed
to be sent byA at step j of the protocol using only the initial
knowledge of A and the messages received by A up to step
j. This condition of feasibility is one simple and prelimi-
nary check on the correctness of protocol specification. As
an example, consider the Shamir Rivest Adelman three pass
protocol [21]: A → B : {m}KA
, B → A : {{m}KA
}KB
,
A → B : {m}KB
. This protocol uses the commutative
property of RSA encryption. It is assumed that A and B
share no information about their keys. The signature Σ
contains the constants m, KA, and KB , and the operations
{ } , dec( , ) and ( )−1 representing encryption, decryp-
tion and key inverses, respectively. We add the equations
that: {{x}y}z = {{x}z}y and dec({x}y, y−1) = x. In this
case, φ(A) = ν{m} � {0 
→ {KA}, 2 
→ {{{m}KA
}KB
}},
we can deduce the following:
deduce0(φ(A)) = {m,KA, {{m}KA
}KB
}
deduce1(φ(A)) = deduce0(φ(A))∪
{K−1
A , dec({{m}KA
}KB
,KA)} ∪ {{{m}KB
}KA
}
deduce2(φ(A)) = deduce1(φ(A))∪
{dec({{m}KB
}KA
,K−1
A )} ∪ {. . .}
deduce3(φ(A)) = deduce2(φ(A)) ∪ {. . .} ∪ {{m}KB
}
Now we want to know how agent A is able to construct
the message he is sending in step j = 3 as a function from
the knowledge he gathered thus far. In other words we want
to get out(φ(A), 3) since the message sent by A at step 3 is
{m}KB
, and {m}KB
∈ deduce3(φ(A)), i.e., d = 3, then
out(φ(A), 3) = proc(φ(A), {m}KB
, 3):
proc(φ(A), {m}KB
, 3)
= proc(φ(A), dec({{m}KB
}KA
,K−1
A , 2)
= dec(proc(φ(A), {{m}KB
}KA
, 1), proc(φ(A),K−1
A , 1))
= dec(proc(φ(A), {{m}KA
}KB
, 0), (proc(φ(A),KA, 0))
−1)
= dec(rA(2),K−1
A )
The last line means that in order to obtain the message
that should be sent at step 3 from the frame φ(A), agent
A must decrypt the message he received at step 2 by the
352352360352
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:46:01 UTC from IEEE Xplore.  Restrictions apply. 
inverse of his key KA.
2.4.1 Agents Responses
The intruder’s behavior is considered nondeterministic in
the sense that at any point in time we cannot tell exactly
which message he’s going to send. Honest agents on the
other hand have a deterministic behavior; the message an
agent A sends at any step i is determined by out(φ(A), i),
i.e., the message is dependent on the frame of messages seen
by A and the step number. The frame φ(A) is constructed
based on the protocol specification, we call it a specifica-
tion frame as the underlying assumption is that the proto-
col is executed exactly as specified. This is not the actual
case however, since we assume the presence of an intruder
and/or dishonest agents. The difference between the real
frame ρ(A) = νC � θf and the specification frame φ(A) of
an agent A lies in the substitution θf . Both frames agree at
θf (0) since it contains the initial knowledge. At any other
i > 0, θf (i) of the specification frame is the message spec-
ified to be received by the agent at step i. For an actual
frame however the message θf (i) is the one that was actu-
ally received from the network during the current session
of the protocol execution. This message could have been
manipulated by the intruder. Therefore, the message sent
by an agent A at step i of an actual protocol execution will
be out(ρ(A), i), this message describes the behavior of an
honest agent. A dishonest agent D, however, can send any
message in deduce(ρ(D)), we note here that we used the
actual frame ρ(D).
2.4.2 Intruder Frames
An intruder frame is always an actual frame, where ρ(I) =
νC � θf . In this case, C is a set containing fresh values cre-
ated by the intruder. The substitution θf in this case maps
the set {0, 1, . . . , N} to messages in M, where θf (0) con-
tains a concatenation of all messages initially known to I
such as public keys and θf (i) = m means that m is the ith
received by the intruder. Deduction rules for the intruder
are similar to those defined above for agents, the difference
is that φ(A) should be replaced by ρ(I).
3 Games for Security Protocols
Similar to the discussion above about game semantics
and programs, in order to build the game that represents the
protocol, we have to assign a certain type to the protocol.
This type will determine the game to be played. The specific
syntax of the protocol (protocol steps specifying messages),
on the other hand, will determine how this game should be
played.
3.1 Definition of Protocol Games
When defining games for security protocols, each move
m in the game represents a message sent from a principal
to the other. As mentioned earlier the set of messages is
M ⊂ TΣ. The generation of a single message by an honest
principal is represented as a strategy over the game Msg
which is defined as follows:
MMsg = {q} ∪ M
λ(q) = OQ
λ(m) = PA ∀m ∈ M
PMsg = {q.m |m ∈ M}
� � q
q � m ∀m ∈ M
Here, we assumed that any m ∈ M can be played at any
time. This is not an accurate assumption, as any principal in
the protocol can play only those messages m that they are
able to construct, i.e., ρ(A) � m. A single communication
step, on the other hand, is represented by a strategy over the
game Csg = Msg � Msg. The formal definition of the
game is given hereafter:
MCsg = {q1} ∪ {q2} ∪ {mi | m ∈ M, i ∈ {1, 2}}
λCsg(q
i) =
�
PQ i = 1
OQ i = 2
λCsg(m
i) =
�
OA ∀m ∈ M ∧ i = 1
PA ∀m ∈ M ∧ i = 2
The following enabling relation is defined over MCsg:
� �Csg q2
q2 �Csg q1
q1 �Csg m1 ∀m ∈ M
m1 �Csg n2 ∀m,n ∈ M
(2)
We notice here that we used a superscript to differentiate
between moves in each game, since the set of moves is
the disjoint union of the sets of the individual games. We
used the superscript 1 to denote moves of the game to the
left of �, and the superscript 2 for the other game. This
is equivalent to denoting the games as Msg1 � Msg2.
The definition of the enabling relation in (2) makes sure
that n2 cannot be played unless m1 is played first (any se-
quence in the game tree will be the prefix of a sequence
in the form q2.q1.m1.n2). This results from the fact that
we assumed that in any communication step (Csg game)
an agent (the proponent) only sends a message in response
to a message that they received from the intruder (the op-
ponent). We clarify these ideas by taking as example the
first three steps of the Woo and Lam authentication proto-
col [26]: Step1. A → B : A, Step2. B → A : Nb, Step3.
A → B : {Nb}Kas
. Examining Step 1, we notice that
A initiates the protocol. Since, in game semantics, O (the
channel) always plays first, we assume A gets a start mes-
sage “start” from the channel and replies with his identity
A. The “start” message serves as an action to begin the ex-
ecution of the protocol. In Step 2, B receives the message
A from the channel and replies with a nonce Nb, and other
steps follow. We rewrite the first three steps as:
Step1. I → A : start
A→ I : A
Step2. I → B : A
B → I : Nb
Step3. I → A : Nb
A→ I : {Nb}Kas
353353361353
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:46:01 UTC from IEEE Xplore.  Restrictions apply. 
The protocol description above makes clear the role of
the intruder I . Each communication step has the form:
I → X : mi followed by X → I : mj where X is
an honest agent. To respect the notation, a protocol will
always end by an agent X sending a terminate message
to the intruder. The terminate message marks the end of
the execution of one protocol session. Expressed this way,
each communication step can be captured as a strategy σ
over the game Csg. The execution of a number of steps
in succession can be represented by a strategy over the ten-
sor product of a number of Csg games. As an example,
Step1 and Step2 are represented as a strategy over the game
(Msg11 � Msg12) ⊗ (Msg21 � Msg22). This strategy
is the sequence q12.q11.start11.A12.q22.q21.A21.N22
b . In
the case of multiple sessions of a protocol, the game Spr is
defined as:
Spr[N]
def
= Csg1,1 . . .⊗ Csg1,N ⊗ Csg2,1 . . .⊗ Csg2,N . . . (3)
Here Csgi,j is the game representing communication
step i in session j, where N is the maximum number of
sessions. The enabling relation defined for Spr[N] contains
eight conditions for moves. The first condition states that
the play begins in Session 1 in any step where an agent ex-
pects to receive his first message in the protocol. Notice
that the first move of this step has to be a question by the
opponent (i.e., q1,t2). Once the game has started in a step in
a certain session, and the intruder has received a message
in this step (mj−1,i2), he can start the play in any step in
the next session (qj,i
′2) provided this is also the first step
in the interaction with a certain agent. This is stated by
the second condition. The third condition is special for the
start message, i.e., the start message is always enabled in
communication step 1 in any session. The fourth condition
states the condition for the termination of one session of
the protocol (i.e., the reception of mj,N1). The fifth, sixth
and seventh rules put a condition on the sequence of moves
in any communication step in a certain session. They sim-
ply state that in any communication step we cannot have
a sequence qj,i2.mj,i2, this sequence means that an agent
sends a message to the intruder without first getting a mes-
sage form the intruder. This is to emphasize the rule that
we established before that each communication step is an
exchange between the intruder and an agent, where the in-
truder has to supply a message in order to get a message
in return. The eighth rule imposes order on the messages
of the intruder in the same session. Basically the intruder
when playing with a certain agent, has to supply messages
in the order that this agent expects. It worth noting that
games defined this way give rise to a category where ob-
jects are games and a morphism between any two games G
and H is a strategy over the game G � H , details can be
found in [6]. Moreover, the game defines above allow us to
ascribe formal semantics to protocol specifications written
in the standard arrow notation. A protocol is interpreted as
a set of strategies over the game Spr[N], where [N] is the
maximum number of sessions. The semantics is given in
the appendix.
3.1.1 Quantification over Strategies
The game Spr represents an interleaving of actions from
different copies if the Csg games. Each Csg game is played
between an agent and the intruder, therefore a strategy over
Spr may involve several agents. The identity of the agent
playing against the intruder in a certain copy of Csg is given
by Id(copy), where copy represents the superscript identi-
fying a specific copy of Csg, e.g., the pair i, j in 3. The set
of all strategies over Spr is denoted SSpr. For any strategy
σ ∈ SSpr and a set A of honest agents identities, we define
σA as:
σA = {s �M | s ∈ σ}
M = {m ∈ Csgcopy | Id(copy) ∈ A}
Intuitively, σA is obtained from σ by eliminating all
moves from any copy of the Csg game whose player P
is not a member of A. The set of all strategies involv-
ing a set A of players is denoted SASpr and is defined as:
SASpr = {σA | σ ∈ SSpr}.
4 Logic for Security Properties
In this section, we present a new logic for the specifi-
cation of security properties. It can be used to specify se-
curity properties that should be satisfied by the game tree
that represents protocol interactions. A tableau-based proof
system is also developed for the verification of such prop-
erties. The logic is based on ideas from [8] and [9]. The
main differences are that in [9], there is no explicit mention
of the intruder, only adversarial behavior between players
is considered. The logic was not specifically designed to
be used for security properties, although its ideas were used
later in [22] to verify non-repudiation protocols. Interaction
between players is not explicitly modeled, i.e., no messages
exchanged between players. This complicates the specifi-
cation of properties based on traces of messages. More-
over, in [8], the model considered is a single trace, verifi-
cation of a protocol amounts to verification of a property
over all traces which limits the analysis. Also, the logic
considers only traces with atomic actions, it cannot spec-
ify a certain structure for the exchanged messages. In our
model, the logic is based on the idea of interaction, where
the game tree is built from possible interactions between
players and intruder. Logic formulas specify properties over
the game tree. Moves of the game are actual messages that
are exchanged in a protocol run. We can therefore spec-
ify properties on the structure of messages, and on traces
354354362354
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:46:01 UTC from IEEE Xplore.  Restrictions apply. 
of messages. We can quantify existentially, universally or
by players strategies, i.e., all traces in which certain players
are interacting. We give examples for a number of security
properties specified in this logic.
4.1 Syntax
Before presenting the syntax of formulas, we present the
concept of a sequence pattern r. A sequence pattern has the
following syntax:
r ::= ε | aj,in.r | xr.r a ::= m | �m� (4)
Here a represents a move in the game and has the form
m or �m�, where i, j ∈ N, n ∈ {1, 2}, andm ∈ TΣ(X), the
free term algebra over Σ. Intuitively, a represents a move
played in a copy of the Msg game , where the message of
this move is eitherm or a term containingm. The term �m�
is defined as m or f(t1, t2, . . . tn) such that ∃ti � ti = �m�.
Here f ∈ Σ is any function symbol in the signature of the
algebra. The variable xr represents a sequence of moves of
zero or any finite length, the subscript r is added to avoid
confusion with variables x of the message algebra. The sets
of variables and moves in r are written var(r) and mov(r)
respectively. Moreover, for any pattern r, the symbol r|i
represents the variable or move at position i of r, where
i ∈ {1, . . . n}.
We define the substitution θr : var(r) → M∗
Msg that
maps variables xr in a sequence pattern to sequences of
moves of the game Msg and the substitution θm : X →
TΣ(X) that maps variables inside messages into terms of
TΣ(X).
We define the predicate satisfy(σ, r, θm, θr), which is
true when a strategy σ in the game tree satisfies a pattern
r. Intuitively, a strategy σ satisfies a pattern r if there is a
sequence s ∈ σ such that s matches r. Formally:
satisfy(σ, r, θm, θr) = ∃s ∈ σ �match(s, r, θm, θr)
The predicate match(s, r, θm, θr), where s =
s1s2 . . . sn is a sequence of moves in the game tree,
is defined as follows:
match(ε, ε, θm, θr) = true
match(s, ε, θm, θr) = false if s = ε
match(s, a.r, θm, θr) = (s1 =E aθm) ∧ match(s2 . . . sn, r, θm, θr)
match(s, xr.r, θm, θr) = ∃j ≤ n � xrθr = s1 . . . sj∧
match(sj+1 . . . sn, r, θm, θr)
A substitution θ : R → M∗
Msg from patterns to se-
quences of moves, where θ = θm∪θr, is defined as follows:
θ(ε) = ε
θ(a.r) = θm(a).θ(r)
θ(xr.r) = θr(xr).θ(r)
We follow the usual notation for substitutions and write
rθ for θ(r), where rθ ∈ {q ∪ TΣ}∗. From the definitions
of the predicate match and the substitution θ above, we no-
tice that the condition for a match between a pattern and a
sequence is the existence of one or more substitutions θ, we
can therefore write the predicates above as satisfy(σ, r, θ)
and match(s, r, θ).
The syntax of a formula φ of our logic is expressed by
the following grammar:
ϕ ::= Z | ¬ϕ | ϕ1 ∧ ϕ2 | [r1 � r2]ϕ | νZ.ϕ | 〈〈A〉〉ϕ (5)
We require the following two syntactic conditions:
• In [r1 � r2], var(r1) = var(r2) and ∀i � (r1|i ∈
var(i) ⇔ r1|i = r2|i) ∧ (r1|i ∈ mov(i) ⇔ r1|i =
r2|i ∨ r2|i = �).
• In νZ.ϕ, any free Z in ϕ appears under the scope of an
even number of negations.
The first condition above means that r2 is obtained from
r1 by replacing some of the moves of r1 by the dummy
symbol �, where θ(�) = � . This condition is necessary
to ensure that r1θ and r2θ have the same length. Hence, if
r1θ ∈ σ, we can replace r1θ by r2θ and still get a strategy
σ′, which is written σ′ = σ[r2θ/r1θ]. The second condi-
tion is necessary for the semantic interpretation function as
will be explained in the semantics section. Intuitively, the
formula [r1 � r2]ϕ is true if there is a sequence in a strat-
egy in the game tree that matches r1 and when modified to
match r2 will satisfy ϕ. The quantifier 〈〈A〉〉 chooses the
subtree of the game tree where the agents in the set A in-
teract together through their strategies. The formula to the
right of 〈〈A〉〉 operates on this subtree. The rest of the for-
mulas have their usual meaning in modal µ-calculus [16].
4.2 Semantics
A formula in the logic is interpreted over a game tree.
Given a certain game tree G, a substitution θ, and a an en-
vironment e that maps formulae variables to strategies in G,
the semantic function [[ ϕ ]]Ge maps a formula ϕ to a set of
strategies S ⊆ SG , where SG is the set of all strategies in G.
[[ Z ]]Ge = e(Z)
[[ ¬ϕ ]]Ge = SG \ [[ ϕ ]]Ge
[[ ϕ1 ∧ ϕ2 ]]Ge = [[ ϕ1 ]]Ge ∩ [[ ϕ2 ]]Ge
[[ [r1 � r2]ϕ ]]Ge = {σ ∈ SG | ∀θ � satisfy(σ, r1, θ) ⇒
σ′ ∈ [[ ϕ ]]G
′
e }
where σ′ = σ[r2θ/r1θ], G′ = G[r2θ/r1θ]
[[ νZ.ϕ ]]Ge =
�{S ⊆ SG | S ⊆ [[ ϕ ]]Ge[Z �→S]}
[[ 〈〈A〉〉ϕ ]]Ge = SAG ∩ [[ ϕ ]]Ge
(6)
From the semantic equations above it can be seen that
the meaning of the recursive formula νZ.ϕ is taken to be
the greatest fixpoint of a function f : 2SG → 2SG , where
f(S) = [[ ϕ ]]G,θe[Z �→S]. The function f is defined over the
lattice (2SG ,⊆,∪,∩), the syntactic condition on ϕ (X ap-
pears under the scope of an even number of negations) en-
sures that f(S) is monotone [16] and hence has a greatest
fixpoint.
355355363355
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:46:01 UTC from IEEE Xplore.  Restrictions apply. 
We use the following shorthand notations:
¬(¬ϕ1 ∧ ¬ϕ2) ≡ ϕ1 ∨ ϕ2
¬ϕ1 ∨ ϕ2 ≡ ϕ1 ⇒ ϕ2
¬[r1 � r2]¬ϕ ≡ 〈r1 � r2〉ϕ
¬νZ.¬ϕ[¬Z/Z] ≡ µZ.ϕ
Moreover, we use the following two notation tt ≡ νZ.Z
and ff ≡ µZ.Z, now we prove some important results re-
garding the logic.
Lemma 4.1 [[ ϕ[ψ/Z] ]]Ge = [[ ϕ ]]G
e[Z �→[[ ψ ]]G
e
]
The proof is done by structural induction over ϕ.
proof
Base case: ϕ = Z
[[ ψ/Z ]]Ge = [[ ψ ]]Ge
But: [[ Z ]]Ge = e(Z), so [[ ψ/Z ]]Ge = [[ Z ]]G
e[Z �→[[ ψ ]]G
e
]
We demonstrate the case ϕ = [r1 � r2]ϕ′ and the other
cases can be easily proved:
[[ ϕ[ψ/Z] ]]Ge = {σ ∈ SG | ∀θ � satisfy(σ, r1, θ) ⇒ σ′ ∈
[[ ϕ′[ψ/Z] ]]G
′
e }
By induction hypothesis:
[[ ϕ[ψ/Z] ]]Ge = {σ ∈ SG | ∀θ � satisfy(σ, r1, θ) ⇒ σ′ ∈
[[ ϕ′ ]]G
′
e[Z �→[[ ψ ]]G
e
]
}
[[ ϕ[ψ/Z] ]]Ge = [[ ϕ ]]G
e[Z �→[[ ψ ]]G
e
]
} �
As a result, we have [[ νZ.ϕ ]]Ge = [[ ϕ[νZ.ϕ/Z] ]]Ge . This
follows from the fact that [[ νZ.ϕ ]]Ge = [[ ϕ ]]Ge[Z �→T ], where
T =
⋃{S ⊆ SG | S ⊆ [[ ϕ ]]Ge[Z �→S]} = [[ νZ.ϕ ]]Ge .
We can now prove that the semantics of the expression
µZ.ϕ defined earlier as ¬νZ.¬ϕ[¬Z/Z] is the least fixpoint
of the function f(S) = [[ ϕ ]]Ge[Z �→S].
[[ ¬νZ.¬ϕ[¬Z/Z] ]]Ge
= SG \�{S ⊆ SG | S ⊆ [[ ¬ϕ[¬Z/Z] ]]Ge[Z �→S]}
= SG \�{S ⊆ SG | S ⊆ SG \ [[ ϕ ]]G
e[Z �→[[ ¬Z ]]G
e[Z �→S]]
}
= SG \�{S ⊆ SG | S ⊆ SG \ [[ ϕ ]]Ge[Z �→SG\S]}
For any set of strategies S ⊆ SG , let Sc = SG \ S. By De
Morgan laws, for any two sets A and B:
(A ∩B)c = Ac ∪Bc, (A ∪B)c = Ac ∩Bc, A ⊆ B ⇒ Bc ⊆ Ac.
[[ ¬νZ.¬ϕ[¬Z/Z] ]]Ge
= (
�{SG \ Sc ⊆ SG | S ⊆ ([[ ϕ ]]G
e[Z �→Sc])
c})c
= (
�{SG \ Sc ⊆ SG | [[ ϕ ]]G
e[Z �→Sc] ⊆ Sc})c
=
�
({SG \ Sc ⊆ SG | [[ ϕ ]]Ge[Z �→Sc] ⊆ Sc})c
=
�{Sc ⊆ SG | [[ ϕ ]]Ge[Z �→Sc] ⊆ Sc}
Moreover, we investigate the semantics of the the expres-
sion 〈r1 � r2〉ϕ as defined above:
[[ 〈r1 � r2〉ϕ ]]Ge = [[ ¬[r1 � r2]¬ϕ ]]Ge
= {σ ∈ SG | ¬∀θ � satisfy(σ, r1, θ) ⇒ σ′ ∈ SG \ [[ ϕ ]]G
′
e }
= {σ ∈ SG | ¬∀θ � satisfy(σ, r1, θ) ⇒ ¬σ′ ∈ [[ ϕ ]]G
′
e )}
= {σ ∈ SG | ¬∀θ �¬(satisfy(σ, r1, θ) ∧ σ′ ∈ [[ ϕ ]]G
′
e )}
= {σ ∈ SG | ∃θ � (satisfy(σ, r1, θ) ∧ σ′ ∈ [[ ϕ ]]G
′
e )}
In the derivation above we used the sequent ψ ⇒ ¬ϕ �
¬(ψ ∧ ϕ), which can be easily proved by propositional cal-
culus. We also used the fact that for any set of strategies S,
S ∩ (SG \ S) = ∅. It is worth noting here that the seman-
tics of 〈r1 � r2〉ϕ is consistent with the definition of the
modality 〈 〉 from modal µ-calculus.
4.3 Tableau-based Proof System
Before we present the rules of the tableau, we define the
immediate subformula relation [16] ≺I as:
ϕ ≺I ¬ϕ ϕ ≺I [r1 � r2]ϕ
ϕi ≺I ϕ1 ∧ ϕ2 i ∈ {1, 2} ϕ ≺I νZ.ϕ
We define ≺ to be the transitive closure of ≺I and � to be
its transitive and reflexive closure. A tableau based proof
system starts from the formula to be proved as the root of
a proof tree and proceeds in a top down fashion. In every
rule of the tableau, the conclusion is above the premises.
Each conclusion of a certain rule represents a node in the
proof tree, whereas the premises represent the children to
this node. In our case, the proof system proves sequents of
the form H, b � σ ∈ ϕ, which means that under a set H
of hypotheses and the symbol b, then the strategy σ satisfies
the property ϕ. The set H contains elements of the form
σ : νZ.ϕ and is needed for recursive formulas. Roughly,
the use of H is to say that in order to prove that a strategy
σ satisfies a recursive formula ϕrec, we must prove the fol-
lowing: Under the hypothesis that σ satisfies ϕrec, then σ
also satisfies the unfolding of ϕrec. We also define the set
H �νZ.ϕ = {σ ∈ L | σ : νZ.ϕ ∈ H}. The use of H , and b
will be apparent after we state the rules of the proof system:
R¬
H, b � σ ∈ ¬ϕ
H,¬b � σ ∈ ϕ
R∧
H, b,� σ ∈ ϕ1 ∧ ϕ2
H, b1 � σ ∈ ϕ1 H, b2 � σ ∈ ϕ2
b1 × b2 = b
Rν
H, b � σ ∈ νZ.ϕ
H′ ∪ {σ : νZ.ϕ}, b � σ ∈ ϕ[νZ.ϕ/Z]
σ : νZ.ϕ ∈/ H
R[]
H, b � σ ∈ [r1 � r2]ϕ
ξ1 ξ2 . . . ξn
Condition
R〈〈〉〉
H, b � σ ∈ 〈〈A〉〉ϕ
H, b � σA ∈ ϕ
Where, H′ = H \ {σ′ : Γ | νZ.ϕ ≺ Γ}
ξi = H, bi � r2θi ∈ ϕ
condition =
��
�
∀θi � match (σ, r1, θi)
∧ b1 × b2 . . .× bn = b
∧ n > 0
The first rule concerns negation of formulas where b ∈
{ε,¬} serves as a “memory” to remember negations, in this
case εϕ = ϕ. We define εε = ε, ε¬ = ¬ε = ¬, and ¬¬ = ε.
Moreover, we define ε × ε = ε, ε × ¬ = ¬ × ε = ¬,
and ¬ × ¬ = ¬. The second rule says that in order to
prove the conjunction, we have to prove both conjuncts.
The third rule concerns proving a recursive formulas, where
the construction of the set H , via H ′, ensures that the va-
lidity of the sequent H, b � σ ∈ νZ.ϕ is determined only
by subformulas of ϕ [16]. The fourth rule takes care of
formulas matching sequences to patterns. Finally, the fifth
rule deals with formulas dealing with subtrees of the game
tree. Starting from the formula to be proved at the root
356356364356
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:46:01 UTC from IEEE Xplore.  Restrictions apply. 
of the proof tree, the tree grows downwards until we hit
a node where the tree cannot be extended anymore, i.e.,
a leaf node. A formula is proved if it has a successful
tableau, where a successful tableau is one whose all leaves
are successful. A successful leaf meets one of the follow-
ing conditions:(1) H, ε � σ ∈ Z and σ ∈ [[ Z ]]Ge , (2)
H,¬ � σ ∈ Z and σ ∈/ [[ Z ]]Ge , (3) H, ε � σ ∈ νZ.ϕ
and σ : νZ.ϕ ∈ H , or (4) H, ε � σ ∈ [r1 � r2]ϕ and
{σ ∈ SG | ∃θ � match (σ, r1, θ)} = ∅.
4.4 Properties of Tableau System
We would like to prove three main properties, namely
the finiteness of the tableau for finite models, the sound-
ness, and the completeness. Soundness and completeness
are proved with respect to a relativized semantics that takes
into account the set H of hypotheses. The new semantics is
the same as the one provided above for all formulas except
for recursive formulas where is it defined as:
[[ νZ.ϕ ]]G,He = (ν[[ ϕ ]]G,H
e[Z �→S∪S′]) ∪ S′
where, S′ = H �νZ.ϕ
In the equation, the greatest fixpoint operator is applied
to a function f(S) = [[ ϕ ]]L,θe[Z �→S] whose argument is S∪S′.
Since the function is monotone over a complete lattice, as
mentioned earlier, then the existence of a greatest fixpoint
is guaranteed. We now list some results regarding the proof
system. The detailed proofs are not provided due to space
limitation.
Theorem 4.1 Finiteness. For any sequent H, b � σ ∈ ϕ
there exists a finite number of finite tableaux.
The idea of the proof is that for any formula at the root
of the proof tree we begin applying the rules R¬, R∧, R[],
R〈〈〉〉, and Rν . The application of the first four rules results
in shorter formulas, while the application of the Rν rule
results in larger hypothesis sets H . The proof shows that
shortening a formula and increasing the size of H cannot
continue infinitely. Hence no path in the tree will have infi-
nite length. Branching happens in the proof tree whenever
we have an expression of the form ϕ1 ∧ ϕ2 or [r1 � r2]ϕ.
Finite branching is guaranteed in the first case by the fi-
nite length of any expression and in the second case by the
finiteness of the model.
Theorem 4.2 Soundness. For any sequent H, b � σ ∈ ϕ
with a successful tableau, σ ∈ [[ ϕ ]]G,He
The idea behind the proof is to show that all the successful
leaves described above are valid and that the application of
the rules of the tableau reserves semantic validity.
Theorem 4.3 Completeness. If for a strategy σ ∈ SG , σ ∈
[[ ϕ ]]G,He , then the sequent H, b � σ ∈ ϕ has a successful
tableau.
The proof relies on showing that we cannot have two suc-
cessful tableaux for the sequents H, b � σ ∈ ϕ and H, b �
σ ∈ ¬ϕ.
5 Conclusion
We presented a game semantics model for security pro-
tocols that is based on an algebraic description of messages.
The message algebra is equipped with an equational theory
that enriches the analysis by expressing algebraic properties
over the algebra of messages. Moreover the definition of the
games makes explicit the role of the intruder in the proto-
col communications. We also developed a logic that can be
used to express security properties. The model and logic
can be used to analyze a wide variety of protocols specified
in the standard arrow notation.
References
[1] M. Abadi. Security protocols and their properties. In
F. Bauer and R. Steinbrueggen, editors, Foundations of Se-
cure Computation, 20th Int. Summer School, Marktoberdorf,
Germany, pages 39–60. IOS Press, 2000.
[2] M. Abadi and V. Cortier. Deciding knowledge in security
protocols under (many more) equational theories. In Pro-
ceedings of the 18th IEEE Computer Security Foundations
Workshop, 2005.
[3] M. Abadi and C. Fournet. Mobile values, new names, and
secure communication. In POPL, pages 104–115, 2001.
[4] M. Abadi and A. B. Gordon. A calculus for cryptographic
protocols: The SPI calculus. In Proceedings of the 4th
ACM Conference on Computer and Communications Secu-
rity, 1997.
[5] M. Abadi and P. Rogaway. Reconciling two views of cryp-
tography (The computational soundeness of formal encryp-
tion). Journal of cryptology, 15(2):103–127, 2002.
[6] S. Abramsky. Semantics of interaction: An introduction to
game semantics. In Proceedings of the 1996 CLiCS Summer
School, Isaac Newton Institute, P. Dybjer and A. Pitts, eds.
(Cambridge University Press), 1997.
[7] S. Abramsky, P. Malacaria, and R. Jagadeesan. Full abstrac-
tion for PCF. In Theoretical Aspects of Computer Software,
pages 1–15, 1994.
[8] K. Adi, M. Debbabi, and M. Mejri. A new logic
for electronic commerce protocols. Theor. Comput. Sci,
291(3):223–283, 2003.
[9] R. Alur, T. Henzinger, and O. Kupferman. Alternating-time
temporal logic. JACM: Journal of the ACM, 49, 2002.
[10] B. Blanchet, M. Abadi, and C. Fournet. Automated verifica-
tion of selected equivalences for security protocols. In LICS,
pages 331–340. IEEE Computer Society, 2005.
[11] A. Blass. A game semantics for linear logic. Annals of Pure
and Applied Logic, 56:183–220, 1992.
[12] M. Boreale and M. Buscemi. A method for symbolic anal-
ysis of security protocols. TCS: Theoretical Computer Sci-
ence, 338, 2005.
357357365357
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:46:01 UTC from IEEE Xplore.  Restrictions apply. 
[13] M. Burrows, M. Abadi, and R. Needham. A logic of authn-
tication. Technical report, Digital Systems Research Center.
[14] I. Cervesato, N. Durgin, P. Lincoln, J. Mitchell, and A. Sce-
drov. A meta-notation for protocol analysis. In PCSFW:
Proceedings of The 12th Computer Security Foundations
Workshop. IEEE Computer Society Press, 1999.
[15] E. Clarke, S. Jha, and W. Marrero. Using state space ex-
ploration and a natural deduction style message derivation
engine to verify security protocols. In International Con-
ference on Programming Concepts and Methods, pages 87–
106, 1998.
[16] R. Cleaveland. Tableau-based model checking in the propo-
sitional mu-calculus. Acta Informatica, 27(8):725–748,
1990.
[17] S. Delaune. Vérification des protocoles cryptographiques
et propriétés algébriques. Thèse de doctorat, Laboratoire
Spécification et Vérification, ENS Cachan, France, June
2006.
[18] D. Dolev and A. Yao. On the security of public key proto-
cols. IEEE transactions on information theory, 29(2):198–
208, 1983.
[19] J. Fabrega, J. Herzog, and J. Guttman. Strand spaces: Prov-
ing security protocols correct. Journal of Computer Secu-
rity, (7):191–230, 1999.
[20] J. M. E. Hyland and C.-H. L. Ong. On full abstraction for
PCF: I, II, III. Info. and Comp., 163:285–408, 2000.
[21] J.Clark and J. Jacob. A survey of authentication protocol
literature.
[22] S. Kremer and J. Raskin. A game approach to the verifica-
tion of exchange protocols - application to non-repudiation
protocols. In Proceedings of the Workshop on Issues in the
Theory of Security (WITS ’00), 2000.
[23] K. Lorenz. Basic objectives of dialogue logic in historical
perspective. Synthese (Elsevier), 127(1–2), April/May 2001.
[24] L. C. Paulson. The inductive approach to verifying cryp-
tographic protocols. Journal of Computer Security, (6):85–
128, 1998.
[25] J. Tucker and J. Zucker. Computable functions and semi-
computable sets on many-sorted algebras. In S. Abramsky,
D. Gabbay, and T. Maibaum, editors, Handbook of Logic in
Computer Science, volume 5, pages 317–523. Oxford Uni-
versity Press, 2000.
[26] T. Woo and S. Lam. A lesson on authentication protocol
design. Operating Systems Review, pages 24–37, 1994.
A Semantics
A.1 Protocol Types
A type τ of a certain protocol can be defined by the fol-
lowing BNF grammar: τ ::= Msg � Msg | τ ⊗ τ . To
assign a type to a protocol we use the typing rules below,
where α, β, . . . represent single communication steps.
�
α : Msg�Msg
α : Msg�Msg Comm : τ
α.Comm : (Msg�Msg) ⊗ τ
Decl : τ Comm : τ ′
Decl.Comm : τ ′
We define the function τ over the algebra of types where,
Msg� Msg = 1 and τ ′ ⊗ τ ′ = τ ′ + τ ′.
A.2 Protocol Semantics
A protocol is well-formed if, in the protocol specifica-
tion, no message is sent by an agent A unless it can be de-
duced from φ(A) (the specification frame). Hereafter we
define first the predicate Wf Prot() that checks a protocol
for well-formedness, then we define the semantic function
of a well-formed protocol.
Wf Prot : Comm→ Frm → Bool
Wf Prot(C)(φ) φ is constructed by “frame” (Section 2.4)
= Wf Prot(A→ B : m.C)(φ)
= φ(A) � m ∧ Wf Prot(C)(φ)
In security semantics, we investigate possible manoeu-
vres that can be performed by the intruder in order to break
the protocol’s security. For any protocol P that has type τ ,
the semantic function assigns to P a set of strategies over
the game Spr[τ ]. First, we define the following:
sess : Session Session : → N sess is the session number.
PG : GameTree Game tree of the game G
P subG : GameTree P subG ⊆ PG a subset of the game tree (subtree)
The semantic function P accepts a protocol, a frame, a
game tree and a protocol type. It returns a subset of the
game tree of the game Spr. This subset represent all possi-
ble sequences the game could proceed with:
P : Prot→ Frm → GameTree →�
τ ∈ τ . P subSpr[τ]
P[[νA � m.D.C]](ρ)(PSpr[τ]
)(τ) ∀P � ρ(P ) = ν∅ � [ ]
= P[[D.C]](ρ[A �→ νC ∪m � θf ])(PSpr[τ]
)(τ)
P[[κA � m.D.C]](ρ)(PSpr[τ]
)(τ)
= P[[D.C]](ρ[A �→ νC � θf [0 �→< θf (0),m >]])(PSpr[τ]
)(τ)
P[[ε.C]](ρ)(PSpr[τ]
)(τ)
= P[[C]](ρ[A �→ νC � θf [0 �→< θf (0),m >]])(PSpr[τ]
)(τ)
P[[step i � A→ B : mi.C]](ρ)(PSpr[τ]
)(τ) =
if i = 1 then
P[[C]](ρ † [I �→ νC � θf [1 �→ mi])
(PSpr[τ]
[q11.start/PSpr[τ]
�Msgsess,11,
q12.m12
i /PSpr[τ]
�Msgsess,12])(τ)
else
∀m � ρ(I) � m let n = out(ρ(A), 3))
in
P[[C]](ρ † [A �→ νC � θf [i �→ m], I �→ νC � θf [1 �→ mi]])
(PSpr[τ]
[qi1.mi1/Pτ �Msgsess,i1,
qi2.ni2/PSpr[τ]
�Msgsess,i2])(τ)
end
end
end
P[[ε]](ρ)(PSpr[τ]
)(τ) =
PSpr[τ]
358358366358
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:46:01 UTC from IEEE Xplore.  Restrictions apply.