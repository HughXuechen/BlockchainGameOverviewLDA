LNCS 7178 - PMAC with Parity: Minimizing the Query-Length Influence
PMAC with Parity:
Minimizing the Query-Length Influence
Kan Yasuda
NTT Information Sharing Platform Laboratories, NTT Corporation, Japan
yasuda.kan@lab.ntt.co.jp
Abstract. We present a new variant of PMAC (Parallelizable Message
Authentication Code). The new mode calls an n-bit block cipher using
four different block-cipher keys but attains a security bound of a novel
form O(q2/2n + �σq/22n). Here, q denotes the total number of queries,
� the maximum length of each query (in blocks), and σ the total query
complexity (in blocks). Our bound improves over the previous PMAC
security O(�q2/2n) from FSE 2007 and over O(σq/2n) from FSE 2010.
Moreover, when � > 2n/6, our bound holds valid for larger values of q than
the beyond-birthday bound O(�3q3/22n) does—the bound of the PMAC
variant from CRYPTO 2011. In particular, our bound becomes “�-free”
as O(q2/2n) under the condition that all queries are shorter than 2n/2
blocks (i.e., � ≤ 2n/2). Our construction is fairly efficient; it runs at rate
2/3 (meaning 1.5 encryptions to process n bits), which can be made even
faster by increasing the number of keys. Thus our construction brings
substantial gain in security guarantee without much loss in efficiency,
which becomes especially valuable for 64-bit block ciphers.
Keywords: Block cipher, permutation, mode of operation, provable
security, game-playing technique, checksum.
1 Introduction
Message Authentication Codes (MACs) are often realized via some modes of
operation using n-bit block ciphers, where typically we have n = 64 or n = 128.
Prominent modes are CBC MACs (e.g., [2,15,6,11,9,13]) and PMAC [7,17,18].
Most of these block-cipher MAC constructions are provided with proofs of
security, which generally guarantee the level of “birthday security.” The basic
birthday bounds look like O(�2q2/2n) or O(σ2/2n),1 where q is the total number
of (chosen-message) queries (to the MAC oracle), � the maximum length of each
query, and σ the total length of all queries (The lengths are measured in terms
of the number of blocks).
The basic birthday bounds often become insufficient, especially when n = 64.
In legacy systems or lightweight applications where 64-bit block ciphers are used,
it is desirable to provide a higher security guarantee. Roughly speaking, we see
1 With abuse of notation we use the big-O notation to mean that constant coefficients
are omitted.
O. Dunkelman (Ed.): CT-RSA 2012, LNCS 7178, pp. 203–214, 2012.
c© Springer-Verlag Berlin Heidelberg 2012
204 K. Yasuda
that there are two aspects of improving the birthday bounds—improving the
�-factor in the bounds, or the q-factor.
Improving in �: Minimizing the Query-Length Influence. The basic
birthday bound O(�2q2/2n) would become void when � ≈ 2n/2. This limitation
on � can be relaxed in multiple ways.
The first is to provide better security analysis, as done for many of the MAC
constructions. Frequently, bounds of the form O(σ2/2n) can be obtained, rather
than O(�2q2/2n). Bounds of the form O(�q2/2n) are proven for CBC MAC [3]
and for PMAC [12]. Even better bounds O(σq/2n) are achieved for a wide class
of block-cipher MAC constructions [14].
The second is to provide constructions that make use of a counter. The idea
of using a counter appears in previous constructions such as XOR MAC [1]
and PCS [5]. For example, the following PMAC-type construction yields an “�-
free” bound O(q2/2n): For simplicity assume that n is even; divide a (padded)
message M into n/2-bit blocks as M [1],M [2], . . . ,M [m]; then compute C[i] ←
EK1
(
i‖M [i]
)
, where EK1 is an n-bit block cipher using a key K1, which encrypts
the counter i encoded into an n/2-bit string and concatenated to the message
block M [i]; finally output the tag value T ← EK2
(
C[1]⊕ · · · ⊕ C[m]
)
, where ⊕
means bitwise xor. Unfortunately this construction runs at rate 1/2 (meaning
two encryptions to process n bits), and by specification the maximum message
length � is limited to 2n/2 blocks.
The third is to utilize randomization (e.g., [8]), which also yields an �-free
O(q2/2n) bound. Such a scheme requires a (pseudo-)random number generator
and must attach each generated random salt to each tag, which results in a larger
tag size.
Improving in q: Maximizing the Query-Number Acceptance. All of the
above bounds so far have the limitation q < 2n/2. Unlike the case of �, this is
inevitable for classical MAC constructions that possess n-bit intermediate state
values, because for such iterated MACs there exists a generic attack that can
produce a forgery using about 2n/2 queries [16].
To get rid of the limitation q < 2n/2, one must come up with new con-
structions that achieve so-called beyond-birthday security. Such constructions
exist [10,20,21], achieving O(�3q3/22n) bounds. So these constructions remain
secure up to O(22n/3) query complexity.
Unbalance between q and �. Let us look more closely at the two bounds
O(�q2/2n) and O(�3q3/22n). It is not the case that one of them is better than
the other for all parameters of � and q. Indeed, we have seen that, when � = 1,
the former provides only the birthday security O(q2/2n), whereas the latter
O(q3/22n). However, when � = 22n/3, the former still gives us (some) security
O(q2/2n/3), whereas the latter beyond-birthday bound vanishes completely.
It depends on each application which factor, � or q, is more important. In the
current work we focus on the situations where the �-factor is more important.
For example, consider the case of 64-bit block ciphers. The figure � = 2n/2 = 232
PMAC with Parity: Minimizing the Query-Length Influence 205
Fig. 1. Values of � and q (unequally scaled) that make the three bounds vacuous
corresponds to 32 GB, whereas q = 232 ≈ 4.3 × 109 corresponds to about 136
years if executed every second. Then our target is, for example, those systems
that handle data of gigabyte sizes but produce at most one tag per second. We
are unable to list specific examples of such targets but believe that a number of
security applications fall into the category.
Our Contributions. We present a new variant of PMAC which attains a
security bound of a novel form O(q2/2n + �σq/22n). This bound improves over
the previous bounds in terms of �-factor. The new construction has the following
features:
1. The scheme does not use randomization.
2. The algorithm can handle messages having � > 2n/2 blocks.
3. The basic version of our construction runs at rate 2/3 (meaning 1.5 encryp-
tions to process n bits).
4. The new bound improves over O(�σ/2n) for all values of � and q.
5. The new bound improves overO(�3q3/22n) for the following values of � and q:
(a) when � > 2n/3,
(b) when 2n/3 ≥ � ≥ 2n/6 and q > 2n/�3.
See Fig. 1, which plots the values of � and q that voids the bounds O(q2/2n +
�σq/22n), O(�3q3/22n) and O(�q2/2n). For n = 64, � = 2n/6 corresponds to
about 12.7 kB and � = 2n/3 to 20.2 MB. In practice, one is interested more
in the curve for which there is some (e.g., 1/232) security left rather than in
the curve for which the security vanishes. The diagram indicating such locations
would become essentially the same, except that it is drawn on a sliding scale.
206 K. Yasuda
Unfortunately, the new construction has some serious disadvantages:
1. The basic version uses four independent block-cipher keys.
2. Different versions run faster at rate 3/4, 4/5, ..., but using five, six, ... dif-
ferent keys.
3. The new construction requires larger memory to store intermediate state
values.
These undesirable features may prevent us from applying the new construction to
some of the lightweight or legacy systems using 64-bit block ciphers. However,
the current work still makes a significant contribution to the construction of
block-cipher MACs, demonstrating a new tradeoff between performance and
security.
Organization of the Paper. Necessary symbols and security notions are given
in Sect. 2. We start with the basic version, a rate-2/3 construction, which is
defined in Sect. 3. Its security proof is given in Sect. 4. In Sect. 5 we describe
other (rate-3/4, 4/5, etc.) versions. We end the paper by making some remarks
in Sect. 6.
2 Preliminaries
Notation System. Let the symbol Perm(n) denote the set of all permutations
P : {0, 1}n → {0, 1}n. Similarly, let Func(n) denote the set of all functions
F : {0, 1}n → {0, 1}n. Fix a key spaceK. UsuallyK = {0, 1}k, where k = 80, 128,
192 or 256. We define a blockcipher E as a function E : K × {0, 1}n → {0, 1}n
such that for each key K ∈ K the specified function EK is in Perm(n). Here
EK : {0, 1}n → {0, 1}n is defined as EK(X) := E(K,X). We write E−1
K for the
inverse permutation.
We sometimes treat {0, 1}n as a set of integers {0, 1, . . . , 2n − 1}. This can
be done by converting an n-bit string an−1 · · ·a1a0 ∈ {0, 1}n to an integer
an−12
n−1 + · · · + a12 + a0, where multiplication and addition are arithmetic
(modulo 2n.)
We let GF (2n) be the finite field having 2n elements. We treat {0, 1}n also as
GF (2n). That is, we identify an n-bit string an−1 · · · a1a0 ∈ {0, 1}n with a formal
polynomial an−1x
n−1 + · · ·a1x + a0 ∈ GF (2)[x]. For this we fix an irreducible
polynomial a(x) = xn + an−1x
n−1 + · · ·+ a1x+ a0 ∈ GF (2)[x]. For example we
can choose irreducible polynomials a(x) = x64 + x4 + x3 + x+ 1 for n = 64 and
a(x) = x128+x7+x2+x+1 for n = 128. These are actually primitive polynomials,
meaning the element 2 = x generates the entire multiplicative group GF (2n)∗
of order 2n − 1.
Security Definitions. In this paper an adversary A is an oracle machine.
We write AO(·) = y to denote the event that A outputs y after interacting
with an oracle O(·). We measure the resources of A in terms of time and
query complexities. We fix a model of computation and a method of encoding.
PMAC with Parity: Minimizing the Query-Length Influence 207
The query complexity is measured in terms of the number q of queries, in terms of
the maximum length � of each query, and in terms of the total query complexity
σ. The resources � and σ are measured in blocks (n bits).
We say that (informally) a block cipher E is a (secure) pseudo-random permu-
tation (PRP) if it is indistinguishable from a random permutation P
$←− Perm(n),
where
$←− means uniformly random sampling. Specifically, we consider the ad-
vantage function
AdvprpE (A) := Pr
[AEK(·) = 1;K
$←− K
]− Pr
[AP (·) = 1;P
$←− Perm(n)
]
,
and if this quantity is “small enough” for a class of adversaries, then we say that
E is a “secure” PRP. Here note that the probabilities are defined over internal
coin tosses of A, if any, as well as over the choices of K and P . We further define
AdvprpE (t, q) := maxA AdvprpE (A), where the max runs over adversaries A whose
time complexity is at most t, making at most q queries to its oracle.
With abuse of notation let {0, 1}∗ denote the set of finite bit strings whose
length is at most � blocks. Let Func(∗, n) denote the set of functionsG : {0, 1}∗ →
{0, 1}n. Our goal is to construct a pseudo-random function (PRF) FK : {0, 1}∗ →
{0, 1}n having keys K ∈ K
′. Recall that any PRF can be used as a secure MAC.
We say that F is a secure PRF if it is indistinguishable from a random function
G
$←− Func(∗, n), or more precisely, we define
AdvprfF (A) := Pr
[AFK(·) = 1;K
$←− K
′]− Pr
[AG(·) = 1;G
$←− Func(∗, n)].
We also define AdvprfF (t, q, �, σ) to be the maximum advantage running over
adversaries A whose resources are limited to t, q, �, σ.
Game-Playing Techniques and Lazy Sampling. Our security proofs are
based on the game-playing techniques [4]. We perform lazy sampling for a ran-
dom permutation P
$←− Perm(n). That is, P is initially everywhere undefined,
and when a value P (X) becomes necessary at some point in the game, a corre-
sponding range point C is randomly sampled as C
$←− {0, 1}n.
3 Description of the New Mode
In this section we define the rate-2/3 version of our PMAC variant. See Algo-
rithm 1 and Fig. 2. The algorithm uses four permutations P1, P2, P3 and P4,
which are in practice realized via a block cipher using four keys.
In pre-computation stage the algorithm PMAC2/3 prepares mask values as
L1 ← P1(0), L2 ← P2(0) and L3 ← P3(0). These values are updated via finite-
field multiplication by 2 as 2iL1, 2
iL2 and 2iL3.
The algorithm takes a message input M and adds the usual 10∗ padding
so that the number of (n-bit) blocks becomes an even number. The padded
message M‖10∗ is then divided into n-bit blocks as M [1], . . . ,M [2m] before
being processed.
208 K. Yasuda
Input: a message M ∈ {0, 1}∗
Output: a tag T
L1 ← P1(0); L2 ← P2(0); L3 ← P3(0)(
M [1], . . . ,M [2m]
)←M‖10∗
for i = 1 to m do
X[2i − 1]← M [2i− 1]⊕ 2i−1L1; X[2i]←M [2i] ⊕ 2i−1L2
C[2i− 1]← P1
(
X[2i − 1]
)
; C[2i]← P2
(
X[2i]
)
Y [i]←M [2i − 1]⊕M [2i] ⊕ 2i−1L3
D[i]← P3
(
Y [i]
)
end
S ← C[1]⊕ · · · ⊕ C[2m]⊕D[1] ⊕ · · · ⊕D[m]
T ← P4(S)
return T
Algorithm 1: The rate-2/3 construction PMAC2/3[P1, P2, P3, P4]
Fig. 2. A pictorial representation of the rate-2/3 construction
The rest of the process is PMAC-like, except that 1) we use different keys be-
tween odd-numbered blocks and even-numbered blocks, 2) we have extra “check-
sum” blocks M [2i− 1]⊕M [2i] for which another key is used, and 3) we use yet
another key for the finalization.
The exact amount of memory to run the rate-2/3 construction depends on the
specific implementation. Generally, the different keys K2,K3,K4, the different
mask values L2, L3, and the checksum block M [2i − 1] ⊕M [2i] are the state
values that need extra memory.
4 Security Proofs
We now prove our security result for the rate-2/3 construction; we prove that
the algorithm PMAC2/3[EK1 , EK2 , EK3 , EK4 ] is a secure PRF having a bound of
the form O(q2/2n + �σq/22n):
Theorem 1. The algorithm PMAC2/3[EK1 , EK2 , EK3 , EK4 ] is a secure PRF on
the assumption that the underlying block cipher E is a secure PRP. More pre-
cisely, we have
PMAC with Parity: Minimizing the Query-Length Influence 209
initialize: P1, P2, P3
$←− Perm(n), F
$←− Func(n)
on α-th query M (α) do
S(α) ← inner[P1, P2, P3]
(
M (α)
)
T ← F
(
S(α)
)
if S(β) = S(α) for some β ∈ {1, . . . , α− 1} then
if ¬bad then
coll(β, α)← true
end
bad← true T
$←− {0, 1}n
end
return T
end
Algorithm 2: Games G0 (with the boxed statement) and G1 (without)
Advprf
PMAC2/3[EK1 ,EK2 ,EK3 ,EK4 ]
(t, q, �, σ) ≤ q2
2n
+
�σq
22n
+ 4AdvprpE (t′, σ),
where t′ is t plus the time complexity to compute the E algorithm σ times.
Proof. We consider the algorithm PMAC2/3[P1, P2, P3, F ] where P1, P2, P3 are
three independent random permutations and F an independent random function.
Let A be an adversary playing the games defined in Algorithm 2. We limit
the resources of A by t, q, �, σ. In the games we use the algorithm inner, which
is defined to be the subroutine of PMAC2/3 that outputs S, so that we have
PMAC2/3[P1, P2, P3, F ](M) = F
(
inner[P1, P2, P3](M)
)
.
Without loss of generality we assume that adversary A never repeats its queries.
We observe that on one hand game G0 corresponds to a truly random function
mapping {0, 1}∗ to {0, 1}n. On the other hand, game G1 corresponds to the
algorithm PMAC2/3[P1, P2, P3, F ]. Therefore, by the fundamental lemma of game
playing, we get
Advprf
PMAC2/3[P1,P2,P3,F ](A) = Pr
[
G1(A) outputs 1
]
− Pr
[
G0(A) outputs 1
]
≤ Pr
[
G1(A) sets bad
]
= Pr
[
∨
β<α
(
G1(A) sets coll(β, α)
)]
≤
∑
β<α
Pr
[
G1(A) sets coll(β, α)
]
,
so in the following we evaluate the probability Pr
[
G1(A) sets coll(β, α)
]
.
210 K. Yasuda
initialize: P1, P2, P3
$←− Perm(n)
(M,M ′)← B
S ← inner[P1, P2, P3](M)
S′ ← inner[P1, P2, P3](M
′)
if M �= M ′ and S = S′ then
bad← true
end
Algorithm 3: Game G for adversary B
To do this, let us consider game G defined in Algorithm 3. The goal of the
adversary B playing game G is to find an inner collision S = S′ for different
messages M �= M ′.
Let us construct an adversary Bβ,α that uses A and plays game G. The ad-
versary Bβ,α runs A and returns random strings to A’s oracle queries. At the
β-th query, Bβ,α stores the query M (β) and resumes A. At the α-th query, Bβ,α
stops A and outputs (M (β),M (α)). If A is to set coll(β, α), then we observe
that Bβ,α correctly simulates game G1 for A, up to (α − 1)-th query, and Bβ,α
must set bad in game G. Therefore, we get
Pr
[
G1(A) sets coll(β, α)
]
≤ Pr
[
G(Bβ,α) sets bad
]
,
and in the following lemma we evaluate the quantity Pr
[
G(B) sets bad
]
:
Lemma 1 (Main Lemma). For two messages M,M ′ ∈ {0, 1}∗ such that M �=
M ′, we have
Pr
[
inner[P1, P2, P3](M) = inner[P1, P2, P3](M
′);
P1, P2, P3
$←− Perm(n)
]
≤ 1
2n
+
m2
22n
,
where m is half the block length of the longer message (M or M ′).
Proof. We prove this lemma by lazy sampling of P1, P2, P3. Without loss of
generality assume m ≥ m′.
Case m > m′. We focus on the last input blocks X [2m−1], X [2m]. We sample
P1(0) and P2(0). The probability that both of the inputsX [2m−1], X [2m] collide
with some other inputs to P1, P2 (including the zero input 0) is at most
m
2n
· m
2n
=
m2
22n
.
Otherwise at least one of the inputs must get sampled in computing the state
value S or S′. In that case the probability that S = S′ happens is at most 1/2n,
which proves the lemma for this case.
PMAC with Parity: Minimizing the Query-Length Influence 211
Case m = m′. Let i be the maximum index such that
(
M [2i − 1],M [2i]
) �=(
M ′[2i − 1],M ′[2i]
)
(The value i is uniquely determined as soon as the two
messages M and M ′ are fixed.) We also look at the checksum blocks M [2i −
1] ⊕M [2i] and M ′[2i − 1] ⊕M ′[2i]. We observe that, of these three blocks in
comparison, at least two of them are different (betweenM andM ′); so choose two
different blocks (according to some fixed order). Sample P1(0), P2(0) and P3(0).
The probability that both of that different input blocks collide with somewhere
else (including zero) is at most
m
2n
· m
2n
=
m2
22n
.
Otherwise at least one of the inputs must get sampled in computing the state
value S or S′. In that case the probability that S = S′ happens is at most 1/2n.
So this case is also proven. �
Now we go back to computing the overall probability. We would like to evaluate
the quantity
∑
β<α
Pr
[
G(Bβ,α) sets bad
]
≤
∑
β<α
(
1
2n
+
m2
22n
)
,
where m is half the block size of the longer message, either M (β) or M (α).
We reorder the messages so that M (1), M (2), . . ., M (q) are in (weakly) length-
increasing order, M (1) being (one of) the shortest message and M (q) (one of)
the longest. Now we have
∑
β<α
(
1
2n
+
m(α)2
22n
)
=
∑
β<α
1
2n
+
∑
β<α
m(α)2
22n
≤
(
q
2
)
· 1
2n
+
�+ 1
2
·
∑
β<α
m(α)
22n
≤ q2
2n+1
+
�+ 1
2
·
q∑
α=2
α−1∑
β=1
m(α)
22n
≤ q2
2n+1
+
�+ 1
2
·
q∑
α=2
m(α)(α− 1)
22n
≤ q2
2n+1
+
�+ 1
2
· (σ − 1)(q − 1)
22n
≤ q2
2n+1
+
�σq
22n
,
to which we add terms q2/2n+1 (PRP/PRF switching lemma [4] for P4), and
4AdvprpE (t′, σ) (replacing P1, P2, P3, P4 with EK1 , EK2 , EK3 , EK4). This would
give us the desired bound. �
212 K. Yasuda
Input: a message M ∈ {0, 1}∗
Output: a tag T
L1 ← P1(0); L2 ← P2(0); L3 ← P3(0); L4 ← P4(0)(
M [1], . . . ,M [3m]
)←M‖10∗
for i = 1 to m do
X[3i − 2]← M [3i− 2]⊕ 2i−1L1; X[3i − 1]← M [3i− 1]⊕ 2i−1L2;
X[3i]←M [3i] ⊕ 2i−1L3
C[3i− 2]← P1
(
X[3i − 2]
)
; C[3i− 1]← P2
(
X[3i − 1]
)
; C[3i]← P3
(
X[3i]
)
Y [i]←M [3i − 2]⊕M [3i− 1]⊕M [3i]⊕ 2i−1L4
D[i]← P4
(
Y [i]
)
end
S ← C[1]⊕ · · · ⊕ C[3m]⊕D[1] ⊕ · · · ⊕D[m]
T ← P5(S)
return T
Algorithm 4: The rate-3/4 construction PMAC3/4[P1, P2, P3, P4, P5]
Fig. 3. A pictorial representation of the rate-3/4 construction
5 Smaller-Rate Versions
We generalize our basic version to obtain rate-3/4, 4/5, etc. constructions. To
do this, we use the idea from [19]. See Algorithm 4 and Fig. 3 for the definition
of rate-3/4 version. The key idea is to make the sum of three blocks, rather than
two. Similarly, the sum of four blocks would yield the rate-4/5 construction.
The three-sum version indeed has a smaller rate of 3/4 but at the same time
introduces a couple of problems. One is inefficiency in padding; depending on
the message length, one might have to pad relatively large number of zeros to
make the number of blocks divisible by three. The other is the larger number of
keys and larger memory size; note that now we have to store four mask values,
L1, L2, L3 and L4.
However, we still have the same security level as the rate-2/3 construction,
as shown in the following theorem. Its proof is similar to the rate-2/3 case and
hence omitted.
PMAC with Parity: Minimizing the Query-Length Influence 213
Theorem 2. The algorithm PMAC3/4[EK1 , . . . , EK5 ] is a secure PRF on the as-
sumption that the underlying block cipher E is a secure PRP. More precisely,
we have
Advprf
PMAC3/4[EK1 ,...,EK5 ]
(t, q, �, σ) ≤ q2
2n
+
�σq
22n
+ 5AdvprpE (t′, σ),
where t′ is t plus the time complexity to compute the E algorithm σ times.
6 Concluding Remarks
We have provided a new PMAC variant whose security bound is of the form
O(q2/2n+ �σq/22n). The bound becomes �-free as O(q2/2n) under the condition
� ≤ 2n/2. Ideally, we would like to obtain O(q2/2n) under the condition � ≤ 2n,
but no such constructions (without randomization) seem to be known.
Our construction achieves rate 2/3, 3/4, etc.. Ideally, we would like to have a
rate-1 construction having a similar security bound. Again, no such constructions
(without randomization) seem to be known.
Finally, we make a remark about the number of keys. Our construction re-
quires at least four independent keys. It would certainly be desirable if one could
reduce the number of block-cipher keys. It is of both practical and theoretical
interest to develop techniques to reduce the number of keys in this kind of situ-
ation.
Acknowledgments. The author would like to thank CT-RSA 2012 PC mem-
bers and reviewers for accurate and helpful feedback.
References
1. Bellare, M., Guérin, R., Rogaway, P.: XOR MACs: New Methods for Message
Authentication Using Finite Pseudorandom Functions. In: Coppersmith, D. (ed.)
CRYPTO 1995. LNCS, vol. 963, pp. 15–28. Springer, Heidelberg (1995)
2. Bellare, M., Kilian, J., Rogaway, P.: The Security of Cipher Block Chaining. In:
Desmedt, Y.G. (ed.) CRYPTO 1994. LNCS, vol. 839, pp. 341–358. Springer, Hei-
delberg (1994)
3. Bellare, M., Pietrzak, K., Rogaway, P.: Improved Security Analyses for CBC MACs.
In: Shoup, V. (ed.) CRYPTO 2005. LNCS, vol. 3621, pp. 527–545. Springer, Hei-
delberg (2005)
4. Bellare, M., Rogaway, P.: The Security of Triple Encryption and a Framework
for Code-Based Game-Playing Proofs. In: Vaudenay, S. (ed.) EUROCRYPT 2006.
LNCS, vol. 4004, pp. 409–426. Springer, Heidelberg (2006)
5. Bernstein, D.J.: How to stretch random functions: The security of Protected
Counter Sums. J. Cryptology 12(3), 185–192 (1999)
6. Black, J.A., Rogaway, P.: CBC MACs for Arbitrary-Length Messages: The Three-
Key Constructions. In: Bellare, M. (ed.) CRYPTO 2000. LNCS, vol. 1880, pp.
197–215. Springer, Heidelberg (2000)
214 K. Yasuda
7. Black, J.A., Rogaway, P.: A Block-Cipher Mode of Operation for Parallelizable
Message Authentication. In: Knudsen, L.R. (ed.) EUROCRYPT 2002. LNCS,
vol. 2332, pp. 384–397. Springer, Heidelberg (2002)
8. Dodis, Y., Pietrzak, K.: Improving the Security of MACs via Randomized Message
Preprocessing. In: Biryukov, A. (ed.) FSE 2007. LNCS, vol. 4593, pp. 414–433.
Springer, Heidelberg (2007)
9. Iwata, T., Kurosawa, K.: OMAC: One-Key CBC MAC. In: Johansson, T. (ed.)
FSE 2003. LNCS, vol. 2887, pp. 129–153. Springer, Heidelberg (2003)
10. JTC1. ISO/IEC 9797-1:1999 Information technology—Security techniques—
Message Authentication Codes (MACs)—Part 1: Mechanisms using a block cipher
(1999)
11. Kurosawa, K., Iwata, T.: TMAC: Two-Key CBC MAC. In: Joye, M. (ed.) CT-RSA
2003. LNCS, vol. 2612, pp. 33–49. Springer, Heidelberg (2003)
12. Minematsu, K., Matsushima, T.: New Bounds for PMAC, TMAC, and XCBC. In:
Biryukov, A. (ed.) FSE 2007. LNCS, vol. 4593, pp. 434–451. Springer, Heidelberg
(2007)
13. Nandi, M.: Fast and Secure CBC-Type MAC Algorithms. In: Dunkelman, O. (ed.)
FSE 2009. LNCS, vol. 5665, pp. 375–393. Springer, Heidelberg (2009)
14. Nandi, M.: A Unified Method for Improving PRF Bounds for a Class of Blockcipher
Based MACs. In: Hong, S., Iwata, T. (eds.) FSE 2010. LNCS, vol. 6147, pp. 212–
229. Springer, Heidelberg (2010)
15. Petrank, E., Rackoff, C.: CBC MAC for real-time data sources. J. Cryptology 13(3),
315–338 (2000)
16. Preneel, B., van Oorschot, P.C.: MDx-MAC and Building Fast MACs from Hash
Functions. In: Coppersmith, D. (ed.) CRYPTO 1995. LNCS, vol. 963, pp. 1–14.
Springer, Heidelberg (1995)
17. Rogaway, P.: Efficient Instantiations of Tweakable Blockciphers and Refinements
to Modes OCB and PMAC. In: Lee, P.J. (ed.) ASIACRYPT 2004. LNCS, vol. 3329,
pp. 16–31. Springer, Heidelberg (2004)
18. Sarkar, P.: Pseudo-random functions and parallelizable modes of operations of a
block cipher. IEEE Transactions on Information Theory 56(8), 4025–4037 (2010)
19. Yasuda, K.: Multilane HMAC—Security beyond the Birthday Limit. In: Srinathan,
K., Rangan, C.P., Yung, M. (eds.) INDOCRYPT 2007. LNCS, vol. 4859, pp. 18–32.
Springer, Heidelberg (2007)
20. Yasuda, K.: The Sum of CBC MACs Is a Secure PRF. In: Pieprzyk, J. (ed.) CT-
RSA 2010. LNCS, vol. 5985, pp. 366–381. Springer, Heidelberg (2010)
21. Yasuda, K.: A New Variant of PMAC: Beyond the Birthday Bound. In: Rogaway,
P. (ed.) CRYPTO 2011. LNCS, vol. 6841, pp. 596–609. Springer, Heidelberg (2011)
	PMAC with Parity: Minimizing the Query-Length Influence
	Introduction
	Preliminaries
	Description of the New Mode
	Security Proofs
	Smaller-Rate Versions
	Concluding Remarks
	References