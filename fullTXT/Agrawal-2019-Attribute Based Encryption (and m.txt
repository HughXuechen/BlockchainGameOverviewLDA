Attribute Based Encryption (and more) for Nondeterministic Finite Automata from LWE
Attribute Based Encryption (and more)
for Nondeterministic Finite Automata
from LWE
Shweta Agrawal1, Monosij Maitra1, and Shota Yamada2(B)
1 IIT Madras, Chennai, India
{shweta.a,monosij}@cse.iitm.ac.in
2 National Institute of Advanced Industrial Science and Technology (AIST),
Tokyo, Japan
yamada-shota@aist.go.jp
Abstract. Constructing Attribute Based Encryption (ABE) [56] for
uniform models of computation from standard assumptions, is an
important problem, about which very little is known. The only known
ABE schemes in this setting that (i) avoid reliance on multilinear maps or
indistinguishability obfuscation, (ii) support unbounded length inputs and
(iii) permit unbounded key requests to the adversary in the security game,
are by Waters from Crypto, 2012 [57] and its variants. Waters provided
the first ABE for Deterministic Finite Automata (DFA) satisfying the
above properties, from a parametrized or “q-type” assumption over
bilinear maps. Generalizing this construction to Nondeterministic Finite
Automata (NFA) was left as an explicit open problem in the same work,
and has seen no progress to date. Constructions from other assumptions
such as more standard pairing based assumptions, or lattice based
assumptions has also proved elusive.
In this work, we construct the first symmetric key attribute based
encryption scheme for nondeterministic finite automata (NFA) from
the learning with errors (LWE) assumption. Our scheme supports
unbounded length inputs as well as unbounded length machines. In more
detail, secret keys in our construction are associated with an NFA M of
unbounded length, ciphertexts are associated with a tuple (x,m) where
x is a public attribute of unbounded length and m is a secret message
bit, and decryption recovers m if and only if M(x) = 1.
Further, we leverage our ABE to achieve (restricted notions of)
attribute hiding analogous to the circuit setting, obtaining the first
predicate encryption and bounded key functional encryption schemes
for NFA from LWE. We achieve machine hiding in the single/bounded
key setting to obtain the first reusable garbled NFA from standard
assumptions. In terms of lower bounds, we show that secret key
functional encryption even for DFAs, with security against unbounded
key requests implies indistinguishability obfuscation (iO) for circuits; this
suggests a barrier in achieving full fledged functional encryption for NFA.
c© International Association for Cryptologic Research 2019
A. Boldyreva and D. Micciancio (Eds.): CRYPTO 2019, LNCS 11693, pp. 765–797, 2019.
https://doi.org/10.1007/978-3-030-26951-7_26
http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-26951-7_26&domain=pdf
https://doi.org/10.1007/978-3-030-26951-7_26
766 S. Agrawal et al.
1 Introduction
Attribute based encryption (ABE) [56] is an emerging paradigm of encryption
that enables fine grained access control on encrypted data. In attribute based
encryption, a ciphertext of a message m is labelled with a public attribute x
and secret keys are labelled with a Boolean function f . Decryption succeeds to
yield the hidden message m if and only if the attribute satisfies the function,
namely f(x) = 1. Starting with the seminal work of Sahai and Waters [56], ABE
schemes have received a lot of attention in recent years [4,10,20,22,23,26,39–41,
43,45,49,57], yielding constructions for various classes of functions under diverse
assumptions.
In most constructions, the function f embedded in the key is represented
as a circuit. While powerful, circuits are a non-uniform model of computation
which necessitates different representations for different input lengths, forcing
the scheme to provide multiple function keys for the same functionality
as the input length varies. This drawback poses a significant deployment
barrier in many practical application scenarios, since data sizes in the real
world are rarely of fixed length1. Attribute based encryption for uniform
models of computation has also been studied, but so far, we have very few
constructions from standard assumptions. Waters [57] provided a construction
of ABE for Deterministic Finite Automata (DFA) from parametrized or
“q-type” assumptions over bilinear maps. Generalizing this construction to
Nondeterministic Finite Automata (NFA) was left as an explicit open problem2
in [57], and has remained open to date. Constructions from other assumptions
such as more standard pairing based assumptions, or lattice based assumptions
has also proved elusive. Boyen and Li [24] provided a construction of ABE for
DFA from the Learning With Errors (LWE) assumption but this was restricted
to DFAs with bounded length inputs, rendering moot the primary advantage
of a DFA over circuits. Agrawal and Singh [8] constructed a primitive closely
related to ABE for DFA, namely reusable garbled DFA from LWE, but their
construction is limited to a security game where the adversary may only request
a single function key.
From strong assumptions such as the existence of multilinear maps [33],
witness encryption [36] or indistinguishability obfuscation [18,34], attribute
based encryption (indeed, even its more powerful generalization – functional
encryption) has been constructed even for Turing machines [6,14,48], but these
are not considered standard assumptions; indeed many candidate constructions
have been broken [15,27–29,31,32,44,55]. Very recently, Ananth and Fan [10]
constructed ABE for RAM programs from LWE achieving decryption complexity
that is sublinear in the database length. However, the key sizes in their
1 A trivial workaround would be to fix the input length to some fixed upper bound
and pad all data to this bound; but this solution incurs substantial overhead (besides
being inelegant).
2 Note that an NFA can be converted to an equivalent DFA but this transformation
incurs exponential blowup in machine size.
Attribute Based Encryption (and more) for NFA from LWE 767
construction are massive and grow with the size of the entire database as well
as with worst case running time of the program on any input. In particular,
restricting the construction to any model of computation that reads the entire
input string (e.g. DFA, TM) yields a bounded input solution, since the key
size depends on the input length. Similarly, [26,42] construct attribute based
encryption for “bundling functionalities” where the size of the public parameters
does not depend on the size of the input chosen by the encryptor, say �. However,
the key generator must generate a key for a circuit with a fixed input length, say
�′, and decryption only succeeds if � = �′. Thus, bundling functionalities do not
capture the essential challenge of supporting dynamic data sizes; this was noted
explicitly in [42].
Our Results. In this work, we construct the first symmetric key attribute
based encryption scheme for nondeterministic finite automata (NFA) from the
learning with errors (LWE) assumption. Our scheme supports unbounded length
inputs as well as unbounded length machines. In more detail, secret keys in our
construction are associated with an NFA M of unbounded length, ciphertexts
are associated with a tuple (x,m) where x is a public attribute of unbounded
length and m is a secret message bit, and decryption recovers m if and only if
M(x) = 1. Moreover our construction achieves succinct parameters, namely, the
length of the function key and ciphertext grow only with the machine size and
input length respectively (and do not depend on the input length and machine
size respectively).
Further, we leverage our ABE to achieve (restricted notions of) attribute
hiding analogous to the circuit setting, obtaining the first predicate encryption
and bounded key functional encryption schemes for NFA. We achieve machine
hiding in the single key3 setting to obtain the first reusable garbled NFA from
standard assumptions. This improves upon the result of [8], which can only
support a single key request (as against bounded), and only DFAs (as against
NFAs).
The above results raise the question of whether full fledged functional
encryption, which achieves full attribute hiding for NFAs is possible
under standard assumptions. However, we show that secret key functional
encryption even for DFA with security against unbounded key requests implies
indistinguishability obfuscation (iO) for circuits. Since constructing iO for
circuits from standard assumptions is a central challenge in cryptography, this
suggests that there is a barrier in further generalizing our result to achieve full
attribute hiding.
We summarize our results in Table 1.
3 This may be generalized to bounded key, for any a-priori fixed (polynomial) bound.
768 S. Agrawal et al.
Table 1. Prior work and our results. Above, we say that input length supported by a
construction is bounded if the parameters and key lengths depend on the input size.
For attribute hiding, yes∗ indicates hiding in the restricted security games of predicate
or bounded key functional encryption.
Construction Model Input Length Number of
Keys
Attribute
and Function
Hiding
Assumption
Waters [57] DFA unbounded unbounded (no, no) q-type
assumption
on bilinear
maps
Boyen-Li [24] DFA bounded unbounded (no, no) LWE
Agrawal-
Singh
[8]
DFA unbounded single (yes, yes) LWE
Ananth-Fan
[10]
RAM bounded unbounded (no, no) LWE
Section 4 NFA unbounded unbounded (no, no) LWE
Full version NFA unbounded unbounded (yes∗, no) LWE
Full version NFA unbounded bounded (yes, yes) LWE
1.1 Our Techniques
In this section, we provide an overview of our techniques. Before we proceed,
we discuss the technical barriers that arise in following the approaches taken by
prior work. Since the construction by Waters [57] is the only one that supports
unbounded attribute lengths and unbounded key requests by the adversary, 4 it is
the most promising candidate for generalization to NFA. However, the challenges
in generalizing this construction to support NFAs were explicitly discussed in the
same work, and this has seen no progress in the last seven years to the best of our
knowledge, despite the significant research attention ABE schemes have received.
Moreover, even the solution for DFAs is not fully satisfactory since it relies on a
non-standard parametrized or “q-type” assumption.
Boyen and Li [24] attempt to construct ABE for DFAs from the LWE
assumption, but their construction crucially requires the key generator to know
the length of the attribute chosen by the encryptor, since it must provide a fresh
“trapdoor” for each row of the DFA transition table and each input position.
Indeed, reusing the same trapdoor for multiple positions in the input leads to
trivial “mix and match” attacks against their scheme. Thus, it is not even clear
how to obtain ABE for DFA with support for unbounded lengths by following
this route. The work of Agrawal and Singh [8] gives a construction of functional
encryption for DFA from LWE that does handle unbounded length inputs, but
4 The construction is later extended to be adaptively secure rather than selectively
secure (e.g., [16]), but the basic structure of the construction is unchanged.
Attribute Based Encryption (and more) for NFA from LWE 769
only in the limited single key setting. Their construction crucially relies on
reusable garbled circuits [37] which is a single key primitive, and natural attempts
to generalize their construction to support even two keys fails5. Similarly, the
very recent construction of Ananth and Fan [10] is also inherently bounded
length, for reasons similar as those discussed above for [24].
Thus, the handful of existing results in this domain all appear to pose
fundamental barriers to generalization. To overcome this hurdle, we design
completely new techniques to handle the challenge of unbounded length; these
may be applicable elsewhere. We focus on the symmetric key setting, and proceed
in two steps: i) we provide a secret key ABE scheme for NFA that supports
unbounded length inputs but only supports bounded size NFA machines,
and ii) we “bootstrap” the construction of step (i) to handle unbounded
length machines. We additionally achieve various notions of attribute hiding
as discussed above, but will focus on the ABE construction for the remainder of
this overview. We proceed to describe each of these steps in detail.
Constructing NfaABE for Bounded Size NFA. Our first goal is to construct a
secret key ABE scheme for NFA that supports unbounded length inputs but
only supports bounded size NFA machines from the LWE assumption. Since
ABE for circuits has received much success from the LWE assumption [22,39],
our first idea is to see if we can run many circuit ABE schemes “in parallel”,
one for each input length. We refer to our resulting ABE scheme for NFAs as
NfaABE and the ABE for circuits scheme simply as ABE, in order to differentiate
them.
Näıve Approach : We start with the following näıve construction that uses
a (public key) ABE for circuits as an ingredient. The master secret key
of the NfaABE scheme is a PRF key K. This PRF key defines a set of
key pairs {(ABE.mpkj ,ABE.mskj)}j∈[2λ] of the ABE scheme, where each
(ABE.mpkj ,ABE.mskj) is sampled using randomness derived from the PRF key
K and supports circuits with inputs of length j. When one encrypts a message
for a ciphertext attribute x, one chooses the master public key ABE.mpk|x| and
encrypts the message using the key, where |x| is the length of x. We can encrypt
for x with length at most 2λ and therefore can deal with essentially unbounded
length strings as ciphertext attributes. In order to generate a secret key for a
machine M , one has to convert it into a circuit since our underlying ingredient
is an ABE for circuits. The difference between an NFA machine M and a circuit
is that while the former takes a string with arbitrary length as an input, the
input length for the latter is fixed. To fill the gap, we prepare a circuit version of
NFA M for all possible input lengths. Namely, we convert the machine M into
an equivalent circuit ̂Mj with input length j for all j ∈ [2λ]. Then, we generate
ABE secret key associated with ̂Mj by running the key generation algorithm
5 For the knowledgeable reader, bounded key variants of reusable garbled circuits exist,
for instance by applying the compiler of [38], but using this in the aforementioned
construction does not work due to the structure of their construction.
770 S. Agrawal et al.
of the ABE for all j to obtain the NfaABE secret key {ABE.skj}j∈[2λ]. When
decrypting a ciphertext associated with x, the decryptor chooses ABE.sk|x| and
runs the decryption algorithm of the underlying ABE to retrieve the message.
Reducing the Number of Keys : Obviously, there are multiple problems with this
approach. The first problem is that there are 2λ instances of ABE and thus the
secret key of NfaABE is exponentially large. To handle this, we thin out most
of the instances and change the secret key to be {ABE.sk2j }j∈[0,λ]. In order to
make sure that the decryption is still possible even with this change, we modify
the encryption algorithm. To encrypt a message for an attribute x, one chooses
i ∈ [0, λ] such that 2i−1 < |x| ≤ 2i and uses the i-th instance to encrypt the
message, where if the length of x is not exactly 2i, it is padded with blank
symbols to adjust the length. This change reduces the number of instances down
to be polynomial.
Reducing the Size of Keys : However, a bigger problem is that even though we
reduced the number of secret keys, we did not reduce their size, which is still not
polynomial. In particular, there is no guarantee on the size of ABE.sk2λ since
the associated circuit ̂M2λ is of exponential size. Here, we leverage a crucial
efficiency property that is enjoyed by the ABE for circuits constructed by Boneh
et al. [22], namely, that the secret keys in this scheme are very short. The size
of secret keys in their scheme is dependent only on the depth of the circuits
being supported and independent of the input length and size. Thus, if we can
ensure that the depth of ̂M2λ is polynomially bounded (even though the input
is exponentially long), we are back in business.
However, converting the NFA to a circuit requires care. We note that
implementing the trivial approach of converting an NFA to a circuit by keeping
track of all possible states while reading input symbols results in circuit whose
depth is linear in input length, which is exponential. To avoid this, we make use
of a divide and conquer approach to evaluate the NFA, which makes the circuit
depth poly-logarithmic in the input length. As a result, the size of the secret
keys can be bounded by a polynomial as desired.
Efficiency of Key Generation : The final and the most difficult problem to be
addressed is that even though we managed to make the size of {ABE.sk2j }j∈[0,λ]
polynomially bounded, computational time for generating it is still exponentially
large, since so is the size of the associated circuits {̂M2j }j∈[0,λ]. To resolve the
problem, we note that the only algorithm which has the “space” to handle
the unbounded input length is the encryption algorithm. Hence, we carefully
divide the computation of generating {ABE.sk2j }j∈[0,λ] into pieces so that the
key generator only needs to do work proportional to the size of the machine,
the encryptor does work proportional to the size of the input and the decryptor
computes the requisite key on the fly.
To implement this idea, we use succinct single-key functional encryption
(FE), which can be realized from the LWE assumption [2,37]. To support
unbounded input length, we generate λ + 1 instances of the FE scheme to
Attribute Based Encryption (and more) for NFA from LWE 771
obtain {FE.mpkj ,FE.mskj}j∈[0,λ]. The secret key of NfaABE is {FE.ctj}j∈[0,λ],
where FE.ctj = FE.Enc(FE.mpkj , (M,K)) is an encryption of a description
of the associated NFA M and the PRF key K under the j-th instance of
the FE scheme. To provide the matching secret key, the encryptor appends
FE.ski = FE.KeyGen(FE.mski, Ci) to the ciphertext. Here, x is the attribute
vector of unbounded length, i is an integer s.t. 2i−1 < |x| ≤ 2i and Ci is a circuit
that takes as inputs the machine M and PRF key K and outputs an ABE secret
key ABE.sk2i associated with M .
We are almost done – the decryptor chooses FE.cti with appropriate i from
the received set {FE.ctj}j∈[0,λ] and decrypts it using FE.ski that is appended
to the ciphertext to obtain an ABE secret key ABE.sk2i . Then, it decrypts the
ABE ciphertext also provided in the ciphertext to retrieve the message. Note
that our construction is carefully designed so that we only require a single key
of the succinct FE scheme.
Arguing the efficiency of the scheme requires care. In order to make the key
generation algorithm run in polynomial time, we rely on the succinctness of
the underlying FE. Recall that the succinctness property says that the running
time of the encryption algorithm is independent of the size of the circuits being
supported and only dependent on the depth and input and output length. In our
construction, the computation of {FE.ctj = FE.Enc(FE.mpkj , (M,K))}j∈[0,λ] can
be performed in polynomial time, since the input length |M | + |K| is bounded
by a fixed polynomial6 and so is the output length |ABE.sk2j |. Note that we
crucially use the succinctness of the FE here, since the size of the circuit C2j ,
which is supported by the j-th instance of FE, is polynomial in 2j and thus
exponential for j = λ.
Security : Our construction of NfaABE satisfies standard (selective) indistin-
guishability based security. The high level idea of the proof is outlined next.
Intuitively, security follows from the security of the single key FE scheme and
the underlying circuit ABE scheme. In the first step, we show that even though
an adversary can obtain multiple FE ciphertexts and secret keys, it cannot obtain
anything beyond their decryption results {FE.Dec(FE.ski,FE.cti) = ABE.ski} by
the security of the FE. Then, we leverage the security of the ABE to conclude
that the message is indeed hidden. We note that in order to invoke the FE
security, we need to ensure that only single secret key is revealed to the adversary
for each instance of FE. This property is guaranteed, since the circuit for which
a secret key of the j-th instance of FE is generated is fixed (i.e., C2j ). Please see
Sect. 3 for details.
Removing the Size Constraint on NFAs. So far, we have constructed NfaABE for
NFA that can deal with unbounded input length and bounded size NFAs. Let
us call such a scheme (u, b)-NfaABE, where “u” and “b” stand for “unbounded”
and “bounded”. We define (b, u)-NfaABE and (u, u)-NfaABE analogously, where
the first parameter refers to input length and the second to machine size.
6 Recall that we are only dealing with bounded size NFAs.
772 S. Agrawal et al.
Our goal is to obtain (u, u)-NfaABE. At a high level, we compile (u, u)-NfaABE
using two pieces, namely (u, b)-NfaABE which we have already constructed, and
(b, u)-NfaABE, which we will instantiate next.
To construct (b, u)-NfaABE, our basic idea is to simply convert an NFA into
an equivalent circuit and then use existing ABE for circuits schemes [22,39]. This
approach almost works, but we need to exercise care to ensure that the depth
of these circuits can be bounded since we hope to support NFAs of unbounded
size. To fill this gap, we show that an NFA can be converted into an equivalent
circuit whose depth is poly-logarithmic in the size of the NFA by again using the
divide and conquer approach we discussed previously. This enables us to bound
the depth of the circuits by a fixed polynomial, even if the size of corresponding
NFA is unbounded and allows us to use existing ABE schemes for circuits to
construct (b, u)-NfaABE.
We are ready to construct (u, u)-NfaABE by combining (u, b)-NfaABE and
(b, u)-NfaABE. The master secret key of the (u, u)-NfaABE is a PRF key K. This
PRF key defines a set of keys {(u, b)-NfaABE.mskj}j∈[2λ] of the (u, b)-NfaABE
scheme, where each (u, b)-NfaABE.mskj supports NFAs with size j. Similarly,
the PRF key also defines keys {(b, u)-NfaABE.mskj}j∈[2λ] of the (b, u)-NfaABE
scheme, where each (b, u)-NfaABE.mskj supports input strings with length j.
To encrypt a message with respect to a ciphertext attribute x, it encrypts the
message for x using (u, b)-NfaABE.mskj to obtain (u, b)-NfaABE.ctj for all j ∈
[x]. Furthermore, it also encrypts the message for x using (b, u)-NfaABE.msk|x|
to obtain (b, u)-NfaABE.ct|x|. The final ciphertext is
( {(u, b)-NfaABE.ctj}j∈[|x|], (b, u)-NfaABE.ct|x|
)
.
To generate a secret key for a machine M , we essentially swap the roles
of (u, b)-NfaABE and (b, u)-NfaABE. Namely, we generate a secret key
(b, u)-NfaABE.skj for M using (b, u)-NfaABE.mskj for all j ∈ [|M |], where |M |
is the size of the machine M . We also generate (u, b)-NfaABE.sk|M | for M using
(u, b)-NfaABE.msk|M |. The final secret key is
(
(u, b)-NfaABE.sk|M |, {(b, u)-NfaABE.skj}j∈[|M |]
)
.
To decrypt a ciphertext for attribute x using a secret key for an NFA machine
M , we first compare |x| and |M |. If |x| > |M |, it decrypts (u, b)-NfaABE.ct|M |
using (u, b)-NfaABE.sk|M |. Otherwise, it decrypts (b, u)-NfaABE.ct|x| using
(u, b)-NfaABE.sk|x|. It is not hard to see that the correctness of the resulting
scheme follows from those of the ingredients. Furthermore, the security of the
scheme is easily reduced to those of the ingredients, as the construction simply
runs them in parallel with different parameters. The proof is by a hybrid
argument, where we change the encrypted messages in a instance-wise manner.
In Sect. 4, we streamline the construction and directly construct (u, u)-NfaABE
from (u, b)-NfaABE and ABE for circuits instead of going through (b, u)-NfaABE.
Generalizations and Lower Bounds. We further generalize our ABE construction
to obtain predicate encryption and bounded key functional encryption for
Attribute Based Encryption (and more) for NFA from LWE 773
NFAs along with the first construction of resuable garbled NFA. These
constructions are obtained by carefully replacing the underlying ABE for circuits
with predicate encryption, bounded key functional encryption for circuits or
reusable garbled circuits. This compiler requires some care as we need to
argue that the delicate balance of efficiency properties that enable our NfaABE
construction are not violated, as well as ensure that the constructions and
security proofs translate. In the full version, we show that we can indeed ensure
this, sometimes by employing additional tricks as required. In Sect. 5 we show
that secret key functional encryption (SKFE) for DFA with security against
unbounded collusion implies indistinguishability obfuscation for circuits. There,
we essentially show that we can convert an SKFE for DFA into an SKFE for NC1
circuit, which implies indistinguishability obfuscation for circuits by previous
results [9,47]. The conversion is by encoding and purely combinatorial – we first
convert an NC1 circuit into an equivalent branching program and then leverage
the similarity between the branching program and DFA to obtain the result.
Organization of the Paper. In Sect. 2, we provide the definitions and
preliminaries we require. In Sect. 3, we provide our ABE for NFA supporting
unbounded input but bounded machine length. In Sect. 4, we enhance the
construction to support both unbounded input and unbounded machine length.
The extensions of our construction to the setting of bounded key functional
encryption and reusable garbled circuits for NFA will appear in the full version.
In Sect. 5 we show that secret key functional encryption for DFA with security
against unbounded collusion implies indistinguishability obfuscation for circuits.
We conclude in Sect. 6.
2 Preliminaries
In this section, we define some notation and preliminaries that we require.
Notation. We begin by defining the notation that we will use throughout the
paper. We use bold letters to denote vectors and the notation [a, b] to denote
the set of integers {k ∈ N | a ≤ k ≤ b}. We use [n] to denote the set [1, n].
Concatenation is denoted by the symbol ‖.
We say a function f(n) is negligible if it is O(n−c) for all c > 0, and we
use negl(n) to denote a negligible function of n. We say f(n) is polynomial if it
is O(nc) for some constant c > 0, and we use poly(n) to denote a polynomial
function of n. We use the abbreviation PPT for probabilistic polynomial-time.
We say an event occurs with overwhelming probability if its probability is 1 −
negl(n). The function log x is the base 2 logarithm of x. For any finite set S we
denote P(S) to be the power set of S. For a circuit C : {0, 1}�1+�2 → {0, 1} and
a string x ∈ {0, 1}�1 , C[x] : {0, 1}�2 → {0, 1} denotes a circuit that takes y and
outputs C(x,y). We construct C[x] in the following specified way. Namely, C[x]
is the circuit that takes as input y and sets
774 S. Agrawal et al.
zi =
{
y1 ∧ ¬y1 if xi = 0
y1 ∨ ¬y1 if xi = 1
and then computes C(z,y), where xi, yi, and zi are the i-th bit of x, y, and z,
respectively. In the above, it is clear that zi = xi and we have C(z,y) = C(x,y).
Furthermore, it is also easy to see that depth(C[x]) ≤ depth(C) + O(1) holds.
2.1 Definitions: Non Deterministic Finite Automata
A Non-Deterministic Finite Automaton (NFA) M is represented by the tuple
(Q,Σ, T, qst, F ) where Q is a finite set of states, Σ is a finite alphabet, T :
Σ × Q → P(Q) is the transition function (stored as a table), qst is the start
state, F ⊆ Q is the set of accepting states. For states q, q′ ∈ Q and a string
x = (x1, . . . , xk) ∈ Σk, we say that q′ is reachable from q by reading x if there
exists a sequence of states q1, . . . , qk+1 such that q1 = q, qi+1 ∈ T (xi, qi) for
i ∈ [k] and qk+1 = q′. We say M(x) = 1 iff there is a state in F that is reachable
from qst by reading x.
Remark 1. As it is known, we can transform an NFA with ε-transitions into a
one without them by a simple and efficient conversion. The conversion preserves
the size of the NFA. For simplicity and without loss of generality, we do not deal
with an NFA with ε-transitions in this paper.
2.2 Definitions: Secret-Key Attribute Based Encryption for NFA
A secret-key attribute-based encryption (SKABE) scheme NfaABE for a message
space M = {Mλ}λ∈N consists of four algorithms. In the following, we fix some
alphabet Σ = Σλ of size 2 ≤ |Σ| ≤ poly(λ).
– NfaABE.Setup(1λ) is a PPT algorithm takes as input the unary representation
of the security parameter and outputs the master secret key NfaABE.msk.
– NfaABE.Enc(NfaABE.msk,x,m) is a PPT algorithm that takes as input the
master secret key NfaABE.msk, a string x ∈ Σ∗ of arbitrary length and a
message m ∈ M. It outputs a ciphertext NfaABE.ct.
– NfaABE.KeyGen(NfaABE.msk,M) is a PPT algorithm that takes as input the
master secret key NfaABE.msk and a description of an NFA machine M . It
outputs a corresponding secret key NfaABE.skM .
– NfaABE.Dec(NfaABE.skM ,M,NfaABE.ct,x) is a deterministic polynomial
time algorithm that takes as input the secret key NfaABE.skM , its associated
NFA M , a ciphertext NfaABE.ct, and its associated string x and outputs
either a message m′ or ⊥.
Remark 2. In our construction in Sect. 3.2, we will pass an additional parameter
s = s(λ) to the NfaABE.Setup,NfaABE.Enc,NfaABE.KeyGen algorithms denoting
the description size of NFAs that the scheme can deal with. Later we give a
construction in Sect. 4 which can support NFAs with arbitrary size.
Attribute Based Encryption (and more) for NFA from LWE 775
Definition 1 (Correctness). An SKABE scheme NfaABE is correct if for all
NFAs M , all x ∈ Σ∗ such that M(x) = 1 and for all messages m ∈ M,
Pr
⎡
⎢
⎢
⎣
NfaABE.msk ← NfaABE.Setup(1λ) ,
NfaABE.skM ← NfaABE.KeyGen(NfaABE.msk,M) ,
NfaABE.ct ← NfaABE.Enc(NfaABE.msk,x,m) :
NfaABE.Dec
(
NfaABE.skM ,M,NfaABE.ct,x
) �= m
⎤
⎥
⎥
⎦
= negl(λ)
where the probability is taken over the coins of NfaABE.Setup, NfaABE.KeyGen,
and NfaABE.Enc.
Definition 2 (Security for NfaABE). The SKABE scheme NfaABE for a
message space M is said to satisfy selective security if for any stateful PPT
adversary A, there exists a negligible function negl(·) such that AdvNfaABE,A
(1λ, Σ) :=
∣
∣
∣Pr[Exp(0)NfaABE,A(1λ) → 1] − Pr[Exp(1)NfaABE,A(1λ) = 1]
∣
∣
∣ ≤ negl(λ),
where for each b ∈ {0, 1} and λ ∈ N, the experiment Exp(b)NfaABE,A, modeled as a
game between the adversary A and a challenger, is defined as follows:
1. Setup phase: At the beginning of the game, A takes as input 1λ and declares
its target X ⊂ Σ∗, which is a set of strings of arbitrary size. Then the
challenger samples NfaABE.msk ← NfaABE.Setup(1λ).
2. Query phase: During the game, A adaptively makes the following queries,
in an arbitrary order and unbounded many times.
(a) Encryption queries: A submits to the challenger an attribute x ∈ X
and a pair of messages (m(0),m(1)) ∈ (Mλ)2. Then, the challenger replies
with NfaABE.ct ← NfaABE.Enc(NfaABE.msk,x,m(b)) in order.
(b) Key queries: A submits to the challenger an NFA M such that M(x) =
0 for all x ∈ X. Then, the challenger replies with NfaABE.skM ←
NfaABE.KeyGen(NfaABE.msk,M) in order.
3. Output phase: A outputs a guess bit b′ as the output of the experiment.
Remark 3. As noted in Remark 2, our construction in Sect. 3.2 is indexed with
an additional parameter s that specifies the size of NFAs being dealt with. In that
case, the above security definitions are modified so that A chooses 1s in addition
to X (or X and S, in the case of very selective security) at the beginning of the
game and key generation queries are made only for machines with size s.
2.3 Definitions: Attribute Based Encryption and Functional
Encryption for Circuits
Attribute Based Encryption for Circuits. For λ ∈ N, let Cinp,d denote a
family of circuits with inp bit inputs, an a-priori bounded depth d, and binary
output and C = {Cinp(λ),d(λ)}λ∈N. An attribute-based encryption (ABE) scheme
ABE for C over a message space M = {Mλ}λ∈N consists of four algorithms:
776 S. Agrawal et al.
– ABE.Setup(1λ, 1inp, 1d) is a PPT algorithm takes as input the unary
representation of the security parameter, the length inp = inp(λ) of the input
and the depth d = d(λ) of the circuit family Cinp(λ),d(λ) to be supported. It
outputs the master public key and the master secret key (ABE.mpk,ABE.msk).
– ABE.Enc(ABE.mpk,x,m) is a PPT algorithm that takes as input the master
public key ABE.mpk, a string x ∈ {0, 1}inp and a message m ∈ M. It outputs
a ciphertext ABE.ct.
– ABE.KeyGen(ABE.mpk,ABE.msk, C) is a PPT algorithm that takes as input
the master secret key ABE.msk and a circuit C ∈ Cinp(λ),d(λ) and outputs a
corresponding secret key ABE.skC .
– ABE.Dec(ABE.mpk,ABE.skC , C,ABE.ct,x) is a deterministic algorithm that
takes as input the secret key ABE.skC , its associated circuit C, a ciphertext
ABE.ct, and its associated string x and outputs either a message m′ or ⊥.
Definition 3 (Correctness). An ABE scheme for circuits ABE is correct if
for all λ ∈ N, polynomially bounded inp and d, all circuits C ∈ Cinp(λ),d(λ), all
x ∈ {0, 1}inp such that C(x) = 1 and for all messages m ∈ M,
Pr
⎡
⎢
⎢
⎢
⎣
(ABE.mpk,ABE.msk) ← ABE.Setup(1λ, 1inp, 1d),
ABE.skC ← ABE.KeyGen(ABE.mpk,ABE.msk, C),
ABE.ct ← ABE.Enc(ABE.mpk,x,m) :
ABE.Dec
(
ABE.mpk,ABE.skC , C,ABE.ct,x
)
�= m
⎤
⎥
⎥
⎥
⎦
= negl(λ)
where the probability is taken over the coins of ABE.Setup, ABE.KeyGen, and
ABE.Enc.
Definition 4 (Selective Security for ABE). The ABE scheme ABE for a
circuit family C = {Cinp(λ),d(λ)}λ∈N and a message space {Mλ}λ∈N is said to
satisfy selective security if for any stateful PPT adversary A, there exists a
negligible function negl(·) such that
AdvABE,A(1λ) =
∣
∣
∣Pr[Exp(0)ABE,A(1λ) = 1] − Pr[Exp(1)ABE,A(1λ) = 1]
∣
∣
∣ ≤ negl(λ),
for all sufficiently large λ ∈ N, where for each b ∈ {0, 1} and λ ∈ N, the
experiment Exp(b)ABE,A, modeled as a game between adversary A and a challenger,
is defined as follows:
1. Setup phase: On input 1λ,A submits (1inp, 1d) and the target X ⊂
{0, 1}inp,which is a set of binary strings of length inp, to the challenger.
The challenger samples (ABE.mpk,ABE.msk) ← ABE.Setup(1λ, 1inp, 1d) and
replies to A with ABE.mpk.
2. Query phase: During the game, A adaptively makes the following queries,
in an arbitrary order and unbounded many times.
(a) Key Queries: A chooses a circuit C ∈ Cinp,d that satisfies C(x) = 0 for
all x ∈ X. For each such query, the challenger replies with ABE.skC ←
ABE.KeyGen(ABE.mpk,ABE.msk, C).
Attribute Based Encryption (and more) for NFA from LWE 777
(b) Encryption Queries: A submits a string x ∈ X and a pair of equal
length messages (m0,m1) ∈ (M)2 to the challenger. The challenger
replies to A with ABE.ct ← ABE.Enc(ABE.mpk,x,mb).
3. Output phase: A outputs a guess bit b’ as the output of the experiment.
Remark 4. The above definition allows an adversary to make encryption queries
multiple times. More standard notion of the security for an ABE restricts the
adversary to make only a single encryption query. It is well-known that they are
actually equivalent, which is shown by a simple hybrid argument. We adopt the
above definition since it is convenient for our purpose.
In our construction of SKABE for NFA in Sect. 3.2, we will use the ABE
scheme by Boneh et al. [22] as a building block. The following theorem
summarizes the efficiency properties of their construction.
Theorem 1 (Adapted from [22]). There exists a selectively secure ABE
scheme ABE = (ABE.Setup,ABE.KeyGen,ABE.Enc,ABE.Dec) with the following
properties under the LWE assumption.
1. The circuit ABE.Setup(·, ·, ·; ·), which takes as input 1λ, 1inp, 1d, and a
randomness r and outputs ABE.msk = ABE.Setup(1λ, 1inp, 1d; r), can be
implemented with depth poly(λ, d). In particular, the depth of the circuit is
independent of inp and the length of the randomness r.
2. We have |ABE.skC | ≤ poly(λ, d) for any C ∈ Cinp,d, where (ABE.mpk,
ABE.msk) ← ABE.Setup(1λ, 1inp, 1d) and ABE.skC ← ABE.KeyGen(ABE.
mpk,ABE.msk, C). In particular, the length of the secret key is independent
of the input length inp and the size of the circuit C.
3. Let C : {0, 1}inp+� → {0, 1} be a circuit such that we have C[v] ∈ Cinp,d
for any v ∈ {0, 1}�. Then, the circuit ABE.KeyGen(·, ·, C[·]; ·), that takes as
input ABE.mpk, ABE.msk, v, and randomness ̂R and outputs ABE.KeyGen
(ABE.mpk,ABE.msk, C[v]; ̂R), can be implemented with depth depth(C) ·
poly(λ, d).
Functional Encryption for Circuits. For λ ∈ N, let Cinp,d,out denote a
family of circuits with inp bit inputs, depth d, and output length out and C =
{Cinp(λ),d(λ),out(λ)}λ∈N. A functional encryption (FE) scheme FE = (FE.Setup,
FE.KeyGen,FE.Enc,FE.Dec) for C consists of four algorithms:
– FE.Setup(1λ, 1inp, 1d, 1out) is a PPT algorithm takes as input the unary
representation of the security parameter, the length inp = inp(λ) of the input,
depth d = d(λ), and the length of the output out = out(λ) of the circuit family
Cinp(λ),d(λ),out(λ) to be supported. It outputs the master public key FE.mpk and
the master secret key FE.msk.
– FE.KeyGen(FE.mpk,FE.msk, C) is a PPT algorithm that takes as input the
master public key FE.mpk, master secret key FE.msk, and a circuit C ∈
Cinp(λ),d(λ),out(λ) and outputs a corresponding secret key FE.skC .
778 S. Agrawal et al.
– FE.Enc(FE.mpk,x) is a PPT algorithm that takes as input the master public
key FE.mpk and an input message x ∈ {0, 1}inp(λ) and outputs a ciphertext
FE.ct.
– FE.Dec(FE.mpk,FE.skC ,FE.ct) is a deterministic algorithm that takes as input
the master public key FE.mpk, a secret key FE.skC and a ciphertext FE.ct and
outputs C(x).
Definition 5 (Correctness). A functional encryption scheme FE is correct if
for all C ∈ Cinp(λ),d(λ),out(λ) and all x ∈ {0, 1}inp(λ),
Pr
⎡
⎢
⎣
(FE.mpk,FE.msk) ← FE.Setup(1λ, 1inp(λ), 1d(λ), 1out(λ));
FE.skC ← FE.KeyGen(FE.mpk,FE.msk, C);
FE.Dec
(
FE.mpk,FE.skC ,FE.Enc(FE.mpk,x)
)
�= C(x)
⎤
⎥
⎦ = negl(λ)
where the probability is taken over the coins of FE.Setup, FE.KeyGen, FE.Enc
and, FE.Dec).
We then define full simulation based security for single key FE as in [37,
Definition 2.13].
Definition 6 (FULL-SIM Security). Let FE be a functional encryption scheme
for a circuits. For a stateful PPT adversary A and a stateless PPT simulator
Sim, consider the following two experiments:
ExprealFE,A(1λ): ExpidealFE,Sim(1λ):
1: (1inp, 1d, 1out) ← A(1λ)
2: (FE.mpk,FE.msk)
← FE.Setup(1λ, 1inp, 1d, 1out)
3: C ← A(FE.mpk)
4: FE.skC
← FE.KeyGen(FE.mpk,FE.msk, C)
5: α ← AFE.Enc(FE.mpk,·)(FE.mpk,FE.skC)
1: (1inp, 1d, 1out) ← A(1λ)
2: (FE.mpk,FE.msk)
← FE.Setup(1λ, 1inp, 1d, 1out)
3: C ← A(FE.mpk)
4: FE.skC
← FE.KeyGen(FE.mpk,FE.msk, C)
5: α ← AO(·)(FE.mpk,FE.skC)
Here, O(·) is an oracle that on input x from A, runs Sim with inputs
(FE.mpk, skC , C, C(x), 1inp) to obtain a ciphertext FE.ct and returns it to the
adversary A.
The functional encryption scheme FE is then said to be single query
FULL-SIM secure if there exists a PPT simulator Sim such that for
every PPT adversary A, the following two distributions are computationally
indistinguishable:
{
ExprealFE,A(1λ)
}
λ∈N
c≈
{
ExpidealFE,Sim(1λ)
}
λ∈N
Attribute Based Encryption (and more) for NFA from LWE 779
Remark 5. The above definition allows an adversary to make encryption queries
multiple times. In the security notion defined in [37], the adversary is allowed to
make only a single encryption query. Similarly to the case of ABE, it is easy to
see that these definitions are actually equivalent (See Remark 4). We adopt the
above definition since it is convenient for our purpose.
In our construction of SKABE for NFA in Sect. 3.2, we will use the FE scheme
by Goldwasser et al. [37] as a building block. The following theorem summarizes
the efficiency properties of their construction.
Theorem 2 ([37]). There exists an FE scheme FE = (FE.Setup,FE.KeyGen,
FE.Enc,FE.Dec) with the following properties.
1. For any polynomially bounded inp(λ), d(λ), out(λ), all the algorithms in FE
run in polynomial time. Namely, the running time of FE.Setup and FE.Enc
do not depend on the size of circuit description to be supported by the scheme.
2. Assuming the subexponential hardness of the LWE problem, the scheme
satisfies full-simulation-based security.
We note that the first property above is called succinctness or semi-compactness
of FE. A stronger version of the efficiency property called compactness requires
the running time of the encryption algorithm to be dependent only on the
length of input message x. An FE with compactness is known to imply
indistinguishability obfuscation [12,21].
3 Attribute-Based Encryption for NFA
3.1 NFA as NC Circuit
Here, we introduce a theorem that provides an efficient algorithm that converts
an NFA into an equivalent circuit with shallow depth. The shallowness of the
circuit will play a crucial role in our construction of SKABE for NFA. In the
following, for ease of notation, we often input a string in Σ∗ to a circuit with the
understanding that the input is actually a binary string encoding a string in Σ∗.
To do so, we set η := �log(|Σ|+1)� and regard a symbol in Σ as a binary string
in {0, 1}η by a natural injection map from Σ to {0, 1}η. Furthermore, we also
introduce a special symbol ⊥ that is not in Σ and assign an unused symbol in
{0, 1}η to it. Intuitively, ⊥ represents a blank symbol that will be used to adjust
the length of a string. We will use alphabets {0, 1}η and Σ∪{⊥} interchangeably.
Theorem 3. Let Σ be an alphabet for NFAs. Then we have the following:
1. There exists a family of circuits {To-Circuits,�}s,�∈N where the circuit
To-Circuits,� takes as input an NFA M with size s and outputs a circuit
780 S. Agrawal et al.
̂M� : (Σ ∪ {⊥})� → {0, 1}. Furthermore, for all �, s ∈ N, all string x ∈ Σ≤�,
and all NFA M with size s, we have
̂M�(x̂) = M(x),
where ̂M� = To-Circuits,�(M) and x̂ = x‖⊥�−|x|.
2. The depths of the circuits To-Circuits,� and ̂M� = To-Circuits,�(M) for an NFA
M of size s are bounded by poly(log s, log �). Furthermore, the sizes of these
circuits are bounded by poly(s, �).
The proof is by divide and conquer and will appear in the full version.
3.2 Construction: SKABE for Bounded Size NFA
We construct an SKABE scheme for NFA denoted by NfaABE = (NfaABE.Setup,
NfaABE.KeyGen,NfaABE.Enc,NfaABE.Dec) from the following ingredients:
1. PRF = (PRF.Setup,PRF.Eval): a pseudorandom function, where a PRF key
K ← PRF.Setup(1λ) defines a function PRF.Eval(K, ·) : {0, 1}λ → {0, 1}. We
denote the length of K by |K|.
2. FE = (FE.Setup,FE.KeyGen,FE.Enc,FE.Dec): a functional encryption scheme
for circuit with the efficiency property described in Item 1 of Theorem 2. We
can instantiate FE with the scheme proposed by Goldwasser et al. [37].
3. ABE = (ABE.Setup,ABE.KeyGen,ABE.Enc,ABE.Dec): An ABE scheme that
satisfies the efficiency properties described in Theorem 1. We can instantiate
ABE with the scheme proposed by Boneh et al. [22].
4. U(·, ·): a universal circuit that takes as input a circuit C of fixed depth and size
and an input x to the circuit and outputs C(x). We often denote by U [C](·) =
U(C, ·) a universal circuit U with the first input C being hardwired. We need
to have depth(U) ≤ O(depth(C)). For construction of such a universal circuit,
we refer to [30].
Below we provide our construction for SKABE for NFA. In the description
below, we abuse notation and denote as if the randomness used in a PPT
algorithm was a key K of the pseudorandom function PRF. Namely, for a
PPT algorithm (or circuit) A that takes as input x and a randomness r ∈
{0, 1}� and outputs y, A(x;K) denotes an algorithm that computes r :=
PRF(K, 1)‖PRF(K, 2)‖ · · · ‖PRF(K, �) and runs A(x; r). Note that if A is a circuit,
this transformation makes the size of the circuit polynomially larger and adds a
fixed polynomial overhead to its depth. In particular, even if we add this change
to ABE.Setup and ABE.KeyGen, the efficiency properties of ABE described in
Theorem 1 is preserved.
NfaABE.Setup(1λ, 1s): On input the security parameter 1λ and a description size
s of an NFA, do the following:
1. For j ∈ [0, λ], sample PRF keys ̂Kj ,Rj ← PRF.Setup(1λ).
Attribute Based Encryption (and more) for NFA from LWE 781
2. For j ∈ [0, λ], sample (FE.mpkj ,FE.mskj) ← Setup(1λ, 1inp(λ), 1out(λ),
1d(λ)).
Here, we generate λ + 1 instances of FE. Note that all instances support
a circuit class with input length inp(λ) = s + 2|K|, output length out(λ),
and depth d(λ), where out(λ) and d(λ) are polynomials in the security
parameter that will be specified later.
3. Output NfaABE.msk = ({̂Kj ,Rj ,FE.mpkj ,FE.mskj}j∈[0,λ]).
NfaABE.Enc(NfaABE.msk,x, m, 1s): On input the master secret key NfaABE.msk,
an attribute x ∈ Σ∗ of length at most 2λ, a message m and the description
size s of NFA, do the following:
1. Parse the master secret key as NfaABE.msk → ({̂Kj ,Rj ,FE.mpkj ,
FE.mskj}j∈[0,λ]).
2. Set x̂ = x‖⊥2i−�, where � = |x| and i = �log ��.
3. Compute an ABE key pair (ABE.mpki,ABE.mski) = ABE.Setup
(1λ, 12
iη, 1d̂; ̂Ki) with ̂Ki as the randomness.
Here, we generate an instance of ABE that supports a circuit class with
input domain {0, 1}2iη ⊇ (Σ ∪ {⊥})2
i
and depth d̂.
4. Compute ABE.ct ← ABE.Enc(ABE.mpki, x̂,m) as an ABE ciphertext for
the message m under attribute x̂.
5. Obtain FE.ski = FE.KeyGen(FE.mpki,FE.mski, Cs,2i ;Ri), where Cs,2i is a
circuit described in Fig. 1.
6. Output NfaABE.ct = (FE.ski,ABE.mpki,ABE.ct).
Fig. 1. The description of the circuit.
NfaABE.KeyGen(NfaABE.msk,M , 1s): On input the master secret key NfaABE.
msk, the description of an NFA M and a size s of the NFA, if |M | �= s, output
⊥ and abort. Else, proceed as follows.
1. Parse the master secret key as NfaABE.msk → ({̂Kj ,Rj ,FE.mpkj ,
FE.mskj}j∈[0,λ]).
2. Sample ̂Rj ← PRF.Setup(1λ) for all j ∈ [0, λ].
3. Compute FE.ctj = FE.Enc(FE.mpkj , (M, ̂Kj , ̂Rj)) for all j ∈ [0, λ].
4. Output NfaABE.skM = {FE.ctj}j∈[0,λ].
NfaABE.Dec(NfaABE.skM ,M,NfaABE.ct,x): On input a secret key for NFA M
and a ciphertext encoded under attribute x, proceed as follows:
782 S. Agrawal et al.
1. Parse the secret key as NfaABE.skM → {FE.ctj}j∈[0,λ] and the ciphertext
as NfaABE.ct → (FE.ski,ABE.mpki,ABE.ct).
2. Set � = |x| and choose FE.cti from NfaABE.skM = {FE.ctj}j∈[0,λ] such
that i = �log �� < λ.
3. Compute y = FE.Dec(FE.mpki,FE.ski,FE.cti).
4. Compute and output z = ABE.Dec(ABE.mpki, y, U [̂M2i ],ABE.cti, x̂),
where we interpret y as an ABE secret key and x̂ = x‖⊥2i−�.
3.3 Correctness of NfaABE
The following theorem asserts that our scheme is efficient. This directly follows
from Theorem 3 and the efficiency of the underlying scheme NfaABE. We refer
to full version for the formal proof.
Theorem 4. Let |Σ|, d(λ), d̂(λ), and out(λ), be polynomials in λ. Then,
NfaABE = (NfaABE.Setup,NfaABE.KeyGen,NfaABE.Enc,NfaABE.Dec) defined
above runs in polynomial time.
The following theorem addresses the correctness of the scheme.
Theorem 5. For appropriately chosen d̂(λ), out(λ), and d(λ), our scheme
NfaABE is correct for any polynomially bounded s(λ).
Proof. We have to show that if we set d̂(λ), out(λ), and d(λ) appropriately, we
have z = m when M(x) = 1, where z is the value retrieved in Step 3.2 of the
decryption algorithm. To show this, let us set d̂(λ) = Ω(λ) and assume that
y = ABE.KeyGen(ABE.mpki,ABE.mski, U [̂M2i ]; ̂Ri) (3.1)
holds for the moment, where y is the value retrieved in Step 3.2 of the decryption
algorithm. Then, we have z = m by the correctness of ABE if U [̂M2i ] is supported
by the scheme, since we have
U [̂M2i ](x̂) = ̂M2i(x̂) = M(x) = 1
by Item 1 of Theorem 3. We claim that the depth of U [̂M2i ] is at most d̂ and
therefore U [̂M2i ] is indeed supported by the scheme. To see this, we observe
that
depth(U [̂M2i ]) ≤ depth(U(·, ·)) + O(1)
≤ O(1) · depth(̂M2i) + O(1)
≤ poly(log s, log 2i)
≤ poly(log λ)
≤ d̂ (3.2)
Attribute Based Encryption (and more) for NFA from LWE 783
holds, where the second inequality follows from the property of the depth
preserving universal circuit U and the third from Item 2 of Theorem 3.
It remains to prove that Eq. (3.1) holds if we set d(λ) and out(λ)
appropriately. To do so, we show that the depth and the output length of Cs,2i
are bounded by some fixed polynomials. By taking d(λ) and out(λ) larger than
these polynomials, we can ensure that the circuit Cs,2i is supported by the FE
scheme and thus Eq. (3.1) follows from the correctness of the FE, since we have
Cs,2i(M, ̂Ki, ̂Ri) = ABE.KeyGen(ABE.mpki,ABE.mski, U [̂M2i ]; ̂Ri),
where (ABE.mpki,ABE.mski) = ABE.Setup(1λ, 12
iη, 1d̂; ̂Ki) by the definition of
Cs,2i . We first bound the depth of Cs,2i . To do so, we first observe that Step 2 of
Cs,2i can be implemented by a circuit of depth poly(λ, d̂) = poly(λ) by Item 1
of Theorem 1. We then observe that Step 3 of Cs,2i can be implemented by a
circuit of depth poly(log s, log 2i) = poly(log λ) by Item 2 of Theorem 3. We
then bound the depth of the circuit that implements Step 4 of Cs,2i . This
step is implemented by the circuit ABE.KeyGen(·, ·, U [·]; ·) that takes as input
ABE.mpki, ABE.mski, U [̂M2i ] constructed in the previous step, and ̂R and returns
ABE.KeyGen(ABE.mpki,ABE.mski, U [̂M2i ]; ̂R). We have
depth(ABE.KeyGen(·, ·, U [·]; ·)) ≤ poly(λ, d̂) · depth(U(·, ·))
≤ poly(λ, d̂) · d̂
≤ poly(λ),
where the first inequality follows from Item 3 of Theorem 1 and the second from
Eq. (3.2). To sum up, we have that the depth of the circuit Cs,2i is bounded by
some fixed polynomial.
We next bound the output length of Cs,2i . Since the output of the circuit
is ABE.sk
U [̂M2i ]
= ABE.KeyGen(ABE.mpki,ABE.mski, U [̂M2i ]; ̂R), we bound the
length of the ABE secret key. We have
|ABE.sk
U [̂M2i ]
| ≤ poly(λ, d̂) ≤ poly(λ,poly(λ)) ≤ poly(λ)
as desired, where the first inequality follows from the Item 2 of Theorem 1. This
completes the proof of the theorem.
3.4 Proof of Security for NfaABE
Here, we prove that NfaABE defined above is secure, if so are FE and ABE.
Formally, we have the following theorem.
Theorem 6. Assume that FE satisfies full simulation based security, ABE is
selectively secure, and that PRF is a secure pseudorandom function. Then,
NfaABE satisfies selective security.
784 S. Agrawal et al.
Proof. To prove the theorem, let us fix a PPT adversary A and introduce the
following game Gamei between the challenger and A for i ∈ [0, λ].
Gamei: The game proceeds as follows.
Setup phase. At the beginning of the game, A takes 1λ as input and submits
1s and the set of its target X ⊂ Σ∗ to the challenger. Then, the challenger
chooses NfaABE.msk ← NfaABE.Setup(1λ, 1s)
The challenger answers the encryption and key queries made by A as follows.
Encryption queries. Given two messages (m(0),m(1)) and x ∈ X from A,
the challenger sets � := |x| and computes
NfaABE.ct =
{
NfaABE.Enc(NfaABE.msk, x̂,m(0)) If �log �� ≥ i
NfaABE.Enc(NfaABE.msk, x̂,m(1)) If �log �� ≤ i − 1.
Then, it returns NfaABE.ct to A.
Key queries. Given an NFA M from A, the challenger runs NfaABE.skM ←
NfaABE.KeyGen(NfaABE.msk,M) and returns NfaABE.skM to A.
Finally, A outputs its guess b′.
In the following, let Exxx denote the probability that A outputs 1 in Gamexxx. It
suffices to prove |Pr[E0] − Pr[Eλ+1]| = negl(λ), since Game0 (resp., Gameλ+1)
corresponds to the selective security game with b = 0 (resp., b = 1). Since we
have
|Pr[E0] − Pr[Eλ+1]| ≤
∑
i∈[0,λ]
|Pr[Ei] − Pr[Ei+1]|
by the triangle inequality, it suffices to show |Pr[Ei] − Pr[Ei+1]| = negl(λ) for
i ∈ [0, λ]. Let us define �max and imax as
�max := max{|x| : x ∈ X} and imax := �log �max�.
Note that �max is bounded by the running time of A and thus is polynomial in
λ. We then observe that for i > imax, we have Gamei = Gameλ+1 and thus
Pr[Ei] − Pr[Ei+1] = 0. Therefore, in the following, we will show that |Pr[Ei] −
Pr[Ei+1]| = negl(λ) holds for i ≤ imax. To do so, we further introduce the
following sequence of games for i ∈ [0, imax]:
Gamei,0: The game is the same as Gamei.
Gamei,1: In this game, we change the setup phase and the way encryption
queries are answered as follows.
Setup phase. Given X ⊂ Σ∗ from A, the challenger chooses NfaABE.msk ←
NfaABE.Setup(1λ, 1s) as in the previous game. In addition, it computes
(ABE.mpki,ABE.mski) ← ABE.Setup(1λ, 12
iη, 1d̂; ̂Ki)
and
FE.ski ← FE.KeyGen(FE.mpki,FE.mski, Cs,2i ;Ri).
Attribute Based Encryption (and more) for NFA from LWE 785
Encryption queries. Given two messages (m(0),m(1)) and x ∈ X from A,
the challenger sets � := |x| and computes NfaABE.ct as in the previous
game if �log �� �= i. Otherwise, it computes
ABE.ct ← ABE.Enc(ABE.mpki, x̂,m(0))
and returns NfaABE.ct = (FE.ski,ABE.mpki,ABE.ct) to A, where FE.ski
and ABE.mpki are the values that are computed in the setup phase.
Gamei,2: In this game, the challenger samples FE.ski as
FE.ski ← FE.KeyGen(FE.mpki,FE.mski, Cs,2i)
in the setup phase. Namely, it is sampled using true randomness instead of
the pseudorandom bits derived from the PRF key Ri.
Gamei,3: We change the way key queries are answered as follows:
Key queries. Given an NFA M of size s from A, the challenger answers the
query as follows. It first chooses ̂Rj ← PRF.Setup(1λ) for j ∈ [0, λ] and
computes
ABE.sk
U [̂M2i ]
= ABE.KeyGen(ABE.mpki,ABE.mski, U [̂M2i ]; ̂Ri),
where ABE.mpki and ABE.mski are the values that are computed in the
setup phase. It then computes FE.ctj ←
{
FE.Enc(FE.mpkj , (M, ̂Kj , ̂Rj)) If j ∈ [0, λ]\{i}
Sim(FE.mpki,FE.ski, Cs,2i ,ABE.sk
U [̂M2i ]
, 1inp(λ)) If j = i.
(3.3)
Then, it returns NfaABE.skM := {FE.ctj}j∈[0,λ] to A.
Gamei,4: In this game, the challenger samples (ABE.mpki,ABE.mski) in the
setup phase as
(ABE.mpki,ABE.mski) ← ABE.Setup(1λ, 12
iη, 1d̂).
It also generates ABE.sk
U [̂M2i ]
as
ABE.sk
U [̂M2i ]
← ABE.KeyGen(ABE.mpki,ABE.mski, U [̂M2i ]).
when answering a key query. Namely, they are sampled using true randomness
instead of the pseudorandom bits derived from the PRF keys ̂Ki and ̂Ri.
Gamei,5: In this game, we change the way the encryption queries are answered
as follows.
Encryption queries. Given two messages (m(0),m(1)) and x ∈ X from A,
the challenger sets � := |x| and computes NfaABE.ct as in the previous
game if �log �� �= i. Otherwise, it computes
ABE.ct = ABE.Enc(ABE.mpki, x̂,m(1))
and returns NfaABE.ct = (FE.ski,ABE.mpki,ABE.ct) to A, where FE.ski
and ABE.mpki are the values that are computed in the setup phase.
786 S. Agrawal et al.
Gamei,6: The game is the same as Gamei+1.
Since we have
|Pr[Ei] − Pr[Ei+1]| ≤
∑
j∈[6]
|Pr[Ei,j−1] − Pr[Ei,j ]|
by the triangle inequality, it suffices to show |Pr[Ei,j−1] − Pr[Ei,j ]| = negl(λ) for
j ∈ [6]. To complete the proof of the theorem, it remains to prove the following
lemmas.
Lemma 1. We have Pr[Ei,0] = Pr[Ei,1].
Proof. The change introduced here is only conceptual, where ABE.mpki and
FE.ski are computed beforehand. The lemma trivially follows.
Lemma 2. We have |Pr[Ei,1] − Pr[Ei,2]| = negl(λ).
Proof. We observe that Ri is used only when generating FE.ski in Gamei,1.
Therefore, the lemma follows by a straightforward reduction to the security of
PRF.
Lemma 3. We have |Pr[Ei,2] − Pr[Ei,3]| = negl(λ).
Proof. To prove the lemma, let us assume that |Pr[Ei,2] − Pr[Ei,3]| is non-
negligible and construct an adversary B that breaks the full simulation security
of FE using A. B proceeds as follows.
Setup phase. At the beginning of the game, B inputs 1λ to A and obtains 1s
and X ⊂ Σ∗ from A. Then B submits its target (1λ, 1inp(λ), 1out(λ)). Then,
the experiment samples
(FE.mpk,FE.msk) ← FE.Setup(1λ, 1inp(λ), 1out(λ))
and returns FE.mpk to B. B then sets FE.mpki := FE.mpk. In the rest of the
simulation, it implicitly sets FE.mski := FE.msk without knowing the value.
B then chooses (FE.mpkj ,FE.mskj) ← FE.Setup(1λ, 1inp(λ), 1out(λ), 1d(λ)) for
j ∈ [0, λ]\{i}. It also chooses ̂Kj ,Rj ← PRF.Setup(1λ) for j ∈ [0, λ]
and (ABE.mpki,ABE.mski) ← ABE.Setup(1λ, 12
iη, 1d̂; ̂Ki). Finally, it declares
Cs,2i as a circuit for which it request a secret key. Then, the experiment runs
FE.sk ← FE.KeyGen(FE.mpk,FE.msk, Cs,2i)
and returns FE.sk to B. B sets FE.ski := FE.sk.
B then handles the encryption and key queries as follows.
Attribute Based Encryption (and more) for NFA from LWE 787
Encryption queries. Given two messages (m(0),m(1)) and x ∈ X from A,
B sets � := |x| and i′ = �log ��. If i′ �= i, B answers the query using
(̂Ki′ ,Ri′ ,FE.mpki′ ,FE.mski′). Otherwise, it computes ABE.ct ← ABE.Enc
(ABE.mpki, x̂,m(0)) and returns NfaABE.ct = (FE.ski,ABE.mpki,ABE.ct) to
A, where ABE.mpki (resp., FE.ski) is the value sampled by itself (resp., by
the experiment) in the setup phase.
Key queries. Given an NFA M of size s from A, B first chooses ̂Rj ←
PRF.Setup(1λ) for j ∈ [0, λ] and computes FE.ctj = FE.Enc(FE.mpkj ,
(M, ̂Kj , ̂Rj)) for j ∈ [0, λ]\{i}. B then submits (M, ̂Ki, ̂Ri) to its encryption
oracle. Then, the experiment computes FE.ct ←
{
FE.Enc(FE.mpk, (M, ̂Ki, ̂Ri)) If B is in ExprealFE,B(1λ)
Sim(FE.mpk,FE.sk, Cs,2i , Cs,2i(M, ̂Ki, ̂Ri), 1inp(λ)) If B is in ExpidealFE,Sim(1λ)
(3.4)
and returns FE.ct to B. B then sets FE.cti := FE.ct and returns
NfaABE.skM := {FE.ctj}j∈[0,λ] to A.
Output phase: B outputs the same bit as A as its guess.
It is easy to see that B simulates Gamei,2 if B is in the real game. We then
claim that B simulates Gamei,3 if B is in the simulated game. The only
difference between these games is the way FE.cti is computed. In Gamei,3, it is
generated as Eq. (3.3) while in the simulation above, it is generated as Eq. (3.4)
(with B being in ExpidealFE,Sim). However, they are equivalent because B has set
(FE.mpki,FE.mski) := (FE.mpk,FE.msk) and FE.ski := FE.sk and we have
Cs,2i(M, ̂Ki, ̂Ri) = ABE.KeyGen(ABE.mpki,ABE.mski, U [̂M2i ]; ̂Ri) = ABE.skU [̂M2i ]
.
From the above observation, we can see that B breaks the security of FE if
A distinguishes the two games. This completes the proof of the lemma.
Lemma 4. We have |Pr[Ei,3] − Pr[Ei,4]| = negl(λ).
Proof. Due to the change we introduced, ̂Ki is not used to answer the encryption
queries any more and used only when generating (ABE.mpki,ABE.mski) in
Gamei,3. We also observe that ̂Ri is used only when generating ABE.sk
U [̂M2i ]
.
Therefore, the lemma follows by straightforward reductions to the security of
PRF.
Lemma 5. We have |Pr[Ei,4] − Pr[Ei,5]| = negl(λ).
Proof. To prove the lemma, let us assume that |Pr[Ei,4] − Pr[Ei,5]| is non-
negligible and construct an adversary B that breaks the selective security of
ABE using A. B proceeds as follows.
788 S. Agrawal et al.
Setup phase. At the beginning of the game, B inputs 1λ to A and obtains 1s
and X ⊂ Σ∗ from A. Then, B sets Xi := {x̂ = x‖⊥2i−|x| : x ∈ X, 2i−1 <
|x| ≤ 2i} and submits its target Xi and (1λ, 12
iη, 1d̂) to its challenger. Then,
the challenger samples
(ABE.mpk,ABE.msk) ← ABE.Setup(1λ, 12
iη, 1d̂)
and returns ABE.mpk to B. B then sets ABE.mpki := ABE.mpk. In the rest
of the simulation, it implicitly sets ABE.mski := ABE.msk without knowing
the value. It then chooses ̂Kj ,Rj ← PRF.Setup(1λ) for j ∈ [0, λ]\{i} and
(FE.mpkj ,FE.mskj) ← Setup(1λ, 1inp(λ), 1out(λ), 1d(λ)) for j ∈ [0, λ]. It also
computes FE.ski ← FE.KeyGen(FE.mpki,FE.mski, Cs,2i).
B then handles the encryption and key queries as follows.
Encryption queries. Given two messages (m(0),m(1)) and x ∈ X from A, B
sets � := |x| and i′ = �log ��. If i′ �= i, B answers the encryption query using
(̂Ki′ ,Ri′ ,FE.mpki′ ,FE.mski′). Otherwise, B makes an encryption query for the
attribute x̂ = x‖⊥2i−� and messages (m(0),m(1)) to its challenger. Then, the
challenger runs
ABE.ct ← ABE.Enc(ABE.mpk, x̂,m(b))
and returns a ciphertext ABE.ct to B. Then, it returns NfaABE.ct = (FE.ski,
ABE.mpki,ABE.ct) to A. Here, B uses FE.ski that is sampled in the setup
phase.
Key queries. Given an NFA M of size s from A, B first chooses ̂Rj ←
PRF.Setup(1λ) for j ∈ [0, λ]\{i}. It then queries a secret key for U [̂M2i ]
to its challenger. Then, the challenger runs
ABE.sk
U [̂M2i ]
← ABE.KeyGen(ABE.mpk,ABE.msk, U [̂M2i ])
and returns ABE.sk
U [̂M2i ]
to B. It then computes FE.ctj for j ∈ [0, λ] as
Eq. (3.3) and returns NfaABE.skM := {FE.ctj}j∈[0,λ] to A.
Output phase: B outputs the same bit as A as its guess.
It is easy to see that B simulates Gamei,4 if b = 0 and Gamei,5 if b = 1.
Therefore, B breaks the security of ABE if A distinguishes the two games. It
remains to prove that B is a legitimate adversary (i.e., it does not make any
prohibited key queries). For any attribute x̂ for which B makes an encryption
query and for any circuit U [̂M2i ] for which B makes a key query, we have
U [̂M2i ](x̂) = ̂M2i(x̂) = M(x),
where the second equality above follows from Item 1 of Theorem 3. Therefore,
B is a legitimate adversary as long as so is A. This completes the proof of the
lemma.
Attribute Based Encryption (and more) for NFA from LWE 789
Lemma 6. We have |Pr[Ei,5] − Pr[Ei,6]| = negl(λ).
Proof. This follows as in the indistinguishability of Gamei,0 and Gamei,4, but
in the reverse order. That is, we first change the random bits used in ABE.KeyGen
to a pseudorandom one by invoking the security of PRF. We then generate FE.cti
by using FE.Enc instead of Sim by invoking the full-simulation security of FE.
Finally, we change the random bits used in ABE.KeyGen to a pseudorandom one
by invoking the security of PRF again.
This concludes the proof of Theorem6.
3.5 Extensions
In the full version, we adapt our ABE construction to achieve (restricted
versions of) attribute privacy. In more detail, we construct secret key predicate
encryption and bounded key functional encryption for nondeterministic finite
automata. We also additionally achieve machine privacy, improving the result of
[8]. Intuitively, these results proceed by replacing the “inner” circuit ABE scheme
in our compiler by predicate encryption or bounded key functional encryption
scheme and arguing that the requisite efficiency requirements (Theorem 1) are
not violated. We again refer to the full version for details.
4 Attribute Based Encryption for NFA with Unbounded
Size Machines and Inputs
In this section we construct a secret-key attribute-based encryption scheme
(SKABE) for nondeterministic finite automata of arbitrary sizes supporting
inputs of arbitrary length. We denote our scheme by uNfaABE =
(uNfaABE.Setup, uNfaABE.KeyGen, uNfaABE.Enc, uNfaABE.Dec) and its con-
struction uses the following two ingredients.
1. NfaABE = (NfaABE.Setup,NfaABE.KeyGen,NfaABE.Enc,NfaABE.Dec): An
SKABE for NFA supporting inputs of unbounded length but for bounded size
machines. We instantiate NfaABE from our construction in Sect. 3.2.
2. ABE = (ABE.Setup,ABE.KeyGen,ABE.Enc,ABE.Dec): An ABE scheme for
circuits that satisfies the efficiency properties described in Theorem 1. We
can instantiate ABE with the scheme proposed by Boneh et al. [22].
3. PRF = (PRF.Setup,PRF.Eval): a pseudorandom function, where a PRF
key K ← PRF.Setup(1λ) defines a function PRF.Eval(K, ·) : {0, 1}λ → R,
where we assume R to be the randomness space of both NfaABE.Setup and
ABE.Setup algorithms. Note that without loss of generality, we may assume
R = {0, 1}p(λ) for some sufficiently large polynomial p(λ).
790 S. Agrawal et al.
Below we provide our construction for SKABE for NFA.
uNfaABE.Setup(1λ): On input the security parameter 1λ, do the following:
1. Sample two PRF keys KNfaABE ← PRF.Setup(1λ),KABE ← PRF.Setup(1λ).
2. Output uNfaABE.msk = (KNfaABE,KABE).
uNfaABE.Enc(uNfaABE.msk,x, m): On input the master secret key
uNfaABE.msk, an attribute as x ∈ Σ∗ of length at most 2λ and a message
m ∈ M, do the following:
1. Parse the master secret key as uNfaABE.msk = (KNfaABE,KABE). Denote
� = |x|.
2. For all i ∈ [�], do the following:
(a) Sample NfaABE.mski ← NfaABE.Setup(1λ, 1i; ri) as an NfaABE
master secret key, where ri = PRF.Eval(KNfaABE, i).
Note that i denotes the size of the NFAs that are supported by
NfaABE.mski.
(b) Compute NfaABE.cti = NfaABE.Enc(NfaABE.mski,x,m, 1i).
3. Sample (ABE.mpk�,ABE.msk�) ← ABE.Setup(1λ, 1�, 1d̂; r�) as an ABE key
pair, where r� = PRF.Eval(KABE, �).
Note that � and d̂ denotes the input length and the depth of the circuit
respectively that (ABE.mpk�,ABE.msk�) supports.
4. Compute ABE.ct� = ABE.Enc(ABE.mpk�,x,m).
5. Output uNfaABE.ct = ({NfaABE.cti}i∈[�],ABE.mpk�,ABE.ct�).
uNfaABE.KeyGen(uNfaABE.msk,M ): On input the master secret key uNfaABE.
msk and the description of a NFA M = (Q,Σ, T, qst, F ), proceed as follows.
1. Parse the master secret key as uNfaABE.msk = (KNfaABE,KABE). Denote
s= |M |.
2. For all i ∈ [s], do the following:
(a) Let ̂Mi = To-Circuits,i(M). (See Theorem 3 for the definition of
To-Circuit.)
(b) Sample (ABE.mpki,ABE.mski) ← ABE.Setup(1λ, 1i, 1d̂; ri) as an ABE
key pair, where ri = PRF.Eval(KABE, i).
(c) Compute ABE.ski = ABE.KeyGen(ABE.mpki,ABE.mski, ̂Mi).
Note that ∀i ∈ [s], i and d̂ denotes the input length and the depth of the
circuit respectively that (ABE.mpki,ABE.mski) supports.
3. Sample NfaABE.msks←NfaABE.Setup(1λ, 1s; rs) as an NfaABE master
secret key, where rs = PRF.Eval(KNfaABE, s).
4. Compute NfaABE.sks = NfaABE.KeyGen(NfaABE.msks,M).
5. Output uNfaABE.skM = (NfaABE.sks, {ABE.mpki,ABE.ski}i∈[s]).
Attribute Based Encryption (and more) for NFA from LWE 791
uNfaABE.Dec(uNfaABE.skM ,M, uNfaABE.ct,x): On input a secret key for NFA
M and a ciphertext encoded under some attribute x, proceed as follows:
1. Parse the secret key as uNfaABE.skM = (NfaABE.sk|M |, {ABE.mpki,
ABE.ski}i∈[|M |]) and the ciphertext as uNfaABE.ct = ({NfaABE.cti}i∈[|x|],
ABE.mpk|x|,ABE.ct|x|).
2. If |x| ≥ |M |, compute and output NfaABE.Dec(NfaABE.sk|M |,M,
NfaABE.ct|M |,x).
3. Otherwise, compute and output ABE.Dec(ABE.mpk|x|,ABE.sk|x|, ̂M|x|,
ABE.ct|x|,x), where ̂M|x| = To-Circuit|M |,|x|(M).
The following theorems assert that our scheme is efficient, satisfies
correctness, and is secure, as long as so are the underlying NfaABE and ABE
schemes. Intuitively, these theorems follow since we simply run these underlying
schemes in parallel. We refer to the full version for the formal proofs.
Theorem 7. The scheme uNfaABE = (uNfaABE.Setup, uNfaABE.KeyGen,
uNfaABE.Enc, uNfaABE.Dec) defined above runs in polynomial time, as long as
d̂ and |Σ| are polynomials in λ.
Theorem 8. For appropriately chosen d̂ = d̂(λ), our scheme uNfaABE is correct
for any NFA.
Theorem 9. Assume that NfaABE and ABE both satisfy selective indistin-
guishability based security and PRF is a secure pseudorandom function. Then,
uNfaABE satisfies selective security.
5 FE for DFA Implies iO
Here, we show that secret key functional encryption (SKFE) for DFA with
security against unbounded collusion implies indistinguishability obfuscation
(iO). This result illuminates the difficulty of constructing such SKFE from a
standard assumption, since no construction of iO from standard assumption
is known despite the significant research effort in recent years [1–3,5,7,8,11–
13,17,21,34,35,37–40,40,50,51,51–54].
5.1 Preliminaries on DFA and Branching Programs
Here, we first recall that a deterministic finite automaton (DFA) is a special case
of NFA where for the transition function T , T (σ, q) consists of a single element
in Q for any σ ∈ Σ and q ∈ Q. We then define branching program similarly
to [25].
792 S. Agrawal et al.
Definition 7 (Branching Programs). A width-5 permutation branching
program BP of length L with input space {0, 1}� is a sequence of L tuples of
the form (var(t), σt,0, σt,1) where
– var : [L] → [�] is a function that associates the t-th tuple with an input bit
xvar(t).
– σj,0 and σj,1 are permutations on 5 elements. We will think of σj,0 and σj,1
as bijective functions from the set {1, 2, 3, 4, 5} to itself.
The computation of the program BP on input x = (x1, . . . , x�) proceeds as
follows. The state of the computation at any point in time t is a number ζt ∈
{1, 2, 3, 4, 5}. Computation starts with the initial state ζ0 = 1. The state ζt is
computed recursively as
ζt = σt,xvar(t) (ζt−1) . (5.1)
Finally, after L steps, our state is ζL. The output of the computation BP(x) is
1 if ζL = 1 and 0 otherwise.
We will use the following theorem, which essentially says that an NC1 circuit
can be converted into an equivalent branching program.
Theorem 10 (Barrington’s Theorem [19]). Every Boolean NAND circuit C
that acts on � inputs and has depth d can be computed by a width-5 permutation
branching program BP of length 4d. Given the description of the circuit BP, the
description of the branching program BP can be computed in poly(�, 4d) time. In
particular, if C is a polynomial-sized circuit with logarithmic depth (i.e., if the
circuit is in NC1), BP can be computed in polynomial time.
5.2 SKFE for DFA Implies iO
We first state the following theorem, which will be useful for our purpose. We
refer to the full version for the proof.
Theorem 11. Let d = d(λ) and � = �(λ) be integers. There exist deterministic
algorithms Encode and ToDFA with the following properties.
– Encode(x) → y ∈ {0, 1}n, where x ∈ {0, 1}� and n is a parameter determined
by d and �.
– ToDFA(C) → M , where C : {0, 1}� → {0, 1} is a circuit with depth bounded
by d and M is a DFA over alphabet Σ = {0, 1}.
We have that M(y) = 1 if and only if C(x) = 1. We also have that the running
time of Encode and ToDFA is poly(�, 2d). In particular, if C is a polynomial-
sized circuit with logarithmic depth (i.e., if the circuit is in NC1), Encode and
ToDFA(C) run in polynomial time.
Attribute Based Encryption (and more) for NFA from LWE 793
We then discuss that if there exists subexponentially secure SKFE for DFA that
is very selectively secure against unbounded collusion, it can be converted into
a secure indistinguishability obfuscation.
To do so, we first convert an SKFE for DFA into an SKFE for NC1 circuits.
The latter SKFE has the same setup algorithm as the former, but when
generating a secret key for a circuit C, it first converts C into a DFA M using
the algorithm in Theorem 11 and then invoke the key generation algorithm of
the SKFE for DFA on input M . Similarly, when encrypting a message x, it
computes y as in Theorem 11 and then invoke the encryption algorithm of the
SKFE for DFA on input y. The decryption algorithm is defined naturally. It is
easy to see that this conversion preserves the correctness and the security since
we have M(y) = C(x) by Theorem 11.
Then, we apply the conversion given by [12,21] to the SKFE for NC1 to
obtain SKFE for all circuits. We then further apply the conversion by Kitagawa
et al. [46,47] to the SKFE for all circuits to obtain iO. Note that while the
former conversion incurs only polynomial loss, the latter conversion incurs sub-
exponential security loss.
In summary, we obtain the following theorem.
Theorem 12. If there exists a subexponentially secure SKFE scheme for DFA
that is very selectively secure against unbounded collusion, then there exists an
indistinguishability obfuscation.
6 Conclusions
Several interesting questions arise from our work. The first is whether we may
generalize our techniques to support more advanced models of computation. For
the moment, we are restricted to NFAs, since we must bound the depth of the
equivalent circuits by a fixed polynomial and this step fails for more general
models such as Turing machines. Second, it would be interesting to design a
public key variant of our scheme. Improving the security proof to satisfy adaptive
rather than selective security is also a useful direction. Finally, it would be nice
to find other applications for our techniques.
Acknowledgement. We thank anonymous reviewers of Crypto 2019 for their
helpful comments. The third author is supported by JST CREST Grant Number
JPMJCR19F6 and JSPS KAKENHI Grant Number 16K16068.
794 S. Agrawal et al.
References
1. Abdalla, M., Bourse, F., Caro, A.D., Pointcheval, D.: Simple functional encryption
schemes for inner products. Cryptology ePrint Archive, Report 2015/017 (2015).
http://eprint.iacr.org/ To appear in PKC’15
2. Agrawal, S.: Stronger security for reusable garbled circuits, general definitions and
attacks. In: Katz, J., Shacham, H. (eds.) CRYPTO 2017. LNCS, vol. 10401, pp.
3–35. Springer, Cham (2017). https://doi.org/10.1007/978-3-319-63688-7 1
3. Agrawal, S.: Indistinguishability obfuscation minus multilinear maps: new methods
for bootstrapping and instantiation (2018)
4. Agrawal, S., Freeman, D.M., Vaikuntanathan, V.: Functional encryption for inner
product predicates from learning with errors. In: Lee, D.H., Wang, X. (eds.)
ASIACRYPT 2011. LNCS, vol. 7073, pp. 21–40. Springer, Heidelberg (2011).
https://doi.org/10.1007/978-3-642-25385-0 2
5. Agrawal, S., Libert, B., Stehlé, D.: Fully secure functional encryption for inner
products, from standard assumptions. In: Robshaw, M., Katz, J. (eds.) CRYPTO
2016. LNCS, vol. 9816, pp. 333–362. Springer, Heidelberg (2016). https://doi.org/
10.1007/978-3-662-53015-3 12
6. Agrawal, S., Maitra, M.: FE and iO for turing machines from minimal assumptions.
In: Beimel, A., Dziembowski, S. (eds.) TCC 2018. LNCS, vol. 11240, pp. 473–512.
Springer, Cham (2018). https://doi.org/10.1007/978-3-030-03810-6 18
7. Agrawal, S., Rosen, A.: Functional encryption for bounded collusions, revisited. In:
Kalai, Y., Reyzin, L. (eds.) TCC 2017. LNCS, vol. 10677, pp. 173–205. Springer,
Cham (2017). https://doi.org/10.1007/978-3-319-70500-2 7
8. Agrawal, S., Singh, I.P.: Reusable garbled deterministic finite automata from
learning with errors. In: ICALP, vol. 80. Schloss Dagstuhl-Leibniz-Zentrum fuer
Informatik (2017)
9. Ananth, P., Brakerski, Z., Segev, G., Vaikuntanathan, V.: From selective to
adaptive security in functional encryption. In: Gennaro, R., Robshaw, M. (eds.)
CRYPTO 2015. LNCS, vol. 9216, pp. 657–677. Springer, Heidelberg (2015).
https://doi.org/10.1007/978-3-662-48000-7 32
10. Ananth, P., Fan, X.: Attribute based encryption with sublinear decryption from
LWE. Cryptology ePrint Archive, Report 2018/273 (2018). https://eprint.iacr.org/
2018/273
11. Ananth, P., Jain, A., Sahai, A.: Indistinguishability obfuscation without multilinear
maps: iO from LWE, bilinear maps, and weak pseudorandomness. Cryptology
ePrint Archive, Report 2018/615 (2018)
12. Ananth, P., Jain, A.: Indistinguishability obfuscation from compact functional
encryption. In: Gennaro, R., Robshaw, M. (eds.) CRYPTO 2015. LNCS, vol.
9215, pp. 308–326. Springer, Heidelberg (2015). https://doi.org/10.1007/978-3-
662-47989-6 15
13. Ananth, P., Jain, A., Sahai, A.: Achieving compactness generically: indistinguisha-
bility obfuscation from non-compact functional encryption. IACR Cryptology
ePrint Archive 2015/730 (2015)
14. Ananth, P., Sahai, A.: Projective arithmetic functional encryption and
indistinguishability obfuscation from degree-5 multilinear maps. In: Coron, J.-S.,
Nielsen, J.B. (eds.) EUROCRYPT 2017. LNCS, vol. 10210, pp. 152–181. Springer,
Cham (2017). https://doi.org/10.1007/978-3-319-56620-7 6
15. Apon, D., Döttling, N., Garg, S., Mukherjee, P.: Cryptanalysis of indistinguisha-
bility obfuscations of circuits over GGH13. eprint 2016 (2016)
http://eprint.iacr.org/
https://doi.org/10.1007/978-3-319-63688-7_1
https://doi.org/10.1007/978-3-642-25385-0_2
https://doi.org/10.1007/978-3-662-53015-3_12
https://doi.org/10.1007/978-3-662-53015-3_12
https://doi.org/10.1007/978-3-030-03810-6_18
https://doi.org/10.1007/978-3-319-70500-2_7
https://doi.org/10.1007/978-3-662-48000-7_32
https://eprint.iacr.org/2018/273
https://eprint.iacr.org/2018/273
https://doi.org/10.1007/978-3-662-47989-6_15
https://doi.org/10.1007/978-3-662-47989-6_15
https://doi.org/10.1007/978-3-319-56620-7_6
Attribute Based Encryption (and more) for NFA from LWE 795
16. Attrapadung, N.: Dual system encryption via doubly selective security: framework,
fully secure functional encryption for regular languages, and more. In: Nguyen,
P.Q., Oswald, E. (eds.) EUROCRYPT 2014. LNCS, vol. 8441, pp. 557–577.
Springer, Heidelberg (2014). https://doi.org/10.1007/978-3-642-55220-5 31
17. Baltico, C.E.Z., Catalano, D., Fiore, D., Gay, R.: Practical functional encryption
for quadratic functions with applications to predicate encryption. In: Katz, J.,
Shacham, H. (eds.) CRYPTO 2017. LNCS, vol. 10401, pp. 67–98. Springer, Cham
(2017). https://doi.org/10.1007/978-3-319-63688-7 3
18. Barak, B., et al.: On the (im)possibility of obfuscating programs. In: Kilian, J. (ed.)
CRYPTO 2001. LNCS, vol. 2139, pp. 1–18. Springer, Heidelberg (2001). https://
doi.org/10.1007/3-540-44647-8 1
19. Barrington, D.A.: Bounded-width polynomial-size branching programs recognize
exactly those languages in NC1. J. Comput. Syst. Sci. 38(1), 150–164 (1989)
20. Bethencourt, J., Sahai, A., Waters, B.: Ciphertext-policy attribute-based
encryption. In: IEEE Symposium on Security and Privacy, pp. 321–334 (2007)
21. Bitansky, N., Vaikuntanathan, V.: Indistinguishability obfuscation from functional
encryption. In: FOCS 2015, 163 (2015). http://eprint.iacr.org/2015/163
22. Boneh, D., et al.: Fully key-homomorphic encryption, arithmetic circuit ABE and
compact garbled circuits. In: Nguyen, P.Q., Oswald, E. (eds.) EUROCRYPT 2014.
LNCS, vol. 8441, pp. 533–556. Springer, Heidelberg (2014). https://doi.org/10.
1007/978-3-642-55220-5 30
23. Boneh, D., Waters, B.: Conjunctive, subset, and range queries on encrypted
data. In: Vadhan, S.P. (ed.) TCC 2007. LNCS, vol. 4392, pp. 535–554. Springer,
Heidelberg (2007). https://doi.org/10.1007/978-3-540-70936-7 29
24. Boyen, X., Li, Q.: Attribute-based encryption for finite automata from LWE. In:
Au, M.-H., Miyaji, A. (eds.) ProvSec 2015. LNCS, vol. 9451, pp. 247–267. Springer,
Cham (2015). https://doi.org/10.1007/978-3-319-26059-4 14
25. Brakerski, Z., Vaikuntanathan, V.: Lattice-based FHE as secure as PKE. In:
Proceedings of the 5th Conference on Innovations in Theoretical Computer Science,
ITCS 2014 (2014)
26. Brakerski, Z., Vaikuntanathan, V.: Circuit-ABE from LWE: unbounded attributes
and semi-adaptive security. In: Robshaw, M., Katz, J. (eds.) CRYPTO 2016. LNCS,
vol. 9816, pp. 363–384. Springer, Heidelberg (2016). https://doi.org/10.1007/978-
3-662-53015-3 13
27. Cheon, J.H., Han, K., Lee, C., Ryu, H., Stehlé, D.: Cryptanalysis of the multilinear
map over the integers. In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015.
LNCS, vol. 9056, pp. 3–12. Springer, Heidelberg (2015). https://doi.org/10.1007/
978-3-662-46800-5 1
28. Cheon, J.H., Fouque, P.A., Lee, C., Minaud, B., Ryu, H.: Cryptanalysis of the new
CLT multilinear map over the integers. Eprint 2016/135
29. Cheon, J.H., Jeong, J., Lee, C.: An algorithm for NTRU problems and cryptanalysis
of the GGH multilinear map without a low level encoding of zero. Eprint 2016/139
(2016)
30. Cook, S.A., Hoover, H.J.: A depth-universal circuit. SIAM J. Comput. 14(4), 833–
839 (1985). https://doi.org/10.1137/0214058
31. Coron, J.-S., et al.: Zeroizing without low-level zeroes: new MMAP attacks and
their limitations. In: Gennaro, R., Robshaw, M. (eds.) CRYPTO 2015. LNCS,
vol. 9215, pp. 247–266. Springer, Heidelberg (2015). https://doi.org/10.1007/978-
3-662-47989-6 12
32. Coron, J.S., Lee, M.S., Lepoint, T., Tibouchi, M.: Zeroizing attacks on
indistinguishability obfuscation over CLT13. Eprint 2016 (2016)
https://doi.org/10.1007/978-3-642-55220-5_31
https://doi.org/10.1007/978-3-319-63688-7_3
https://doi.org/10.1007/3-540-44647-8_1
https://doi.org/10.1007/3-540-44647-8_1
http://eprint.iacr.org/2015/163
https://doi.org/10.1007/978-3-642-55220-5_30
https://doi.org/10.1007/978-3-642-55220-5_30
https://doi.org/10.1007/978-3-540-70936-7_29
https://doi.org/10.1007/978-3-319-26059-4_14
https://doi.org/10.1007/978-3-662-53015-3_13
https://doi.org/10.1007/978-3-662-53015-3_13
https://doi.org/10.1007/978-3-662-46800-5_1
https://doi.org/10.1007/978-3-662-46800-5_1
https://doi.org/10.1137/0214058
https://doi.org/10.1007/978-3-662-47989-6_12
https://doi.org/10.1007/978-3-662-47989-6_12
796 S. Agrawal et al.
33. Garg, S., Gentry, C., Halevi, S.: Candidate multilinear maps from ideal lattices.
In: Johansson, T., Nguyen, P.Q. (eds.) EUROCRYPT 2013. LNCS, vol. 7881, pp.
1–17. Springer, Heidelberg (2013). https://doi.org/10.1007/978-3-642-38348-9 1
34. Garg, S., Gentry, C., Halevi, S., Raykova, M., Sahai, A., Waters, B.: Candidate
indistinguishability obfuscation and functional encryption for all circuits. In: FOCS
(2013). http://eprint.iacr.org/
35. Garg, S., Gentry, C., Halevi, S., Sahai, A., Waters, B.: Attribute-based encryption
for circuits from multilinear maps. In: Canetti, R., Garay, J.A. (eds.) CRYPTO
2013. LNCS, vol. 8043, pp. 479–499. Springer, Heidelberg (2013). https://doi.org/
10.1007/978-3-642-40084-1 27
36. Goldwasser, S., Kalai, Y.T., Popa, R.A., Vaikuntanathan, V., Zeldovich, N.:
How to run turing machines on encrypted data. In: Canetti, R., Garay, J.A.
(eds.) CRYPTO 2013. LNCS, vol. 8043, pp. 536–553. Springer, Heidelberg (2013).
https://doi.org/10.1007/978-3-642-40084-1 30
37. Goldwasser, S., Kalai, Y.T., Popa, R.A., Vaikuntanathan, V., Zeldovich, N.:
Reusable garbled circuits and succinct functional encryption. In: STOC, pp. 555–
564 (2013)
38. Gorbunov, S., Vaikuntanathan, V., Wee, H.: Functional encryption with bounded
collusions via multi-party computation. In: Safavi-Naini, R., Canetti, R. (eds.)
CRYPTO 2012. LNCS, vol. 7417, pp. 162–179. Springer, Heidelberg (2012).
https://doi.org/10.1007/978-3-642-32009-5 11
39. Gorbunov, S., Vaikuntanathan, V., Wee, H.: Attribute based encryption for
circuits. In: STOC (2013)
40. Gorbunov, S., Vaikuntanathan, V., Wee, H.: Predicate encryption for circuits from
LWE. In: Gennaro, R., Robshaw, M. (eds.) CRYPTO 2015. LNCS, vol. 9216, pp.
503–523. Springer, Heidelberg (2015). https://doi.org/10.1007/978-3-662-48000-
7 25
41. Gorbunov, S., Vinayagamurthy, D.: Riding on asymmetry: efficient abe for
branching programs. In: Iwata, T., Cheon, J.H. (eds.) ASIACRYPT 2015. LNCS,
vol. 9452, pp. 550–574. Springer, Heidelberg (2015). https://doi.org/10.1007/978-
3-662-48797-6 23
42. Goyal, R., Koppula, V., Waters, B.: Semi-adaptive security and bundling
functionalities made generic and easy. In: Hirt, M., Smith, A. (eds.) TCC 2016.
LNCS, vol. 9986, pp. 361–388. Springer, Heidelberg (2016). https://doi.org/10.
1007/978-3-662-53644-5 14
43. Goyal, V., Pandey, O., Sahai, A., Waters, B.: Attribute-based encryption for fine-
grained access control of encrypted data. In: ACM Conference on Computer and
Communications Security, pp. 89–98 (2006)
44. Hu, Y., Jia, H.: Cryptanalysis of GGH map. Cryptology ePrint Archive: Report
2015/301 (2015)
45. Katz, J., Sahai, A., Waters, B.: Predicate encryption supporting disjunctions,
polynomial equations, and inner products. In: Smart, N. (ed.) EUROCRYPT 2008.
LNCS, vol. 4965, pp. 146–162. Springer, Heidelberg (2008). https://doi.org/10.
1007/978-3-540-78967-3 9
46. Kitagawa, F., Nishimaki, R., Tanaka, K.: Indistinguishability obfuscation for all
circuits from secret-key functional encryption. IACR Cryptology ePrint Archive
2017/361 (2017)
47. Kitagawa, F., Nishimaki, R., Tanaka, K.: Obfustopia built on secret-key functional
encryption. In: Nielsen, J.B., Rijmen, V. (eds.) EUROCRYPT 2018. LNCS, vol.
10821, pp. 603–648. Springer, Cham (2018). https://doi.org/10.1007/978-3-319-
78375-8 20
https://doi.org/10.1007/978-3-642-38348-9_1
http://eprint.iacr.org/
https://doi.org/10.1007/978-3-642-40084-1_27
https://doi.org/10.1007/978-3-642-40084-1_27
https://doi.org/10.1007/978-3-642-40084-1_30
https://doi.org/10.1007/978-3-642-32009-5_11
https://doi.org/10.1007/978-3-662-48000-7_25
https://doi.org/10.1007/978-3-662-48000-7_25
https://doi.org/10.1007/978-3-662-48797-6_23
https://doi.org/10.1007/978-3-662-48797-6_23
https://doi.org/10.1007/978-3-662-53644-5_14
https://doi.org/10.1007/978-3-662-53644-5_14
https://doi.org/10.1007/978-3-540-78967-3_9
https://doi.org/10.1007/978-3-540-78967-3_9
https://doi.org/10.1007/978-3-319-78375-8_20
https://doi.org/10.1007/978-3-319-78375-8_20
Attribute Based Encryption (and more) for NFA from LWE 797
48. Kitagawa, F., Nishimaki, R., Tanaka, K., Yamakawa, T.: Adaptively secure and
succinct functional encryption: Improving security and efficiency, simultaneously.
Cryptology ePrint Archive, Report 2018/974 (2018). https://eprint.iacr.org/2018/
974
49. Lewko, A., Okamoto, T., Sahai, A., Takashima, K., Waters, B.: Fully secure
functional encryption: attribute-based encryption and (hierarchical) inner product
encryption. In: Gilbert, H. (ed.) EUROCRYPT 2010. LNCS, vol. 6110, pp. 62–91.
Springer, Heidelberg (2010). https://doi.org/10.1007/978-3-642-13190-5 4
50. Lin, H.: Indistinguishability obfuscation from constant-degree graded encoding
schemes. In: Fischlin, M., Coron, J.-S. (eds.) EUROCRYPT 2016. LNCS, vol. 9665,
pp. 28–57. Springer, Heidelberg (2016). https://doi.org/10.1007/978-3-662-49890-
3 2
51. Lin, H.: Indistinguishability obfuscation from SXDH on 5-linear maps and locality-
5 PRGs. In: Katz, J., Shacham, H. (eds.) CRYPTO 2017. LNCS, vol. 10401, pp.
599–629. Springer, Cham (2017). https://doi.org/10.1007/978-3-319-63688-7 20
52. Lin, H., Matt, C.: Pseudo flawed-smudging generators and their application
to indistinguishability obfuscation. Cryptology ePrint Archive, Report 2018/646
(2018)
53. Lin, H., Tessaro, S.: Indistinguishability obfuscation from trilinear maps and block-
wise local PRGs. In: Katz, J., Shacham, H. (eds.) CRYPTO 2017. LNCS, vol.
10401, pp. 630–660. Springer, Cham (2017). https://doi.org/10.1007/978-3-319-
63688-7 21
54. Lin, H., Vaikuntanathan, V.: Indistinguishability obfuscation from DDH-like
assumptions on constant-degree graded encodings. In: FOCS (2016)
55. Miles, E., Sahai, A., Zhandry, M.: Annihilation attacks for multilinear maps:
cryptanalysis of indistinguishability obfuscation over GGH13. In: Robshaw, M.,
Katz, J. (eds.) CRYPTO 2016. LNCS, vol. 9815, pp. 629–658. Springer, Heidelberg
(2016). https://doi.org/10.1007/978-3-662-53008-5 22
56. Sahai, A., Waters, B.: Fuzzy identity-based encryption. In: Cramer, R. (ed.)
EUROCRYPT 2005. LNCS, vol. 3494, pp. 457–473. Springer, Heidelberg (2005).
https://doi.org/10.1007/11426639 27
57. Waters, B.: Functional encryption for regular languages. In: Safavi-Naini, R.,
Canetti, R. (eds.) CRYPTO 2012. LNCS, vol. 7417, pp. 218–235. Springer,
Heidelberg (2012). https://doi.org/10.1007/978-3-642-32009-5 14
https://eprint.iacr.org/2018/974
https://eprint.iacr.org/2018/974
https://doi.org/10.1007/978-3-642-13190-5_4
https://doi.org/10.1007/978-3-662-49890-3_2
https://doi.org/10.1007/978-3-662-49890-3_2
https://doi.org/10.1007/978-3-319-63688-7_20
https://doi.org/10.1007/978-3-319-63688-7_21
https://doi.org/10.1007/978-3-319-63688-7_21
https://doi.org/10.1007/978-3-662-53008-5_22
https://doi.org/10.1007/11426639_27
https://doi.org/10.1007/978-3-642-32009-5_14
	Attribute Based Encryption (and more) for Nondeterministic Finite Automata from LWE
	1 Introduction
	1.1 Our Techniques
	2 Preliminaries
	2.1 Definitions: Non Deterministic Finite Automata
	2.2 Definitions: Secret-Key Attribute Based Encryption for NFA
	2.3 Definitions: Attribute Based Encryption and Functional Encryption for Circuits
	3 Attribute-Based Encryption for NFA
	3.1 NFA as NC Circuit
	3.2 Construction: SKABE for Bounded Size NFA
	3.3 Correctness of NfaABE
	3.4 Proof of Security for NfaABE
	3.5 Extensions
	4 Attribute Based Encryption for NFA with Unbounded Size Machines and Inputs
	5 FE for DFA Implies iO
	5.1 Preliminaries on DFA and Branching Programs
	5.2 SKFE for DFA Implies iO
	6 Conclusions
	References