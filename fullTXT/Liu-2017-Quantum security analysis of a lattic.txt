1348 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
Frontiers of Information Technology & Electronic Engineering
www.jzus.zju.edu.cn; engineering.cae.cn; www.springerlink.com
ISSN 2095-9184 (print); ISSN 2095-9230 (online)
E-mail: jzus@zju.edu.cn
Quantum security analysis of a lattice-based
oblivious transfer protocol∗
Mo-meng LIU†‡1, Juliane KRÄMER2, Yu-pu HU1, Johannes BUCHMANN2
(1State Key Laboratory of Integrated Service Networks, Xidian University, Xi’an 710071, China)
(2Technische Universität Darmstadt, Darmstadt 64289, Germany)
†E-mail: liumomeng@gmail.com
Received Jan. 12, 2017; Revision accepted Apr. 17, 2017; Crosschecked Sept. 24, 2017
Abstract: Because of the concise functionality of oblivious transfer (OT) protocols, they have been widely used as
building blocks in secure multiparty computation and high-level protocols. The security of OT protocols built upon
classical number theoretic problems, such as the discrete logarithm and factoring, however, is threatened as a result
of the huge progress in quantum computing. Therefore, post-quantum cryptography is needed for protocols based
on classical problems, and several proposals for post-quantum OT protocols exist. However, most post-quantum
cryptosystems present their security proof only in the context of classical adversaries, not in the quantum setting.
In this paper, we close this gap and prove the security of the lattice-based OT protocol proposed by Peikert et al.
(CRYPTO, 2008), which is universally composably secure under the assumption of learning with errors hardness,
in the quantum setting. We apply three general quantum security analysis frameworks. First, we apply the
quantum lifting theorem proposed by Unruh (EUROCRYPT, 2010) to prove that the security of the lattice-based
OT protocol can be lifted into the quantum world. Then, we apply two more security analysis frameworks specified
for post-quantum cryptographic primitives, i.e., simple hybrid arguments (CRYPTO, 2011) and game-preserving
reduction (PQCrypto, 2014).
Key words: Oblivious transfer; Post-quantum; Lattice-based; Learning with errors; Universally composable
https://doi.org/10.1631/FITEE.1700039 CLC number: TP309.7
1 Introduction
As a fundamental cryptographic primitive,
oblivious transfer (OT) has been proposed to de-
pict a scenario between two parties, where one party
(called the sender) sends a message to the other party
(called the receiver) with the requirement that the
receiver can obtain only this message with proba-
bility 1/2 and the sender remains oblivious as to
whether the message has been received or not. To
build protocols for secure multiparty computation, a
‡ Corresponding author
* Project supported by the National Key R&D Program of China
(No. 2017YFB0802000), the National Natural Science Founda-
tion of China (Nos. 61672412, 61472309, and 61572390), and the
China Scholarship Council (No. 201406960041)
ORCID: Mo-meng LIU, http://orcid.org/0000-0002-8545-5551
c©Zhejiang University and Springer-Verlag GmbH Germany 2017
more useful flavor of OT, called 1-out-of-2 OT, was
developed, where the receiver is allowed to retrieve
one message from the sender’s message pair without
knowing anything about the other message, and the
sender is required not to know about the receiver’s
message choice. Due to the concise functionality of
OT, it can be used to securely implement some ba-
sic mathematical operations, e.g., secure two-party
multiplication (Gilboa, 1999), in an efficient way.
Therefore, OT is widely used as a building block for
cryptographic construction and holds an important
position in the development of modern cryptography.
However, most OT protocols are built from
cryptosystems whose security relies on number the-
oretical problems, such as factoring and the discrete
logarithm, which are only assumed to be hard for
www.jzus.zju.edu.cn
engineering.cae.cn
www.springerlink.com
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1349
classical algorithms. Adversaries equipped with a
quantum computer, however, can efficiently break
those classical cryptographic constructions (Shor,
1997). Therefore, the security of OT protocols built
upon these hardness assumptions will immediately
break down in the quantum setting.
A natural countermeasure is to apply quantum
resistant primitives as the cornerstone for OT con-
structions, in the sense that one uses cryptosys-
tems whose underlying computational assumptions
remain hard in the quantum setting. Develop-
ing and improving such cryptosystems is the scope
of the research area of post-quantum cryptogra-
phy (Bernstein et al., 2009). It emerges from the
challenge caused by quantum computers and in-
cludes subareas such as lattice-based (Micciancio
and Regev, 2009; Peikert, 2009) cryptography and
code-based (Sendrier, 2011) cryptography. Such
post-quantum cryptosystems can be used as un-
derlying primitives of cryptographic protocols and
possibly make them secure against quantum adver-
saries. However, most existing security proofs of
post-quantum constructions assume only classical
adversaries and base the promised quantum security
on the dependency on quantum resistant assump-
tions. Nonetheless, quantum resistant assumptions
alone do not guarantee the quantum security of cryp-
tographic constructions, since other fundamental is-
sues in the security proof may be subtle and eas-
ily overlooked, especially in the complex proofs of
protocols.
1.1 Related works
The concerns above have led to research on
the security of classical cryptosystems in a quan-
tum world. Damgård et al. (2014) introduced a
new quantum attack model, i.e., the superposition
attack model, on classical cryptographic protocols,
where it allows adversaries to query in quantum su-
perposition. Moreover, they revisited the security
of several classical primitives in this stronger attack
model. Unruh (2010) presented a quantum analogue
of the universal composability (UC) model and con-
structed a statistically quantum-UC-secure OT pro-
tocol. In addition, he defined and constructed quan-
tum proofs of knowledge (Unruh, 2012), where the
main technique, i.e., a new quantum rewinding tech-
nique (Watrous, 2009), was used to extract witness in
many classical proofs of knowledge. Hallgren et al.
(2011) showed the existence of classical two-party
protocols under reasonable computational assump-
tions that can keep their security in a quantum world.
Fehr et al. (2013) explored the feasibility of realizing
functionalities in the UC framework by moving from
the classical to quantum world, regarding both com-
putational and information-theoretic securities.
1.2 Contribution
By using three general security analysis results,
we give a comprehensive quantum security analy-
sis for an existing lattice-based OT protocol (Peik-
ert et al., 2008) which is secure in the UC frame-
work. Our work relies mainly on the quantum lift-
ing theorem (QLT) (Unruh, 2010), to explore the
resilience of this latticed-based OT protocol against
quantum adversaries. We present two additional dis-
cussions to supplement our analysis, one of which
relies on a framework called ‘simple hybrid argu-
ments (SHA)’ (Hallgren et al., 2011; 2015), which
supports the conjecture for the computational quan-
tum lifting theorem proposed by Unruh (2010). The
other one shows that the analysis we have made also
falls into a framework termed ‘game-preserving re-
duction’ (Song, 2014), which is proposed to discuss
the quantum resistance of post-quantum primitives
from the perspective of a provable security reduction.
Our work can be regarded as a concrete application
of general quantum security analysis tools for post-
quantum cryptographic constructions.
2 Preliminaries
For clarity, we first introduce some basic nota-
tions and relevant backgrounds. Most notations and
concepts mentioned are taken from Canetti (2001),
Peikert et al. (2008), and Unruh (2010). We assume
that the reader is familiar with the basic concepts of
quantum information theory (Nielsen and Chuang,
2010).
2.1 Notation
We use bold lowercase to denote vector, e.g., v,
and bold uppercase letter to denote matrix, e.g., M .
The notation vT represents the transpose of vector
v. For any x, y ∈ R with y > 0, xmod y = x−�x/y�y
and �x� = �x + 1/2�. For any n ∈ N, [n] represents
a set {1, 2, . . . , n}.
1350 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
For an integer q ≥ 1, Zq denotes the quotient
ring Z/qZ. We let T = R/Z denote the group of
reals [0, 1) with modulo 1 addition. For any α ∈
R
+, Ψα denotes the distribution on T obtained by
sampling from a variable with mean 0 and standard
deviation α/
√
2π, reduced modulo 1. Moreover, its
discretization Ψ̄α : Zq → R
+ defines the discrete
distribution over Zq of the random variable �q ·XΨα�
mod q, where XΨα has distribution Ψα.
If D is a probability distribution over Zq, then
x ← D denotes sampling x ∈ Zq according to D. If
D(·) is a probabilistic algorithm, y ← D(x) denotes
running D on input x and assigning the output to y.
Let n ∈ N denote a security parameter which
is taken as an implicit input to all other quanti-
ties. We classify the growth of functions using stan-
dard asymptotic notation. Let f(n) and g(n) be
two positive functions. We say f(n) = O(g(n))
if there exist two fixed positive constants c and
n0 such that f(n) ≤ cg(n) for all n ≥ n0, and
f(n) = o(g(n)) if for any arbitrarily positive con-
stant c, there exists a positive constant n0 such
that f(n) ≤ cg(n) for all n ≥ n0. We say that
f(n) = Õ(g(n)) if f(n) = O(g(n) logc g(n)) for some
fixed constant c. Let poly(n) denote an unspecified
function f(n) = O(nc) for some constant c. We let
negl(n) denote a function f(n) ‘negligible’ in n such
that f(n) = o(n−c) for any constant c. We say that
an event happens with overwhelming probability if
it happens with a probability of at least 1− negl(n).
Let X = {X(n, z)}n∈N,z∈{0,1}∗ denote a binary
distribution ensemble (i.e., an infinite set of prob-
ability distributions over {0, 1}), where a distribu-
tion X(n, z) is associated with each security pa-
rameter n ∈ N and input z ∈ {0, 1}∗. Now we
have two such ensembles X = {X(n, z)}n∈N,z∈{0,1}∗
and Y = {Y (n, z)}n∈N,z∈{0,1}∗ . If |Pr(X(n, z) =
1)− Pr(Y (n, z) = 1)| ≤ negl(n), we say that X and
Y are indistinguishable, denoted by X ≈ Y .
2.2 Oblivious transfer
Oblivious transfer was first introduced by Ra-
bin (1981) who also proposed an OT construction
based on the RSA cryptosystem. Then, a more use-
ful form called ‘1-out-of-2 OT’ (Even et al., 1985)
was developed to build protocols for secure multi-
party computation. 1-out-of-2 OT is an execution of
a two-party computation, where the sender (denoted
by S) takes as input a message pair (m0,m1) and the
receiver (denoted by R) chooses one bit σ ∈ {0, 1}
as its input. It requires that R will receive mσ with-
out knowing m1−σ and S has no knowledge about
the receiver’s choice after the execution of the pro-
tocol. Moreover, 1-out-of-N OT can be viewed as a
generalization of 1-out-of-2 OT, where the sender S
runs a database with N messages and the receiver R
obliviously chooses one message from that database.
2.3 Lattice-based cryptography
Lattice-based cryptography is a promising post-
quantum cryptography candidate since it has strong
provable security guarantees and good asymptotic
efficiency. As a versatile primitive for lattice-based
cryptographic constructions, the learning with errors
(LWE) problem (Regev, 2005) is widely used and re-
garded as quantum resistant due to its provable prop-
erty that solving the average-case LWE problem is
at least as hard as solving some standard worst-case
lattice problem which cannot be efficiently solved by
quantum algorithms. Referring to Regev (2005), the
LWE problem is defined as follows:
Definition 1 (LWE) Let n ≥ 1 and q ≥ 2 be posi-
tive integers, χ an error distribution over Zq, and s a
secret vector following the uniform distribution over
Z
n
q . LetAs,χ denote the probability distribution over
Z
n
q×Zq obtained by choosing a∈Zn
q uniformly at ran-
dom, choosing e∈Zq according to χ, and returning
(a, c) = (a, 〈a, s〉+ e) ∈ Z
n
q ×Zq. The LWE prob-
lem has two versions: search-version and decision-
version. Search-LWE finds s given access to an ar-
bitrary number of independent samples (a, c) from
As,χ. Decision-LWE distinguishs an oracle which re-
turns independent samples from As,χ from an oracle
which returns independent samples from the uniform
distribution on Z
n
q × Zq.
Regev (2005) gave a quantum reduction from
worst-case lattice problems to the search-LWE prob-
lem. Moreover, he established the equivalences of
the search-LWE problem using elementary reduc-
tions, including a reduction from the (average-case)
decision-version to the search-version. In the rest of
this paper we denote this decision-LWE problem as
the LWE problem. Here we state the result in Regev
(2005) with regard to the average-case decision-LWE
problem, which is denoted by LWEq,χ and used in
the following cryptographic application (Section 3)
as underlying hardness. That is, for certain choices
of q and χ, we have:
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1351
Proposition 1 (Theorem 1.1 and Lemma 4.2 in
Regev (2005)) Let n and q be integers and α =
α(n) ∈ (0, 1) be such that αq > 2
√
n. If there exists
an efficient algorithm that can solve LWEq,χ, then
there exists an efficient quantum algorithm for solv-
ing the shortest vector problem (GapSVP) and the
shortest independent vectors problem (SIVP) within
Õ(n/α) in the worst case.
2.4 Classical UC framework
Since the OT protocol that we intend to analyze
in the quantum setting is proven to be secure in the
standard UC framework proposed by Canetti (2001),
we first give an overview of this model. The security
in this model is defined by comparison: given a cer-
tain protocol task, e.g., a secure OT, we assume that
there exists a specific machine, called the ideal func-
tionality FOT, which can securely implement this
task. Two more involved parties S and R (called
‘dummy parties’) forward only their inputs (m0,m1)
and σ to FOT, and FOT will return mσ to R and
nothing to S. All communication between FOT and
these two parties is performed over secure channels,
and their interactions can be regarded as an ideal
protocol (denoted by ρFOT) which can securely real-
ize OT.
However, in the real world we cannot obtain
such an ideal protocol ρFOT . We need a real protocol
π to implement FOT and intuitively expect that π
is at least as secure as FOT. It implies that if there
exists an adversary that can do something during
the execution of π, then the adversary can do the
same thing during an execution using FOT. Due to
the ideal security of FOT, this adversary cannot suc-
cessfully attack π either. In other words, we hope to
build an ideal adversary in the execution of FOT us-
ing the power of the real adversary in the execution
of π. If such an ideal adversary cannot be successful,
then neither can the real adversary. The security
is captured by comparing the execution of π to the
execution of FOT within the existence of the adver-
sary. That is to say, we compare what can be learned
by a real adversary who receives the real information
to what can be learned by an ideal adversary who
receives nothing (due to the security of ideal func-
tionality, the ideal adversary learns nothing). If they
can both learn approximately the same amount of
information (i.e., look indistinguishable), then the
security of the real protocol is guaranteed.
Formally, it requires that for any adversaryAdv,
there is another adversary Sim called the ‘simulator’,
such that an execution of π with Adv (called the
‘real world’) is indistinguishable from an execution
ofFOT with Sim (called the ‘ideal world’). Moreover,
in the UC framework, there is a new algorithmic en-
tity called ‘environment’ Z, which can freely interact
with both worlds during the course of execution. If
no machineZ can guess whether it is interacting with
the real world or the ideal world, then we say this real
protocol π can securely UC-emulate FOT or the ideal
protocol ρFOT ; i.e., π can achieve UC-security.
Referring to Canetti (2001), let F be an ideal
functionality. EXECπ,Adv,Z(n, z) denotes the ran-
dom variable describing the 1-bit output of Z when
interacting with Adv and running π on an input z ∈
{0, 1}∗, where n represents the security parameter.
Likewise, the random variable describing the single
bit output of Z when interacting with F and Sim on
the same input z is denoted by IDEALF ,Sim,Z(n, z).
Let EXECπ,Adv,Z and IDEALF ,Sim,Z denote
the ensembles {EXECπ,Adv,Z(n, z)}n∈N,z∈{0,1}∗ and
{IDEALF ,Sim,Z(n, z)}n∈N,z∈{0,1}∗), respectively, of
distributions over {0, 1}. Then the general notion
that π can securely UC-emulate F is formally de-
fined as follows:
Definition 2 (UC-security) LetF be an ideal func-
tionality. A protocol π is said to UC-emulate F if,
for any adversary Adv, there exists a simulator Sim
such that for all environments Z it holds that
IDEALF ,Sim,Z ≈ EXECπ,Adv,Z ,
where ‘≈’ denotes indistinguishability. That is to
say, π achieves UC-security.
Note that all machines involved in the above
classical UC framework are modeled as interactive
Turing machines (ITMs). When we restrict the
adversary, simulator, and environment as classical
polynomial-time machines, the notion of compu-
tational classical-UC-security will be derived from
the above framework. Likewise, when we allow
unbounded adversary, simulator, and environment,
the notion of statistical classical-UC-security can be
achieved. If we further require the complexities
of Sim and Adv be polynomial-time related in the
statistical setting, then the statistical UC-security
will imply computational UC-security (see Canetti
(2001) for details).
1352 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
2.5 Quantum universal composability frame-
work
A quantum analogue of Canetti’s standard UC
framework was proposed by Unruh (2010). In
this quantum UC framework, all computation ma-
chines are modeled as quantum interactive machines
(QIMs). For illustration, we briefly give an overview
of the quantum machine model defined in the quan-
tum UC model (Unruh, 2010), which presents the
work pattern between QIMs and aims to mimic the
counterpart in the classical UC model. Here we
first introduce some basic notions of quantum in-
formation theory and refer the reader to Nielsen and
Chuang (2010) for a detailed treatment.
A state in a quantum system is described by a
vector |ψ〉 in a Hilbert space (a complex vector space
with inner product) of the form H = C
N , where N
is a countable set and N = {0, 1} for qubit or N =
{0, 1}∗ for multiple qubits. A joint quantum system
is defined by the tensor product of several separate
Hilbert spaces CN1×N2×···×Nn = H1⊗H2⊗·· ·⊗Hn,
where Hi = C
Ni for all i ∈ [1, n] and n ∈ N. Usually,
we assume an orthonormal basis, i.e., the computa-
tion basis {|x〉 : x ∈ N} for each Hilbert space. Then
the quantum state |ψ〉 can be represented as a state
vector |ψ〉 =
∑
i αi|xi〉, where the measurement out-
come xi ∈ N occurs with probability |αi|2 following
the normalization condition that
∑
i∈N |αi|2 = 1.
In addition, we use 〈ψ| to represent a linear trans-
formation mapping |ϕ〉 to the inner product 〈ψ|ϕ〉.
|ψ〉〈ψ| denotes the orthogonal projector on |ψ〉. If a
quantum system is not in a single pure state as de-
fined above, but in a mixture of different pure states
|ψi〉 ∈ H with respective probability pi, we use a
density operator to describe this quantum system in
the form of ρ =
∑
i pi|ψi〉〈ψi| over H. Note that
this formulation is mathematically equivalent to the
state vector representation. When a quantum sys-
tem is in the pure state case, its density operator
representation is simply ρ = |ψ〉〈ψ|. In this study,
we describe quantum states in the density operator
representation.
Let P(H) denote the set of all density operators
on H, i.e., positive operators with trace 1 (see Theo-
rem 2.5 in Nielsen and Chuang (2010) for the charac-
teristic of the density operator). A composed system
can be denoted by operators in P(H1⊗H2⊗···⊗Hn).
Any operation on a quantum system can be de-
scribed by a superoperator (i.e., quantum opera-
tions). We say a map E : P(H) → P(H) is a su-
peroperator on P(H) if and only if E is a completely
positive trace preserving map. That is to say, E(ρ)
is positive (Hermitian with nonnegative eigenvalues)
for all positive operators ρ over H.
In this work, we perform measurements in the
computational basis. Given a state ρ ∈ P(H) let
ρx = (|x〉〈x|)ρ(|x〉〈x|). Then the outcome of mea-
suring ρ over H in the computational basis is x with
probability tr(ρx) (i.e., the trace of ρx), and the re-
sulting quantum state after measuring is ρx/tr(ρx).
In addition, we can represent a classical state by
a density operator ρ =
∑
x∈N P (x)|x〉〈x| ∈ P(CN )
that corresponds to a classical probability distribu-
tion P : N → [0, 1], where {|x〉} represents the
computational basis. Accordingly, we can define a
classical superoerator E : P(CN1) → P(CN2) by the
form E(ρ) =
∑
x∈N1
y∈N2
Pr(F (x) = y) · 〈x|ρ|x〉 · |y〉〈y|
corresponding to a classical randomized function
F : N1 → N2.
2.5.1 Machine model
In the classical UC framework, all computation
elements are modeled as ITMs, denoted by M , while
in the quantum setting they are modeled by QIMs,
denoted by M̂ , where ‘ˆ’ represents a machine with
quantum power.
A QIM is represented by an identity idM̂ ∈
{0, 1}∗ and a sequence of superoperators E(n)
M̂
on
the tensor product of three Hilbert spaces Hstate ⊗
Hclass ⊗ Hquant, where Hstate,Hclass,Hquant :=
C
{0,1}∗
. Here Hstate, Hclass, and Hquant can be
viewed as three registers. Hstate represents the state
kept by M̂ between invocations. Hclass and Hquant
store incoming and outgoing messages with the clas-
sical part stored in Hclass and the quantum message
part stored in Hquant.
If a QIM idsender wants to send a message con-
sisting of the classical part m and the quantum part
|ψ〉 to another QIM idreceiver, idsender first initializes
Hclass with (idsender, idreceiver,m) and Hquant with
|ψ〉. When we say that we initialize H with m, it
means that we apply a superoperator Eminit on P(H),
where Eminit(ρ) = |m〉〈m|. Similarly, it is applicable
to the initialization with quantum part |ψ〉. If a QIM
does not want to send a message, it initializes Hclass
and Hquant with an empty word.
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1353
Each QIM can be regarded as a special classical
ITM which can perform classical linear operations.
For example, we denote Eclass : ρ→
∑
x〈x|ρ|x〉·|x〉〈x|
as a classical superoperator in E(n)
M̂
which measures
the density operator ρ in the computational basis,
thus removing all superpositions from ρ.
In the security proof, the corruption scenario is
necessarily considered, where an adversary can cor-
rupt some parties to control their current status and
behave in the name of them. We denote a corrupted
party with identity id by PC
id , where C represents
a corruption set that contains all identities of cor-
rupted parties. The corrupted party PC
id can be
viewed as a special machine instructed by a quan-
tum adversary, denoted by Âdv. Once it is invoked,
PC
id will measure Hclass first and parse the outcome
as (idsender, idreceiver,m). If idsender is Âdv, Hclass is
initialized with m. Otherwise, the message is for-
warded to adversary Âdv.
In addition, a notion called ‘network’, denoted
by N , represents a set of machines with pairwise
distinct identities containing a QIM Ẑ with identity
idẐ . Given a network N and a corruption set C,
NC represents the network by substituting machines
M̂ ∈ N with their identities id ∈ C with PC
id .
2.5.2 Quantum-UC-security
Let π be a real protocol, and ρ be an ideal proto-
col which can securely realize some specific function-
ality. We denote partiesπ as the set of all machines
running in protocol π. From the above description
of the quantum machine model, we can accordingly
obtain the following two variants of quantum-UC-
security in the quantum UC framework:
Definition 3 (Statistical quantum-UC-security,
Definition 3 in Unruh (2010)) We say that π sta-
tistically quantum-UC-emulates ρ if and only if for
every set C ⊆ partiesπ and for every adversary Âdv,
there is a simulator Ŝim such that for every environ-
ment Ẑ, two networks πC∪{Âdv, Ẑ} (called the ‘real
world’) and ρC ∪ {Ŝim, Ẑ} (called the ‘ideal world’)
are indistinguishable. That is to say, π achieves sta-
tistical quantum-UC-security. Furthermore, we re-
quire that if Âdv is quantum polynomial-time, so is
Ŝim.
Definition 4 (Computational quantum-UC-secu-
rity, cf. Definition 4 in Unruh (2010)) We say that π
computationally quantum-UC-emulates ρ if and only
if for every set C ⊆ partiesπ and for every quantum
polynomial-time adversary Âdv, there is a quantum
polynomial-time simulator Ŝim such that for every
quantum polynomial-time environment Ẑ, two net-
works πC ∪ {Âdv, Ẑ} (called the ‘real world’) and
ρC ∪ {Ŝim, Ẑ} (called the ‘ideal world’) are indistin-
guishable. That is to say, π achieves computational
quantum-UC-security.
Remark 1 The statement that two networks
πC ∪ {Âdv, Ẑ} and ρC ∪ {Ŝim, Ẑ} are indis-
tinguishable implies that, for all z ∈ {0, 1}∗
and n ∈ N, |Pr(EXEC
πC∪{̂Adv,Ẑ}(n, z) = 1) −
Pr(EXEC
ρC∪{̂Sim,Ẑ}(n, z) = 1)| ≤ negl(n).
3 Lattice-based oblivious transfer
In this section, we introduce an existing lattice-
based OT protocol (Peikert et al., 2008) which will
be analyzed in the quantum setting (Section 4). This
lattice-based OT protocol is extracted from a dual-
mode cryptosystem proposed by Peikert et al. (2008),
which can be instantiated with several standard the-
oretic assumptions, including the decisional Diffie-
Hellman problem, the quadratic residuosity problem,
and the worst-case lattice assumption. Once such a
dual-mode cryptosystem under certain standard as-
sumptions is built well, an efficient and UC-secure
OT protocol based on the same hardness assump-
tion can be directly derived. In Section 3.1, we first
present the dual-mode cryptosystem in lattice set-
ting, i.e., an instantiation with LWE hardness. Then
we introduce the corresponding OT protocol derived
from this LWE-based dual-mode cryptosystem in
Section 3.2. In addition, for a clear quantum anal-
ysis (i.e., UC-security proof in quantum setting) of
this LWE-based OT protocol shown in Section 4, we
need to recall the simulator constructions (the main
ingredients of (classical) UC-security proof) under
different corruptions in Section 3.3.
3.1 Dual-mode cryptosystem based on LWE
hardness
A dual-mode cryptosystem behaves like a nor-
mal encryption scheme which can correctly decrypt
a message encrypted with a given public key by
the corresponding secret key. The main feature of
this encryption scheme is that it can operate in two
modes, i.e., messy mode and decryption mode. The
1354 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
mode in which the scheme runs is determined by
a trusted setup phase of this dual-mode construc-
tion. In the trusted setup phase, a common reference
string (denoted by crs) and the corresponding trap-
door information (τ) are created, where crs may be
chosen, either uniformly at random or from a speci-
fied distribution. The distribution of crs decides the
mode in which the dual-mode cryptosystem oper-
ates and specifies the type of public key used in the
encryption.
The instantiation of the dual-mode cryptosys-
tem with LWE hardness relies on some techniques
developed by Gentry et al. (2008), including an LWE-
based encryption which is a variant of Regev’s CPA-
secure LWE-based cryptosystem (Regev, 2005) and
an efficient algorithm called IsMessy. Gentry et al.
(2008) showed how to securely embed a trapdoor into
the public matrix A of this LWE-based encryption
cryptosystem, so that when this trapdoor informa-
tion is given, the algorithm IsMessy can efficiently
identify the messy public key, which has the prop-
erty that a ciphertext produced by the messy public
key carries no information (statistically) about the
encrypted message.
3.1.1 LWE-based encryption
Here we first introduce this LWE-based encryp-
tion, where the message space is Z2 = {0, 1}. Let
the modulus q = poly(n) be a large prime. For
every message μ ∈ Z2, the center of μ is defined as
t(μ) = μ ·�q/2� ∈ Zq. Let χ denote an error distribu-
tion over Zq and DZm,r a Gaussian-like distribution
over Z
m with standard deviation approximately r.
All operations are performed over Zq.
1. LWEKeyGen(1n): choose A ← Z
n×m
q un-
der a distribution statistically close to uniform, to-
gether with a trapdoor called S (Gentry et al., 2008).
Choose a secret key s ← Z
n×1
q uniformly at ran-
dom. To generate the public key, choose an error
vector x ∈ Z
1×m
q according to the error distribu-
tion χ = Ψ̄α for some parameter α = α(n) ∈ (0, 1)
(here xi is chosen independently for all i ∈ [m] and
m denotes the number of samples). Then compute
(A,p = sTA + x), where each entry (ai, pi) is a
sample from As,χ.
2. LWEEnc(pk = (A,p), μ): to encrypt a mes-
sage μ ∈ Z2, choose a vector e ∈ Z
m fromDZm,r and
output the ciphertext (u, c) = (Ae,pe + t(μ)) =
(Ae,pe+ μ · �q/2�) ∈ Z
n
q × Zq.
3. LWEDec(sk = s, (u, c)): to recover message
μ from the ciphertext, compute d = c − sTu ∈ Zq.
Output 0 if d is closer to 0 than to �q/2� modulo q;
otherwise, output 1.
Remark 2 The above LWE-based encryption
scheme can also be applied when the message is a
vector µ ∈ Z
�
2, where � = poly(n) ≥ 1. The main
advantage that matrix A can be reused over � differ-
ent bits enables the fulfillment of a multi-session OT
protocol, where it can implement � individual OT
executions using the same matrix A and obliviously
transfer one bit to the receiver in each subsession.
3.1.2 Messy public keys (cf. Gentry et al. (2008),
Section 6).
For an arbitrary fixed public key (A,p), we de-
fine δ(p) to be the statistical distance between the
uniform distribution over Zn
q × Zq and the distribu-
tion of (Ae,pe), where e ← DZm,r. If δ(p) is negli-
gible, we say p is a messy public key. It implies that
the ciphertext produced by p will lose essentially all
information (statistically) about the encrypted bit;
i.e., LWEEnc((A,p), 0) and LWEEnc((A,p), 1) are
statistically close since both distributions are sta-
tistically close to uniform. However, the correct-
ness of LWEDec implies that a key p generated by
LWEKeyGen typically has large δ(p). It means that
when encrypting messages under the keys generated
by LWEKeyGen, the encrypted data is computation-
ally hidden. For a large enough m (the number
of LWE samples), a public key (A,p) chosen uni-
formly at random over Zn×m
q × Z
1×m
q is messy with
overwhelming probability. There is no efficient ad-
versary which can distinguish between messy public
keys and the public keys generated by LWEKeyGen.
However, if the corresponding trapdoor information
about A is given, the algorithm IsMessy can identify
messy public keys by taking (τ,p) as input, and then
output messy if p is a messy public key.
3.1.3 LWE-based dual-mode cryptosystem
Now we introduce the LWE-based dual-mode
cryptosystem constructed by the above LWE-based
encryption and the messy key identification algo-
rithm IsMessy. For simplicity, we present only this
LWE-based dual-model cryptosystem for � = 1.
1. SetupMessy(1n): choose a matrix A← Z
n×m
q
uniformly at random, together with the trapdoor
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1355
information τ = (S,A). For each b ∈ {0, 1}, choose
a vector vb ← Z
1×m
q uniformly at random. Let
crs = (A,v0,v1). Output (crs, τ).
2. SetupDec(1n): choose a matrix A ← Z
n×m
q
and a vector w ← Z
1×m
q uniformly at random.
For each b ∈ {0, 1}, choose a secret sb ← Z
n
q uni-
formly at random and an error vector xb ← χ1×m,
where all entries are chosen independently from the
error distribution χ. Let vb = sT
b A + xb − w,
crs = (A,v0,v1), and τ = (w, s0, s1). Output
(crs, τ).
3. KeyGen(crs, σ): choose a secret s ← Z
n
q uni-
formly at random and a vector x ← χ1×m. Let
pk = sTA + x − vσ, where σ ∈ {0, 1} denotes the
decryptable branch. Let sk = s and output (pk, sk).
4. Enc(pk, b, μ): output y ←LWEEnc((A,p =
pk + vb), μ), where b ∈ {0, 1} is chosen by the en-
crypter. Here y is pair (u, c).
5. Dec(sk, y): output μ ←LWEDec(sk =
s, (u, c)).
6. FindMessy(τ,pk): parse τ as (S,A), run
IsMessy((S,A),pk + vb) for each b ∈ {0, 1}, and
output b such that IsMessy can output messy on
at least one branch correctly with overwhelming
probability.
7. TrapdoorKeyGen(τ): parse τ as (w, s0, s1),
and output (pk, sk0, sk1)=(w, s0, s1).
Remark 3 SetupMessy generates crs and trapdoor
τ = (S,A), where S is an embedded trapdoor in A
so that IsMessy can be used in FindMessy to reveal
whether pk + vb is a messy key for each b ∈ {0, 1}
with the given trapdoor τ .
The dual-mode cryptosystem has three required
security properties: (1) in messy mode, for each base
public key pk, at least one of the derived public keys
pk + vb for b ∈ {0, 1} can statistically hide its en-
crypted message; (2) in decryption mode, the honest
receiver’s chosen bit σ is statistically hidden by its
choice of base key pk; (3) given crs, no adversary
can efficiently distinguish two modes (i.e., satisfying
computational indistinguishability). These security
properties guarantee that a UC-secure OT protocol
can be derived from this dual-mode cryptosystem.
However, this LWE-based dual-mode cryptosys-
tem satisfies only a slightly relaxed version of the
above security requirements. Fortunately, a UC-
secure OT protocol based on LWE hardness can still
be derived from this relaxed LWE-based dual-mode
cryptosystem, although it leads to a slightly weaker
security of the honest receiver when running in de-
cryption mode, i.e., computational security.
3.2 LWE-based oblivious transfer
Once this LWE-based dual-mode cryptosystem
is built well, an LWE-based OT protocol denoted
by dmmode can be derived directly (Fig. 1). This
dmmode can securely UC-emulate a multi-session OT
functionality (denoted by F̃OT) in the common ref-
erence string model (Canetti, 2001), where two com-
putation parties query a trusted party for a com-
mon reference string crs. Here F̃OT serves as a shell
around a bounded number of independent FOT exe-
cutions, where it specifies the interaction with two
parties in a single session by sid and coordinates
each subsession included in a single session by ssid.
Let FD
CRS denote the common reference string func-
tionality, where it produces crs for two parties by
running PPT algorithm D before the interaction be-
tween two parties. Note that dmmode can also op-
erate in two modes by two instantiations of FD
CRS:
when D = SetupMessy (i.e., FD
CRS = Fmes
CRS), dmmode
runs in the messy mode (i.e., dmmode = dmmes);
when D = SetupDec (i.e., FD
CRS = Fdec
CRS), dmmode
runs in the decryption mode (i.e., dmmode = dmdec).
The procedure of dmmode is described in Fig. 1. Note
that protocol dmmode is a UC-secure 1-out-of-2 OT
and it can be easily extended as a 1-out-of-2k OT
protocol by choosing vb for each b ∈ {0, 1}k.
3.3 Construction of the simulator
As shown in Peikert et al. (2008), dmmode is
proven to be secure against static corruptions in
the standard UC model. Static corruption means
that the adversary can decide only which parties will
be corrupted before the execution of the protocol
instead of during the course of protocol execution.
Then the adversary will control all the behavior of
the corrupted party when interacting with the hon-
est parties. Referring to Section 2.4, the obtained
UC-security of dmmode implies that for any real ad-
versary Adv, there exists an ideal adversary Sim in-
teracting with the ideal functionality F̃OT, such that
no machine Z can distinguish its interaction with
Adv in an execution of dmmode from an interaction
with Sim using F̃OT.
Since the UC-security proof of dmmode is
proven against the static corruptions, four different
1356 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
Sender Receiver
(sid, ssid, m0, m1) (sid, ssid, σ)
Setup
Multi-session OT
(sid, S, R) (sid, S, R)
(sid, ssid, pk)
(sid, crs) (sid, crs)
(sid, ssid, y0, y1)yb←Enc(pk, b, mb) for each ∈ {0,1}b
(pk, sk)←KeyGen(crs, σ)
outputs(sid, ssid, Dec(sk, yσ))
CRSF D
Fig. 1 Protocol dmmode for oblivious transfer
corruption cases should be considered in each mode:
Case 1: Only the receiver is corrupted;
Case 2: Only the sender is corrupted;
Case 3: Both parties are corrupted;
Case 4: Neither party is corrupted.
Therefore, we recall the constructions of Sim un-
der these four corruption cases, respectively. As folk-
lore, the non-trivial parts of the UC-security proof lie
in the constructions of Sim when only the receiver or
the sender is corrupted. The security under another
two corruptions can be achieved trivially.
In Section 4, we will give the quantum security
analysis of dmmode by modifying machines step by
step, i.e., changing all adversarial ITMs into QIMs.
For clarity, when we show that the security of dmmode
in the classical setting can be preserved in the quan-
tum setting, we divide the construction of two sim-
ulators (i.e., under corruptions cases 1 and 2) into
four steps, denoted by Sim(S1, S2, S3, S4).
When we look into the UC-security proof of
dmmode, each participant involved in the proof is
modeled by an ITM which has its own input and
output tapes for recording the incoming value and
outgoing value from and to its outer environment. In
each corruption case, Sim starts by running a copy of
Adv. Every incoming value that Sim receives from
Z is written into Adv’s input tape. Every outgoing
value written by Adv on its output tape is copied to
Sim’s output tape. Note that regardless of the mode
in which the protocol runs, the construction of Sim
differs only according to the current corruption case.
3.3.1 When only R is corrupted
S1: Sim runs the messy mode setup algorithm
and generates (crs, τ) ← SetupMessy(1n). Namely,
Sim chooses a matrix A ← Z
n×m
q uniformly at ran-
dom, together with a trapdoor τ = (S,A). For each
b ∈ {0, 1}, Sim selects a vector vb ← Z
1×m
q uni-
formly at random, sets crs = (A,v0,v1), and out-
puts (crs, τ). When the parties start to query FD
CRS,
Sim returns (sid, crs) to them and stores τ privately.
S2: Adv produces a message (sid, ssid,pk),
where pk = sTA + x − vσ, and sends it to Sim.
This communication betweenAdv and Sim can be re-
garded as a message produced by Z if Adv is dummy
(denoted by Advdummy); i.e., Adv is fully controlled
by Z and works as the communication channel for
delivering messages between Z and honest parties.
S3: Sim runs FindMessy(crs, τ,pk) to find b
which specifies the messy branch, and queries the
ideal functionality F̃OT with (sid, ssid, receiver, 1−b)
in the name of R. Then Sim receives output
(sid, ssid,m1−b) from F̃OT and stores (b,m1−b).
S4: When S is activated on some subses-
sion (sid, ssid), then Sim must play the role of the
sender to interact with Adv as an execution of the
real world. Sim first looks up the corresponding
(b,m1−b), and then computes y1−b ← Enc(pk, 1 −
b,m1−b) and yb ← Enc(pk, b, 0�). Finally, Sim sends
message (sid, ssid, y0, y1) to Adv as if it were from S.
3.3.2 When only S is corrupted
S1: Sim runs the decryption mode setup al-
gorithm and generates (crs, τ) ← SetupDec(1n).
Namely, Sim chooses a matrix A ← Z
n×m
q and a
vector w ← Z
1×m
q uniformly at random. For each
b ∈ {0, 1}, Sim chooses a secret vector sb ← Z
n
q uni-
formly at random and an error vector xb ← χ1×m,
and then sets vb = sT
b A+xb −w, crs = (A,v0,v1),
and τ = (w, s0, s1). When the parties query the
ideal functionality FD
CRS, Sim returns (sid, crs) to
them and stores τ privately.
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1357
S2: When R is activated on some subsession
(sid, ssid), Sim runs TrapKeyGen(crs, τ) to generate
(pk, sk0, sk1), where (pk, sk0, sk1) = (w, s0, s1),
and sends (sid, ssid,pk) to Adv (or Advdummy when
Adv is dummy) as if it were from R, and stores
(sid, ssid,pk, sk0, sk1).
S3: When Adv replies with a tuple (sid,
ssid, y0, y1), Sim first looks up the correspond-
ing (pk, sk0, sk1), and then computes mb ←
Dec(skb, yb) for each b ∈ {0, 1}.
S4: Since S has been activated, Sim sends
(sid, ssid, sender,m0,m1) to F̃OT as if it were from S.
3.3.3 Remaining corruption cases
When both parties are corrupted, Sim just in-
ternally runs a copy of Adv which controls S and R
and generates the messages from them both by itself.
When neither party is corrupted, Sim internally
runs the honestR on input (sid, ssid, σ = 0) and hon-
est S on input (sid, ssid,m0 = 0�,m1 = 0�) by per-
forming the interaction specified by protocol dmmode
and delivering all communication messages between
internals R and S to Adv.
4 Quantum security analysis
Based on different simulator constructions in
different corruption cases, the protocol dmmode is
provably secure in the standard UC framework (Peik-
ert et al., 2008). However, its security is considered
only within the existence of classical adversaries in-
stead of a quantum one. Due to the fact that the
protocol dmmode is built upon LWE hardness, we
conjecture that it may be quantum resistant. There-
fore, in this section, by using some results from Un-
ruh (2010), we revisit the security proof of dmmode
by considering the existence of a quantum adversary
and show that dmmode can also preserve its security
in the quantum setting. In Section 4.1, we first intro-
duce some results proposed by Unruh (2010). Then
we use these results to make quantum analysis for
dmmode in Section 4.2.
4.1 Quantum lifting theorem
The quantum analogue of the classical UC
framework was proposed by Unruh (2010). Further-
more, an additional result, called the ‘quantum lift-
ing theorem (QLT)’, is presented.
Theorem 1 (Quantum lifting theorem (statisti-
cally), cf. Theorem 15 in Unruh (2010)) Let π and
ρ be classical protocols. If π statistically classical-
UC-emulates ρ, then π also statistically quantum-
UC-emulates ρ.
To the best of our knowledge, this is the first
result (cf. Unruh (2010) for its proof) to discuss
the classical security in the quantum setting, al-
though it is restricted to the statistical case. One
might expect that a computational analogue of such
a QLT exists. However, computational QLT (that
is, π can computationally quantum-UC-emulate ρ
if π computationally classical-UC-emulates ρ) can-
not be directly obtained. The reason is that if the
hardness on which protocol π relies is not quantum
resistant, then such a computational QLT does not
exist and cannot be used to lift the classical secu-
rity of protocols into the quantum setting. How-
ever, Unruh (2010) proposed an additional restric-
tion for the computational QLT, i.e., requiring that
the classical adversary have the same computational
power as a quantum polynomial-time machine in the
classical UC framework. This type of adversary is
called a ‘quantum-strong probabilistic polynomial-
time (QPPT)’ machine, which is defined as follows:
Definition 5 (Quantum-strong probabilistic poly-
nomial-time machine, cf. Definition 16 in Unruh
(2010)) For a classical machine M , if there is a
quantum polynomial-time machine M̂ such that for
any network N , N ∪{M} and N ∪{M̂} are perfectly
indistinguishable, then we say that M is a quantum-
strong probabilistic polynomial-time machine, i.e., a
QPPT machine. If a classical machine M is a QPPT
machine, then we denote it by M ′.
Remark 4 Now we recall the machine model
as described in Section 2.5 for illustrating Defini-
tion 5 (Unruh, 2010). Given a QIM M̂ , let C(M̂)
denote a machine, which behaves like M̂ , but mea-
sures incoming messages in the computational ba-
sis before processing them and measures outgoing
messages in the computational basis. More pre-
cisely, its superoperater E(n)C(M̂)
first invokes Eclass on
Hclass⊗Hquant, then invokes M̂ ’s superoperator E(n)
M̂
on Hstate⊗Hclass⊗Hquant, and finally invokes Eclass
on Hclass ⊗ Hquant again. C(M̂) can be regarded as
a special QIM which operates with quantum com-
putation inside but classical communication outside.
Since it is possible to simulate QIMs on ITMs with
1358 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
an exponential overhead, for every machine M̂ , there
exists a classical machine M such that C(M̂) and M
are perfectly indistinguishable. Then such a machine
M is a QPPT machine, denoted by M ′.
Based on Definition 5, the notion of QPPT
classical-UC-security can be derived directly, where
the adversaries are required to be QPPT machines.
Thus, a computational QLT with the restriction
on the computation power of adversaries can be
achieved.
Definition 6 (QPPT classical-UC-security, cf. Defi-
nition 17 in Unruh (2010)) Let π and ρ be classical
protocols. We say π QPPT classical-UC-emulates
ρ if and only if for every corruption case C and for
every QPPT adversary Adv′, there is a QPPT sim-
ulator Sim′ such that for every QPPT environment
Z ′ the networks πC ∪{Adv′,Z ′} and ρC ∪{Sim′,Z ′}
are indistinguishable. That is to say, π can achieve
QPPT classical-UC-security.
Theorem 2 (Quantum lifting theorem (computa-
tionally), cf. Theorem 18 in Unruh (2010)) Let π
and ρ be classical protocols. If π QPPT classical-UC-
emulates ρ, then π also computationally quantum-
UC-emulates ρ.
However, the above computational QLT cannot
be directly applied to the classical security proof of
dmmode. We first have to prove that dmmode can
achieve the QPPT classical-UC-security. Therefore,
we carefully revisit its original classical-UC-security
proof and show that its security can be preserved
when all adversarial machines are QPPT machines.
We point out that all QIMs involved in our analysis
match the description of the machine model shown in
Section 2.5, so do the communication and corruption
behaviors between QIMs.
4.2 Quantum security analysis of dmmode
In the classical-UC-security proof of dmmode,
the achieved security is described as follows:
1. When in messy mode, the security of S is
statistical and the security of R is computational;
2. When in decryption mode, the security of S
and R are both computational.
We view the interaction between F̃OT and two
dummy parties (S and R) as an ideal protocol,
denoted by ρ
˜FOT , which securely realizes a multi-
session OT. If dmmode classical-UC-emulates F̃OT, it
implies that dmmode classical-UC-emulates the ideal
protocol ρ ˜FOT .
If the protocol dmmode operates in a specific cor-
ruption case, e.g., when only R is corrupted, then we
denote it with dmmode
R . When only R is corrupted,
the interaction between environment Z and the real
world will be denoted by dmmode
R ∪ {Z,Adv}. Anal-
ogously, the interaction between environment Z and
the ideal world will be denoted by ρ ˜FOT
R ∪ {Z , Sim}.
In addition, if Z cannot distinguish with which world
it is interacting, then we say these two networks
are indistinguishable, i.e., dmmode
R ∪ {Adv,Z} ≈
ρ
˜FOT
R ∪ {Sim,Z}.
Now we give a new security analysis for dmmode
by restricting the adversary, simulator, and environ-
ment as polynomial-time QIMs, denoted by Âdv,
Ŝim, and Ẑ, respectively. In the quantum set-
ting, we still consider the security of dmmode under
static corruptions, where the corruption decision is
made before the execution of the protocol and can-
not be changed during the execution of the protocol.
However, if the classical-UC-security of dmmode is
achieved under adaptive corruptions (i.e., the cor-
ruption is probabilistically decided during the pro-
tocol execution), we cannot separate different cor-
ruption cases in a case distinction when we consider
its security within the existence of a quantum adver-
sary. This is caused by the fact that it is not clear
at the beginning of the protocol in which corruption
case it will be. However, thanks to the UC-security
of dmmode achieved under static corruptions, we can
analyze its quantum security in a case distinction
by using different QLTs as presented before. With
this strategy, we first show our analysis of dmmode in
messy mode, and then step into the case in decryp-
tion mode.
4.2.1 In messy mode
In this part, we first analyze dmmode’s quantum
security in messy mode and under static corruptions:
(1) when only the receiver is corrupted; (2) when
only the sender is corrupted; (3) when both parties
are corrupted; (4) when neither party is corrupted.
1. When only R is corrupted
In messy mode, the classical security of the
sender is statistical if only R is corrupted, i.e.,
dmmes
R ∪ {Adv,Z} s≈ ρ
˜FOT
R ∪ {Sim,Z}, where
‘
s≈’ denotes that both networks are statistically
indistinguishable.
Since Adv is a static adversary who decides its
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1359
corruption with R before the execution of dmmes
R , we
can achieve Lemma 1 by using Theorem 1. Here, we
require Âdv, Ŝim, and Ẑ to be quantum polynomial-
time machines by following Unruh (2010).
Lemma 1 If dmmes
R ∪{Z,Adv} s≈ ρ ˜FOT
R ∪{Z, Sim},
and assuming that the adversary, simulator, and en-
vironment are quantum polynomial-time machines,
denoted by Âdv, Ŝim, and Ẑ, respectively, we have
dmmes
R ∪ {Ẑ, Âdv} s≈ ρ ˜FOT
R ∪ {Ẑ, Ŝim}.
Remark 5 When only R is corrupted in messy
mode, the output distributions of the real world and
the ideal world are statistically close. Actually, an
unboundedM and an unbounded M̂ can be regarded
as having the same probability to distinguish any
distribution. In particular, if two distributions are
statistically close, then neither a polynomial-time or
unbounded M , nor polynomial-time or unbounded
M̂ can distinguish them.
2. When only S is corrupted
In messy mode, the classical security of the re-
ceiver is computational when only S is corrupted,
i.e., dmmes
S ∪ {Adv,Z} c≈ ρ
˜FOT
S ∪ {Sim,Z}, where
‘
c≈’ denotes that both networks are computationally
indistinguishable. As illustrated before, we cannot
directly use Theorem 2 to lift this computational se-
curity into the quantum setting. Thus, we revisit its
classical security proof to check whether its security
satisfies Definition 6. If so, we obtain Lemma 2:
Lemma 2 If dmmes
S ∪{Z,Adv} c≈ ρ ˜FOT
S ∪{Z, Sim},
and assuming that the adversary, simulator, and en-
vironment are quantum polynomial-time machines,
denoted by Âdv, Ŝim, and Ẑ, respectively, we have
dmmes
S ∪ {Ẑ, Âdv} c≈ ρ ˜FOT
S ∪ {Ẑ, Ŝim}.
Proof If Adv corrupts only S in messy mode, then
dmmes
S ∪{Adv,Z} c≈ ρ ˜FOT
S ∪{Sim,Z} in the classical
setting. Now we consider the security of dmmes in
the same corruption case except for substituting the
adversary, simulator, and environment with QIMs.
In the execution of the real world, each party
will query the ideal functionality Fmes
CRS for crs, where
Fmes
CRS runs SetupMessy(1n) to generate crs. All
interactions will be executed in the following two
phases:
Phase 1 In this phase, the environment machine
chooses σ for honest R. Then R runs (pk, sk) ←
KeyGen(crs, σ) and sends pk to Z.
Now we assume that the environment and adver-
sary are both quantum polynomial-time machines,
i.e., Ẑ and Âdv. Since dmmes
S is classical, all messages
sent from Ẑ to dmmes
S should be measured before be-
ing used. Then honest R will return message pk to
environment Ẑ. Here, pk can also be regarded as a
communication message sent from R and then for-
warded by adversary Âdvdummy to environment Ẑ,
where adversary Âdv is dummy to be controlled by
the environment. Since pk is generated as an LWE
instance, for quantum PPT machine Ẑ and classical
PPT machine Z (even equipped with polynomial-
time quantum computation power), they both have
negligible probability to break LWE hardness. Thus,
in this phase, the view of a quantum polynomial-time
machine Ẑ and the view of a PPT classical machine
Z are perfectly indistinguishable. Here Ẑ behaves
like C(Ẑ) described in Remark 4, and then machine
Z is a QPPT machine Z ′.
Phase 2 In this phase the environment machine
will produce (y0, y1) using pk and then send it to R.
The honest R will output mσ ← Dec(sk, yσ).
Actually (y0, y1) is a communication message
sent from S to R, and it can be regarded as a
message sent from Âdv or forwarded by Âdvdummy
which is controlled by Ẑ. Since Âdv classically com-
municates with R in the name of S, it would ad-
ditionally measure the forwarded messages in the
computational basis first. Thus, the view of Ẑ
will not be modified; i.e., dmmes
S ∪ {Ẑ, Âdv} and
dmmes
S ∪ {Ẑ,Adv} are perfectly indistinguishable,
where Âdv behaves like C(Âdv). Then, Adv is a
QPPT machine Adv′ as defined by Definition 5. Fur-
thermore, both Adv′ and dmmes
S measure all mes-
sages upon sending and receiving, and then dmmes
S ∪
{Ẑ,Adv′} and dmmes
S ∪ {C(Ẑ),Adv′} are perfectly
indistinguishable, where C(Ẑ) is perfectly indistin-
guishable from a QPPT machine Z ′; thus, dmmes
S ∪
{C(Ẑ),Adv′} and dmmes
S ∪ {Z ′,Adv′} are perfectly
indistinguishable.
Based on the above two-phase execution of the
real world, the views of Ẑ and Z are perfectly
indistinguishable. Thus, dmmes
S ∪ {Z,Adv} and
dmmes
S ∪ {Z ′,Adv′} are perfectly indistinguishable
when two QPPT machines Adv′ and Z ′ participate
in the execution of the real world.
In the execution of the ideal world, we re-
visit the construction of the simulator in four
steps. For clarity, we define the simulator as
Sim(S1, S2, S3, S4) and a quantum polynomial-time
simulator as Ŝim(Ŝ1, Ŝ2, Ŝ3, Ŝ4).
1360 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
S1: First the simulator runs (crs, τ) ←
SetupDec(1n) and sends only crs to the environment
machine. In this step the simulator simulates the
classical ideal functionality Fmes
CRS which allows only
classical state access and returns crs as output.
Now we assume that the simulator has
polynomial-time quantum computation power in
S1, denoted as Ŝim(Ŝ1, S2, S3, S4). After running
(crs, τ) ← SetupDec(1n), Ŝim(Ŝ1, S2, S3, S4) will
measure the output before sending it to Z as if the
output came from Fmes
CRS. Thus, the view of Z would
not be modified, and ρ
˜FOT
S ∪{Z, Sim(S1, S2, S3, S4)}
and ρ
˜FOT
S ∪ {Z, Ŝim(Ŝ1, S2, S3, S4)} are perfectly
indistinguishable.
The simulation in this step will lead to the differ-
ence between the distributions of simulated crs and
the real one that comes from Fmes
CRS. Since distin-
guishing these two crs’ distributions amounts to solv-
ing a decisional LWE problem, classical polynomial-
time Z and quantum polynomial-time Ẑ have negli-
gible probability to distinguish these two distribu-
tions. Then ρ
˜FOT
S ∪ {Z, Ŝim(Ŝ1, S2, S3, S4)} and
ρ
˜FOT
S ∪ {Ẑ, Ŝim(Ŝ1, S2, S3, S4)} are perfectly indis-
tinguishable; i.e., Z is a QPPT machine Z ′ running
in this network.
S2: In this step, the simulator will run
(pk, sk0, sk1) ← TrapKeyGen(τ) and send pk to
the environment. Here we assume that the sim-
ulator has polynomial time quantum computation
power in S2, denoted by Ŝim(Ŝ1, Ŝ2, S3, S4). Since
Ŝim(Ŝ1, Ŝ2, S3, S4) simulates the behavior of R, it
will communicate classically outside but perform
quantum computation inside. The generation of
pk comes from the trapdoor information that is re-
lated to crs whose generation is based on LWE hard-
ness. Thus, for both classical PPT Z and quan-
tum polynomial-time Ẑ, Ŝim(Ŝ1, S2, S3, S4) and
Ŝim(Ŝ1, Ŝ2, S3, S4) are perfectly indistinguishable.
Summarizing the above, Ŝim(Ŝ1, Ŝ2, S3, S4) is
perfectly indistinguishable with classical simulator
Sim(S1, S2, S3, S4). It means that for a quantum
polynomial-time Ẑ, there exists a classical PPT Z
which has a perfectly indistinguishable view with
that of Ẑ, such that ρ ˜FOT
S ∪{Z, Sim(S1, S2, S3, S4)}
and ρ
˜FOT
S ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, S3, S4)} are perfectly
indistinguishable.
S3: In this step, the environment machine will
produce (y0, y1) for R. As a communication mes-
sage, (y0, y1) will be received by the simulator which
plays the role of R to interact with the environment.
Message (y0, y1) can be generated by invoking the
real adversary as a black box, where the simulator
works as the shell of the real adversary. As soon as
the simulator receives (y0, y1) from the output tape
of the adversary, it will compute mb ← Dec(skb, yb)
for each b ∈ {0, 1}.
Based on the analysis of Phase 2 in the
real world, we substitute Adv by a polynomial-
time QIM Âdv in the simulator’s construc-
tion, i.e., Ŝim(Ŝ1, Ŝ2, Ŝ3, S4). All messages
sent by Âdv will be measured before being
used, and then ρ
˜FOT
S ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, S3, S4)}
and ρ
˜FOT
S ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, Ŝ3, S4)} are perfectly
indistinguishable.
S4: Since R has been activated, the simulator
has to send (m0,m1) to the ideal functionality F̃OT
as if it were from S. In this step, as there is no
interaction between the simulator and the environ-
ment machine, then ρ ˜FOT
S ∪{Ẑ, Ŝim(Ŝ1, Ŝ2, Ŝ3, S4)}
and ρ
˜FOT
S ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, Ŝ3, Ŝ4)} are perfectly
indistinguishable.
Summarizing the above analysis in the ideal
world, we know that ρ
˜FOT
S ∪{Z, Sim(S1, S2, S3, S4)}
and ρ
˜FOT
S ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, Ŝ3, Ŝ4)} are perfectly
indistinguishable. By the definition of QPPT ma-
chines, Z and Sim(S1, S2, S3, S4) are both QPPT
machines in the ideal world, i.e., Z ′ and Sim′.
Based on the above analyses in both worlds, we
have dmmes
S ∪ {Ẑ, Âdv} c≈ ρ
˜FOT
S ∪ {Ẑ, Ŝim}. By the
definition of QPPT machines, we also have dmmes
S ∪
{Z ′,Adv′} c≈ ρ ˜FOT
S ∪ {Z ′, Sim′}. Lemma 2 has been
proven.
3. When both parties are corrupted
In the case where both the sender and the re-
ceiver are corrupted, the simulator can internally run
a copy of the adversary to perfectly simulate a pro-
tocol execution by generating the real messages ex-
changed between two parties. In this corruption case,
the security in the classical setting can be trivially
preserved in the quantum setting since the quantum
adversary cannot distinguish between two perfectly
indistinguishable worlds.
4. When neither party is corrupted
In the case where neither party is corrupted, the
simulator internally runs the honest R and S on in-
puts (sid, ssid, σ = 0) and (sid, ssid,m0 = 0�,m1 =
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1361
0�). When some dummy party is activated in the
ideal execution, the simulator will activate the ap-
propriate algorithm for the corresponding dummy
party, and deliver all communications between its in-
ternal S and R to the adversary Adv. Peikert et al.
(2008) showed the computational security in messy
mode when neither party is corrupted and its proof
is sketched as follows:
Let EXECdmmes,Adv,Z(m0,m1, b) denote Z’s
output in protocol dmmes where it sets the inputs
of S and R as (m0,m1) and b. By the messy prop-
erty of dual-mode encryption, we have
EXECdmmes,Adv,Z(m0,m1, 1)
s≈
EXECdmmes,Adv,Z(0�,m1, 1)
and
EXECdmmes,Adv,Z(0�,m1, 0)
s≈
EXECdmmes,Adv,Z(0�, 0�, 0).
Due to the computational security of R in messy
mode, we also have
EXECdmmes,Adv,Z(0�,m1, 1)
c≈
EXECdmmes,Adv,Z(0�,m1, 0).
Here EXECdmmes,Adv,Z(m0,m1, 1) is an actual real-
world execution, and EXECdmmes,Adv,Z(0�, 0�, 0) is
the execution of the simulator. In addition, thanks
to the completeness of the dual-mode cryptosystem,
EXECdmmes,Adv,Z(m0,m1, 1) is statistically indistin-
guishable from the ideal-world execution on inputs
(m0,m1, b). Thus, the computational security is
achieved in this corruption case.
Note that the security in the case where neither
party is corrupted is deduced by the security in the
cases where only S is corrupted and where only R
is corrupted. Thus, each indistinguishability derived
from each two adjacent protocol executions above
can be lifted into the quantum setting, thanks to the
quantum analysis in the cases where only S is cor-
rupted and where onlyR is corrupted. Therefore, the
computational security of dmmes when neither party
is corrupted is preserved in the quantum setting.
4.2.2 In decryption mode
In this part, we analyze dmmode’s quantum se-
curity in decryption mode under four static corrup-
tions. However, since the security of dmdec in the
cases where both parties are corrupted and neither
party is corrupted is similar to that we have shown
in messy mode, here we analyze only dmdec’s quan-
tum security in the cases where only the receiver is
corrupted and where only the sender is corrupted.
1. When only R is corrupted
In decryption mode, the security of the sender
is computational if only R is corrupted, i.e., dmdec
R ∪
{Z,Adv} c≈ ρ
˜FOT
R ∪ {Z, Sim}. Now under this cor-
ruption, we revisit the original security proof of
dmdec
R considering the existence of quantum adver-
saries. Then we can obtain Lemma 3:
Lemma 3 If dmdec
R ∪{Z,Adv}
c≈ ρ ˜FOT
R ∪{Z, Sim},
and when we assume that the adversary, simulator,
and environment are quantum polynomial-time ma-
chines, denoted by Âdv, Ŝim, and Ẑ, respectively,
then dmdec
R ∪ {Ẑ, Âdv} c≈ ρ ˜FOT
R ∪ {Ẑ, Ŝim}.
Proof If Adv corrupts only with R in decryption
mode, then dmdec
R ∪ {Z,Adv} c≈ ρ ˜FOT
R ∪ {Z, Sim} in
the classical setting.
In the execution of the real world, all parties
first query ideal functionality Fdec
CRS for crs, where
Fdec
CRS runs SetupDec(1n) to generate crs. All in-
teractions will proceed as follows: the environment
machine first chooses an arbitrary pk and inputs
(m0,m1) for the honest S, and then S sends yb ←
Enc(pk, b,mb) for each b ∈ {0, 1} to the environment
machine.
Now we assume that the environment and the
adversary are both quantum polynomial-time ma-
chines, i.e., Ẑ and Âdv. Since dmdec
R is classical, all
messages sent from Ẑ to dmdec
R should be measured
before being used. As a communication message sent
from R to S, pk can be viewed as a message sent
from Âdv or forwarded by Âdvdummy which is con-
trolled by Ẑ. Since Âdv classically communicates
with S in the name of R, it would additionally mea-
sure the forwarded messages in the computational
basis first. Thus, the view of Ẑ would not be mod-
ified; i.e., dmdec
R ∪ {Ẑ, Âdv} and dmdec
R ∪ {Ẑ,Adv}
are perfectly indistinguishable, where Âdv behaves
like C(Âdv). Then Adv can be regarded as a QPPT
machine Adv′. Furthermore, both Adv′ and dmdec
R
measure all messages upon sending and receiving.
Then dmdec
R ∪ {Ẑ,Adv′} and dmdec
R ∪ {C(Ẑ),Adv′}
are perfectly indistinguishable, where C(Ẑ) is per-
fectly indistinguishable from a QPPT machine Z ′.
Thus, dmdec
R ∪ {C(Ẑ),Adv′} and dmdec
R ∪ {Z ′,Adv′}
are perfectly indistinguishable.
1362 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
Since messages (y0, y1) sent from dmdec
R to Ẑ
are ciphertexts of (m0,m1) which are generated us-
ing the LWE-based encryption scheme described in
Section 3, quantum PPT machine Ẑ and classical
PPT Z (even equipped with polynomial-time quan-
tum computation power) have negligible probabili-
ties to break the LWE hardness. Thus, the view
of a quantum polynomial-time machine Ẑ and the
view of a PPT classical machine Z are perfectly
indistinguishable. By the definition of QPPT ma-
chine, we know that Z is a QPPT machine Z ′. Then
dmdec
R ∪ {Z,Adv} and dmdec
R ∪ {Z ′,Adv′} are per-
fectly indistinguishable when two QPPT machines
Adv′ and Z ′ participate in the execution of the real
world.
In the execution of the ideal world, we re-
visit the construction of the simulator in four steps.
For clarity, we denote the classical simulator as
Sim(S1, S2, S3, S4) and a quantum polynomial-time
simulator as Ŝim(Ŝ1, Ŝ2, Ŝ3, Ŝ4).
S1: The simulator runs (crs, τ) ←
SetupMessy(1n) and outputs only crs when
the query for crs is asked. In this step, the simulator
simulates the classical ideal functionality Fdec
CRS
which allows only classical state access and returns
crs as the output.
Now we assume that the simulator has
polynomial-time quantum computation power in
S1, denoted by Ŝim(Ŝ1, S2, S3, S4). After running
(crs, τ) ← SetupMessy(1n), Ŝim(Ŝ1, S2, S3, S4) will
measure the output before sending it to Z as if it
were from Fdec
CRS. Thus, the view of Z would not
be modified; i.e., ρ ˜FOT
R ∪ {Z, Sim(S1, S2, S3, S4)}
and ρ
˜FOT
R ∪ {Z, Ŝim(Ŝ1, S2, S3, S4)} are perfectly
indistinguishable.
The simulation in this step will lead to the dif-
ference in the distribution from the simulated crs
and the real one generated by Fdec
CRS. Since distin-
guishing these two crs distributions amounts to solv-
ing a decisional LWE problem, classical PPT Z and
quantum polynomial-time Ẑ have negligible proba-
bilities to distinguish these two distributions. Then
we know that ρ ˜FOT
R ∪ {Z, Ŝim(Ŝ1, S2, S3, S4)} and
ρ
˜FOT
R ∪ {Ẑ, Ŝim(Ŝ1, S2, S3, S4)} are perfectly indis-
tinguishable; i.e., Z is a QPPT machine Z ′ running
in this network by Definition 5.
S2: In this step, the environment machine will
produce pk for S. As a communication message,
pk will be received by the simulator which plays
the role of S. Message pk can be generated by in-
voking the real adversary as a black box, where the
simulator works as the shell of the real adversary.
Now we substitute the classical PPT machine Adv
by a quantum polynomial-time machine Âdv in the
simulator’s construction, i.e., Ŝim(Ŝ1, Ŝ2, S3, S4).
Since all messages sent by Âdv will be mea-
sured before being used, based on the analysis
in the real world, ρ ˜FOT
R ∪ {Ẑ, Ŝim(Ŝ1, S2, S3, S4)}
and ρ
˜FOT
R ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, S3, S4)} are perfectly
indistinguishable.
S3: In the third step, the simulator will run
b ← FindMessy(τ,pk) to find messy branch b with
an overwhelming probability. Then the simulator
queries ideal functionality F̃OT with the chosen bit
1 − b to obtain m1−b in the name of R. Here we
assume that as this simulator has polynomial-time
quantum power in S3, it will communicate classi-
cally outside but perform quantum computation in-
side. Since FindMessy is a classical PPT algorithm,
it is still efficient when a quantum PPT machine
runs on it. Thus, ρ ˜FOT
R ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, S3, S4)}
and ρ
˜FOT
R ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, Ŝ3, S4)} are perfectly
indistinguishable.
S4: In this step the simulator will compute
(y1−b = Enc(pk, 1 − b,m1−b), yb = Enc(pk, b, 0�))
and send it to the adversary as if it were
from S. We assume that the simulator has
polynomial-time quantum power in S4, i.e.,
Ŝim(Ŝ1, Ŝ2, Ŝ3, S4), and it simulates the behav-
ior of honest S and sends (y0, y1) to the envi-
ronment. Thus, ρ
˜FOT
R ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, Ŝ3, S4)}
and ρ
˜FOT
R ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, Ŝ3, Ŝ4)} are perfectly
indistinguishable.
Since simulated yb = LWEEnc(pk, b, 0�) is sta-
tistically close to real yb = LWEEnc(pk, b,mb), clas-
sical PPT Z and quantum polynomial-time Ẑ have
negligible probabilities to distinguish these two ci-
phertexts. Then ρ
˜FOT
R ∪ {Z, Ŝim(Ŝ1, Ŝ2, Ŝ3, Ŝ4)}
and ρ ˜FOT
R ∪{Ẑ, Ŝim(Ŝ1, Ŝ2, Ŝ3, Ŝ4)} are perfectly in-
distinguishable; i.e., Z is a QPPT machine Z ′ in this
network.
Summarizing the above analysis in the ideal
world, we have that ρ ˜FOT
R ∪{Z, Sim(S1, S2, S3, S4)}
and ρ
˜FOT
R ∪ {Ẑ, Ŝim(Ŝ1, Ŝ2, Ŝ3, Ŝ4)} are perfectly
indistinguishable. By the definition of QPPT ma-
chines, Z and Sim(S1, S2, S3, S4) are both QPPT
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1363
machines in the execution of the ideal world, i.e., Z ′
and Sim′.
Based on the above analysis in two worlds, we
have dmdec
R ∪ {Ẑ, Âdv} c≈ ρ ˜FOT
R ∪ {Ẑ, Ŝim}. By Def-
inition 5, we have dmdec
R ∪ {Z ′,Adv′} c≈ ρ
˜FOT
R ∪
{Z ′, Sim′}. Lemma 3 has been proven.
2. When only S is corrupted
In this corruption case, because the construc-
tion of the simulator is the same as that in messy
mode, the quantum analysis is similar to the case
when only the sender is corrupted in messy mode.
The only difference between the real world and the
ideal world lies in the generation of the public and
secret keys. However, the trapdoor key generation
(pk, skσ) is computationally indistinguishable with
KeyGen(crs, σ) for any crs generated by SetupDec.
By assuming the LWE hardness, it provides only
computational security for the receiver in decryption
mode (cf. Lemma 7.7 in Peikert et al. (2008)). The
quantum security follows similarly. We can directly
obtain Lemma 4:
Lemma 4 If dmdec
S ∪{Z,Adv}
c≈ ρ ˜FOT
S ∪{Z, Sim},
assuming that the adversary, simulator, and environ-
ment are quantum polynomial-time machines, de-
noted by Âdv, Ŝim, and Ẑ, respectively, then we
have dmdec
S ∪ {Ẑ, Âdv} c≈ ρ ˜FOT
S ∪ {Ẑ, Ŝim}.
3. Remaining corruption cases
The security in the cases where both parties are
corrupted and where neither party is corrupted fol-
lows symmetrically as shown in messy mode.
According to the above security analysis of
dmmode considering the existence of polynomial-time
quantum adversaries, we can claim that the security
of dmmode can be lifted into a quantum world by
Proposition 2:
Proposition 2 UC-secure OT protocol dmmode
can preserve its achieved security in the quantum set-
ting within the existence of polynomial-time quan-
tum adversaries.
5 Simple hybrid arguments framework
In this section, we first introduce a framework
proposed by Hallgren et al. (2011; 2015), called ‘sim-
ple hybrid arguments (SHA)’, which is developed to
capture a large family of classical security in the UC
model that can go through into the quantum setting
as long as their underlying primitives are quantum
resistant. As a supplement to our quantum security
analysis shown in Section 4, we apply this framework
to the OT protocol dmmode and show that our quan-
tum analysis of dmmode is compatible with the SHA
framework.
5.1 Simple hybrid arguments
To introduce the notion of SHA, some relevant
notions are presented first. Here we first recall their
description for the QIM, which respects the machine
model proposed by Unruh (2010).
A QIM M̂ is an ensemble of interactive cir-
cuits {M̂n}n∈N, where n is the security parameter.
For some n, M̂n consists of a sequence of circuits
{M̂ (i)
n }i=1,2,...,r(n), where {M̂ (i)
n } defines the opera-
tions of M̂ in the ith round and r(n) is the round
number for which M̂n operates. M̂ works on three
registers, i.e., a state register S used for input and
workspace, an output register O, and a network reg-
ister N for interacting with other machines. The size
or the running time of M̂ is denoted by t(n). We say
a machine M̂ is polynomial time if there exists a de-
terministic classical Turing machine that computes
the description of M̂n in t(n) = poly(n) on input
1n. A non-interactive quantum machine, denoted by
QTM, is a QIM without network register; i.e., its
machine circuit is only {M̂ (i)
n }i=1. Note that a clas-
sical ITM can be viewed as a special QIM, where
it stores only classical string and all circuits there
are classical. Then we recall the definition of simply
related machines as follows:
Definition 7 (Simply related machines, cf. Defini-
tion 4.2 in Hallgren et al. (2015)) Let M̂a and M̂b
denote two QIMs. If there exists a t(n)-time QTM
M̂ and a pair of classical distributions (Da, Db) such
that (1) M̂(Da) ≡ M̂a (for two QIMs M̂1 and M̂2,
M̂1 ≡ M̂2 implies that two machines can be de-
scribed by the same circuits and behave identically
on all inputs), (2) M̂(Db) ≡ M̂b, and (3)Da ≈2t,ε
qc Db
(ε(n) denotes a negligible advantage for distinguish-
ing Da and Db), we say that M̂a and M̂b are (t, ε)-
simply related.
Note that here M̂(Da) represents a machine M̂
running on the inputs sampled from Da. In addi-
tion, Da ≈2t,ε
qc Db means that for any 2t(n)-time
quantum distinguisher, it can distinguish only these
two distributions with a negligible advantage ε(n).
The condition Da ≈2t,ε
qc Db is required for the deriva-
tion of Lemma 5 whose proof comes from the con-
tradiction that if a t(n)-time distinguisher Ẑ that
1364 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
can distinguish M̂a and M̂b exists, then a 2t(n)-time
distinguisher D̂ for distinguishing Da and Db can be
constructed. Before we introduce Lemma 5, we first
recall the notion of (t, ε)-interactively indistinguish-
able QIMs.
Definition 8 ((t, ε)-interactively indistinguishable
QIMs, cf. Definition 2.5 in Hallgren et al. (2015))
Let M̂a and M̂b denote two QIMs. We say M̂a and
M̂b are (t, ε)-interactively indistinguishable, denoted
by M̂a ≈t,ε
i M̂b, if for any t(n)-time QIM Ẑ and any
mixed state ϕn on t(n) qubits,
| Pr[〈Ẑ(ϕn), M̂a〉 = 1]−Pr[〈Ẑ(ϕn), M̂b〉 = 1] |≤ ε(n),
where ε(n) is negligible.
If for every t(n) ≤ poly(n), there exists a negligi-
ble ε(n) such that M̂a and M̂b are (t, ε)-interactively
indistinguishable, M̂a and M̂b are called ‘quantum
computationally interactively indistinguishable’, de-
noted by M̂a ≈qci M̂b. Likewise, for statistically
interactively indistinguishable QIMs, this type of
indistinguishability is denoted by M̂a ≈qsi M̂b, if
an unbounded interactive quantum distinguisher Ẑ
exists.
Based on Definitions 7 and 8, Lemma 5 can be
achieved:
Lemma 5 (cf. Lemma 4.3 in Hallgren et al. (2015))
If two QIMs M̂a and M̂b are (t, ε)-simply related,
then M̂a ≈t,ε
qci M̂b.
Now we can introduce the SHA framework,
which uses the above notions.
Definition 9 (Simple hybrid arguments, cf. Defini-
tion 4.4 in Hallgren et al. (2015)) If there is a se-
quence of intermediate machines M̂1, M̂2, . . . , M̂�−1
between M̂0 and M̂� such that each two adjacent
machines M̂i−1 and M̂i (i = 1, 2, . . . , �) are (t, ε/�)-
simply related, we say M̂0 and M̂� are related by a
(t, ε)-SHA of length �.
Furthermore, we can obtain Lemma 6
(cf. Lemma 4.5 in Hallgren et al. (2015)):
Lemma 6 (cf. Lemma 4.5 in Hallgren et al. (2015))
For any t, ε, and �, if M̂0 and M̂� are related by a
(t, ε)-SHA of length �, then M̂0 and M̂� are (t, ε)-
interactively indistinguishable.
Lemma 6 is deduced by showing that if two
QIMs can fall into the SHA framework, then these
two QIMs are (t, ε)-interactively indistinguishable
by Lemma 5; i.e., no t(n)-time distinguisher Ẑ
can distinguish these two QIMs with overwhelming
advantages.
5.2 Application of the SHA framework
Now we apply the SHA framework to pro-
tocol dmmode. We first regard the execution of
dmmode with Adv as a composed machine, denoted
by Mdmmode,Adv. The execution of F̃OT with two
dummy parties in the ideal world can be regarded as
an ideal protocol ρ ˜FOT which captures the security
requirements of secure oblivious transfer. Likewise,
the execution of ρ ˜FOT with simulator Sim is repre-
sented by a composed machine M
ρ
˜FOT ,Sim
. Using
the SHA framework in Definition 9, we show that
M
dmmode,̂Adv
andM
ρ
˜FOT ,̂Sim
are still interactively in-
distinguishable after all adversarial ITMs; i.e., the
adversary, simulator, and environment are changed
into QIMs.
Now we recall the classical UC-security proof of
dmmode. The real world and the ideal world can be
represented by Mdmmode,Adv and M
ρ
˜FOT ,Sim
, respec-
tively. These two composed classical ITMs can be
regarded as two special QIMs, where the registers
store only classical states and all circuits are clas-
sical. In Section 4, we show the quantum security
of dmmode by modifying the adversarial machines
Adv, Sim, and Z step by step in each corruption
case. During the execution of the real world (or the
ideal world), we modify the composed machine from
M
dmmode,̂Adv
to Mdmmode,Adv (or from M
ρ
˜FOT ,Sim
to
M
ρ
˜FOT ,̂Sim
), where these modifications will lead to a
sequence of intermediate machines fromM
dmmode,̂Adv
to Mdmmode,Adv (or from M
ρ
˜FOT ,Sim
to M
ρ
˜FOT ,̂Sim
).
Each two adjacent machines in the ma-
chine modification sequence from M
dmmode,̂Adv
to
Mdmmode,Adv are perfectly indistinguishable. It im-
plies that these two adjacent machines behave identi-
cally on all inputs chosen from the same distribution.
They can be viewed as a special pair of simply related
machines with a negligible impact on (t, ε). Thus,
M
dmmode,̂Adv
and Mdmmode,Adv are related by a (t, ε)-
SHA of length �real (the number of machine mod-
ifications in the real world), i.e., (t, ε)-interactively
indistinguishable. Likewise, each two adjacent ma-
chines betweenM
ρ
˜FOT ,Sim
andM
ρ
˜FOT ,̂Sim
are simply
related. Thus, M
ρ
˜FOT ,Sim
and M
ρ
˜FOT ,̂Sim
are related
by a (t, ε)-SHA of length �ideal (the number of ma-
chine modifications in the real world). In addition,
since the classical UC-security of dmmode shows that
Mdmmode,Adv and M
ρ
˜FOT ,Sim
are interactively indis-
tinguishable, we finally have that M
dmmode,̂Adv
and
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1365
M
ρ
˜FOT ,̂Sim
are interactively indistinguishable, i.e.,
M
dmmode,̂Adv
≈t,ε
qci Mρ
˜FOT ,̂Sim
.
6 Game-preserving reduction
In this section, we introduce another framework,
called ‘game-preserving reduction’ (Song, 2014),
which is used to check whether the classical security
proof of post-quantum cryptographic primitives can
be preserved in the quantum setting. In other words,
this framework explores whether the reductions de-
rived from the classical security proof of some post-
quantum cryptographic primitives are still available
in the quantum setting from the perspective of the
provable security paradigm. If so, we say these reduc-
tions are quantum-friendly, and this post-quantum
cryptographic primitive is quantum resistant.
Intuitively, a reduction is a transformation from
an adversary to another adversary. The notion of
game-preserving reduction is used to depict the type
of reductions that can still make sense when adver-
saries are assumed to have quantum power. In ad-
dition, a notion, called ‘class-respectful reduction’,
is proposed as an instance to illustrate the game-
preserving reductions.
In this section, we show that the classical reduc-
tions inherently included in the classical UC-security
proof of dmmode satisfy the sufficient conditions of
class-respectful reduction. Therefore, these reduc-
tions are quantum-friendly and this application is
compatible with our analysis in Section 4. We first
recall the notion of ‘class-respectful reduction’ (Song,
2014) in Section 6.1 and apply it to dmmode in Sec-
tion 6.2.
6.1 Game-preserving reduction: class-
respectful reduction
For a clear overview of class-respectful reduc-
tion, we introduce a formal definition of ‘reduction’,
which is built upon the notion of ‘game’. Then we
list some expected properties that an effective reduc-
tion may have and show the procedure on which a
reduction can be built. These notions (Song, 2014)
are used for the check on whether an effective re-
duction already at hand respects the properties of a
specified class of reductions. If it does, we call this
reduction a ‘class-respectful reduction’ for that spec-
ified class. Finally, we recall the formal definition of
class-respectful reduction which is specified as two
sufficient conditions and the main tool for checking
the security of dmmode in the quantum setting (Sec-
tion 6.2).
A game G denotes a probabilistic process be-
tween two players, i.e., a challenger C and an ad-
versary A. After several rounds of interaction be-
tween them, C will output one bit to indicate if A
wins game G. We denote the success probability of
A in G by ωG(A). In addition, if there exist two
machines M and N such that ωG(M) = ωG(N),
then we call M and N G-equivalent. If for a classi-
cal machine M , there exists a machine N ∈ C such
that ωG(M) = ωG(N), where C denotes a class of
machines, then we say that M is ‘[G,C]-realizable’.
EG(C) denotes the collection of classical machines
that are [G,C]-realizable.
A reduction R is represented by
(Gext(B), T , Gint(A)), where Gext and Gint de-
note the external game and the internal game,
respectively, and transformer T transforms an
adversary A in Gint into an adversary B = T (A) in
Gext. In particular, if R is a black-box reduction
(i.e., transformation T does not look into the inner
workings of adversary A), then the output of T
can be viewed as an oracle machine with access
to A, denoted by TA. A meaningful reduction
R = (Gext(B), T , Gint(A)) is supposed to have some
properties as described below. Let A and B denote
two classes of machines. We say R is
1. A-compatible, if ∀A ∈ A, Gint(A) and
Gext(T (A)) are well defined, i.e., A and T (A) re-
spect the game specifications;
2. (A,B)-consistent, if R is A-compatible and
∀A ∈ A, T (A) ∈ B—we denote such a reduction R
by (Gext(B), T , Gint(A)) or R(A,B);
3. value-dominating, if ωGext(T (A)) =
ωGext(T (B)) whenever ωGint(A) = ωGint(B);
4. (αsucc,A)-effective, if ∀A ∈ A, ωGext(T (A)) ≥
αsucc(ωGint(A)), where αsucc : R+ → R
+ denotes a
function bounded by the global security parameters.
To analyze the security of a classical crypto-
graphic scheme in the provable security paradigm,
an effective reduction should be built and it proceeds
mainly as follows:
1. A security requirement is formalized by a
game Gint, i.e., (Gint(A), εA), where the adver-
sary in Gint is restricted to a particular class A
and εA represents the upper bound on the success
1366 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
probability that any adversary in A can win Gint.
Namely, ωGint(A) ≤ εA ∈ (0, 1].
2. A computational assumption is formalized by
another game Gext, i.e., (Gext(B), εB), where the
adversary in Gext is restricted to class B and εB is
the upper bound of the success probability in Gext.
Namely, ωGext(B) ≤ εB ∈ (0, 1].
3. An (A,B)-consistent reduction R =
(Gext(B), T , Gint(A)) is constructed, if its security
follows that R is αsucc-effective with αsucc ≥ εB/εA.
It implies that if there exists an adversary A ∈ A
with ωGint(A) > εA, then an adversary T (A) ∈ B
exists such that ωGext(T (A)) ≥ αsucc·ωGint(A) > εB.
Now let R = (Gext(B), T , Gint(A)) be a classi-
cal reduction as described before. Let Ĝext(B̂) and
Ĝint(Â) be two extended games in the quantum set-
ting, where the adversaries are restricted to classes
of quantum machines (Â, B̂). Here Ĝext(B̂) and
Ĝint(Â) respect the game specifications of Gext and
Gint, respectively. Similarly, (Ĝint(Â), εÂ) formalizes
a security requirement against quantum adversaries
in Â with ωĜint(Â) ≤ εÂ, and (Ĝext(B̂), εB̂) formal-
izes a computational assumption against quantum
adversaries in class B̂. Now we would like to ex-
plore whether there exists a reduction R̂(Â, B̂) that
can keep similar properties to those of R(A,B). To
achieve this goal easily, we will apply the notion of
class-respectful reduction, which is sketched by two
conditions in Definition 10 for checking if a classical
reduction R(A,B) can be lifted into the quantum
setting.
Definition 10 (β-(Â, B̂)-respectful reduction,
cf. Definition 3 in Song (2014)) Let R be a clas-
sical reduction (Gext(B), T , Gext(A)) and (Â, B̂) de-
note two quantum machine classes. We say R is
β-(Â, B̂)-respectful for some β ∈ R
+ if R satisfies
the following two conditions:
1. (β, Â)-extendable, if R is EGint(Â)-
compatible and (β,EGint(Â))-effective;
2. (Â, B̂)-closed, if R is (EGint(Â), EGext(B̂))-
consistent.
Note that the above notions can be interpreted
for checking whether a classical reduction can still
make sense when the adversaries are restricted to the
class of quantum machines β-(Â, B̂), where the inter-
nal and external adversaries are restricted to Â and
B̂, respectively, and β is a value related to the effec-
tiveness of such a reduction. If a classical reduction
R satisfies the above two conditions, by Theorem 3
(cf. Song (2014) for its proof), we can directly show
that an effective quantum reduction exists. Further-
more, if all the classical reductions derived from the
security proof of a post-quantum primitive satisfy
Definition 10, then we say this primitive can pre-
serve its security in the quantum setting.
Theorem 3 (Quantum lifting for game-preserv-
ing reductions, cf. Theorem 1 in Song (2014))
If R(A,B) is β-(Â, B̂)-respectful, then there ex-
ists an (Â, B̂)-consistent reduction R̂(Â, B̂) :=
(Gext(B̂), T̂ , Gint(Â)) that is (β, Â)-effective.
6.2 Application of class-respectful reduction
In this section, we apply Definition 10 to the de-
rived reductions of dmmode and show that these re-
ductions are class-respectful reductions. Therefore,
by Theorem 3, the classical security of dmmode can
be lifted into the quantum setting.
We note that the provable security of dmmode
is achieved by the simulation-based paradigm, where
the main ingredients of its UC-security proof are sev-
eral hybrid arguments defined in terms of Adv and
Sim. The hybrid argument is a proof technique to
show that two distributions are computationally in-
distinguishable by building a sequence of polynomial
distributions (called ‘hybrids’) between the original
two distributions and showing that each two adjacent
hybrids are indistinguishable.
When we recall the classical UC-security of
dmmode, we can find that there exists a reduction
R = (Gext, T , Gint) whenever the final computa-
tional indistinguishability is obtained by distinguish-
ing between the real world and the ideal world in
different corruption cases. In each corruption case,
we can formalize the distinguishing game between
the real world and the ideal world as a general form,
which is executed between a challenger C and a dis-
tinguisher D and viewed as Gint in reduction R.
This internal game is denoted by GZ,Sim(Adv), where
Sim(Adv) represents that Sim runs a copy of Adv
as its subroutine. Game GZ,Sim(Adv) is defined as
follows:
1. C flips a random coin i ∈R {0, 1}. If i = 0,
C runs an execution of the real world and sends the
view of Adv to D; if i = 1, C runs an execution of
the ideal world, and sends the output of Sim to D.
2. D collects all messages received from C, and
outputs one bit i′ to C.
3. C outputs success if i = i′ or failure otherwise.
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1367
We note that the environment machine Z plays
the role of D in distinguishing game GZ,Sim(Adv).
Since dmmode is built upon LWE hardness, a clas-
sical reduction R := (Gext, T , Gint := GZ,Sim(Adv))
can be built, where we define Gext as a game of dis-
tinguishing the LWE distribution from the uniform
distribution.
Now we can apply Definition 10 to check
whether reduction R := (Gext, T , Gint :=
GZ,Sim(Adv)) is a class-respectful reduction or not,
where the class is restricted as a quantum machine
class. It is clear that the class of internal adver-
saries A and the class of external adversaries B
in R := (Gext, T , Gint := GZ,Sim(Adv)) are both
polynomial-time classical machine classes. In the
application of Definition 10, we restrict the class of
internal adversaries Â and the class of external adver-
saries B̂ in the quantum setting to both polynomial-
time quantum machine classes, denoted by Q.
During this check, the first condition of Defi-
nition 10 is usually easier to check than the second
condition. However, if the classical reduction R is
obtained in a black-box pattern with an additional
condition thatR is straight-line (i.e., the output ma-
chine of T on A is the form of TA and A is run in a
straight-line till completion without rewinding), then
the second condition of Definition 10 can be checked
easily by Theorem 4 (cf. Song (2014) for its proof).
Theorem 4 (Straight-line reduction) Let R =
(Gext(B), T , Gint(A)) be a classical reduction, where
A and B are both classical polynomial-time ma-
chines. Let Â and B̂ be quantum polynomial-
time machines Q. If R is black-box, straight-line,
Â-compatible, and value-dominating, we say R is
(Â, B̂)-closed.
Now we show that whenever the computa-
tional indistinguishability is obtained in the se-
curity proof of dmmode, it will directly fall into
the game-preserving reduction framework by check-
ing whether these inherent reductions satisfy two
conditions of class-respectful reduction. Specifi-
cally, in each corruption case, a classical reduc-
tion R := (Gext, T , Gint := GZ,Sim(Adv)) can be
obtained, where the environment machine Z plays
the role of A in Gint(A). When we replace
Z with a quantum polynomial-time machine Ẑ,
then Z ∈ EGint(Q), which indicates that there
is a machine Ẑ ∈ Q such that ωGint(Z) =
ωGint(Ẑ). Since Gint(Z) and Gext(T (Z)) are
well-defined, R is EGint(Q)-compatible. Further-
more, R is (β,EGint(Q))-effective, where β satisfies
ωGext(T (Z)) ≥ β(ωGint(Z) for any Z ∈ EGint(Q).
Thus, R is (β,Q)-extendable.
Based on the simulator construction of dmmode
in each corruption case, we know that the corre-
sponding reduction R is black-box and straight-line,
i.e., T (Z) = TZ . Since ∀Ẑ ∈ Q both Gint(Ẑ)
andGext(T (Ẑ)) are well-defined,R isQ-compatible.
In addition, R is value-dominating, which means
that if ωGext(T (A)) = ωGext(T (B)), we always have
ωGint(A) = ωGint(B). Then we know that R is
(Q,Q)-closed by Theorem 4. According to Defi-
nition 10, we can claim that such R is a (β,Q)-
respectful reduction, i.e., a (β,Q)-effective reduc-
tion. It implies that in the current corruption case
dmmode is secure against quantum adversaries re-
stricted in Q. After checking for all derived reduc-
tions, we can say that dmmode is still secure in the
quantum setting.
7 Discussion and conclusions
The widespread use of oblivious transfer (OT)
and the concerns about the quantum resistance
of post-quantum cryptographic constructions moti-
vate us to explore the feasible security of the post-
quantum OT protocol in the quantum world.
In this work, we use three tools and give a com-
prehensive quantum security analysis of an existing
lattice-based OT protocol. These three tools are all
existing techniques that can be applied to the se-
curity analysis of classical protocols in a quantum
world. We first prove the quantum security of this
lattice-based OT protocol using the quantum lifting
theorem in Section 4, and then apply another two
tools (SHA framework and game-preserving reduc-
tion) to this OT protocol for a comprehensive analy-
sis. From some points of view, the discussions shown
in Sections 5 and 6 seem somewhat redundant since
they do not contribute to the proof in Section 4 and
simply work for the same argument using different
tools. The purpose of what we have done in Sec-
tions 5 and 6 is to show that our analysis is compati-
ble with that of the other two frameworks. Actually,
the application of the quantum lifting theorem in our
analysis also obeys the hybrid arguments technique,
which is the main ingredient of the SHA framework;
i.e., two adjacent machines are indistinguishable for
1368 Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369
a quantum distinguisher. Game-preserving reduc-
tion attempts to achieve the same goal, but instead
it interprets the security proof of classical protocols
as several reductions, i.e., checking whether these
reductions can meet some requirements (regarding
the quantum adversary), and thus lifting the whole
security proof into the quantum setting. It seems
that they are two different kinds of methods to prove
quantum security; however, these three tools give the
same results for the lattice-based OT in our work.
We think that one can use any tool as the circum-
stances may require; sometimes it may be easier to
approach the desired security from one point of view
rather than the other.
Our work can be regarded as an application of
the quantum security analysis framework for pro-
tocols. Furthermore, it motivates us to do some
more interesting work. The cryptographic applica-
tions based on the standard LWE problem are rather
inefficient in practice due to the large key size, the
error sampling, and large modulus operations. For
this concern, an algebraic variant of LWE called ‘ring
learning with errors (RLWE)’ was proposed, and is
provably at least as hard as the worst-case problems
in ideal lattice setting (Lyubashevsky et al., 2013).
Many applications based on the LWE problem can
be made more efficient by transforming the original
cryptosystem into a variant of the RLWE problem.
Therefore, searching for an efficient RLWE-based
OT protocol is an interesting research topic. One
possible way is to transform dmmode into an RLWE-
based variant using some results on trapdoor appli-
cations in ideal lattices (Lai et al., 2014). We believe
that the three security analysis frameworks used in
this work will also be available for this RLWE-based
OT variant.
For a practical deployment of the OT protocol,
a more efficient method called ‘OT extension’ (Ishai
et al., 2003) has been proposed, which enables a rel-
atively small number of base OTs to compute a very
large number of OTs at low cost. This OT exten-
sion protocol can be viewed as a hybrid of asym-
metric and symmetric constructions, i.e., extending
a small number of base (asymmetric) OTs via sym-
metric cryptography. In addition, Zhandry (2012)
showed three secure classical constructions of pseu-
dorandom functions in a quantum setting. Based
on these two results, an interesting question arises:
if we use a post-quantum OT protocol that is prov-
ably secure in the quantum setting as the base OT in
the OT extension protocol, and some proper quan-
tum secure pseudorandom functions as the symmet-
ric tools in the OT extension protocol, can we obtain
a post-quantum OT extension protocol which is se-
cure in the quantum setting? If this post-quantum
OT extension indeed exists, then we will have an ef-
ficient and practical way to implement a large use
of post-quantum OTs without loss of security in the
quantum world.
References
Bernstein, D.J., Buchamann, J., Dahmen, E., 2009. Post-
Quantum Cryptography. Springer, Berlin.
https://doi.org/10.1007/978-3-540-88702-7
Canetti, R., 2001. Universally composable security: a new
paradigm for cryptographic protocols. Proc. 42nd IEEE
Symp. on Foundations of Computer Science, p.136-145.
https://doi.org/10.1109/SFCS.2001.959888
Damgård, I., Funder, J., Nielsen, J.B., et al., 2014. Super-
position attacks on cryptographic protocols. LNCS,
8317:142-161.
https://doi.org/10.1007/978-3-319-04268-8_9
Even, S., Goldreich, O., Lempel, A., 1985. A random-
ized protocol for signing contracts. Commun. ACM,
28(6):637-647. https://doi.org/10.1145/3812.3818
Fehr, S., Katz, J., Song, F., et al., 2013. Feasibility and
completeness of cryptographic tasks in the quantum
world. LNCS, 7785:281-296.
https://doi.org/10.1007/978-3-642-36594-2_16
Gentry, C., Peikert, C., Vaikuntanathan, V., 2008. Trapdoors
for hard lattices and new cryptographic constructions.
Proc. 40th Annual ACM Symp. on Theory of Comput-
ing, p.197-206.
https://doi.org/10.1145/1374376.1374407
Gilboa, N., 1999. Two party RSA key generation. LNCS,
1666:116-129.
https://doi.org/10.1007/3-540-48405-1_8
Hallgren, S., Smith, A., Song, F., 2011. Classical cryp-
tographic protocols in a quantum world. LNCS,
6841:411-428.
https://doi.org/10.1007/978-3-642-22792-9_23
Hallgren, S., Smith, A., Song, F., 2015. Classical cryp-
tographic protocols in a quantum world. Cryptology
ePrint Archive, 2015/687.
http://eprint.iacr.org/2015/687
Ishai, Y., Kilian, J., Nissim, K., et al., 2003. Extending
oblivious transfers efficiently. LNCS, 2729:145-161.
https://doi.org/10.1007/978-3-540-45146-4_9
Lai, R.W.F., Cheung, H.K.F., Chow, S.S.M., 2014. Trap-
doors for ideal lattices with applications. LNCS,
8957:239-256.
https://doi.org/10.1007/978-3-319-16745-9_14
Lyubashevsky, V., Peikert, C., Regev, O., 2013. On ideal
lattices and learning with errors over rings. J. ACM,
60(6):43. https://doi.org/10.1145/2535925
Micciancio, D., Regev, O., 2009. Lattice-based cryptography.
In: Bernstein, D.J., Buchmann, J., Dahmen, E. (Eds.),
Post-Quantum Cryptography. Springer, Berlin, p.147-
191. https://doi.org/10.1007/978-3-540-88702-7_5
Liu et al. / Front Inform Technol Electron Eng 2017 18(9):1348-1369 1369
Nielsen, M.A., Chuang, I.L., 2010. Quantum Computa-
tion and Quantum Information. Cambridge University
Press, Cambridge.
Peikert, C., 2009. Some recent progress in lattice-based
cryptography. LNCS, 5444:72.
https://doi.org/10.1007/978-3-642-00457-5_5
Peikert, C., Vaikuntanathan, V., Waters, B., 2008. A frame-
work for efficient and composable oblivious transfer.
LNCS, 5157:554-571.
https://doi.org/10.1007/978-3-540-85174-5_31
Rabin, M.O., 1981. How to Exchange Secrets with Oblivious
Transfer. Technical Report No. TR-81, Aiken Compu-
tation Lab, Harvard University, Cambridge, MA.
http://eprint.iacr.org/2005/187
Regev, O., 2005. On lattices, learning with errors, random
linear codes, and cryptography. Proc. 37th Annual
ACM Symp. on Theory of Computing, p.84-93.
https://doi.org/10.1145/1060590.1060603
Sendrier, N., 2011. Code-based cryptography. In: van
Tilborg, H.C.A., Jajodia, S. (Eds.), Encyclopedia of
Cryptography and Security. Springer, New York, p.215-
216. https://doi.org/10.1007/978-1-4419-5906-5_378
Shor, P.W., 1997. Polynomial-time algorithms for prime fac-
torization and discrete logarithms on a quantum com-
puter. SIAM J. Comput., 26(5):1484-1509.
https://doi.org/10.1137/S0097539795293172
Song, F., 2014. A note on quantum security for post-quantum
cryptography. LNCS, 8772:246-265.
https://doi.org/10.1007/978-3-319-11659-4_15
Unruh, D., 2010. Universally composable quantum multi-
party computation. LNCS, 6110:486-505.
https://doi.org/10.1007/978-3-642-13190-5_25
Unruh, D., 2012. Quantum proofs of knowledge. LNCS,
7237:135-152.
https://doi.org/10.1007/978-3-642-29011-4_10
Watrous, J., 2009. Zero-knowledge against quantum attacks.
SIAM J. Comput., 39(1):25-58.
https://doi.org/10.1137/060670997
Zhandry, M., 2012. How to construct quantum random
functions. IEEE 53rd Annual Symp. on Foundations
of Computer Science, p.679-687.
https://doi.org/10.1109/FOCS.2012.37
	Introduction
	Related works
	Contribution
	Preliminaries
	Notation
	Oblivious transfer
	Lattice-based cryptography
	Classical UC framework
	Quantum universal composability framework
	Machine model
	Quantum-UC-security
	Lattice-based oblivious transfer
	Dual-mode cryptosystem based on LWE hardness
	LWE-based encryption
	Messy public keys (cf. DBLP:conf/stoc/GentryPV08, Section 6).
	LWE-based dual-mode cryptosystem
	LWE-based oblivious transfer
	Construction of the simulator
	When only R is corrupted
	When only S is corrupted
	Remaining corruption cases
	Quantum security analysis
	Quantum lifting theorem
	Quantum security analysis of dmmode
	In messy mode
	In decryption mode
	Simple hybrid arguments framework
	Simple hybrid arguments
	Application of the SHA framework
	Game-preserving reduction
	Game-preserving reduction: class-respectful reduction
	Application of class-respectful reduction
	Discussion and conclusions