Blockchain-based Bug Bounty Framework
Blockchain-based Bug Bounty Framework
Lital Badash
Department of Software and
Information Systems Engineering,
Ben-Gurion University of the Negev
litalbe@post.bgu.ac.il
Nachiket Tapas
Department of Engineering,
University of Messina
Messina, Italy
ntapas@unime.it
Asaf Nadler
Department of Software and
Information Systems Engineering,
Ben-Gurion University of the Negev
asafnadl@post.bgu.ac.il
Francesco Longo
Department of Engineering,
University of Messina
Messina, Italy
flongo@unime.it
Asaf Shabtai
Department of Software and
Information Systems Engineering,
Ben-Gurion University of the Negev
shabtaia@bgu.ac.il
ABSTRACT
Bug bounty programs are a popular solution for security researchers
to disclose software vulnerabilities in exchange for compensation.
They suffer, however, from two main drawbacks that limit their
effectiveness: (i) they use a trusted intermediary that charges hefty
commission fees and may have a conflict of interest with the soft-
ware vendor, and (ii) they may mistreat security researchers by
compensating less than guaranteed and no means to appeal against
it. In this paper, we propose a permissioned Blockchain-based frame-
work that addresses the drawbacks of existing bug bounty programs.
The framework allows a confidential exchange of vulnerabilities
and compensations using smart contracts. In cases of policy viola-
tion, security researchers can appeal to a trusted group of security
experts called arbitrators, that can force the software vendors to
compensate the security researchers fairly. A formal evaluation of
the proposed framework using TLA+ specification supports the
viability of the proposal. A Hyperledger Fabric-based prototype
is implemented to simulate the proposed framework. The analy-
sis of the framework uses a game-theoretic notion to argue that
if the majority of arbitrators behave honestly, then the rational
strategy of software vendors is to compensate security researchers
that disclose vulnerabilities accurately. Similarly, rational security
researchers do not gain any financial profit by playing unfairly.
CCS CONCEPTS
• Security and privacy → Domain-specific security and privacy
architectures; • Information systems→ Collaborative and social
computing systems and tools;
KEYWORDS
Blockchain, Bug Bounty, Software vulnerability
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
SAC ’21, March 22–26, 2021, Virtual Event, Republic of Korea
© 2021 Association for Computing Machinery.
ACM ISBN 978-1-4503-8104-8/21/03. . . $15.00
https://doi.org/10.1145/3412841.3441906
ACM Reference Format:
Lital Badash, Nachiket Tapas, Asaf Nadler, Francesco Longo, and Asaf Shab-
tai. 2021. Blockchain-based Bug Bounty Framework. In The 36th ACM/SI-
GAPP Symposium on Applied Computing (SAC ’21), March 22–26, 2021, Vir-
tual Event, Republic of Korea. ACM, New York, NY, USA, Article 4, 10 pages.
https://doi.org/10.1145/3412841.3441906
1 INTRODUCTION
Software vulnerabilities are bugs that can be exploited by hackers to
compromise systems and consequently harm organizations’ reputa-
tion. Successful exploitation of software vulnerabilities may result
in corruption of information, disclosure of information, denial of
service, and theft of service [7]. This drives software companies to
actively search for existing vulnerabilities and fix them before they
are exploited. Searching for vulnerabilities is an exhaustive process
that requires skills, creativity, and time. Thus, most software devel-
opers cannot search for vulnerabilities on their own and rely on
third-party experts through bug-bounty programs [9].
Bug-bounty programs (or vulnerability reward program) are an
offer made by a software company directly or indirectly through a
third-party, to encourage independent security researchers, pene-
tration testers, and white hat hackers [15] to search for software
vulnerabilities and disclose them for compensation and recognition.
Previous studies [4, 13] demonstrated that security researchers will
get higher rewards on average for selling their disclosed vulnera-
bility on black markets with malicious intent [13] compared to bug
bounty programs, and are therefore less incentivized to use bug
bounty programs. To tackle this problem, modern bug bounty solu-
tions seek better social and economic models for minimizing the
gap between legitimate and malicious vulnerability markets [13].
The most popular bug bounty program solutions are managed
service platforms such as HackerOne Inc. [1] and BugCrowd Inc.1
that maintain a community of security researchers and have a repu-
tation for operating successful indirect bug bounty programs. These
platforms are growing rapidly through more bounties program and
more valuable rewards [12] reaching a 19 million dollars of rewards
in 2018, a figure which is nearly the sum of total reward of all
preceding years combined [10]. However, software vendors and
researchers may hesitate in participating in bug bounties programs
through these platforms due to the following concerns: (i) Costs.
1https://www.bugcrowd.com/
239
https://doi.org/10.1145/3412841.3441906
https://doi.org/10.1145/3412841.3441906
http://crossmark.crossref.org/dialog/?doi=10.1145%2F3412841.3441906&domain=pdf&date_stamp=2021-04-22
The reward for disclosing vulnerabilities on bug bounty platforms
encompasses a non-negligible fee of the platform. For example,
HackerOne Inc. charges up to 20% higher fees than direct bug
bounties to support the platform operation [1]. (ii) Transparency.
The lack of transparency in the process of evaluating whether a
disclosed vulnerability is rewardable may in turn lead to a conflict-
of-interest between software companies, that are the customers
of the bug bounty service, and the security researcher community
maintained by the bug bounty platform. (iii) Security. The direct bug
bounty program uses a secure communication channel between
the software vendor and the security researcher for exchanging
vulnerability information. Indirect bug bounty programs force the
inclusion of a third party, thus increasing the risk of sensitive in-
formation leakage [22]. (iv) Fairness. Current bug bounty platforms
do not guarantee fairness, and security researchers face the risk of
non-payment [4]. With these platforms often suggesting a repu-
tation mechanism for security-researchers, lack of fairness forces
the security researcher to disclose security vulnerabilities to direct
sellers they can trust.
We propose a decentralized bug bounty program framework
that uses a permissioned blockchain technology to better address
the concerns of software companies and security researchers (cost,
transparency, security, and fairness) that seek a bug bounty pro-
gram. A software company, interested in initiating a bug bounty
program, posts a smart contract on the blockchain with the program
details, including the scope, terms and conditions, submission pro-
cess, and the proposed reward. The smart contract for a bug bounty
program needs to state and publish the program’s policy/business
rules followed by any bug bounty platform like HackerOne or
BugCrowd, and therefore, with precise and unambiguously defined
rules [17], defining a smart contract is easy as its counterpart. A
security researcher that discovers a vulnerability can disclose it to
the software company via the smart contract.
The primary guarantees of the framework are transparency and
fair exchange i.e., either a software company verifies the disclosed
vulnerabilities and behaves honestly by rewarding the security re-
searcher, or alternatively, the security researcher decides to initiate
an arbitration. In the latter case, a committee of trusted arbitrators
is set in place to decide disputed cases, and the party found guilty
of misbehavior is forced to compensate the other party for a value
that exceeds that of the disclosed vulnerability, thus guaranteeing
fairness. The permissioned blockchain complements the process of
trusted arbitration by providing transparency, immutability, and
non-repudiation properties alongside smart contracts execution
to bind payment in cases of dispute execution thus filling the gap
and ensure trust and fairness. Existing fair exchange proposals
involve either a centralized, trusted third party [20] or gradually
releasing the commodity in parts [5]. Both approaches have their
limitations of trust and the need for secret’s verifiability in poly-
nomial time, which is achieved in the proposed framework via
the trusted committee as verifiers to any free text vulnerability
description, which cannot be performed in polynomial time The
fairness of vulnerability disclosure using the suggested framework
is analyzed by modeling the process as a game, and demonstrating
a Nash equilibrium as proposed by Buttyan et al. [5].
To summarize, the main contributions of this research are: (i)We
propose a decentralized bug bounty framework that uses a permis-
sioned blockchain to guarantee security, transparency, fairness, and
reasonable cost. (ii) The bug bounty platform uses an arbitration
committee to decide disputed cases to ensure fairness and trans-
parency. (iii) A formal specification of the proposed framework
is presented to evaluate the correctness of the framework. (iv) A
Hyperledger Fabric-based prototype is implemented to validate the
operation of the proposed framework. (v) A game-theoretic analysis
of the bug bounty platform is presented to prove that vendors and
security researchers gain the most profit from this framework if
they are rational and honest.
2 BACKGROUND
Bug bounty programs. Bug bounty programs contain a set of
details, including the program’s scope, the reward for disclosing
bugs, and legal constraints. The details must be made publicly
available to encourage any security researcher to search for bugs
and disclose them in exchange for a reward. The average length of
bug bounty programs’ details is 481 words [17], which is sufficiently
small to fit in blockchain smart contracts.
The process of vulnerability disclosure starts by submitting a
private message to the bug bounty platform and waiting for a
commonly agreed grace period in which the software company has
the chance to verify, evaluate and fix the vulnerability [6]. After
the defined grace period, a disclosed vulnerability is referred to as
public knowledge. It can be shared publicly to educate other security
researchers, demonstrate the software’s improved security status,
and allow security researchers to file a dispute, if needed, without
risking legal liability for publicly discussing the vulnerability.
Blockchain and smart contracts. A blockchain is a distributed
public ledger of transactions or digital events among participat-
ing parties [8]. Despite being introduced as digital currency, the
blockchain is widely adopted in non-financial use cases as an im-
mutable and transparent, general-purpose public ledger of digi-
tal events. One of the blockchain’s primary extensions is “smart
contracts”, which are computer programs that can automatically
execute the terms of a contract [8]. A smart contract can be pro-
grammed to enforce the desired set of rules encoded in its pro-
gramming language. Smart contracts are identified by an address (a
160-bit identifier) to which users send transactions to execute the
contract code [19], and their code is immutable similarly to every
digital event on the blockchain.
3 RELATEDWORK
Bug bounty programs. The most popular form of bug bounty
programs is software-as-a-service (SaaS) programs [21], such as
HackerOne and BugCrowd. Companies that offer SaaS bug bounty
programs have experience maintaining a community of security
researchers, drafting bounty contracts, negotiating terms, and guar-
anteeing a secure disclosure. Thus, software companies lacking
competency can use SaaS bug bounty programs to encourage bug
disclosures. The main downside of SaaS bug bounty programs, in
contrast to the proposed solution, is the fees required to cover the
legal and operational costs.
240
An additional bug bounty alternative is a self-managed bug
bounty that is published and managed directly by software com-
panies. In contrast to SaaS bug bounty programs, a self-managed
program saves the cost of third-party services. However, it requires
the software company to be actively involved with the security
community and possess legal expertise in vulnerability disclosures.
The proposed framework attempts to provide the advantage
of software-as-a-service and self-managed bug bounty programs
by providing a framework with an active community of security
researchers and software companies and has clear and binding legal
policies drafted through smart contracts. The fees for the proposed
framework are expected to be significantly less than those of SaaS
bug bounties while also encouraging security researchers to search
for bugs.
Bug bounties using blockchain. The Hydra project [4] proposes
a complete bug bounty specifically for immutable smart contracts
using a technique referred to as N-of-N version programming
(NNVP). NNVP requires that the smart contract would be imple-
mented in N independent versions to identify and automatically
remediate bug disclosures. While this is reasonable for immutable
smart contracts that consist of a small number of code lines and that
offer large amounts of tokens, it is not cost-effective for a general-
ized bug-bounty program. The work of [23] uses smart contracts
for bug bounties (using Software Guard Extensions (SGX)). Their
system is focused on the peer-to-peer fare exchange by zero knowl-
edge and sealed glass proofs, in contrast to our suggestion that
relies on feedback and arbitration process by the community. More-
over, their suggestion targets only bug bounties for applications
that can be ported to SGX.
Blockchain and smart contracts solutions for enhanced se-
curity. In a closely related work, researchers propose a system
named Desma [14], in which trusted intermediaries operating a
marketplace can be replaced with a set of rules encoded in smart
contracts. However, in proposed work, dispute resolution can be
settled automatically by code. Researchers in [11] suggest a reputa-
tion based knowledge sharing system in blockchain for knowledge
owner’s copyright protection and paid for content service. The
project Polyswarm [2] suggest a system to analyze artifacts by
researchers. Researchers bid the right to ‘answer’ if an artifact is
malicious or benign by using an automated tool. In the proposed
framework, we use the smart contract to publish immutable, time-
limited, bug bounty programs, accumulate publicly visible feedback,
and manage arbitration in case of a dispute between the parties, in
a traceable but confidential manner, while respecting the rules of
responsible disclosure [6].
We use the blockchain-based network to publish bug bounty
programs as smart contracts and allow security researchers to par-
ticipate. Simultaneously, our framework’s protocols follow a game-
theoretic approach to address the fair-exchange issue by accumu-
lative feedback and a unique arbitration process that increase the
economically rational researcher’s incentives to participate.
4 PROPOSED FRAMEWORK
We propose a framework to support bug bounty programs where
software vendors and security researchers can exchange vulnera-
bility information for compensation and recognition while guar-
anteeing fairness. We refer to the proposed work as a framework
rather than a concrete system design because some of the parts are
provided as a general guideline and can be implemented in several
ways and with different technologies.
4.1 Framework components
The proposed framework consists of the following components.
A permissioned blockchain network, in which vendors commit
to rewarding security researchers in exchange for their disclosure of
a vulnerability. This is managed using smart contracts. Blockchain
network nodes are host machines owned by bug bounty program
holders or other stakeholders. As part of the system initialization,
each user willing to participate in the system has to register with
a trusted registration authority. The initialization prevents Sybil
attacks and feedback cheating behaviors. Users won’t be able to cre-
ate multiple identities to gain feedback and thus win more rewards.
They have a coin account, and associated accumulative feedback is
stored in a smart contract.
Smart contract. Bug bounty program can be phrased in a smart
contract. Vendors use smart contracts to publish their bug boun-
ties programs and to reward researchers for their findings. The
arbitration process is managed in a different smart contract. The
framework handles the arbitration process, which occurs when
the researcher and vendor disagree regarding a bug severity that
influences the bug’s cost. This way, the arbitration process is cor-
rectly executed. Another type of contract is for the feedback storage.
Feedback is given automatically by the smart contract managing
the arbitration process and manually by the participating users and
saved corresponding to the user’s identity.
Committee of arbitrators. A trusted committee with 𝑁 (odd)
members, who act as arbitrators in case of a dispute between a
researcher and a vendor regarding the severity of the bug that de-
termines the reward. At least half of the arbitrators are assumed to
be honest, i.e., their verification is considered as the ground truth.
The realization of the trusted committee can be a set of trusted ma-
chines that are owned by highly professional security researchers
that are part of the community and are incentivized to perform this
task fairly. For instance: representatives from participated compa-
nies and highly reliable users with proven experience.
Figure 1: Disclosure of vulnerability, feedback, and arbitra-
tion processes.
241
4.2 Actors
The framework supports three types of actors, namely: vendors, se-
curity researchers, and arbitrators. Software vendor (shortly referred
to as vendor). The goal of vendors in the system is to provide com-
pensation for the disclosure vulnerabilities found in their system.
The vendors achieve this goal by publishing a bug bounty program
as a smart contract on the blockchain network and committing to
adequately compensate for the vulnerability disclosure. The pro-
posed contract defines the program’s scope and the rules alongside
incentives to encourage security researchers to find vulnerabilities.
Security researcher (shortly referred to as researcher). The goal of
researchers is to disclose vulnerabilities that they find in return
for compensation. A researcher that finds a vulnerability sends it
within an encrypted transaction to the vendor to assure confiden-
tiality. In turn, the vendor verifies the vulnerability and rewards the
researcher as guaranteed in the corresponding bug bounty smart
contract. Arbitrator. Researchers or professionals can be part of
the committee of arbitrators. Their role is to resolve the conflict
between a vendor and a researcher in the event of a disagreement
regarding a finding’s severity that determines the reward.
4.3 The framework flow
In our framework, there are three processes: (i) disclosure of vul-
nerability – proposing bug bounty programs by vendors to the
community, (ii) feedback – allowing researchers and vendors to
leave their impressions on each other in a specific format, and (3)
arbitration process – trusted committee that can make a verdict
in case of a dispute. Feedback and the arbitration process are not
mandatory. Disclosure of vulnerability allows vendors to propose
bug bounty programs in the form of smart contracts in which the
vendor commits to provide coins in exchange for a vulnerability
disclosure satisfying the program rules and scope. Researchers who
want to demonstrate their skills and win the reward join the pro-
gram, test the vendor’s site/artifact/system, and, if a security-related
issue is found, encrypt the data and transact with the vendor di-
rectly. Once the vendor receives messages from the researchers,
he verifies the data. He decides if and how a researcher should be
rewarded according to the bug severity estimation model stated
in the program. Feedback is to give performance reviews accord-
ing to agree upon topics to the researchers and the vendors. The
feedback is symmetric, should be honest, reflect the researcher’s
set of knowledge and skills, and the vendor’s professional and fair
behavior. The arbitration process occurs when a researcher feels
the vendor is trying to withdraw his commitment from the smart
contract and not pay fairly. A special smart contract is automati-
cally managing the arbitration process, collecting the arbitrators’
votes, and transferring payment to the party who got the majority
of votes. The architecture of the framework is depicted in Figure 1.
4.4 Disclosure of vulnerability
We denote 𝑝𝑘𝑉 , 𝑝𝑘𝑅 , 𝑝𝑘𝐴 as the public keys of vendor𝑉 , researcher
𝑅, and arbitrator𝐴 respectively. The bug bounty index is 𝑝𝑖𝑑 , deter-
mined by the id of the transaction that deployed the smart contract,
and the id is unique. The process for disclosing a vulnerability pro-
cess is the main process of the framework, and it includes both
software vendors and security researchers. This process includes
multiple consecutive steps: (i) Commitment: A vendor 𝑣𝑖 willing
to participate in the system, is required to make a deposit to the
arbitration contract before offering a program. (ii) Publish: A ven-
dor 𝑣𝑖 releases a new bug bounty program 𝑃 , by deploying a smart
contract to the blockchain network.
𝐷𝑒𝑝𝑙𝑜𝑦𝐵𝑢𝑔𝐵𝑜𝑢𝑛𝑡𝑦 (𝑝𝑘𝑣𝑖 , 𝑡𝑣𝑖 , 𝑑𝑣𝑖 ,𝑚𝑣𝑖 , 𝑐𝑣𝑖 )
where 𝑝𝑘𝑣𝑖 denotes the vendor who own and manage the program,
𝑡𝑣𝑖 denotes the program’s expiration date, 𝑑𝑣𝑖 denotes the program
details, 𝑚𝑣𝑖 denotes the amount of coins deposited to the smart
contract for the reward fee, and 𝑐𝑣𝑖 denotes the program code
which essentially says: transfer coins according to the bug impact
estimation model to the researcher upon vendor’s validation. (iii)
Discovery: Researchers (denoted 𝑅) are watching the blockchain
for an indication that a relevant smart contract is deployed by a
vendor known by his public key, 𝑝𝑘𝑣𝑖 . If the researcher is interested,
he or she can query for the program details by
𝑄𝑢𝑒𝑟𝑦𝑃𝑟𝑜𝑔𝑟𝑎𝑚𝐷𝑒𝑡𝑎𝑖𝑙𝑠 (𝑝𝑘𝑣𝑖 )
(iv) Disclosure: The Researcher, finds a bug, describe its details,
generates a key, named 𝐾𝑝𝑖𝑑 , the key is encrypted by the public
key of the involved vendor, and sends the transaction to the vendor.
The vulInfo represents the vulnerability information.
𝐸𝑛𝑐𝑝𝑘𝑣𝑖 (𝐾𝑝𝑖𝑑 )
𝑆𝑒𝑐𝐼𝑠𝑠𝑢𝑒𝐷𝑖𝑠𝑐 (𝐸𝑛𝑐𝑝𝑘𝑣𝑖 (𝐾𝑝𝑖𝑑 ), 𝐸𝑛𝑐𝐾𝑝𝑖𝑑 (𝑣𝑢𝑙𝐼𝑛𝑓 𝑜))
(v) Evaluation: The vendor verifies the security issue sent to him
by a researcher on the time frame to decrypt the message, trying
the steps to reproduce as suggested by the researcher, estimate bug
reward and send a reply to the bug bounty program smart contract
where 𝑠 denotes the bug impact estimation value that set the reward
fee. In case of rejection, 𝑠 is not applicable and the researcher is not
getting any reward.
𝑉𝑒𝑟𝑖 𝑓 𝑦 (𝐸𝑛𝑐𝑝𝑘𝑣𝑖 (𝑣𝑢𝑙𝐼𝑛𝑓 𝑜))
𝑅𝑒𝑤𝑎𝑟𝑑𝑅𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟 (𝑝𝑘𝑟𝑖 , 𝑠)
4.5 Feedback
In our suggested framework, we use feedback messages as a key
component that represents the user’s hall of fame. Users, both ven-
dors, and researchers accumulate feedback. Bug bounty programs
from vendors with positive feedback messages have better chances
to get picked by high-rated and relevant researchers. Researchers
with positive feedback indicate their knowledge and expertise and
have a better chance to be recognized for their professionalism in
the community. They have higher probabilities of being noticed by
vendors and motivate them to find security flaws and earn more re-
wards. Feedback is given in a pre-defined format and categories and
not as a free text to encourage only positive feedback. Dishonest
behavior is noticed and marked by the system. This paper provides
the format and a few examples of the category. The framework
allows two types of feedback: User feedback. Users of the system
can leave their impressions on each other using feedback by calling
the method managed by the feedback storage smart contract.
𝐶𝑎𝑙𝑙𝐹𝑒𝑒𝑑𝑏𝑎𝑐𝑘 (𝑢𝑠𝑒𝑟𝑝𝑘 , 𝑝𝑖𝑑 , 𝑓 𝑒𝑒𝑑𝑏𝑎𝑐𝑘)
𝑢𝑠𝑒𝑟𝑝𝑘 denotes the public key of the user who receives the feed-
back, 𝑝𝑖𝑑 denoted the bug bounty index. Vendors fill the feedback
values by selecting from a pre-defined list of expertise that they find
relevant to the issue raised by the researcher. For example, SQL in-
jection, cross-site scripting (XSS), etc. Researchers fill the feedback
values by selecting from a pre-defined list of categories important
to the disclosure of the vulnerability process and assign their satis-
faction score. For example (responding time, score), (committing to
the reward promised, score). Penalty feedback. The losing party in
242
the arbitration process is penalized by penalty feedback. Multiple
losses for the vendors or researchers can dramatically affect his
attractiveness. This kind of feedback is executed automatically by
the arbitration process smart contract using the following method.
𝐶𝑎𝑙𝑙𝑃𝑒𝑛𝑎𝑙𝑡𝑦𝐹𝑒𝑒𝑑𝑏𝑎𝑐𝑘 (𝑢𝑠𝑒𝑟𝑝𝑘 , 𝑝𝑖𝑑 )
Feedback is stored and managed by the feedback storage smart
contract, which allows anyone to read the system’s users’ feedback
and retrieve relevant researchers by their public keys. Since a re-
searcher can receive more than one feedback on the same expertise,
the feedback storage maintains a counter per expertise per 𝑝𝑘𝑟𝑖 .
The vendor’s total rating score on each category is the average of
all scores on the same category. Penalty feedback is accumulated
as well.
Figure 2: Bug bounty framework state transition diagram.
4.6 Arbitration process
The arbitration process should provide trusted verification. That is
the basis of the framework’s fair exchange. This process is an op-
tional step, initiated by a researcher and using the community to ad-
vise in case of a disagreement between a vendor 𝑣𝑖 and a researcher
𝑟𝑖 regarding the bug’s severity. For this purpose, the arbitration
process’s contract needs to maintain state of the vendor-to-deposit
mapping, allow vendors to deposit coins, and enable researchers to
find committed vendors. Initialization: In the commitment phase
of the disclosure of vulnerability process, a vendor is required to
make a deposit to the arbitration contract. The amount of coins the
vendor submit is the reflective of his guarantee to the researchers.
The arbitration contract is essentially guaranteeing that the money
deposited by a vendor is either: (A) redeemed by a majority vote of
the arbitrators, or (B) released back to the vendor if a time lock he
set during deposit expires. Request Arbitration: Researcher 𝑟𝑖 uses
the same key he used during submission, 𝐾𝑝𝑖𝑑 , the key is encrypted
by the public key of the involved vendor, 𝐸𝑛𝑐𝑝𝑘𝑣𝑖 (𝐾𝑝𝑖𝑑 ) and send a
message to the arbitration process smart contract.
𝐴𝑠𝑘𝐹𝑜𝑟𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛 (𝑘𝑛𝑜𝑤𝑙𝑒𝑑𝑔𝑒𝑝𝑟𝑒 𝑓 𝑒𝑟𝑒𝑛𝑐𝑒𝑠, 𝑝𝑖𝑑, 𝐸𝑛𝑐𝐾𝑝𝑖𝑑 (𝑣𝑢𝑙−
𝐼𝑛𝑓 𝑜), 𝐸𝑛𝑐𝑝𝑘𝑣𝑖 (𝐾𝑝𝑖𝑑 ), (𝑠𝑒𝑣𝑒𝑟𝑖𝑡𝑦 𝑒𝑠𝑡𝑖𝑚𝑎𝑡𝑖𝑜𝑛 𝑣𝑎𝑙𝑢𝑒𝑠))
Severity estimation values are the two values the arbitrators should
vote from. One is the value assigned by the vendor and the other
is the value the researcher believe is more suitable. Arbitration
execution: Upon request for arbitration, the contract executes the
following:
• Request the vendor to supply virtual machines and inform arbi-
trators respectively by:
𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛𝑃𝑟𝑒𝑝𝑎𝑟𝑒 (𝑝𝑘𝑟𝑖 , 𝐸𝑛𝑐𝐾𝑝𝑖𝑑 (𝑣𝑢𝑙𝐼𝑛𝑓 𝑜), 𝑝𝑖𝑑,𝑛𝑢𝑚𝑏𝑒𝑟𝑂𝑓 −
𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑠, 𝐸𝑛𝑐𝑝𝑘𝑣𝑖 (𝐾𝑝𝑖𝑑 ))
𝐼𝑛𝑓 𝑜𝑟𝑚𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟 (𝑝𝑖𝑑, 𝑠𝑢𝑏𝑚𝑖𝑠𝑠𝑖𝑜𝑛 𝑡𝑖𝑚𝑒, (𝑠𝑒𝑣𝑒𝑟𝑖𝑡𝑦 𝑒𝑠𝑡𝑖𝑚𝑎𝑡𝑖𝑜𝑛
𝑣𝑎𝑙𝑢𝑒𝑠), 𝐸𝑛𝑐𝐾𝑝𝑖𝑑 (𝑣𝑢𝑙𝐼𝑛𝑓 𝑜))
• Accumulate the arbitrator’s votes and set the winning party to
the one that got the majority of votes,
• Transfer the money to the wining party, and
• fill feedback penalty on the losing party
The vendor is technically losing in the arbitration if he/she re-
fuses to participate in the process by not supplying the testing
environment when needed. This case is marked as special penalty
feedback due to its importance.
Upon request to verdict the arbitrator first accept the arbitration
and only after that gets access to the environment (vminfo).
𝐴𝑐𝑐𝑒𝑝𝑡𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛 (𝑝𝑖𝑑, 𝐸𝑛𝑐𝐾𝑝𝑖𝑑 (𝑣𝑢𝑙𝐼𝑛𝑓 𝑜))
𝐴𝑐𝑐𝑒𝑠𝑠𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛𝐸𝑛𝑣 (𝐸𝑛𝑐𝑝𝑘𝑎𝑖 (𝐾𝑝𝑖𝑑 ), 𝐸𝑛𝑐𝐾𝑝𝑖𝑑 (𝑣𝑚𝑖𝑛𝑓 𝑜)), 𝐸𝑛𝑐𝐾𝑝𝑖𝑑 (𝑣𝑢𝑙𝐼𝑛𝑓 𝑜))
Supplying virtual machine details are necessary only when it is
listed as a prerequisite in the program’s contract. 𝐾𝑝𝑖𝑑 is used as a
symmetric key encryption. Arbitrator extract 𝐾𝑝𝑖𝑑 and decrypt the
vminfo, access the VM with the given credentials, and examine the
case. Note, the arbitrator receives the vulInfo both from the vendor
and the researcher to avoid fraud. Finally the arbitrator send his
vote to the arbitration contract by:
𝑆𝑒𝑛𝑑𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛𝐷𝑒𝑐𝑖𝑠𝑖𝑜𝑛(𝑎𝑖 , 𝑝𝑖𝑑 , (impact estimation value))
5 FORMAL SPECIFICATION
In this section, we present a formal specification of the bug bounty
framework using TLA+ abstract language [16, 18] for model verifi-
cation. The system operation is defined as TLA+ definitions, and
the correctness of the protocol is verified using the TLC model
checking tool. The resulting formal specification is then used as
input for the implementation of the framework.
5.1 State Transitions
The framework involves interaction between software vendors
(V) and researchers (R) for discovering software vulnerabilities
(Figure 2). In case there is a conflict, the arbitrators (A) mediate
the conflict and announce a winner. Blockchain acts as a ledger
of records containing performed operations and is also used as a
communication and payment medium. We begin by initializing
each variable with a default value. The variables InitVendor, Ini-
tResearcher, InitArbitrator, and InitBlockchain are initial values of
the variables for the software vendor, researcher, arbitrator, and
blockchain, respectively. The channel variable is used to represent
a secure communication between the researcher and vendor for
vulnerability disclosure. The state change for the proposed model is
defined as 𝐼𝑛𝑖𝑡 ∧ ∗[ 𝑁𝑒𝑥𝑡] 𝑣𝑎𝑟𝑠 ∧𝑊𝐹_𝑣𝑎𝑟𝑠 (𝑁𝑒𝑥𝑡) in TLA+ specifi-
cations where the𝑊𝐹_𝑣𝑎𝑟𝑠 is for fairness. The possible transitions
from the initial state are described in the following equation:
Next ≜
∨ ∃ 𝑣 ∈ 𝑉𝑒𝑛𝑑𝑜𝑟 :
∨𝐶𝑜𝑚𝑚𝑖𝑡𝑚𝑒𝑛𝑡 (𝑣) ∨ 𝑃𝑢𝑏𝑙𝑖𝑠ℎ (𝑣) ∨𝑉𝑒𝑟𝑖 𝑓 𝑦𝑆𝑜𝑙𝑢𝑡𝑖𝑜𝑛 (𝑣) ∨ 𝑅𝑒𝑤𝑎𝑟𝑑 (𝑣)
∨𝑅𝑒𝑑𝑒𝑒𝑚 (𝑣)
∨ ∃ 𝑟 ∈ 𝑅𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟 :
243
∨𝐷𝑖𝑠𝑐𝑜𝑣𝑒𝑟 (𝑟 ) ∨𝐷𝑖𝑠𝑐𝑙𝑜𝑠𝑢𝑟𝑒 (𝑟 ) ∨𝑉𝑒𝑟𝑖 𝑓 𝑦𝑃𝑎𝑦𝑚𝑒𝑛𝑡 (𝑟 )
∨ ∃𝑎 ∈ 𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟 :
∨𝐴𝑐𝑐𝑒𝑝𝑡𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛 ∨𝑉𝑜𝑡𝑒 (𝑎) ∨𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛𝑅𝑒𝑠𝑢𝑙𝑡
∨𝐶𝑜𝑛𝑓 𝑖𝑟𝑚𝑅𝑒𝑐𝑒𝑖𝑝𝑡
∨ (∗𝐷𝑖𝑠 𝑗𝑢𝑛𝑐𝑡 𝑡𝑜 𝑝𝑟𝑒𝑣𝑒𝑛𝑡 𝑑𝑒𝑎𝑑𝑙𝑜𝑐𝑘 𝑜𝑛 𝑡𝑒𝑟𝑚𝑖𝑛𝑎𝑡𝑖𝑜𝑛 ∗)
( (∀ 𝑣𝑒𝑛 ∈ 𝑉𝑒𝑛𝑑𝑜𝑟 : 𝑣𝑆𝑡𝑎𝑡𝑒 [𝑣𝑒𝑛] = 𝑉 _𝐹𝑖𝑛𝑎𝑙) ∧ 𝑇𝑒𝑟𝑚𝑖𝑛𝑎𝑡𝑖𝑛𝑔)
Spec ≜
𝐼𝑛𝑖𝑡 ∧ ∗ [𝑁𝑒𝑥𝑡 ]𝑣𝑎𝑟𝑠 ∧ 𝑊𝐹_𝑣𝑎𝑟𝑠 (𝑁𝑒𝑥𝑡 )
The system can transit to any of the states defined by Next which
includes the terminating condition. A private channel is created
to communicate the vulnerability information securely. Finally,
termination is indicated by the expiration of the published bug
bounty program, and the vendor can redeem the initial commitment.
The researchers may or may not disclose a vulnerability.
5.2 Software vendors
The software vendor is interested in identifying the vulnerability
in his/her software. The vendor begins with a𝑉 _𝑊𝑎𝑖𝑡𝑖𝑛𝑔 and then
transits through 𝑉 _𝐶𝑜𝑚𝑚𝑖𝑡𝑚𝑒𝑛𝑡 , 𝑉 _𝑉𝑒𝑟𝑖 𝑓 𝑦𝑆𝑜𝑙𝑢𝑡𝑖𝑜𝑛, 𝑉 _𝑅𝑒𝑤𝑎𝑟𝑑 ,
𝑉 _𝐹𝑒𝑒𝑑𝑏𝑎𝑐𝑘 , and 𝑉 _𝐹𝑖𝑛𝑎𝑙 . In the end, the vendor is either able to
identify the vulnerabilities and can work on fixing them or the
time expires, and the vendor is assured that the software is bug-
free. (i) Commitment: The software vendor begins by committing a
pre-defined amount to the blockchain to act as a guarantee in case
arbitration is required.
𝐶𝑜𝑚𝑚𝑖𝑡𝑚𝑒𝑛𝑡 (𝑣) ≜
∧ 𝑣𝑆𝑡𝑎𝑡𝑒 [𝑣 ] = 𝑉 _𝑊𝑎𝑖𝑡𝑖𝑛𝑔
∧𝐿𝐸𝑇
𝑡𝑦𝑝𝑒 == 𝑇𝑋_𝐶𝑂𝑀𝑀𝐼𝑇𝑀𝐸𝑁𝑇 𝑝𝑔𝑟𝑚𝑛𝑢𝑚 == 𝑁𝑈𝑀𝐵𝐸𝑅
𝑐𝑜𝑚𝑚𝑖𝑡𝑚𝑒𝑛𝑡 == 𝐶𝑂𝑀𝑀𝐼𝑇𝑀𝐸𝑁𝑇
𝐼𝑁
𝑇𝑟𝑎𝑛𝑠𝑎𝑐𝑡𝑖𝑜𝑛 ( 𝑡𝑦𝑝𝑒, 𝑝𝑔𝑟𝑚𝑛𝑢𝑚, 𝑣, ⟨𝑐𝑜𝑚𝑚𝑖𝑡𝑚𝑒𝑛𝑡 ⟩ )
∧ 𝑣𝑆𝑡𝑎𝑡𝑒′ = [ 𝑣𝑆𝑡𝑎𝑡𝑒 𝐸𝑋𝐶𝐸𝑃𝑇 ![𝑣 ] = 𝑉 _𝐶𝑜𝑚𝑚𝑖𝑡𝑚𝑒𝑛𝑡 ]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠, 𝑏𝑙𝑜𝑐𝑘𝑇𝑥,
𝑏𝑎𝑙𝑎𝑛𝑐𝑒, 𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
The transaction is identified by𝑇𝑋_𝐶𝑂𝑀𝑀𝐼𝑇𝑀𝐸𝑁𝑇 . Although
the commitment phase is optional in our model, the formal speci-
fication begins with the commitment phase as it ensures trust. A
researcher may decide not to participate in the bug bounty program
in the absence of commitment. (ii) Publish: The vendor, after making
a commitment on the blockchain, transits to 𝑉 _𝐶𝑜𝑚𝑚𝑖𝑡𝑚𝑒𝑛𝑡 state.
The vendor publishes the bug bounty program on the blockchain.
𝑃𝑢𝑏𝑙𝑖𝑠ℎ (𝑣) ≜
∧ 𝑣𝑆𝑡𝑎𝑡𝑒 [𝑣 ] = 𝑉 _𝐶𝑜𝑚𝑚𝑖𝑡𝑚𝑒𝑛𝑡
∧𝐿𝐸𝑇
𝑡𝑦𝑝𝑒 == 𝑇𝑋_𝑃𝑈𝐵𝐿𝐼𝑆𝐻 𝑝𝑔𝑟𝑚𝑛𝑢𝑚 == 𝑁𝑈𝑀𝐵𝐸𝑅
𝑝𝑜𝑙𝑖𝑐𝑦 == 𝑃𝑂𝐿𝐼𝐶𝑌 𝑖𝑠𝑠𝑢𝑒 == 𝐷𝐴𝑇𝐸_𝐼𝑆𝑆𝑈𝐸
𝑒𝑥𝑝𝑖𝑟𝑎𝑡𝑖𝑜𝑛 == 𝐷𝐴𝑇𝐸_𝐸𝑋𝑃 𝑏𝑜𝑢𝑛𝑡𝑦 == 𝐵𝑂𝑈𝑁𝑇𝑌
𝐼𝑁
𝑇𝑟𝑎𝑛𝑠𝑎𝑐𝑡𝑖𝑜𝑛 ( 𝑡𝑦𝑝𝑒, 𝑝𝑔𝑟𝑚𝑛𝑢𝑚, 𝑣, ⟨𝑝𝑜𝑙𝑖𝑐𝑦, 𝑖𝑠𝑠𝑢𝑒, 𝑒𝑥𝑝𝑖𝑟𝑎𝑡𝑖𝑜𝑛, 𝑏𝑜𝑢𝑛𝑡𝑦 ⟩ )
∧ 𝑣𝑆𝑡𝑎𝑡𝑒′ = [𝑣𝑆𝑡𝑎𝑡𝑒 𝐸𝑋𝐶𝐸𝑃𝑇 ![𝑣 ] = 𝑉 _𝑉𝑒𝑟𝑖 𝑓 𝑦𝑆𝑜𝑙𝑢𝑡𝑖𝑜𝑛]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠, 𝑏𝑙𝑜𝑐𝑘𝑇𝑥,
𝑏𝑎𝑙𝑎𝑛𝑐𝑒, 𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
The publish transaction contains the details related to the bug
bounty program like the policy of the program, issue date, expiry
date, and the bounty to be awarded to the researcher. The trans-
action is identified by TX_PUBLISH. Once the transaction is sent
to the blockchain, the vendor transits to 𝑉 _𝑉𝑒𝑟𝑖 𝑓 𝑦𝑆𝑜𝑙𝑢𝑡𝑖𝑜𝑛 state,
waiting for any researcher to submit the vulnerability. (iii) Verify
solution: The vendor in 𝑉 _𝑉𝑒𝑟𝑖 𝑓 𝑦𝑆𝑜𝑙𝑢𝑡𝑖𝑜𝑛 state observes the se-
cure channel for the vulnerability report. Though the exchange
of vulnerability report is done privately, the proof of exchange is
published on the blockchain to prevent repudiation by the vendor
regarding receiving vulnerability reports.
𝑉𝑒𝑟𝑖 𝑓 𝑦𝑆𝑜𝑙𝑢𝑡𝑖𝑜𝑛 (𝑣) ≜
∃ 𝑐 ∈ 𝑐ℎ𝑎𝑛𝑛𝑒𝑙 :
𝐿𝐸𝑇
𝑒𝑛𝑐𝑘𝑒𝑦 == 𝑐.𝑘𝑒𝑦 𝑣𝑢𝑙𝑖𝑛𝑓 𝑜 == 𝑐.𝑖𝑛𝑓 𝑜
𝐼𝑁
𝐼𝐹 𝑉𝑒𝑟𝑖 𝑓 𝑦 ( 𝑒𝑛𝑐𝑘𝑒𝑦, 𝑣𝑢𝑙𝑖𝑛𝑓 𝑜 )𝑇𝐻𝐸𝑁
∧ 𝑣𝑆𝑡𝑎𝑡𝑒′ = [𝑣𝑆𝑡𝑎𝑡𝑒 𝐸𝑋𝐶𝐸𝑃𝑇 ![𝑣 ] = 𝑉 _𝑅𝑒𝑤𝑎𝑟𝑑 ]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠, 𝑏𝑙𝑜𝑐𝑘𝑐ℎ𝑎𝑖𝑛𝑉𝑎𝑟𝑠,
𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
𝐸𝐿𝑆𝐸
𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑣𝑒𝑛𝑑𝑜𝑟𝑉𝑎𝑟𝑠, 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠,
𝑏𝑙𝑜𝑐𝑘𝑐ℎ𝑎𝑖𝑛𝑉𝑎𝑟𝑠, 𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
On successful verification of the vulnerability report, the vendor
transits to 𝑉 _𝑅𝑒𝑤𝑎𝑟𝑑 state. For the sake of simplicity, we have
abstracted the verification of the report. If the report is not valid,
the vendor remains in the same state, waiting for a valid report.
(iv) Reward: The vendor, after validating the vulnerability report,
rewards the researcher with the bounty as per the severity of the
incidence. This may lead to contention between the vendor and the
researcher and is dealt with later.
𝑅𝑒𝑤𝑎𝑟𝑑 (𝑣) ≜
∧ 𝑣𝑆𝑡𝑎𝑡𝑒 [𝑣 ] = 𝑉 _𝑅𝑒𝑤𝑎𝑟𝑑
∧𝐿𝐸𝑇
𝑡𝑦𝑝𝑒 == 𝑇𝑋_𝑅𝐸𝑊𝐴𝑅𝐷 𝑝𝑔𝑟𝑚𝑛𝑢𝑚 == 𝑁𝑈𝑀𝐵𝐸𝑅
𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟 == 𝑅𝐸𝑆𝐸𝐴𝑅𝐶𝐻𝐸𝑅 𝑖𝑠𝑠𝑢𝑒 == 𝐷𝐴𝑇𝐸_𝐼𝑆𝑆𝑈𝐸
𝑟𝑒𝑤𝑎𝑟𝑑 == 𝑅𝐸𝑊𝐴𝑅𝐷
𝐼𝑁
𝑇𝑟𝑎𝑛𝑠𝑎𝑐𝑡𝑖𝑜𝑛 ( 𝑡𝑦𝑝𝑒, 𝑝𝑔𝑟𝑚𝑛𝑢𝑚, 𝑣, ⟨ 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟, 𝑖𝑠𝑠𝑢𝑒, 𝑟𝑒𝑤𝑎𝑟𝑑 ⟩ )
∧ 𝑣𝑆𝑡𝑎𝑡𝑒′ = [𝑣𝑆𝑡𝑎𝑡𝑒 𝐸𝑋𝐶𝐸𝑃𝑇 ![𝑣 ] = 𝑉 _𝐹𝑒𝑒𝑑𝑏𝑎𝑐𝑘 ]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠, 𝑏𝑙𝑜𝑐𝑘𝑇𝑥,
𝑏𝑎𝑙𝑎𝑛𝑐𝑒, 𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
The vendor sends the transaction identified by 𝑇𝑋_𝑅𝐸𝑊𝐴𝑅𝐷
and containing the researcher who identified the vulnerability, is-
sue date, and the reward. Once done, the vendor moves to the
feedback state to provide feedback to the researcher. (v) Vendor
feedback: On successful acceptance of reward by the researcher, the
vendor provides the feedback for the researcher as a transaction
on the blockchain. The vendor sends the transaction identified by
𝑇𝑋_𝐹𝐸𝐸𝐷𝐵𝐴𝐶𝐾 and containing the researcher who identified the
vulnerability, and the feedback. The overall feedback can be iden-
tified by accumulating all such transactions. (vi) Redeem: This is
the final state of the vendor where the vendor recovers the initial
commitment. In case there was no arbitration requested by any
researcher, the vendor sends an equal and opposite transaction to
the commitment transaction. In the case of arbitration, the vendor
recovers the remaining amount.
𝑅𝑒𝑑𝑒𝑒𝑚 (𝑣) ≜
∧ 𝑣𝑆𝑡𝑎𝑡𝑒 [𝑣 ] = 𝑉 _𝐹𝑒𝑒𝑑𝑏𝑎𝑐𝑘
∧𝐿𝐸𝑇
𝑡𝑦𝑝𝑒 == 𝑇𝑋_𝐶𝑂𝑀𝑀𝐼𝑇𝑀𝐸𝑁𝑇 𝑝𝑔𝑟𝑚𝑛𝑢𝑚 == 𝑁𝑈𝑀𝐵𝐸𝑅
𝑐𝑜𝑚𝑚𝑖𝑡𝑚𝑒𝑛𝑡 == 𝐶𝑂𝑀𝑀𝐼𝑇𝑀𝐸𝑁𝑇 ∗ (−1)
𝐼𝑁
𝑇𝑟𝑎𝑛𝑠𝑎𝑐𝑡𝑖𝑜𝑛 ( 𝑡𝑦𝑝𝑒, 𝑝𝑔𝑟𝑚𝑛𝑢𝑚, 𝑣, ⟨𝑐𝑜𝑚𝑚𝑖𝑡𝑚𝑒𝑛𝑡 ⟩ )
∧ 𝑣𝑆𝑡𝑎𝑡𝑒′ = [𝑣𝑆𝑡𝑎𝑡𝑒 𝐸𝑋𝐶𝐸𝑃𝑇 ![𝑣 ] = 𝑉 _𝐹𝑖𝑛𝑎𝑙 ]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠, 𝑏𝑙𝑜𝑐𝑘𝑇𝑥, 𝑏𝑎𝑙𝑎𝑛𝑐𝑒,
𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
244
The vendor sends the transaction identified by𝑇𝑋_𝐶𝑂𝑀𝑀𝐼𝑇𝑀−
𝐸𝑁𝑇 and containing the relevant amount to recover. This transac-
tion also marks the completion of a bug bounty program.
5.3 Researchers
The researcher begins with a 𝑅_𝑊𝑎𝑖𝑡𝑖𝑛𝑔 and then transits through
𝑅_𝐷𝑖𝑠𝑐𝑙𝑜𝑠𝑢𝑟𝑒 , 𝑅_𝑊𝑎𝑖𝑡𝑖𝑛𝑔𝑉𝑒𝑟𝑖 𝑓 𝑖𝑐𝑎𝑡𝑖𝑜𝑛, and 𝑅_𝐹𝑒𝑒𝑑𝑏𝑎𝑐𝑘 . Option-
ally, a researchermay transit to𝑅_𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛, and𝑅_𝑊𝑎𝑖𝑡𝑖𝑛𝑔𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛.
In the end, the researchers receive rewards for identifying the vul-
nerabilities with the software.
Discover: The researcher observes the blockchain looking for the
bug bounty programs initiated by the vendors. Based on the ven-
dor commitment, the researcher may decide to participate in the
program. Once the researcher decides to take part in the program,
the researcher transits to state 𝑅_𝐷𝑖𝑠𝑐𝑙𝑜𝑠𝑢𝑟𝑒 .
𝐷𝑖𝑠𝑐𝑜𝑣𝑒𝑟 (𝑟 ) ≜
∃ 𝑡𝑟𝑎𝑛𝑠 ∈ 𝑏𝑙𝑜𝑐𝑘𝑇𝑥 :
∧ 𝑟𝑆𝑡𝑎𝑡𝑒 [𝑟 ] = 𝑅_𝑊𝑎𝑖𝑡𝑖𝑛𝑔 ∧ 𝑡𝑟𝑎𝑛𝑠.𝑡𝑦𝑝𝑒 = 𝑇𝑋_𝑃𝑈𝐵𝐿𝐼𝑆𝐻
∧ 𝑡𝑟𝑎𝑛𝑠.𝑛𝑢𝑚𝑏𝑒𝑟 = 𝑁𝑈𝑀𝐵𝐸𝑅 ∧ 𝑡𝑟𝑎𝑛𝑠.𝑖𝑠𝑠𝑢𝑒𝑟 = 𝑉𝐸𝑁𝐷𝑂𝑅
∧ 𝑟𝑆𝑡𝑎𝑡𝑒′ = [𝑟𝑆𝑡𝑎𝑡𝑒 𝐸𝑋𝐶𝐸𝑃𝑇 ![𝑟 ] = 𝑅_𝐷𝑖𝑠𝑐𝑙𝑜𝑠𝑢𝑟𝑒 ]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑣𝑒𝑛𝑑𝑜𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠, 𝑏𝑙𝑜𝑐𝑘𝑐ℎ𝑎𝑖𝑛𝑉𝑎𝑟𝑠,
𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
Disclosure: In this state, the researcher identifies the vulnerability
in the software, prepares a vulnerability report, and sends the re-
port privately to the vendor. The researcher also records it on the
blockchain as a proof of participation.
𝐷𝑖𝑠𝑐𝑙𝑜𝑠𝑢𝑟𝑒 (𝑟 ) ≜
∧ 𝑟𝑆𝑡𝑎𝑡𝑒 [𝑟 ] = 𝑅_𝐷𝑖𝑠𝑐𝑙𝑜𝑠𝑢𝑟𝑒
∧𝐿𝐸𝑇
𝑒𝑛𝑐𝑘𝑒𝑦 == 𝐸𝑁𝐶_𝐾𝐸𝑌 𝑣𝑢𝑙𝑖𝑛𝑓 𝑜 == 𝑉𝑈𝐿𝑁𝐸𝑅𝐴𝐵𝐼𝐿𝐼𝑇𝑌
𝐼𝑁
𝑆𝑒𝑛𝑑𝐷𝑖𝑠𝑐𝑙𝑜𝑠𝑢𝑟𝑒 ( [𝑘𝑒𝑦 |− > 𝑒𝑛𝑐𝑘𝑒𝑦, 𝑖𝑛𝑓 𝑜 |− > 𝑣𝑢𝑙𝑖𝑛𝑓 𝑜 ] )
∧ 𝑟𝑆𝑡𝑎𝑡𝑒′ = [𝑟𝑆𝑡𝑎𝑡𝑒 𝐸𝑋𝐶𝐸𝑃𝑇 ![𝑟 ] = 𝑅_𝑊𝑎𝑖𝑡𝑖𝑛𝑔𝑉𝑒𝑟𝑖 𝑓 𝑖𝑐𝑎𝑡𝑖𝑜𝑛]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑣𝑒𝑛𝑑𝑜𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠, 𝑏𝑙𝑜𝑐𝑘𝑐ℎ𝑎𝑖𝑛𝑉𝑎𝑟𝑠 ⟩
The function SendDisclosure abstracts the secure sending of the
vulnerability report. This can be handled by existing web technolo-
gies like SSL 2 or more advanced features of blockchain like private
data of Hyperledger Fabric.3 Also, together with the report, the
researcher sends the severity of the incidence. Once the researcher
sends the report, he/she transits to 𝑅_𝑊𝑎𝑖𝑡𝑖𝑛𝑔𝑉𝑒𝑟𝑖 𝑓 𝑖𝑐𝑎𝑡𝑖𝑜𝑛 state,
waiting for the verification of the solution and receiving the reward.
Verify payment: On receiving the reward transaction from the ven-
dor, the researcher verifies the reward received on the blockchain.
There is a possibility of a dispute between the incident severity
estimated by the researcher and the vendor. In case there is no
dispute, the researcher transits to 𝑅_𝐹𝑒𝑒𝑑𝑏𝑎𝑐𝑘 state. In case of a
dispute, the researcher requests for mediation from the arbitrators.
𝑉𝑒𝑟𝑖 𝑓 𝑦𝑃𝑎𝑦𝑚𝑒𝑛𝑡 (𝑟 ) ≜
∃ 𝑡𝑟𝑎𝑛𝑠 ∈ 𝑏𝑙𝑜𝑐𝑘𝑇𝑥 :
∧ 𝑟𝑆𝑡𝑎𝑡𝑒 [𝑟 ] = 𝑅_𝑊𝑎𝑖𝑡𝑖𝑛𝑔𝑉𝑒𝑟𝑖 𝑓 𝑖𝑐𝑎𝑡𝑖𝑜𝑛 ∧ 𝑡𝑟𝑎𝑛𝑠.𝑖𝑠𝑠𝑢𝑒𝑟 = 𝑉𝐸𝑁𝐷𝑂𝑅
∧ 𝑡𝑟𝑎𝑛𝑠.𝑡𝑦𝑝𝑒 = 𝑇𝑋_𝑅𝐸𝑊𝐴𝑅𝐷 ∧ 𝑡𝑟𝑎𝑛𝑠.𝑛𝑢𝑚𝑏𝑒𝑟 = 𝑁𝑈𝑀𝐵𝐸𝑅
∧ 𝐼𝐹 𝑉𝑒𝑟𝑖 𝑓 𝑦𝑅𝑒𝑤𝑎𝑟𝑑 ( 𝑡𝑟𝑎𝑛𝑠.𝑑𝑎𝑡𝑎 [3] )𝑇𝐻𝐸𝑁
∧ 𝑟𝑆𝑡𝑎𝑡𝑒′ = [𝑟𝑆𝑡𝑎𝑡𝑒 𝐸𝑋𝐶𝐸𝑃𝑇 ![𝑟 ] = 𝑅_𝐹𝑒𝑒𝑑𝑏𝑎𝑐𝑘 ]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑣𝑒𝑛𝑑𝑜𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠, 𝑏𝑙𝑜𝑐𝑘𝑐ℎ𝑎𝑖𝑛𝑉𝑎𝑟𝑠,
𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
𝐸𝐿𝑆𝐸
∧𝐿𝐸𝑇
2https://link.springer.com/referenceworkentry/10.1007%2F978-1-4419-5906-5_223
3https://hyperledger-fabric.readthedocs.io/en/release-2.0/private-data/private-
data.html
𝑡𝑦𝑝𝑒 == 𝑇𝑋_𝐴𝑅𝐵𝐼𝑇𝑅𝐴𝑇𝐼𝑂𝑁 𝑝𝑔𝑟𝑚𝑛𝑢𝑚 == 𝑁𝑈𝑀𝐵𝐸𝑅
𝑝𝑟𝑜𝑝𝑜𝑠𝑎𝑙 == 𝑃𝑅𝑂𝑃𝑂𝑆𝐴𝐿 𝑜𝑝𝑡𝑖𝑜𝑛 == 𝑂𝑃𝑇𝐼𝑂𝑁
𝑖𝑠𝑠𝑢𝑒 == 𝐷𝐴𝑇𝐸_𝐼𝑆𝑆𝑈𝐸 𝑒𝑥𝑝𝑖𝑟𝑎𝑡𝑖𝑜𝑛 == 𝐷𝐴𝑇𝐸_𝐸𝑋𝑃
𝐼𝑁
𝑇𝑟𝑎𝑛𝑠𝑎𝑐𝑡𝑖𝑜𝑛 ( 𝑡𝑦𝑝𝑒, 𝑝𝑔𝑟𝑚𝑛𝑢𝑚, 𝑟, ⟨𝑝𝑟𝑜𝑝𝑜𝑠𝑎𝑙, 𝑜𝑝𝑡𝑖𝑜𝑛, 𝑖𝑠𝑠𝑢𝑒,
𝑒𝑥𝑝𝑖𝑟𝑎𝑡𝑖𝑜𝑛 ⟩ )
∧ 𝑟𝑆𝑡𝑎𝑡𝑒′ = [𝑟𝑆𝑡𝑎𝑡𝑒 𝐸𝑋𝐶𝐸𝑃𝑇 ![𝑟 ] = 𝑅_𝑊𝑎𝑖𝑡𝑖𝑛𝑔𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑣𝑒𝑛𝑑𝑜𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠, 𝑏𝑙𝑜𝑐𝑘𝑇𝑥, 𝑏𝑎𝑙𝑎𝑛𝑐𝑒,
𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
The arbitration transaction is identified by 𝑇𝑋_𝐴𝑅𝐵𝐼𝑇𝑅𝐴𝑇𝐼𝑂𝑁
and contains details like the details related to the bug bounty pro-
gram and the identified vulnerability, the researcher and the vendor
incident severity, issue, and expiry. Once the transaction is sent
to the blockchain, the researcher transits to 𝑅_𝑊𝑎𝑖𝑡𝑖𝑛𝑔𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛
and waits for the decision of the arbitrators.
Researcher feedback: The researcher in the feedback state provides
feedback for the vendor based on his/her interaction. The feed-
back is in the form of a transaction on the blockchain containing
the vendor identification and corresponding feedback. Once the
researcher provides the feedback, the researcher may try to find
more vulnerabilities until the program expires.
5.4 Arbitrators
The arbitrators are responsible for resolving the dispute between
the vendor and the researcher. The consortium of arbitrators vote on
a particular dispute and declare the result based on majority voting.
Also, at the end of each arbitration, the arbitrator provides negative
feedback to the losing entity. The arbitrators begin A_Waiting and
then transit to 𝐴_𝑉𝑜𝑡𝑒 .
Accept arbitration: The arbitrators accept the arbitration and transit
to the voting state.
𝐴𝑐𝑐𝑒𝑝𝑡𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛 ≜
∃ 𝑡𝑟𝑎𝑛𝑠 ∈ 𝑏𝑙𝑜𝑐𝑘𝑇𝑥 :
∧ 𝑡𝑟𝑎𝑛𝑠.𝑡𝑦𝑝𝑒 = 𝑇𝑋_𝐴𝑅𝐵𝐼𝑇𝑅𝐴𝑇𝐼𝑂𝑁 ∧ 𝑡𝑟𝑎𝑛𝑠.𝑛𝑢𝑚𝑏𝑒𝑟 = 𝑁𝑈𝑀𝐵𝐸𝑅
∧ 𝑡𝑟𝑎𝑛𝑠.𝑖𝑠𝑠𝑢𝑒𝑟 = 𝑅𝐸𝑆𝐸𝐴𝑅𝐶𝐻𝐸𝑅
∧𝑎𝑆𝑡𝑎𝑡𝑒′ = [𝑥 ∈ 𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟 |− > 𝐴_𝑉𝑜𝑡𝑒 ]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨𝑛𝑢𝑚𝑉𝑜𝑡𝑒𝑑, 𝑣𝑒𝑛𝑑𝑜𝑟𝑉𝑎𝑟𝑠, 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟𝑉𝑎𝑟𝑠,
𝑏𝑙𝑜𝑐𝑘𝑐ℎ𝑎𝑖𝑛𝑉𝑎𝑟𝑠, 𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
Vote: The arbitrators begin voting on the proposal proposed by the
arbitration transaction, choosing between the options included in
the transaction. The voting status of the arbitrators is tracked to
identify the end of the voting process.
𝑉𝑜𝑡𝑒 (𝑎) ≜
∧𝑎𝑆𝑡𝑎𝑡𝑒 [𝑎] = 𝐴_𝑉𝑜𝑡𝑒 ∧ 𝑛𝑢𝑚𝑉𝑜𝑡𝑒𝑑′ = 𝑛𝑢𝑚𝑉𝑜𝑡𝑒𝑑 + 1
∧𝑎𝑆𝑡𝑎𝑡𝑒′ = [𝑎𝑆𝑡𝑎𝑡𝑒 𝐸𝑋𝐶𝐸𝑃𝑇 ![𝑎] = 𝐴_𝑅𝑒𝑠𝑢𝑙𝑡 ]
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑣𝑒𝑛𝑑𝑜𝑟𝑉𝑎𝑟𝑠, 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟𝑉𝑎𝑟𝑠, 𝑏𝑙𝑜𝑐𝑘𝑐ℎ𝑎𝑖𝑛𝑉𝑎𝑟𝑠,
𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
Arbitration result: Once all the arbitrators have voted, the result of
the arbitration is sent to the blockchain identified by TX_ARBITRA-
TIONRESULT. Also, corresponding feedback is sent to the blockchain.
𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑖𝑜𝑛𝑅𝑒𝑠𝑢𝑙𝑡 ≜
∧ 𝐼𝐹 𝑛𝑢𝑚𝑉𝑜𝑡𝑒𝑑 = 𝐶𝑎𝑟𝑑𝑖𝑛𝑎𝑙𝑖𝑡𝑦 (𝐴𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟 )𝑇𝐻𝐸𝑁
∧𝐿𝐸𝑇
𝑡𝑦𝑝𝑒 == 𝑇𝑋_𝐴𝑅𝐵𝐼𝑇𝑅𝐴𝑇𝐼𝑂𝑁𝑅𝐸𝑆𝑈𝐿𝑇 𝑝𝑔𝑟𝑚𝑛𝑢𝑚 == 𝑁𝑈𝑀𝐵𝐸𝑅
𝑖𝑠𝑠𝑢𝑒𝑟 == 𝑅𝐸𝑆𝐸𝐴𝑅𝐶𝐻𝐸𝑅 𝑟𝑒𝑠𝑢𝑙𝑡 == 𝑅𝐸𝑆𝑈𝐿𝑇 𝑤𝑖𝑛𝑛𝑒𝑟 == 𝑊𝐼𝑁𝑁𝐸𝑅
𝑙𝑜𝑜𝑠𝑒𝑟 == 𝐿𝑂𝑂𝑆𝐸𝑅 𝑓 𝑒𝑒𝑑𝑏𝑎𝑐𝑘 == 𝐹𝐸𝐸𝐷𝐵𝐴𝐶𝐾
𝐼𝑁
𝑇𝑟𝑎𝑛𝑠𝑎𝑐𝑡𝑖𝑜𝑛 ( 𝑡𝑦𝑝𝑒, 𝑝𝑔𝑟𝑚𝑛𝑢𝑚, 𝑖𝑠𝑠𝑢𝑒𝑟, ⟨ 𝑟𝑒𝑠𝑢𝑙𝑡 ⟩ )
𝑇𝑟𝑎𝑛𝑠𝑎𝑐𝑡𝑖𝑜𝑛 ( 𝑡𝑦𝑝𝑒, 𝑝𝑔𝑟𝑚𝑛𝑢𝑚, 𝑤𝑖𝑛𝑛𝑒𝑟, ⟨ 𝑓 𝑒𝑒𝑑𝑏𝑎𝑐𝑘 ⟩ )
𝑇𝑟𝑎𝑛𝑠𝑎𝑐𝑡𝑖𝑜𝑛 ( 𝑡𝑦𝑝𝑒, 𝑝𝑔𝑟𝑚𝑛𝑢𝑚, 𝑙𝑜𝑜𝑠𝑒𝑟, ⟨ 𝑓 𝑒𝑒𝑑𝑏𝑎𝑐𝑘 ∗ −1 ⟩ )
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑣𝑒𝑛𝑑𝑜𝑟𝑉𝑎𝑟𝑠, 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠,
245
𝑏𝑙𝑜𝑐𝑘𝑇𝑥, 𝑏𝑎𝑙𝑎𝑛𝑐𝑒, 𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
𝐸𝐿𝑆𝐸
∧𝑈𝑁𝐶𝐻𝐴𝑁𝐺𝐸𝐷 ⟨ 𝑣𝑒𝑛𝑑𝑜𝑟𝑉𝑎𝑟𝑠, 𝑟𝑒𝑠𝑒𝑎𝑟𝑐ℎ𝑒𝑟𝑉𝑎𝑟𝑠, 𝑎𝑟𝑏𝑖𝑡𝑟𝑎𝑡𝑜𝑟𝑉𝑎𝑟𝑠,
𝑏𝑙𝑜𝑐𝑘𝑐ℎ𝑎𝑖𝑛𝑉𝑎𝑟𝑠, 𝑐ℎ𝑎𝑛𝑛𝑒𝑙 ⟩
5.5 Model checking
The TLC model evaluation involves parsing the state space to find
critical states, e.g., states leading to deadlock conditions or violation
of invariants. We performed simulation on TLA+ model verification
tool to check the correctness of the proposed system and the critical
conditions. We ran the experiment on a Windows 10-based Intel i7
quad-core machine with 32 GB RAM. The evaluation is performed
for: (i) the normal situation with no arbitration, and (ii) the situation
involving arbitration. The results are presented in Table 1.
The normal situation does not involve any contention between
the researchers and vendors. The researcher accepts the decision
taken by the vendor. For the normal situation, the simulation pro-
cess took 11s and visited 31,161 distinct states. In arbitration, where
there is a conflict between researchers and vendors, due to the static
nature of the simulation, the simulation process did not terminate.
However, the simulation did not find a deadlock for the duration of
3600s. Here we present the statistics for the first 10 minutes. Based
on the results presented in the Table 1, we can conclude that the
proposed scheme is error-free.
6 IMPLEMENTATION AND SIMULATION
The proposed prototype is based on a permissioned - enterprise
blockchain called Hyperledger fabric [3], release-1.4 Inc.4 The ar-
chitecture consists of three organizations, Vendors, Researchers,
and Arbitrators Researchers exchange vulnerability disclosures for
bounties under arbitrators’ supervision. In Hyperledger Fabric, or-
ganizations own the network and contribute their resources in the
form of nodes. Since there is no real word ’researchers’ or ’arbitra-
tors’ organizations, their nodes are contributed by all participating
vendor companies. All three organizations are using the same chan-
nel, i.e., one instance of a blockchain. Each organization has one
peer node, maintaining a copy of the ledger and is part of the chan-
nel. Vendors also maintain a private data collection on the Network
channel, allowing it to preserve the privacy of the vulnerability
disclosure data by controlling who can access the data, where it
is stored, and for how long. The hash value of the private data is
written to all of the peer’s ledgers and serves as evidence of the
transaction, state validation and integrity check in case that the
private data is shared with another party in the network, in our
use case with the arbitrators. The Hyperledger fabric infrastructure
needs few more settings: Orderer node, responsible for transaction
ordering with other nodes in ordering service, CouchDB service,
peers’ state db, and a certificate authority (CA). Each peer with its
ledger, the orderer, and the CA runs in their docker container.
4https://hyperledger-fabric.readthedocs.io/en/release-1.4/
Table 1: TLA+ simulation results.
Situation Time Depth States Found Distinct Errors
States
Normal 11’ 30 335,459 31,161 0
Arbitration 600’ 816 274,486,189 20,908,899 0
A smart contract on Fabric is known as a chaincode. Once the
bug bounty smart contracts and arbitrator’s contracts are installed
on the networks’ peer nodes, the embedded logic is ready to be
executed via transactions. The user applications interact via trans-
actions to either read or update the ledger state. We used several
user applications, written in Java or JavaScript, to invoke the chain-
code transactions. Each user has a wallet, stored in the local file
system, containing digital identities with certifications issued to
him by his organization’s trusted CA. To create a new Bug Bounty
smart program contract in memory, the application connects to
the channel with credentials of permissioned user from Vendor’s
organization and invoke the following transaction that creates a
bug bounty programs and saves its instance to the ledger database.
@Transact ion
p u b l i c BugBountySmartProgram i s s u e ( BugBountySmart−
ProgramContext c tx , S t r i n g po l i c y , S t r i n g owner ,
S t r i n g i s sueDateTime , i n t bountyValue , S t r i n g exp−
i r a t i onDa t eT ime , S t r i n g programNumber ) ;
For simplification, the program’s policy is represented as a string.
The arbitration smart contract similarly allows security researchers
to create an arbitration instance with the program’s id and voting
option. Then, each arbitrator can use its application to invoke the
vote transaction, which saves the arbitrators’ choice and updates
the ledger state.
7 SECURITY PROPERTIES
The proposed framework has the following security properties:
Confidential disclosure and arbitration. Communication regarding
vulnerability disclosure is listed publicly on the blockchain, but it is
encrypted so that only the disclosing researcher and relevant ven-
dor can decrypt it (as explained in subsection 4.4). Immutable and
transparent log of communication. Every message between security
researchers and vendors is logged into the blockchain, and accord-
ingly, messages are immutable and transparent, though encrypted.
The logging of communication between security researchers and
vendors, without specifying its content is a common mean used by
bug bounty programs to encourage communication and is not re-
garded as a data leakage. In cases in which the logging is not desired,
one can implement the framework on a private blockchain, where
the communication is not logged until a the vendor decides it is safe
according to responsible disclosure procedure. Resiliency to denial
of service. The main components of the framework are the smart
contracts and the blockchain, that are resistant to denial-of-service
under the assumption of an honest majority. Feedback transparency.
The accumulative feedback messages are publicly accessible to
every researcher, thus discouraging vendors from avoiding partici-
pation in arbitration process, and conversely encourage researchers
to disclose vulnerability for rewards (as explained in detail in Sec-
tion 4.5). Fairness. A researcher that discloses a valid vulnerability
is always rewarded by the relevant vendor, under the assumption
of an honest arbitration process (as demonstrated in Section 8).
8 FAIR EXCHANGE USING GAME THEORY
The game theoretic definition of a fair protocol is defined as a case in
which no party can improve its utilization by a dishonest behavior,
i.e., not following the protocol as specified [20]. In this section
we attempt to prove that the proposed platform, when modeled
246
as game, is fair based on the above definition. For the sake of the
proof, the proposed platform is modeled as a game tree model [5].
Game tree models are directed, labeled tree data structures that
model every possible action of a party until reaching a leaf node,
thus indicating the termination of the game. Every leaf node is a
associated with payoff that can be either positive or negative, and
the utilization of a party is define as the payoff of a single game. The
security researcher and vendors are assumed to be rational i.e., they
aim to increase their payoffs by any means, including deviating
from the protocol.
In this section, we analyze the payoffs for every possible case
of exchanging vulnerabilities for rewards using the framework
through a game tree model. We argue that given only two assump-
tion, rationality and feedback transparency, the honest behavior
yields the optimal payoff i.e., the protocol for exchanging vulnera-
bilities for rewards is a Nash equilibrium.
The proposed platform has two parties, security researcher and
software company, that wish to exchange a vulnerability informa-
tion disclosure for a reward. The game plays as follows. Firstly, the
software company, denoted by V, publishes a bug bounty smart
contract, with x tokens deposited at it. Then, the security researcher,
denoted by R, provides information regarding a vulnerability that
matches scope of of the bug bounty contract, and its expected re-
ward is 𝑦 | 𝑦 ≤ 𝑥 . After the disclosure,V can either properly reward
R or reject the finding. Finally, R can terminate or ask an arbitration
process, in which he can either lose or win. The game tree of the
described protocol is illustrated in Figure 3.
Figure 3: Proposed framework protocol modeled as a game
tree.
8.1 Formal notations
Following [5] formal definition, let 𝑃 be a two-party exchange
protocol. Let us consider the game representation of the protocol
and denote the two players by 𝐴 and 𝐵. Denote the strategy pair
that corresponds to the faithful execution of the protocol by (𝑆∗
𝐴
, 𝑆∗
𝐵
).
𝑃 is said to be Nash equilibrium fair if:
1. −→
𝑃
(𝑆∗𝐴, 𝑆
∗
𝐵 ) = (0, 0) and
2. (𝑆∗𝐴, 𝑆
∗
𝐵 ) is a Nash equilibrium
where the requirement for −→
𝑃
(𝑆∗
𝐴
, 𝑆∗
𝐵
) = (0,0) is that:
∀𝑆𝐵 ∈
∑
𝐵
: 𝑝𝐵 (𝑆∗𝐴, 𝑆𝐵 ) ≤ 0 and
∀𝑆𝐴 ∈
∑
𝐴
: 𝑝𝐴 (𝑆𝐴, 𝑆∗𝐵 ) ≤ 0
where
∑
𝑖 stands for the player strategy set, and 𝑝𝑖 stands for the
player payoff.
The bug bounty game has two underlying assumptions: (i) Both
parties are rational i.e., parties will always select the action that
results in the maximal payoff. (ii) A feedback penalty for software
companies (vendors) is worse than every token penalty which is
reasonable assuming a recurring game.
8.2 Cases
The game starts by V publishing the bug bounty contract, and R
disclosing a security vulnerability within the bug bounty scope
to V. V has two possible actions. The honest action, in which V
rewards R, and the dishonest action in which V reject the disclosed
vulnerability. These two moves are represented by the two edges
starting from vertex 1.
8.2.1 Valid vulnerability for a reward. If V rewards R, then the
game terminates in vertex 1.1 with a payoff of 0 for R and 0 for V
because the vulnerability was exchanged for an equivalent reward,
therefore there’s no gain nor loss to any of the parties.
8.2.2 Vulnerability, without a reward. If however, V doesn’t reward
R and rejects the disclosed vulnerability, then R has two possible
actions represented by the two edges starting from vertex 1.2. R
can either terminate the game or ask for an arbitration process.
By terminating the game, R agree with V ’s rejection and the game
terminates in vertex 1.2.2 with the following possible payoffs:
−−−−→
𝑃𝑅,𝑉
= (
{
0, R is unfair
−𝑦, R is fair;
,
{
𝑦, V is unfair
0, V is fair;
) (1)
8.2.3 Valid vulnerability, without a reward. If R disclosed a valid
vulnerability but V either rejected it entirely or paid less than
the expected reward of 𝑦 tokens, then R lost at most 𝑦 tokens.
Conversely, in this case, V gained at most 𝑦 tokens advantage.
8.2.4 Invalid vulnerability, without a reward. Another possible case
is thatV is refuses to reward R because the vulnerability is invalid, in
whichV ’s payoff is 0. Similarly, if R discloses an invalid vulnerability
to V, the payoff of R is also 0, because the invalid vulnerability is
not worthy of a reward.
8.2.5 Researcher asks for arbitration. If R asks for an arbitration
process (see vertex 1.2), then V has two possible actions repre-
sented by the two edges starting from vertex 1.2.1, either ignore or
participate in the arbitration process
8.2.6 Vendor ignores arbitration. If V decides to ignore the arbitra-
tion process, then the game terminates in vertex 1.2.1.1 with the
following possible payoffs:
−−−−→
𝑃𝑅,𝑉
= (
{
𝑦, R is unfair
0, R is fair;
,
{
feedback penalty, V is unfair
−𝑦 + feedback penalty, V is fair;
) (2)
If V is playing fair and refuses to participate in arbitration, it
means that the finding is not valuable to V or not following the
program’s rules and not worthy for him to supply a testing environ-
ment in case the arbitrators can’t check in their own environment.
Therefore, in this case V ’s payoff is feedback penalty as he can not
ignore framework rules.
247
8.2.7 Vendor participates in arbitration. If V ’s chose to participate
in the arbitration process (see vertex 1.2.1), there are two possible
outcomes, either R wins and V loses, or the opposite. These two
outcomes are represented by the two edges starting from vertex
1.2.1.2.
8.2.8 Researcher wins arbitration. If R wins, then the game termi-
nates in vertex 1.2.1.2.1 with the following payoffs:
−−−−→
𝑃𝑅,𝑉
= (0, feedback penalty) (3)
If 𝑅 wins for a valid vulnerability, both parties payoff is 0 for the
fair trade.
8.2.9 Researcher loses arbitration. If R loses, then the game termi-
nates in vertex 1.2.1.2.2 with the following payoffs:
−−−−→
𝑃𝑅,𝑉
= (
{
0 + feedback penalty, R is unfair
−𝑦 + feedback penalty, R is fair;
, 0) (4)
If R disclosed a valid vulnerability, then he actually lost maximum
y tokens that he worked for. Otherwise, if R disclosed an invalid
vulnerability, there’s no lose for R. Either way, R is punished with
feedback penalty, and V wins in a case in which no trade was ever
made, therefore, the payoff is 0 for both parties.
8.3 Summary: Nash Equilibrium
The bug bounty game has only two scenarios in which one of the
party improves its utilization compared to the honest scenario: (i) V
rejects despite R being honest, and R doesn’t ask for arbitration (see
vertex 1.2.2). This state is unreachable based on the first assumption
(rational parties), because an rational honest R must ask for arbitra-
tion in which it’ll gain an additional payoff. (ii) V is dishonest, R
asks for arbitration, but V refuses to participate (see vertex 1.2.1.1).
This state is unreachable based on the second assumption (feed-
back penalty is worse than token penalty), because the dishonest
vendors must participate in the arbitration to incur in a penalty of
tokens rather than feedback. To conclude, neither the vendor or the
researcher will gain anything from playing unfairly according to
this protocol, and hence the protocol provides the Nash equilibrium
fairness.
9 CONCLUSIONS AND FUTURE WORK
In this paper, we proposed a secure bug bounty framework that
guarantees decentralized trust, fairness, and potentially low com-
mission fees. The system ensures these properties by using smart
contracts that enforce the policies agreed by the participating enti-
ties, and trusted committee that forces a software vendor to pay the
penalty in case of misbehavior. A TLA+ specification based formal
evaluation of the proposed framework indicates the viability of
the proposal. A Hyperledger Fabric-based prototype simulates the
proposed framework in a real scenario. A game-theoretic analysis
of the proposed framework indicated that rational parties’ use of
the framework guarantees honest use of the protocol, thus ensuring
fairness and low fees. In the future, we would like to investigate
the scalability of the proposal and the costs associated with main-
taining such a network. Hyperledger Caliper tool can be used to
calculate and compare such statistics to existing solutions.
Acknowledgments
This research was partially supported by the CONCORDIA project
that has received funding from the European Union’s Horizon
2020 research and innovation programme under grant agreement
number 830927.
REFERENCES
[1] [n. d.]. HackerOne. https://www.hackerone.com/
[2] [n. d.]. polyswarm. https://polyswarm.io/
[3] Elli Androulaki et. al. 2018. Hyperledger Fabric: A Distributed Operating Sys-
tem for Permissioned Blockchains. Proceedings of the 13th EuroSys Conference,
EuroSys 2018 2018-January (2018). https://doi.org/10.1145/3190508.3190538
arXiv:1801.10228
[4] Lorenz Breidenbach, Phil Daian, Floriantra Er, and Ari Juels. 2018. Enter the
Hydra: Towards Principled Bug Bounties and Exploit-Resistant Smart Con-
tracts. USENIX Security (2018), 1335–1352. https://www.usenix.org/conference/
usenixsecurity18/presentation/breindenbach{%}0Ahttps://thehydra.io/paper.
pdf
[5] Levente Buttyan and Jean-Pierre Hubaux. 1999. Toward a Formal Model of Fair
Exchange - a Game Theoretic Approach. December 1999 (1999), 1–16.
[6] Hasan Cavusoglu, Huseyin Cavusoglu, and Srinivasan Raghunathan. 2007. Ef-
ficiency of vulnerability disclosure mechanisms to disseminate vulnerability
knowledge. IEEE Transactions on Software Engineering 33, 3 (2007), 171–185.
https://doi.org/10.1109/TSE.2007.26
[7] Cohen Fred. 1999. Simulating cyber attacks, defences, and consequences. Com-
puters& Security 18, 6 (1999), 479–518.
[8] M Crosby, P Pattanayak, S Verma, and V Kalyanaraman. 2016. Applied Innovation
Review. Applied Innovation Review 2 (2016), 5–20.
[9] William Crumpler and James A Lewis. 2019. The Cybersecurity Workforce
Gap. Center for Strategic and International Studies July 2016 (2019), 1–10. http:
//www.isaca.org/Knowledge-Center/
[10] Hackerone. 2019. Hacker Report. Technical Report. 54 pages.
[11] Shuang Hu, Lin Hou, Gongliang Chen, Jian Weng, and Jianhua Li. 2018.
Reputation-based distributed knowledge sharing system in blockchain. ACM
International Conference Proceeding Series (2018), 476–481. https://doi.org/10.
1145/3286978.3286981
[12] Vijayan Jai. 2017. Bug Bounty Programs are Growing Up Fast and Pay-
ing More. https : / /www. darkreading . com / vulnerabilities---threats /
bug-bounty-programs-are-growing-up-fast-and-paying-more/d/d-id/1328428
[13] Jay P Kesan and Carol M Hayes. 2016. Bugs in the Market: Creating a Legitimate,
Transparent, and Vendor-Focused Market for Software Vulnerabilities. Ariz. L.
Rev. 58 (2016), 753.
[14] Markus Klems, Jacob Eberhardt, Stefan Tai, Steffen Härtlein, Simon Buchholz, and
Ahmed Tidjani. 2017. Trustless Intermediation in Blockchain-BasedDecentralized
Service Marketplaces BT - Service-Oriented Computing, Michael Maximilien,
Antonio Vallecillo, Jianmin Wang, and Marc Oriol (Eds.). Springer International
Publishing, Cham, 731–739.
[15] Andreas Kuehn and Milton Mueller. 2018. Analyzing Bug Bounty Programs: An
Institutional Perspective on the Economics of Software Vulnerabilities. SSRN
Electronic Journal (2018), 1–16. https://doi.org/10.2139/ssrn.2418812
[16] Leslie Lamport. 2002. Specifying systems: the TLA+ language and tools for hardware
and software engineers. Addison-Wesley Longman Publishing Co., Inc.
[17] Aron Laszka, Mingyi Zhao, Akash Malbari, and Jens Grossklags. 2018. The rules
of engagement for bug bounty programs. In International Conference on Financial
Cryptography and Data Security. Springer, 138–159.
[18] Tianxiang Lu, Stephan Merz, and Christoph Weidenbach. 2011. Towards verifi-
cation of the pastry protocol using TLA+. In Formal Techniques for Distributed
Systems. Springer, 244–258.
[19] Loi Luu, Duc Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor.
2016. Making smart contracts smarter. Proceedings of the ACM Conference
on Computer and Communications Security 24-28-Octo (2016), 254–269. https:
//doi.org/10.1145/2976749.2978309
[20] Adrienne Margolis. 2000. Fair exchange. Engineer 289, 7510 (2000), 22. https:
//doi.org/10.7748/ns2014.04.28.32.27.s32
[21] Luciana Obregon. 2019. Information Security Reading Room A Technical Ap-
proach at Securing SaaS using Cloud Institute. (2019).
[22] Pascal Schulz, Leonardo Martucci, and Donald F Ross. 2014. Penetration Testing
of Web Applications in a Bug Bounty Program. (2014). http://www.diva-portal.
org/smash/get/diva2:723516/FULLTEXT02
[23] Florian Tramèr, Fan Zhang, Huang Lin, Jean Pierre Hubaux, Ari Juels, and Elaine
Shi. 2017. Sealed-Glass Proofs: Using Transparent Enclaves to Prove and Sell
Knowledge. Proceedings - 2nd IEEE European Symposium on Security and Privacy,
EuroS and P 2017 (2017), 19–34. https://doi.org/10.1109/EuroSP.2017.28
248
https://www.hackerone.com/
https://polyswarm.io/
https://doi.org/10.1145/3190508.3190538
http://arxiv.org/abs/1801.10228
https://www.usenix.org/conference/usenixsecurity18/presentation/breindenbach{%}0Ahttps://thehydra.io/paper.pdf
https://www.usenix.org/conference/usenixsecurity18/presentation/breindenbach{%}0Ahttps://thehydra.io/paper.pdf
https://www.usenix.org/conference/usenixsecurity18/presentation/breindenbach{%}0Ahttps://thehydra.io/paper.pdf
https://doi.org/10.1109/TSE.2007.26
http://www.isaca.org/Knowledge-Center/
http://www.isaca.org/Knowledge-Center/
https://doi.org/10.1145/3286978.3286981
https://doi.org/10.1145/3286978.3286981
https://www.darkreading.com/vulnerabilities---threats/bug-bounty-programs-are-growing-up-fast-and-paying-more/d/d-id/1328428
https://www.darkreading.com/vulnerabilities---threats/bug-bounty-programs-are-growing-up-fast-and-paying-more/d/d-id/1328428
https://doi.org/10.2139/ssrn.2418812
https://doi.org/10.1145/2976749.2978309
https://doi.org/10.1145/2976749.2978309
https://doi.org/10.7748/ns2014.04.28.32.27.s32
https://doi.org/10.7748/ns2014.04.28.32.27.s32
http://www.diva-portal.org/smash/get/diva2:723516/FULLTEXT02
http://www.diva-portal.org/smash/get/diva2:723516/FULLTEXT02
https://doi.org/10.1109/EuroSP.2017.28
 
 
    
   HistoryItem_V1
   TrimAndShift
        
     Range: all pages
     Trim: fix size 8.500 x 11.000 inches / 215.9 x 279.4 mm
     Shift: move up by 12.60 points
     Normalise (advanced option): 'original'
      
        
     32
            
       D:20200106120622
       792.0000
       US Letter
       Blank
       612.0000
          
     Tall
     1
     0
     No
     675
     322
     Fixed
     Up
     12.6000
     0.0000
            
                
         Both
         AllDoc
              
       PDDoc
          
     Uniform
     0.0000
     Top
      
        
     QITE_QuiteImposingPlus2
     Quite Imposing Plus 2.9
     Quite Imposing Plus 2
     1
      
        
     10
     9
     10
      
   1
  
    
   HistoryItem_V1
   TrimAndShift
        
     Range: From page 1 to page 1
     Trim: none
     Shift: move down by 1.80 points
     Normalise (advanced option): 'original'
      
        
     32
     1
     0
     No
     675
     322
     Fixed
     Down
     1.8000
     0.0000
            
                
         Both
         1
         SubDoc
         1
              
      
       PDDoc
          
     None
     0.0000
     Top
      
        
     QITE_QuiteImposingPlus2
     Quite Imposing Plus 2.9
     Quite Imposing Plus 2
     1
      
        
     10
     0
     1
      
   1
  
 HistoryList_V1
 qi2base