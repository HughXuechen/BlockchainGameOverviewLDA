How to Use Bitcoin to Play Decentralized Poker
Ranjit Kumaresan
MIT
ranjit@csail.mit.edu
Tal Moran
IDC Herzliya
talm@idc.ac.il
Iddo Bentov
Technion
idddo@cs.technion.ac.il
ABSTRACT
Back and Bentov (arXiv 2014) and Andrychowicz et al. (Security
and Privacy 2014) introduced techniques to perform secure multi-
party computations on Bitcoin. Among other things, these works
constructed lottery protocols that ensure that any party that aborts
after learning the outcome pays a monetary penalty to all other par-
ties. Following this, Andrychowicz et al. (Bitcoin Workshop 2014)
and concurrently Bentov and Kumaresan (Crypto 2014) extended
the solution to arbitrary secure function evaluation while guaran-
teeing fairness in the following sense: any party that aborts after
learning the output pays a monetary penalty to all parties that did
not learn the output. Andrychowicz et al. (Bitcoin Workshop 2014)
also suggested extending to scenarios where parties receive a pay-
off according to the output of a secure function evaluation, and out-
lined a 2-party protocol for the same that in addition satisfies the
notion of fairness described above.
In this work, we formalize, generalize, and construct multiparty
protocols for the primitive suggested by Andrychowicz et al. We
call this primitive secure cash distribution with penalties. Our for-
mulation of secure cash distribution with penalties poses it as a
multistage reactive functionality (i.e., more general than secure func-
tion evaluation) that provides a way to securely implement smart
contracts in a decentralized setting, and consequently suffices to
capture a wide variety of stateful computations involving data and/or
money, such as decentralized auctions, markets, and games such
as poker, etc. Our protocol realizing secure cash distribution with
penalties works in a hybrid model where parties have access to a
claim-or-refund transaction functionality F?CR which can be effi-
ciently realized in (a variant of) Bitcoin, and is otherwise indepen-
dent of the Bitcoin ecosystem. We emphasize that our protocol is
dropout-tolerant in the sense that any party that drops out during
the protocol is forced to pay a monetary penalty to all other parties.
Our formalization and construction generalize both secure compu-
tation with penalties of Bentov and Kumaresan (Crypto 2014), and
secure lottery with penalties of Andrychowicz et al. (Security and
Privacy 2014).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full cita-
tion on the first page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12-16, 2015, Denver, CO, USA.
Copyright 2015 ACM 978-1-4503-3832-5/15/10 ...$15.00.
http://dx.doi.org/10.1145/2810103.2813712.
Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General—Secu-
rity and protection
Keywords
Secure Computation; Bitcoin; Smart Contracts; Markets; Poker.
1. INTRODUCTION
Once there were two “mental chess” experts who had
become tired of their favorite pastime. Let’s play “men-
tal poker” for some variety suggested one. “Sure”
said the other. “Just let me deal!”
Motivated by this anecdote, Shamir, Rivest, and Adleman set forth
in their seminal paper [1] to propose protocols that allow a pair of
parties to play “fair” mental poker. Arguably their paper gave birth
to the concept of secure multiparty computation (MPC), a primi-
tive that allows a set of mutually distrusting parties to carry out a
distributed computation without compromising on the privacy of
inputs or the correctness of the end result [2]. Indeed mental poker
has since been used as a metaphor for MPC [3]. Clearly, MPC can
be used to allow a set of parties to play poker over the Internet with-
out having to trust a third party. However this comes with certain
caveats.
The obvious problem is that secure computation as defined can
only allow players to play mental poker (i.e., without involving real
money). Another serious problem is that secure computation in the
presence of a dishonest majority (including the important two-party
case) does not provide dropout-tolerant solutions to mental poker.
Players may wait until the end of the hand to decide whether they
want to drop out, i.e., after they have a much better idea of whether
they are going to win or lose. As [4] points out, an even more
fundamental issue is to get parties to respect the outcome of the
protocol and distribute the money as dictated by the output.
Tying payments to secure computation. More generally, there
are many cases in which we would like to tie real-world payments
to secure computation, e.g., decentralized fair exchange of digi-
tal goods or services for money in online marketplaces, decentral-
ized multistage auctions, decentralized online gambling, etc. Cur-
rently, these tasks are delegated to a trusted third party (such as
a bank, escrow service, or a court system). For “traditional” cur-
rency systems, any payment—whether or not it is based on secure
computation— requires trust in a third party (as the currency it-
self is based on a trusted party, such as a central bank). However,
the introduction of cryptocurrencies, such as Bitcoin [5], opens the
possibility of handling payments in a decentralized manner [6, 7].
195
http://crossmark.crossref.org/dialog/?doi=10.1145%2F2810103.2813712&domain=pdf&date_stamp=2015-10-12
Indeed cryptocurrencies are a natural choice for combining MPC
with “real money.” Andrychowicz et al. [4] and Back and Ben-
tov [8] introduced techniques to perform secure multiparty com-
putations on Bitcoin. Among other things, these works constructed
lottery protocols that ensure that any party that aborts after learning
the outcome pays a monetary penalty to all other parties. Following
this, Andrychowicz et al. [9] and concurrently Bentov and Kumare-
san [10] extended the solution to arbitrary secure function evalua-
tion while guaranteeing fairness in the following sense: any party
that aborts after learning the output pays a monetary penalty to all
parties that did not learn the output. Andrychowicz et al. [9] also
suggested extending to scenarios where parties receive a payoff ac-
cording to the output of a secure function evaluation, and outlined
a 2-party protocol for the same that in addition satisfies the notion
of fairness described above.
Our contributions in a nutshell. In this work, we formalize, gen-
eralize, and construct multiparty protocols for the primitive sug-
gested by [9]. We call this primitive secure cash distribution with
penalties. Our formulation of secure cash distribution with penal-
ties poses it as a multistage reactive functionality (i.e., more gen-
eral than secure function evaluation) that suffices to capture a wide
variety of stateful computations involving data and/or money, such
as decentralized auctions, games, markets, etc. Our protocol re-
alizing secure cash distribution with penalties works in a hybrid
model where parties have access to a claim-or-refund transaction
functionality F?CR which can be efficiently realized in (a variant
of) Bitcoin, and is otherwise independent of the Bitcoin ecosystem.
We emphasize that our protocol is dropout-tolerant in the sense that
any party that drops out during the protocol is forced to pay a mon-
etary penalty to all other parties. Our formalization and construc-
tion simultaneously generalize secure computation with penalties
of Bentov and Kumaresan [10], and secure lottery with penalties of
Andrychowicz et al. [4]. Below we describe our contributions in
more detail.
Defining SCD. We define SCD as a bounded reactive functional-
ity, i.e., the computation proceeds in a finite number of stages. In
an initial “deposit” stage, parties deposit sums of money. In each
succeeding stage, parties provide inputs and obtain outputs for that
stage. Then in the last stage, the money deposited by the parties is
redistributed among them according to the output of the last stage.
Any party that aborts during any stage of the computation will be
forced to pay penalties to all parties. Thus SCD guarantees that
honest parties either complete the entire computation or are com-
pensated financially.
Implementing SCD. Note that while in the standard setting, reac-
tive secure computation reduces to non-reactive secure computa-
tion by secret sharing the state between successive stages, a similar
reduction does not carry over when we are in the penalty setting
since a malicious party may abort between successive stages of a re-
active computation and go unpenalized. We design a protocol that
realizes SCD (i.e., with full simulation security [11]) in a hybrid
model where parties have access to a claim-or-refund transaction
functionality F?CR. The main technical idea in our solution is the
construction of a see-saw transaction mechanism which is a novel
extension of the ladder transaction mechanism of [10]. Loosely
speaking, the ladder mechanism implements fair exchange with
penalties in the following sense: each party has their (digital) item
at the beginning of the protocol, and at the end if one party receives
all items, then it pays a penalty to parties which have not received
all items. In contrast the see-saw mechanism implements the fol-
lowing variant of fair exchange with penalties: the exchange pro-
ceeds in multiple rounds, and in each round, parties can adaptively
choose their input item they want exchanged based on the items put
up for exchange by other parties in previous rounds. Penalties are
now enforced across the entire exchange process. That is, if a party
decides to terminate the exchange process, then it pays a penalty
to all other parties. Note in particular that penalties are enforced
even when no party receives all items. Contrast this with the ladder
mechanism that enforces penalties to all parties only when some
party received all items. See Section 5 for the implementation of
the see-saw mechanism. Our protocol for secure cash distribution
makes non-black-box use of an underlying MPC protocol (cf. Sec-
tion 4).
Practical applications. Consider a group of servers that agree to
carry out an intensive computation task that spans several days.
Furthermore, assume that the computation requires multiple rounds
of interactions and the full participation of all participating servers,
and otherwise fails. Here, we would like to guarantee that the
servers exchange information as agreed upon without defaulting. In
such a setting, it is critical to ensure that the computation is carried
out as intended, and that no server invests computational effort only
to learn that a different server abruptly decided to not continue the
computation any more. Observe that the problem description as is
does not involve money. Still our formulation of SCD allows us to
capture such a setting and offers a meaningful solution to this prob-
lem, namely that a defaulting server will be forced to pay a penalty
to everyone else. Such a solution can be achieved by a straightfor-
ward use of a verifiable computation scheme in combination with
our see-saw transaction mechanism.
Next, consider a group of agents who participate in a set of fi-
nancial transactions over the internet. For example, these could be
agents in a prediction market (possibly with dark pool trading ca-
pabilities) who place bets on the occurrence of sets of events, and
may adaptively vary their choices depending on whether a previous
event in the set happened or not. One must also consider what hap-
pens when a malicious agent stops participating during the process.
A naïve solution would require that the agents make a deposit at the
beginning of the protocol which they would forfeit when they abort.
To make this idea work in a decentralized setting, one must develop
a method to put the deposits in escrow, and make sure that in the
event of an abort (1) honest agents can always retrieve their de-
posits from the escrow, and (2) honest agents obtain penalties from
the escrow when a dishonest agent aborts. Implementing such a de-
centralized escrow when a majority of agents are dishonest is not
straightforward. Our formulation of SCD exactly allows the capa-
bility to maintain a decentralized escrow across multiple stages of
a computation and hence our protocol implementing SCD provides
a solution to the prediction market problem described above.
More generally, since SCD models stateful reactive functional-
ities it provides a way to securely implement smart contracts in
a decentralized setting, and consequently captures a wide variety
of games, including poker (assuming that the strategy space of the
players includes variables that cannot be clearly defined and may
depend on side information that cannot be completely captured).
Limitations. Note that the plain model realizations of F?CR rely
on Bitcoin scripts. While we explicitly specify the checks that the
scripts need to perform, the current Bitcoin scripting language is
quite conservative (many opcodes became blacklisted [12]), and
therefore some of the required checks are not currently supported
in Bitcoin. More concretely, our construction requires signature
verification of arbitrary messages (i.e., not more burdensome than
the supported signature verification for the entire transaction data).
In addition it requires scripts to support calculations whose com-
plexity depends on the specific application. For instance, in the
application to poker, we require Bitcoin scripts to support simple
196
arithmetic calculations that verify whether a transcript of a poker
protocol follows the rules of poker. In the most general setting, the
validation complexity [13] (which corresponds to the complexity
of script verification) equals the complexity of verifying validity
of partial transcripts of an underlying secure computation proto-
col that realizes the reactive functionality. As suggested in [13],
validation complexity may also accurately reflect additional trans-
action fees that may be levied to include “unordinary” transactions
(i.e., transactions of the kind that our constructions need) into the
blockchain. Currently, only a small fraction of miners (e.g., Eligius
mining pool) accept transactions that make use of the entire Bit-
coin scripting language. In any case, our constructions require
that new opcodes be added to the Bitcoin scripting language (e.g.,
the opcode mentioned above for verifying signatures of arbitrary
messages). While we expect Bitcoin to be less conservative in the
scripts it supports in the future, our protocols can be deployed on
alt-coins with Turing complete scripts. However, Turing complete
scripts are an overkill for our constructions. This is because the
number of rounds until the final cash distribution must be bounded
(cf. Section 4), hence miners can levy a suitable transaction fee
by easily assessing the verification complexity of a certain SCD
(e.g., poker of some fixed number of rounds) script. By contrast,
a full-fledged Turing-complete cryptocurrency (like the Ethereum
project) has to resort to extra mechanisms in order to protect itself
from DoS attacks [14].
Our main goal in this work is to show feasibility of realizing
SCD. As mentioned earlier, our SCD protocol makes non-black-
box use of an underlying MPC protocol and can be inefficient in
practice. We note that this limitation can be removed for some
applications. For example, in Section 6, we show how to obtain a
protocol for decentralized poker with dropout tolerance that makes
only black-box use of MPC.
Related work. The general problem of secure computation was
solved in the 2-party setting by Yao [15], and in the multiparty set-
ting in [3]. Besides not handling payments, none of the schemes
above can guarantee fairness in the presence of a dishonest major-
ity [16]. [4] designed a multiparty lottery protocol in the penalty
model. [9] designed a secure computation protocol in the penalty
model but their protocol handles only the two-party setting. Secure
multiparty computation with penalties and secure multiparty lot-
tery with penalties were formalized, and protocols realizing these
were constructed in [10]. [13] shows applications of Bitcoin to var-
ious other interesting cryptographic primitives. The work of [17]
also shows how to enforce smart contracts with financial privacy
but with different trust assumptions.
Relation to [9]. The extension to a setting where payoffs depend on
the output of a secure function evaluation was proposed in [9, Sec-
tion 6]. The authors then show how to modify the Bitcoin scripts
that implements two-party secure function evaluation with penal-
ties and obtain a solution for the extended setting with payoffs. We
emphasize that [9] handles the two-party case, with a non-reactive
functionality, and outlines a solution using ad-hoc Bitcoin transac-
tions. In contrast, we provide formal definitions for secure cash
distribution with penalties which we define as a stateful reactive
functionality, then construct a multiparty protocol that securely re-
alize this definition, and provide formal proofs. Furthermore, our
protocol works in a clean hybrid model where parties have access
to a claim-or-refund transaction functionalityF?CR and is otherwise
independent of the Bitcoin ecosystem. That is, our protocol can
be easily adapted to any setting (e.g., alt-coins, PayPal) that can
support an implementation of F?CR. In a sense, our work shows
that F?CR is a complete primitive for secure computations involving
money. Finally, a technique that we use in our cash distribution
mechanism was previously outlined in [9]. Specifically, we use the
idea from [9] that allows the parties to transfer arbitrary amounts of
money by dividing a large amount into “power of 2 fractions.” Note
that it is possible to replace this technique with a naïve mechanism
and still obtain our feasibility results.
2. PRELIMINARIES
A function µ(·) is negligible in λ if for every positive polynomial
p(·) and all sufficiently large λ’s it holds that µ(λ) < 1/p(λ). A
probability ensemble X = {X(a, λ)}a∈{0,1}∗,n∈N is an infinite
sequence of random variables indexed by a and λ ∈ N. Two dis-
tribution ensembles X = {X(a, λ)}λ∈N and Y = {Y (a, λ)}λ∈N
are said to be computationally indistinguishable, denoted X
c≡ Y
if for every non-uniform polynomial-time algorithm D there exists
a negligible function µ(·) such that for every a ∈ {0, 1}∗,
|Pr[D(X(a, λ)) = 1]− Pr[D(Y (a, λ)) = 1]| ≤ µ(λ).
All parties are assumed to run in time polynomial in the security
parameter λ. We prove security in the “secure computation with
coins” (SCC) model proposed in [10]. Note that the main difference
from standard definitions of secure computation [18] is that now the
view of Z contains the distribution of coins. Let IDEALf,S,Z(λ, z)
denote the output of environment Z initialized with input z after
interacting in the ideal process with ideal process adversary S and
(standard or special) ideal functionality Gf on security parameter
λ. Recall that our protocols will be run in a hybrid model where
parties will have access to a (standard or special) ideal functionality
Gg . We denote the output of Z after interacting in an execution of
π in such a model withA by HYBRIDgπ,A,Z(λ, z), where z denotes
Z’s input. We are now ready to define what it means for a protocol
to SCC realize a functionality.
Definition 1. Let n ∈ N. Let π be a probabilistic polynomial-
time n-party protocol and let Gf be a probabilistic polynomial-
time n-party (standard or special) ideal functionality. We say that
π SCC realizes Gf with abort in the Gg-hybrid model (where Gg
is a standard or a special ideal functionality) if for every non-
uniform probabilistic polynomial-time adversary A attacking π
there exists a non-uniform probabilistic polynomial-time adversary
S for the ideal model such that for every non-uniform probabilistic
polynomial-time adversary Z ,
{IDEALf,S,Z(λ, z)}λ∈N,z∈{0,1}∗
c≡
{HYBRIDgπ,A,Z(λ, z)}λ∈N,z∈{0,1}∗ . ♦
Ideal functionality F?CR [10, 19, 20]. This special ideal func-
tionality has been employed in the design of multiparty fair secure
computation and lottery protocols [10]. See Figure 1 for a formal
description. At a high level, F?CR allows a sender Ps to condition-
ally send coins(x) to a receiver Pr . The condition is formalized as
the revelation of a satisfying assignment (i.e., witness) for a sender-
specified circuit φs,r( · ; z) (i.e., relation) that may depend on some
public input z. Further, there is a “time” bound, formalized as a
round number τ , within which Pr has to act in order to claim the
coins. An important property that we wish to stress is that the sat-
isfying witness is made public by F?CR. In the Bitcoin realization
of F?CR, sending a message with coins(x) corresponds to broad-
casting a transaction to the Bitcoin network, and waiting according
to some time parameter until there is enough confidence that the
transaction will not be reversed.
197
F?CR with session identifier sid, running with parties Ps and
Pr , a parameter 1λ, and adversary S proceeds as follows:
• Deposit phase. Upon receiving the tuple (deposit, sid,
ssid, s, r, φs,r, τ, coins(x)) from Ps, record the message
(deposit, sid, ssid, s, r, φs,r, τ, x) and send it to all par-
ties. Ignore any future deposit messages with the same ssid
from Ps to Pr .
• Claim phase. In round τ , upon receiving (claim, sid,
ssid, s, r, φs,r, τ, x, w) from Pr , check if (1) a tuple
(deposit, sid, ssid, s, r, φs,r, τ, x) was recorded, and (2) if
φs,r(w) = 1. If both checks pass, send (claim, sid, ssid,
s, r, φs,r, τ, x, w) to all parties, send (claim, sid, ssid, s,
r, φs,r, τ, coins(x)) to Pr , and delete the record (deposit,
sid, ssid, s, r, φs,r, τ, x).
• Refund phase: In round τ + 1, if the record (deposit, sid,
ssid, s, r, φs,r, τ, x) was not deleted, then send (refund,
sid, ssid, s, r, φs,r, τ, coins(x)) to Ps, and delete the
record (deposit, sid, ssid, s, r, φs,r, τ, x).
Figure 1: The ideal functionality F?CR.
3. SECURE CASH DISTRIBUTION
In this section, we introduce secure cash distribution with penal-
ties. Loosely speaking, secure cash distribution with penalties (or
simply “secure cash distribution”) allows each party to first make
a cash deposit and then supply additional inputs to a function. The
deposited cash is then distributed back to the parties depending on
(and along with) the output of the function evaluation. Any ma-
licious party that aborts the protocol after learning output and/or
receiving coins must pay a monetary penalty to all honest parties.
Clearly, such a primitive generalizes both secure computation
with penalties [10, 9] and secure lottery with penalties [10, 4].
As it turns out, this informal definition of secure cash distribution
is not strong enough to enable applications that we are interested
in. What is needed is to handle the reactive setting, i.e., allowing
multiple “stages” of computation with parties providing inputs to
each stage and receiving outputs at the end of each stage. Let F
be a reactive functionality, i.e., one that keeps state across eval-
uations and proceeds in multiple stages. To keeps things simple,
we assume an upper bound ρ on the number of stages of F . That
is, we assume F = (f1, . . . , fρ) is a collection of functionalities
which accumulate state with each evaluation. More concretely, let
x` = (x`,1, . . . , x`,n) denote the parties’ input to the `-th stage
for ` ∈ [ρ], and let state0 be initialized as state0 := NULL.
Then over the course of the computation, parties successively eval-
uate f`(x`; state`−1) to obtain (z`, state`) for ` = 1, . . . , ρ. Here
z` = (z`,1, . . . , z`,n) represents the parties’ output, i.e., party Pi
obtains z`,i. The value state` represents the state saved for the
(` + 1)-th computation stage, and is kept private from the parties
(via use of secret sharing).
Although we now handle a reactive functionality, we stress that
the cash that is deposited at the beginning of the protocol is dis-
tributed only at the end (i.e., no cash distribution occurs in any
intermediate stage). That is, secure cash distribution provides a
means to keep the cash deposited in escrow while parties’ learn
output from each stage’s function evaluation, and thus can revise
their inputs to a later stage. The capability to maintain an escrow
turns out to be crucial in enabling the applications we are interested
in.
We now proceed to the formal details. Let d? = (d?1, . . . , d
?
n)
be the initial cash deposit from the parties, i.e., party Pi deposits
coins(d?i ) into the computation. Then at the end of the protocol
all the deposited coins, i.e., coins(
∑
i∈[n] d
?
i ), are distributed back
to the parties according to the evaluation of the reactive function-
ality F on the parties’ inputs. More precisely, let zρ denote the
parties’ output at the end of the last stage of the computation. We
assume that zρ specifies how the coins are (re)distributed at the
end of the entire computation. That is, we can parse zρ = (z =
(z1, . . . , zn), z
? = (z?1 , . . . , z
?
n)) where zi represents the parties’
output, and z?i represents the amount of cash that Pi is supposed to
get back. We are now ready to define bounded zero-sum reactive
distribution.
Definition 2 (Bounded zero-sum reactive distribution). For all ` ∈
[ρ], let fi : ({0, 1}∗)n × {0, 1}∗ → ({0, 1}∗)n × {0, 1}∗ be a
function. Let d? = (d?1, . . . , d
?
n) ∈ Nn be a vector. We say that
(F = (f1, . . . , fρ), d
?) is a bounded zero-sum reactive distribution
if ∀ x1, . . . , xρ ∈ ({0, 1}∗)n it holds that the value zρ = ((z1, . . . ,
zn), (z
?
1 , . . . , z
?
n)) ∈ ({0, 1}∗)n×Nn obtained from the sequence:
(z1, state1)← f1(x1;NULL);
(z2, state2)← f2(x2; state1);
...
(zρ, stateρ)← fρ(xρ; stateρ−1),
satisfies
∑
i z
?
i =
∑
i d
?
i . ♦
Observation 1. The coins earned by Pi, namely z?i may be such
that z?i > d?i (e.g., when F represents the lottery functionality [4,
10]). To simplify exposition, we make use of a “helper” function
g which on input (d?, z?) returns a matrix A whose (i, j)-th entry
denoted ai,j specifies the amount of coins that need to be trans-
ferred from Pi to Pj . In particular, it must hold for all i ∈ [n] that∑
j∈[n] ai,j = d?i , and for all j ∈ [n] that
∑
i∈[n] ai,j = z?j . Ob-
serve that it is easy to design g for a zero-sum distribution (F, d?).
Next we formally define F?F,d? which idealizes SCD.
Ideal functionality F?F,d? . See Figure 2 for the formal defnition.
In an initial cash deposit phase, the functionality F?F,d? receives
coins(d + d?r) from each honest Pr , where d represents a param-
eterizable safety deposit and d?r represents the cash that will be
stored in escrow. In addition, F?F,d? allows the ideal world adver-
sary S to deposit some coins which may be used to compensate
honest parties if S aborts after receiving the outputs. If there is an
abort at this stage, that is, S does not submit the necessary amount
of cash then the protocol terminates, and the honest parties get their
deposit back. Note that at this stage there is no penalty for aborts;
the penalties enter the picture only after this stage. Once the de-
posit phase ends, parties enter the computation phase. In the `-th
stage of the computation phase, the honest parties supply their in-
puts to `-th stage of the computation. The functionality then waits
to receive corrupt parties’ inputs for this stage. If S aborts at this
stage, then the honest parties receive coins(q) penalty in addition to
getting their deposit coins(d) back (and may also obtain some extra
coins(qr)), and the computation phase is terminated. Now honest
parties receive the amount that they deposited at the beginning of
the protocol in the cash distribution phase. However, if S does con-
tinue (i.e., provide inputs to this stage), then the functionality com-
putes the output of the `-th stage. Now the simulator gets a chance
to look at the output first, and then decide if it wants to continue
or not. If it decides to continue then the honest parties receive the
output as well, and proceed to the next stage of the computation.
198
Let (F = (f1, . . . , fn), d
? = (d?1, . . . , d
?
n)) be a bounded
zero-sum reactive distribution (cf. Definition 2). F?F,d? with
session identifier sid running with parties P1, . . . , Pn, a pa-
rameter 1λ, and an ideal adversary S that corrupts parties
{Ps}s∈C proceeds as follows: Let H = [n] \C and h = |H|.
Let d represent the safety deposit, and let q denote the penalty
amount. Initialize state0 := NULL and flag = 1.
• Deposit phase: Wait to receive a message (deposit, sid,
ssid, r, d?, coins(d+d?r)) from Pr for all r ∈ H . Then wait
to receive (deposit, sid, ssid, d?, coins(hq +
∑
s∈C d
?
s))
from S.
• Computation phase: For each ` = 1, . . . , ρ, do:
– Wait to receive a message (input, sid, ssid, r, x`,r) from
Pr for all r ∈ H .
– If S sends (abort, sid, ssid, {coins(qr)}r∈H), send
(penalty, sid, ssid, coins(q + qr)) to Pr for all r ∈ H ,
send (payback, sid, ssid, coins(
∑
s∈C d
?
s −
∑
r∈H qr))
to S, set flag = 0, and terminate phase.
– Else if S sends (input, sid, ssid, {x`,s}s∈C), set x` =
(x`,1, . . . , x`,n).
– Compute (z`, state`)← f`(x`; state`−1), and parse z` to
obtain (z`,1, . . . , z`,n).
– Send (output, sid, ssid, {zs,`}s∈C) to S.
– If S returns (continue, sid, ssid), then send (output, sid,
ssid, z`,r) to Pr for all r ∈ H .
– Else if S sends (abort, sid, ssid, {coins(qr)}r∈H), send
(penalty, sid, ssid, coins(q + qr)) to Pr for all r ∈ H ,
send (payback, sid, ssid, coins(
∑
s∈C d
?
s −
∑
r∈H qr))
to S, set flag = 0, and terminate phase.
• Distribution phase: If flag = 0, send (return, sid, ssid,
coins(d + d?r)) to Pr for all r ∈ H , and terminate. Else,
parse zρ to obtain z? = (z?1 , . . . , z
?
n), and send (pay, sid,
ssid, z?, coins(d+ z?r )) to Pr for all r ∈ H , and send (pay,
sid, ssid, z?, coins(hq +
∑
s∈C z
?
s )) to S.
Figure 2: Secure cash distribution with penalties F?F,d? .
On the other hand, if S decides to abort, then the honest parties get
compensated as before, i.e., with coins(d+d?r+q+qr) in total, and
the protocol is terminated. The computation phase terminates after
the ρ-th stage ends. Note that upon successful completion of the
ρ-th stage, all parties receive their final outputs. After this, parties
enter the cash distribution phase; the cash is distributed according
to the output of the ρ-th stage, i.e., zρ. The functionality parses zρ
to obtain z? which dictates how the cash is distributed among the
parties. Using z?, the functionality distributes the cash among the
parties, and returns their original deposits as well. In addition, the
functionality also sends the value z? to all parties, i.e., the way the
cash gets distributed at the end is not private.
How to use F?F,d? to implement poker. We now describe a naïve
implementation of how to play poker hand via F?F,d? . (In Sec-
tion 6 we provide an optimized poker protocol.) We assume that
there is a bound on the maximum number of betting stages within
a single hand. Players start the protocol by depositing their “chips”
or equivalently cash to F?F,d? . This ends the deposit phase. Now
players supply inputs to the first stage function whose purpose is
to deal players’ hole cards. They do this by each picking uniform
random string and sending it to F?F,d? . That is player Pi picks
and sends r̃i to F?F,d? . Then F?F,d? computes f1(r̃1, . . . , r̃n) in
the following way: first compute r̃ =
⊕n
i=1r̃i (note: no coalition
of malicious players can influence r̃i in any way), then interpret
uniform random string r̃ in a natural way to generate players’ hole
cards as well as the community cards. This value r̃ is then saved
to the private state. Now note that any player that aborts with-
out supplying r̃i pays a penalty to every honest player. Otherwise,
players get their hole cards (the community cards still remain hid-
den), and can start to place bets. Again note that any player that
aborts after seeing its hole cards pays a penalty to every honest
player. Each move by a single player is considered as a computa-
tion stage. In the stage corresponding to player Pi’s turn, Pi simply
submits its next move (e.g., “match,” “fold,” “raise by $1”) as the
input to the stage. (Other players have no inputs to this stage.)
Then the stage computation is simply to append player Pi’s move
to the saved transcript of bets made so far (i.e., the state of the pre-
vious stage), and then send Pi’s move to all players. It is possible
that a player Pi submits an illegal move (i.e., inconsistent with the
transcript, or simply overbets) in which case the last stage compu-
tation will reconstruct an illegal transcript, and ensure that the cash
distribution phase compensates every honest party with coins(q).
Note that players never submit any additional coins (other than at
the beginning, i.e., the deposit phase). In the stage corresponding
to revealing community cards (say after the last player has placed
its bet), the stage function simply uses r̃ to regenerate the commu-
nity cards that need to be revealed, and additionally broadcasts the
last player’s move. Again a player that aborts after seeing the com-
munity cards pays a penalty to every honest player. Players keep
continuing to make their moves during their turn until it’s time for
the last move to be made. Once this move is made, F?F,d? first de-
termines the pot (using the bets made in the game that can be found
in the saved state containing the transcript), and then send the pot
earnings to the winner(s), and the remaining cash (from that de-
posited initially) back to the players. To play the next hand, players
execute the above all over again.
It is instructive to note why just secure computation with penal-
ties does not seem powerful enough to implement poker. Note that
secure computation with penalties can indeed implement each stage
of the computation. At first glance chaining them together seems
to solve the problem. However, this is an incorrect approach since
there is no way to force players’ to continue to the next stage (in
particular to supply inputs to the next stage). Indeed, the only guar-
antees that we get from such an approach is that malicious play-
ers who learn the output of a stage of computation cannot prevent
honest parties from learning the same (except by paying a penalty).
This is not enough to satisfy the notion of dropout tolerance that we
desire since a player may dropout in the middle of a hand without
getting penalized.
4. REALIZING SCD
In this section we provide the blueprint of our protocol that realizes
secure cash distribution with penalties. As we will see soon, our
general strategy is to use a protocol that securely realizes a standard
reactive functionality (with no coins, and unfair abort), denoted
FF , to set things up such that the see-saw transaction mechanism
of Section 5 applies to ensure that either the protocol is completed
until the very end or all honest parties get compensated. Then, to
make the final transfers between parties we will make use of a cash
distribution mechanism that we describe later in this section.
To simplify the presentation of our protocol, we consider the case
when there is only a single stage in the computation, i.e., ρ = 1 and
F = f . Essentially we are dealing with secure function evaluation
199
but with an important difference: namely, aborts anywhere during
the computation (i.e., not only at the output delivery step) will be
penalized. The extension to multiple stages is straightforward and
we describe it later.
First let us set up some notation. We say (r, i) > (r′, i′) iff either
(1) r > r′, or (2) r = r′ and i > i′. For (r, i), let pred(r, i) be
(r′, i′) such that for every (r′′, i′′) it holds that (r′′, i′′) < (r, i) iff
(r′′, i′′) ≤ (r′, i′). In other words, pred(r, i) is the “predecessor”
of (r, i). Let πf be am-round protocol that realizes function f . For
each i ∈ [n], let xi denote party Pi’s input to f . We assume that
in each round of the protocol, parties take turns to broadcast their
message, i.e., the entire protocol transcript is public.1 Let TT
πf
r,i
denote the transcript of protocol πf up until party Pi’s message in
the r-th round. Let nmfr,i denote the next message function for
party Pi in round r. The function nmfr,i takes as input the actual
input xi, the private randomness of party Pi, denoted ωi, and the
public transcript seen so far, i.e., TT
πf
pred(r,i). In other words, we
have that TT
πf
r,i ← nmfr,i(TT
πf
pred(r,i); (xi, ωi)) (i.e., nmfr,i outputs
the entire transcript so far). Also, since all messages are public
broadcasts, there exists a function tv
πf
r,i which checks if a given
transcript TTr,i (that contains all messages until and including party
Pi’s message in round r) is valid or not. By definition, we have
that tv
πf
r,i (TT
πf
r,i ) = 1. For simplicity and wlog, we assume that all
messages (i.e., transcripts) broadcasted are signed by the sending
party. This implies that the function tv that checks validity of the
transcript also checks for the necessary signatures.
Our strategy is to force each party Pi to deliver its round r
message during its turn. That is, first, we want party P1 to ei-
ther reveal its first round message TT
πf
1,1 to all parties, or pay a
penalty to all parties. If P1 revealed TT
πf
1,1, then P2 can apply
nmf1,2(TT
πf
1,1; (x2, ω2)) to obtain TT
πf
1,2. Now we want P2 to ei-
ther reveal TT
πf
1,2 to all parties or otherwise pay a penalty to all
parties. This way, we want to force every party to either make its
move or pay a penalty. If we implement this strategy successfully,
then we have ensured that each party either learned its output, or is
compensated with a penalty. (Note that cash distribution at the end
still needs to be handled.) Designing a transaction mechanism for
implementing the above strategy is one of the main contributions in
this paper. We defer the presentation of the transaction mechanism
to Section 5, and devote the rest of this section to handling other
issues.
Handling multiple valid transcripts. In an actual implementation
of the above strategy in the F?CR-hybrid model, we will have par-
ties receive multiple F?CR transactions from other parties that can
be claimed if they produce a valid transcript. It is possible that
a malicious party may claim a subset of these F?CR transactions
using one valid transcript and a different subset using a different
valid transcript. Such an “attack” may indeed be possible by vary-
ing the actual input and private randomness input to the next mes-
sage function. Indeed malicious coalitions of k consecutive parties
can potentially change the last k messages in the transcript (since
they possess the required signing keys to do this). In applications
to poker, a player (admittedly a novice) may leak an “expression
of surprise” upon seeing a (malicious) player’s “confirmed” move,
only to see this move modified by the next (malicious) player. In
any case, we consider such attacks as violations, and must compen-
sate the honest parties upon such violations. Note that a “proof” of
1That is, all messages exchanged in the protocol are simply broad-
casts. Protocols secure against dishonest majority typically fall un-
der this category. For an explicity example, see the main construc-
tion in [21, 3]. See also the discussion in [22].
any such violation is readily obtained from the inconsistent tran-
scripts. We ask each party Pi to make F?CR transactions to ev-
ery other party that can be claimed by revealing a proof of viola-
tion: i.e., pair of transcripts T vio
i = (TTi, TT′i) such that for some
r ∈ [m], it holds that tv
πf
r,i (TTi) = tv
πf
r,i (TT′i) and yet TTi 6= TT′i.
Since transcripts are signed, a proof of violation against an honest
party can never be obtained (except with negligible probability).
Following the notation in [10], we use P1
T−−→
q,τ
P2 to denote an
F?CR transaction for coins(q) made byP1 that can be claimed byP2
if P2 produces witness T within time τ . Thus to safeguard against
violations we ask each Pi to make the following set of transactions
for each j ∈ [n] \ {i}:
Pi
T vio
i−−−−−−−−−−−−−−→
n·q,τ
Pj (Txvio
i,j)
Here τ is such that the transaction can be claimed until the end
of the protocol. Note that the transaction if claimed will transfer
coins(n ·q) from the violating party Pi. This is because, upon such
a violation an honest Pj will be asked to abort the rest of the proto-
col and directly claim Txvio
i,j where Pi is the violating party. Since
Pj aborts the rest of the protocol, it may be forced to pay a to-
tal compensation of coins((n−1)q) to the remaining parties. Thus
upon any violation by malicious parties, we ensure that each honest
Pj will still be coins(q) up at the end of the protocol execution.
Handling multiple stages of computation. At an abstract level,
adding stages to a reactive computation merely amounts to adding
more “next messages” to the transcript. Indeed an intermediate
stage of computation simply begins by reconstructing the current
state, and then performing the computation on this state and the
current inputs. Thus it is trivial to merge multiple stages of com-
putation into a single stage—simply append the protocol messages
of the multiple stages together. Since our strategy works by keep-
ing track of the protocol transcript, it ensures that an abort at any
round/stage of a multi-stage computation will be penalized.
Handling the cash distribution. To do this, we first need parties
to make deposits at the beginning of the protocol that will allow
them to claim their returns at the end of the protocol. Note that
parties might have to transfer an arbitrary amount of coins between
themselves. Adopting an idea from [9], we ask parties to commit
to money transfers for all powers of 2 up to the maximum possible
sum. In more detail, let d? = (d?1, . . . , d
?
n), and for each i ∈ [n], let
mi = dlog(d?i )e. The high level idea is to have, for every ordered
pair (i, j) with i, j ∈ [n] and i 6= j, and for each k ∈ [mi], party
Pi make an F?CR transaction as follows:
Pi
T fin
i,j,k−−−−−−−−−−−−−−−−−−−→
2k,τfin
Pj (Txfin
i,j,k)
Given these transactions, it is easy to see that Pj can claim any
arbitrary amount of coins from the rest of the parties. Also, we need
to ensure that Pj obtains exactly the correct amount of coins. That
is, suppose the output of the reactive computation is zρ = (z, z?)
with z? = (z?1 , . . . , z
?
n), then we want Pj to obtain coins(z?j ) at
the end of the protocol. In other words, we need to provide Pj with
the right subset of {T fin
i,j,k}i,k that will allow it to claim exactly
coins(z?j ). This subset will obviously need to be transferred in the
last computation stage fρ. To make sure the deposits are made at
the very beginning, the parties need to know the corresponding ver-
ification circuits φfin
i,j,k at the beginning as well. To design the ver-
ification circuits, we employ honest binding commitments [22, 10]
(See also Appendix A). Let (S,R) be a honest binding commitment
scheme. (Note that such commitment schemes can be realized by
cryptographic hash functions in the programmable random oracle
200
model.) More precisely we require parties to execute a standard,
secure-with-abort MPC protocol at the very beginning that for all
i ∈ [n], j ∈ [n] \ {i}, k ∈ [mi]:
• chooses T fin
i,j,k ← {0, 1}λ and ωfin
i,j,k ← {0, 1}λ at random;
• computes comfin
i,j,k ← S(1λ, T fin
i,j,k, ω
fin
i,j,k);
• n-out-of-n secret shares each (T fin
i,j,k, ω
fin
i,j,k);
• outputs comfin
i,j,k and `-th share of (T fin
i,j,k, ω
fin
i,j,k) to P`.
The secret sharing is done so that parties can reconstruct the
T fin
i,j,k values (saved as part of the state) at the beginning of the
last stage of the computation. Note that now parties possess the
verification circuits φfin
i,j,k to make the transaction Txfin
i,j,k. Next we
describe the modification to the last stage. Instead of realizing fρ
in the last stage, parties realize f ′ρ which:
• computes z? = (z?1 , . . . , z
?
n) by invoking fρ;
• computes A = g(d?, z?) (cf. Observation 1), let ai,j denote the
(i, j)-th entry of matrixA, and let b?i,j,1, ..., b
?
i,j,mi
be the binary
representation of ai,j ;
• for all i ∈ [n], j ∈ [n] \ {i}, k ∈ [mi]:
reconstructs T fin
i,j,k (from stateρ−1);
outputs T fin
i,j,k if b?i,j,k = 1, else outputs 0.
Given the above it is easy to see that the set of transactions
{Txfin
i,j,k} transfer the right amounts of money according to the
output z?. Next we show how to design the see-saw transaction
mechanism that implements our strategy of forcing parties to send
the next message of the protocol realizing FF .
5. SEE-SAW MECHANISM
Recall that our goal is to force parties to reveal their next message
of say am-round protocol for computing function f , one-by-one in
a round-robin fashion round after round. That is, partyP1 first com-
putes and reveals “token” T1,1 = TT
πf
1,1, then party P2 computes
(using T1,1) and reveals token T1,2 = TT
πf
1,2, and so on until party
Pn computes and reveals token T1,n = TT
πf
1,n. (Note that the order
of revelations is important.) Following this, parties move on to the
next round, and so on and so forth until at the end Pn reveals token
Tm,n = TT
πf
m,n. What we need is a transaction mechanism that
incentivizes parties to follow the above sequence of reveals. More
precisely for every i ∈ [n], r ∈ [m], we force Pi to pay a penalty to
all other parties if (a) all parties P1, . . . , Pn revealed their tokens
until round r−1; and (b) in round r parties P1, . . . , Pi−1, revealed
their tokens; and (c) in round r party Pi did not reveal Tr,i.
Towards solving this problem, we let parties participate in a ini-
tial deposit phase where parties make some sequence of transac-
tions. We are lenient towards any aborts during this initial deposit
phase, i.e., we do not penalize any party for an abort during this de-
posit phase. However once this deposit phase ends, then we enter
the reveal phase. Any party that deviates during its turn in any of
the m rounds in the reveal phase has to pay a penalty to all the re-
maining parties. Contrast this with the “ladder mechanism” of [10],
where a party that aborts without learning the final output may not
necessarily pay penalties to all parties.
Honest parties’ strategy. As mentioned earlier, our protocol will
be an ordered sequence of claim-or-refund transactions. In an hon-
est execution of our protocol, all deposits will be made first before
any of them is claimed. Also, the sequence deposits will be claimed
in the reverse order in which they are made. Note that a malicious
party may abort the protocol either (1) by not making a deposit it
was supposed to make, or (2) by not claiming a deposit it could
have claimed. The following two rules of thumb may be kept in
mind to understand how honest parties behave in the event of such
aborts.
1. When it’s an honest party’s turn to make a deposit, it makes the
deposit if and only if all the deposits that were supposed to made
before its deposit were made. That is, if a malicious party does
not make a deposit during its turn, then no honest party makes
any subsequent deposit in the protocol.
2. When it’s an honest party’s turn to make a claim, it makes the
claim if it possesses all the witnesses necessary for making the
claim. That is, an honest party may go ahead and claim a deposit
even if (1) some deposits were not made, and (2) some claims
were not made.
Two simplifying assumptions. The first is that our constructions
will try to penalize deviations of party Pi in round r only when
(r, i) 6= (1, 1). Later in this section, we show how to handle the
“bootstrapping” step of forcing P1 to start the protocol. The second
is that we assume parties can use only unique witnesses to claim
F?CR transactions. In our constructions, the witnesses correspond to
protocol transcripts, and we already discussed in the previous sec-
tion how to handle the case when parties broadcast multiple valid
transcripts.
We construct our final protocol in a step-by-step manner. We
start with n = 2 and m = 1.
Single-round two-party case. Since we are in the single-round
case we use Ti to denote the token T1,i. Consider the following
sequence of deposit transactions where τ2 > τ1:
P1
T1∧T2−−−−−−−−−−−→
q,τ2
P2 (Tx2)
P2
T1−−−−−−−−→
q,τ1
P1 (Tx1)
Note that the verification circuits for these transactions are sim-
ply the corresponding transcript checking functions tv
πf
r,i , and are
already known to the parties, and thus the deposits can be made.
Once all the deposits are made, the deposits are claimed in reverse.
That is, P1 first claims Tx1. Using T1 revealed by P1, party P2
is able to claim Tx2. We first consider aborts during the initial
deposit phase. If P1 aborts without making Tx2, then clearly no
money changes hands and we are good. Now if P2 aborts without
making Tx1, then note that P1 does not enter the reveal phase, and
so does not reveal T1. This in turn ensures that P2 will not be able
to claim Tx2, and thus no money changes hands, and we are good.
These attacks imply that we do not even get past the initial deposit
phase (meaning that we are not required to penalize any party).
Next, we consider aborts during the reveal phase. Recall that
once we enter the reveal phase, then we must penalize P2 if P1
revealed T1 but P2 did not reveal T2. First suppose P1 aborts, i.e.,
does not claim Tx1. Then note that Tx1 gets refunded back to P2,
and no party is penalized. Note that if P1 does claim Tx1, then
P2 is able to claim Tx2, and the parties even out as well as obtain
both T1 and T2. Next, we consider the case when P2 aborts the
protocol, i.e., does not claim Tx2. In this case, Tx2 gets refunded
back to P1. Also, P1 would have already gained coins(q) after
claiming Tx1 and hence is compensated at the end of the protocol.
We use the following notation to simplify the presentation: for
r ∈ [m], let TTr = ∧rs=1(Ts,1 ∧ · · · ∧ Ts,n), and for i ∈ [n] and
r ∈ [m], let TTr,i = TTr−1 ∧ (∧ij=1Tr,j). (Here TT stands for
“transcript.”) Also, let “(r′, i′) > (r, i)” if either (1) r′ > r, or (2)
r′ = r and i′ > i.
201
ROOF DEPOSIT.
P1
TTm,2−−−−−−−−−−−→
q,τm,2
P2 (Txm,2)
SEE-SAW DEPOSITS. For r = m− 1 to 1:
P2
TTr+1,1−−−−−−−−−−−−→
2q,τr+1,1
P1 (Txr+1,1)
P1
TTr,2−−−−−−−−−−→
2q,τr,2
P2 (Txr,2)
FLOOR DEPOSIT.
P2
TT1,1−−−−−−−−−−→
q,τ1,1
P1 (Tx1,1)
Figure 3: Multi-round two party see-saw mechanism.
Multi-round two-party see-saw mechanism. The sequence of
transactions is shown in Figure 3 where τr′,i′ > τr,i iff (r′, i′) >
(r, i). As in the single-round case, the reveals are made in re-
verse: namely, P1 first claims Tx1,1. Using TT1,1 = T1,1 re-
vealed by P1, party P2 is now able to claim Tx1,2 by revealing
TT1,2 = T1,1 ∧ T1,2. Likewise parties P1 and P2 take turns claim-
ing each others’ F?CR transactions.
We first consider aborts during the initial deposit phase. Sup-
pose Pi aborts without making Txr,j for j 6= i and some r. First,
this ensures that (1) Pj does not make Txr′,i for (r′, i) < (r, j),
and (2) Pj will never reveal Tr,j (since Tr,j needs to be revealed
only to claim Txr′,i′ for (r′, i′) ≥ (r, j)), and (3) no party can
claim Txr′,i′ for (r′, i′) ≥ (r, j) (since Tr,j is necessary to claim
Txr′,i′ ), and (4) all the deposits Txr′,i′ for (r′, i′) > (r, i) (i.e.,
those that were made so far) will get automatically refunded after
τr′,i′ (since Tr,j is need to claim this, but is never revealed by Pj).
Thus in such a situation neither party stands to gain or lose coins.
Next, we discuss aborts by parties in the reveal phase.
First suppose P1 aborts without claiming Tx1,1. In this case,
dishonest P1 will never obtain T1,2. This is because P2 would not
have obtained T1,1 from P1, and hence cannot claim Tx1,2. Now
note that all deposits Txr,i for (r, i) ≥ (1, 2) require T1,2, and
hence none of these deposits can be claimed. Thus we have that
neither party stands to lose or gain coins. Recall that this corre-
sponds to the case where the reveal phase hasn’t started yet, and so
parties don’t get penalized yet.
Recall that once the reveal phase starts, we must penalize every
party that did not reveal its token during its turn. Suppose P1 does
claim Tx1,1 (i.e., the reveal phase has started). Then in this case,
P2 is down coins(q) while P1 is up coins(q). If P2 aborts at this
stage, then essentially P2 has compensated P1 with coins(q). On
the other hand if P2 claims Tx1,2, then note that it gets coins(2q)
from that claim. Thus, it is now coins(q) up while P1 is down
coins(q). It is easy to see that as the remaining claims are made,
parties take turns going up and down coins(q) (hence the name
“see-saw”). Thus we have the property that whenever a party Pi
claims Txr,i (except for (r, i) = (m, 2)), it gains coins(q) while
the other party loses coins(q). This incentivizes the other party
to go ahead and claim F?CR transaction immediately above Txr,i,
say Txr′,i′ . Indeed if the other party does not make the claim,
then we have that the honest party (i.e., Pi) is compensated with
coins(q) at the end of the protocol. This is because if Txr′,i′ is not
claimed, then either (1) (r′, i′) = (m, 2), and this case Pi does
not lose coins from this transaction, and simply ends the protocol
with coins(q) as compensation, or (2) (r′, i′) 6= (m, 2), in which
case Pi will never reveal Tr+1,i thus making it impossible for any
Txr′′,i′′ to be claimed for any (r′′, i′′) ≥ (r+1, i), essentially en-
suring that no further money transfers happen, and that Pi can end
the protocol with coins(q) as compensation. Finally, in an honest
execution, when P2 claims the last transaction Txm,2 it gets only
coins(q) from that claim, and thus in this case both parties even
out.
Multiparty locked ladder mechanism. Generalizing the two
party solution is nontrivial. To better understand the complications
we will first look a naïve 3-party protocol.
Naïve single-round 3-party case. The high level idea is to try and
ensure that all parties are already compensated by Pi just before
the step where party Pi is required to reveal Ti. Then after Pi is
supposed to reveal Ti, we get the compensation that was delivered
to the parties back to Pi. (Observe that we do not need to apply the
above strategy for i = 1.) Consider the following implementation
of the above strategy:
ROOF DEPOSITS. For j ∈ {1, 2}:
Pj
TT3−−−−−−−−−−−−−−→
q,τ3,j
P3
THIRD STAGE DEPOSITS.
P3
TT2−−−−−−−−−−−−−−→
3q,τ2,3
P2
SECOND STAGE DEPOSITS.
P2
TT1−−−−−−−−−−−−−−→
q,τ3,2
P3
FIRST STAGE DEPOSITS.
P2
TT1−−−−−−−−−−−−−−→
q,τ1,2
P1
To see why the above may be a faithful implementation of the
strategy, note that the end of the first two deposit stages, P2 has
already compensated both P1 and P3 with coins(q), i.e., P2 has lost
coins(2q). Then, in the third stage, it claims coins(3q) from P3 by
revealing T2. This is effectively equivalent to P3 compensating P2
with coins(q), and learning T1 and T2. That is, at the end of the
third stage, it is P3’s turn to reveal T3, and both P1 and P2 have
already been compensated with coins(q) by P3. Then, in the roof
stage, P3 claims back coins(q) from both P1 and P2 by revealing
T3 (along with T1, T2), and thus all parties even out.
The problem with the above scheme is that it is not resistant to a
“coalition attack.” Consider a malicious P2 that does not make the
first and second stage deposits. Recall that the roof deposits and
the third stage deposits have already been made. Now a malicious
coalition of P1 and P2 possesses both T1 and T2, i.e., TT2 and can
claim the third stage deposit of coins(3q). While P3 can use TT2
to claim the roof deposits, and learn all the tokens, it does so at an
expense of coins(q) (i.e., it claims coins(2q) from the roof deposits
but has lost coins(3q) in the third stage deposits). This is clearly an
undesirable situation as the honest party has lost coins(q).
To avoid the “coalition attack,” we now introduce two new ideas
that will help us construct our multiparty protocol. The first idea
is a locking mechanism that prevents the collusion attack that we
just described on our naïve 3-party protocol. The second is an in-
tegration of the first idea with the ladder mechanism of [10] which
allows transitions between different stages of the protocol. We ex-
plain these two ideas below.
Locking mechanism. Recall that the high level idea in our naïve
3-party protocol was to ensure that all parties are already compen-
sated by Pi just before the step where party Pi is required to reveal
202
Ti. Then after Pi reveals Ti, we get the compensation that was
delivered to the parties back to Pi. That is, we have a set of trans-
actions S+i where Pi claims coins(q) each from a set of parties,
followed by a set of transactions S−i where the same set of parties
each claim coins(q) from Pi. (Recall that transactions in S−i are
claimed first, which forces Pi to reveal Ti and claim transactions in
S+i.)
The general form of the attack on the naïve protocol is that Pi
aborts when it has to make transactions in S−i. Then colluding
with parties P1, . . . , Pi−1, party Pi starts claiming transactions in
S+i. This allows Pi to unfairly obtain additional coins from parties
Pi+1, . . . , Pn while ensuring that they are unable to claim deposits
in S−i.
The main idea that we use to prevent such attacks is to “lock”
transactions in S+i such that they can be “unlocked” and claimed
only if the transactions in S−i were already claimed. To do this,
we make use of “dummy tokens” Ui,j that will be used by Pj (and
known only to Pj) to lock transactions in S+i. (We will generate
these dummy token via an initial MPC protocol. A similar strategy
is used to “bootstrap” the computation, and we defer details until
then.) More concretely, to claim the transaction from Pj in S+i,
party Pi needs to produce Ui,j in addition to TTi. Then to enable
an honest Pi to claim transactions in S+i, we let party Pj to claim
transactions in S−i only if it produces Ui,j in addition to TTi−1.
Ladder mechanism. While the above locking mechanism deals with
aborts in the deposit phase, we must obviously be wary of aborts
in the reveal phase. Indeed, it turns out that the locking mecha-
nism alone does not suffice. To see why, watch what happens when
it is (honest) Pi’s turn to reveal the witness, and yet none of the
parties claim transactions in S−i thus disabling Pi from revealing
its token. In effect, all parties other than Pi have aborted, and yet
Pi does not receive any compensation, thus violating our require-
ments. For a more concrete example of what we refer to as the
“locked-out attack,” consider the naïve 3-party protocol enhanced
with the locking mechanism (i.e., both second stage as well as the
third stage deposits are locked). Now P1 claims the first stage de-
posit, and after that P3 simply aborts without claiming the sec-
ond stage locked transaction. This will disallow P2 from claiming
the third stage deposit as it remains locked. Thus, essentially P3
aborted the protocol, and yet P2 does not gain coins(q) (in fact, it
loses coins(q) here).
The above attack naturally leads us to include a F?CR transaction
to Pi that can be claimed just by revealing TTi, i.e., it is essen-
tially an unlocked transaction. What the above would ensure is that
Pi will never be stranded in a situation where it wishes to reveal
its token, and yet is unable to claim any transactions. While the
above is true, unfortunately if we include unlocked F?CR transac-
tions from each Pj to Pi (i.e., those that can be claimed just using
TTi), then we have negated the locking mechanism, and are back to
square one. Thus, what we want to do is to give a chance to Pi to
avoid the “locked-out attack” while at the same time preventing the
“coalition attack.” To do this, we let only Pi+1 make an unlocked
F?CR transaction to Pi that can be claimed by revealing just TTi.
In some sense, this breaks the symmetry of the protocol, but it also
gives us a chance to make use of the ladder mechanism of [10].
That is, following [10], we let Pi+1 make an unlocked F?CR trans-
action to Pi for coins(i · q) that can be claimed by revealing TTi.
We present our protocol in Figure 4.
At a high level, the protocol proceeds by getting a roof deposit
from each of the parties to Pn that can be claimed if Pn produces
TTn. Next, we enter the ladder deposits for each i = n − 1 down
to 2 (note the order is important), where party Pi receives a de-
posit that is locked with token Ui,j from each party Pj for j > i
ROOF DEPOSITS. For each j ∈ [n− 1]:
Pj
TTn−−−−−−−−−−−−−−−−−→
q,τ2n−2
Pn
LADDER DEPOSITS. For i = n− 1 down to 2:
• Rung unlock: For j = n down to i+ 1:
Pj
TTi∧Ui,j−−−−−−−−−−−−−−−−−→
q,τ2i−1
Pi
• Rung climb:
Pi+1
TTi−−−−−−−−−−−−−−−−−→
i·q,τ2i−2
Pi
• Rung lock: For each j = n down to i+ 1:
Pi
TTi−1∧Ui,j−−−−−−−−−−−−−−−−−−−→
q,τ2i−2
Pj
FOOT DEPOSIT.
P2
TT1−−−−−−−−−−−−−−−−−→
q,τ1
P1
Figure 4: Locked ladder mechanism.
(these correspond to S+i), an unlocked deposit from Pi+1 that can
be claimed if Pi reveals TTi, and makes deposits to Pj for j > i
that are locked with Ui,j (these correspond to S−i). Note that de-
posits in S−i can be claimed with TTi−1 (in addition to Ui,j), and
that deposits in S+i can be claimed with TTi (in addition to Ui,j).
Finally, we have the foot deposit (essentially foot of the ladder that
involves P1) where P2 makes a deposit to P1 that can be claimed
with T1.
As usual these deposits will be claimed in reverse. That is, P1
first claims the floor deposit by revealing T1. Then parties enter the
ladder reveal phase. As in [10], the parties metaphorically climb
the ladder as they take turns claiming the ladder deposits. The dif-
ference from [10] is that before climbing a rung of the ladder, par-
ties first do a “rung lock” step, and after they climb the rung, they
perform a “rung unlock” step. Hence, while the protocol is being
executed, Pi first pays the parties above it (who haven’t “played”
yet), but Pi will then immediately be able to “play” by extending
TTi−1 and thereby reclaim these coins that it paid, thus avoiding
the locked-out and coalition attacks.
As in the ladder mechanism of [10], once the i-th ladder deposit
is claimed, parties P1 through Pi become “inactive” in the sense
that they no longer claim any deposits and nor are any of their lad-
der deposits remain unclaimed. (In fact their only unclaimed de-
posits are those that are part of the roof deposits.) It is easy to see
that the “inactive” parties are always coins(q) up after the i-th lad-
der rung unlock deposits are claimed, and that they remain coins(q)
up until the beginning of roof claims. As it turns out, the lock and
ladder mechanisms are sufficient to deal with aborts in the deposit
and reveal phases, respectively.
Multiparty see-saw mechanism. Our idea is to mimic the two-
party see-saw mechanism. That is, all we need to do is to ensure
that the end of each of the m rounds, party P1 has already com-
203
pensated coins(q) to every other party, and is thus incentivized to
send the first token for the next round. This is quite straightfor-
ward to implement. For every round we invoke an instance of the
single-round locked ladder mechanism (with the transcript verifi-
cation circuits corresponding to the round of the protocol). These
instances are invoked sequentially, and thus the timelocks have to
be set accordingly.
Recall that at the end of the reveal phase of every instance of the
locked ladder mechanism, parties have either already been com-
pensated, or they learn all the protocol messages for the round, and
are all evened out w.r.t. deposits. Then to apply the see-saw idea,
we need to introduce new “chain” deposits between successive in-
stances of the locked ladder mechanism.
CHAIN DEPOSITS.
• For j = 2 to n:
Pj
TTr+1,1−−−−−−−−−−−−−−−−−→
q,τr+1,1
P1 (Txchain
j,1 )
• For j = 2 to n:
P1
TTr,n−−−−−−−−−−−−−−−→
q,τr+1,1
Pj (Txchain
1,j )
Remark. Note that solving the single-round multiparty case yields
a solution to the multi-round multiparty case as well. To see why,
let us denote the problem for the m-round n-party case by LLm,n.
Then the problem LLm,n is obtained by simply “folding” LL1,nm.
That is, for i ∈ [nm], interpret Pi’s move in LL1,nm as Pi mod n’s
move in the (bi/nc + 1)-th round of LLm,n. The key observa-
tion behind why this transformation is secure is that any protocol π
solving LL1,nm is resistant to malicious coalitions of any subset of
nm parties, and therefore, the “folded” m-round n-party protocol
obtained from π is also resistant to any coalitions of subset of the
n parties. Since the protocol in Figure 4 solves the single-round
multiparty case, we trivially obtain the multi-round multiparty so-
lution.
However note that the efficiency of such a solution obtained for
the m-round two-party case i.e., for LLm,2 by using the 2m-party
locked ladder mechanism, has worse efficiency than the two-party
see-saw protocol from Figure 3. While the see-saw protocol re-
quires parties to each deposit coins(2mq), the amount deposited in
the ladder grows as O(m2q).
Bootstrapping. Finally we focus on how to incentivize P1 to start
the protocol (i.e., reveal T1,1) or otherwise pay penalty. To do this,
we make use of “dummy tokens” {U1,j}j∈{2,....n}. These dummy
tokens are obtained by the parties via an initial secure computation
step. In more detail, for all j ∈ [n] \ {1}, the secure computation
protocol:
• chooses U1,j ← {0, 1}λ and ωboot
1,j ← {0, 1}λ at random;
• computes comboot
1,j ← S(1λ, U1,j , ω
boot
1,j );
• outputs comboot
1,j to all parties and (U1,j , ω
boot
1,j ) to Pj ,
where S is the sender algorithm of a honest binding commitment
scheme. Note that comboot
1,j is computed in order to allow parties to
generate the verification circuit for transaction Txboot
1,j and Txboot
j,1
described below. Also, we stress that for j 6= 1, the dummy token
U1,j is unknown to P1; it only knows the corresponding commit-
ment comboot
1,j . (We note that the above MPC step can be combined
with the MPC step for handling the cash distribution step (cf. Sec-
tion 4) as well as for generating the dummy tokens {Ui,j} in the
lock mechanism.) Consider the following set of deposit transac-
tions where τ1 > τ0:
BOOTSTRAP DEPOSITS.
• For j = 2 to n:
Pj
T1∧U1,j−−−−−−−−−−−−−−−−−→
q,τ1
P1 (Txboot
j,1 )
• For j = 2 to n:
P1
U1,j−−−−−−−−−−−−−−−→
q,τ0
Pj (Txboot
1,j )
That is, first each Pj makes a deposit Txboot
j,1 to P1, and then P1
makes deposits Txboot
1,j to each Pj . Then in the reveal phase, the
claims are made in reverse: each Pj first claims Txboot
1,j using the
dummy tokenU1,j . Now P1 learnsU1,j , and since it already knows
T1, it can go ahead and claim each Txboot
j,1 . More importantly, note
that once the bootstrap deposits are made, an honest Pj will always
claim Txboot
1,j , and thus will be coins(q) up. Thus the onus is on
P1 to deliver the first token (and to reclaim its coins(q)), failing
which it effectively pays a penalty coins(q) to each honest party.
The bootstrap deposits will be the last deposits to be made in the
initial deposit phase, and will be the first deposits to be claimed in
the reveal phase.
We are now ready to state our main theorem. Since the ideal
oblivious transfer primitive FOT is suffficient to obtain a common
random string, we can then apply e.g., [21] to obtain:
Theorem 2. Let (F, d?) be a bounded zero-sum reactive distribu-
tion as in Definition 2. Then assuming the existence of enhanced
trapdoor permutations, there exists a protocol that SCC-realizes
(cf. Definition 1) F?F,d? in the (FOT,F?CR)-hybrid model.
Proof sketch. The main idea behind the proof is that the witnesses
used to claim F?CR transactions are simply successive messages of
a secure computation protocol πF that realizes that standard reac-
tive functionality FF . Since πF is secure by definition, we have
that the computation also proceeds securely. To do the simula-
tion, we make use of (1) the simulator for πF , (2) the simulator
for initial MPC step (alternatively access to ideal unfair function-
ality realized in the FOT-hybrid model) that generates the dummy
tokens for the lock mechanism, the bootstrap deposits (i.e., the val-
ues {Ui,j}), and also for the cash deposits at the end (i.e., the val-
ues {T fin
i,j,k}), and (3) the simulator algorithms for honest-binding
commitments. Simulating the coins part of the protocol is more in-
volved but closely follows the simulation of the ladder mechanism
in [10]. We defer further details to the full version.
6. EFFICIENT POKER PROTOCOL
In this section we describe an optimized protocol for Texas hold
‘em poker that avoids non-black-box use of a secure computation
protocol. Our key observation is that in each stage, only player
Pi has an input in a stage of the computation that corresponds to
player Pi’s r-th round move. Let (S,R) be a non-interactive honest
binding commitment (cf. Definition 3, Appendix A). Parties run a
secure computation protocol that does the following:
• selects hands hi uniformly at random for each party Pi, as well
as the five community cards y1, . . . , y5;
• performs an n-out-of-n secret sharing of each hand hi to obtain
{hi,j}j∈[n], and a n-out-of-n secret sharing of each of the five
cards yk to obtain {yk,j}j∈[n];
204
• applies the sender algorithm of an honest-binding commitment
using random ωhi,j to secret share hi,j to obtain comh
i,j and set
Taghi,j = comh
i,j and Tokenhi,j = (hi,j , ω
h
i,j);
• applies the sender algorithm of an honest-binding commitment
using random ωyi,j to secret share yi,j to obtain comy
i,j and set
Tagyi,j = comy
i,j and Tokenyi,j = (yi,j , ω
y
i,j);
• sets AllTags = {Taghi,j ,Tagyi,j}i,j∈[n]; and
• delivers AllTags, {Tokenhi,j ,Tokenyi,j}j∈[n] to each Pi.
Note that at the end of this step, none of these cards are deliv-
ered to the parties. Instead all of these cards (including each party’s
hands) are simply secret shared among the parties. In addition, par-
ties also receive (honest-binding) commitments on all the shares,
and the decommitments to the shares held by them. These are
given so that parties can later verify if each party indeed reveals
the correct shares by sending the decommitments corresponding to
the public commimtments.
Once this is done, parties make a series of deposits as in the
see-saw (alternatively, locked ladder) mechanism. We defer the
description of the φi,r for these deposits, and first focus on the
structure of the protocol. Each party Pj is first required to reveal
Hj = {hi,j}i∈[n]\{j}, i.e., the secret shares of other party’s hands.
This is so that each party learns its private hands. Here we will
make use of the see-saw mechanism to ensure that each party Pj
either reveals Hj or pays a penalty to all other parties. The ver-
ification circuits for the F?CR transactions will depend on comh
i,j
generated in the initial secure computation step.
Next parties enter a round of (pre-flop) betting. Here we assume
a bound on maximum number of stages of betting (this is so that
we can ensure that parties make all the necessary F?CR deposits in
the see-saw mechanism). To place a bet, party Pi simply sends
the entire transcript of bets made so far in this hand along with its
new bet. Note that each party signs its bet when it makes one, and
thus when parties send a transcript containing the bets, they must
also contain the necessary signatures. We assume that there is a
well-defined function tvr,i (tv stands for “transcript validity”) that
takes the transcript of the poker game so far (including bets made
so far, and the new bet made by party Pi in round r), and verifies
if it is a valid bet. Note that a bet bi made by Pi simply specifies
the additional amount of coins it is willing to bet during its turn in
pre-flop betting round. (Similarly to fold, Pi simply sends a signed
“fold” message.) We wish to stress that no actual coins related to
the bet amounts are transferred in this phase. (These will all be
transferred at the very end of the protocol.)
Now note that once this round of betting ends, the flops needs to
be revealed to all the parties. We adopt the same strategy that we
used to reveal each party’s hands. That is, each party Pj is required
to reveal Y 1
j = {y1,j , y2,j , y3,j}, i.e., the secret shares of the flop.
Once again we will make use of the see-saw mechanism to ensure
that each party Pj either reveals Y 1
j or pays a penalty to all other
parties.
Two additional rounds of betting take place before revealing the
turn and the river. These are handled exactly like the pre-flop bet-
ting. Once all the community cards are revealed, parties that wish
to claim the pot start revealing their cards. That is, parties execute
an additional stage where they take turns to reveal their cards, i.e.,
reveal their share hi,i (which reveals their hand). Once all parties
complete the showdown round, and the entire transcript TTm,n is
available, then the pot winner can be determined. Note that we
run only one MPC at the very beginning, and AllTags generated in
this step is sufficient to design the verification circuits for all F?CR
deposits in the see-saw mechanism. Since the see-saw mechanism
now applies, any party that aborts the protocol before the winner
has been determined will pay a penalty to all other parties.
The above description turns out to be sufficient to realize “mental
poker” [1], but is not sufficient to realize standard poker (i.e., poker
with money). This is because we still haven’t let the winner(s)
take the pot. Next we describe the cash distribution stage. Let
d? = (d?1, . . . , d
?
n), and for each i ∈ [n], let mi = dlog(d?i )e.
As in Section 4, for every ordered pair (i, j) with i, j ∈ [n] and
i 6= j, and for each k ∈ [mi], we let Pi make anF?CR transaction as
follows (we slightly abuse theF?CR notation and use the verification
circuit instead of the verifying witness):
Pi
φfin
i,j,k−−−−−−−−−−−−−−−−−−−→
2k,τ0
Pj (Txfin
i,j,k)
where verification circuit φfin
i,j,k takes TTm,n as input and:
• outputs 0 and terminates if tvm,n(TTm,n) = 0;
• computes z? = (z?1 , . . . , z
?
n) using TTm,n, where z?i represents
the amount which party Pi is supposed to get at the end of the
protocol;
• computes A = g(d?, z?) (cf. Observation 1), lets ai,j denote
the (i, j)-th entry of matrix A, and lets b?i,j,1, ..., b
?
i,j,mi
be the
binary representation of ai,j ;
• outputs 1 if b?i,j,k = 1, else outputs 0.
Efficiency. Note that each party Pi makes (n − 1) · mi calls to
F?CR and deposits a total of (n − 1) · d?i coins. For implementing
the see-saw mechanism we require O(n2m) calls to F?CR and each
party to make a maximum deposit of O(nm) where m represents
the bound on the maximum number of betting rounds in a hand.
Note that we can preprocess both the secure computation, as well
as the initial deposit phase (thus managing the long waiting times
for transaction confirmation offline). Other than this, note that the
messages in our secure poker protocol are mostly signed messages
indicating the player’s move, and thus not very different from the
messages in an insecure poker protocol.
7. CONCLUSIONS
In this paper, we presented formal definitions for secure cash distri-
bution with penalties (SCD), a primitive that allows stateful compu-
tations involving data and/or money, and guarantees a strong notion
of dropout tolerance. We then constructed a protocol for SCD that
only makes use of a claim-or-refund transaction functionality F?CR
(which can be implemented in a variant of Bitcoin) and is otherwise
independent of the Bitcoin ecosystem. Our SCD protocol may be
improved in a number of ways, including improvements to round
complexity, validation complexity of F?CR transactions, as well as
alternate constructions that make only black-box use of MPC.
Acknowledgments
We would like to thank Ananth Raghunathan, Yuval Ishai, and
Stefan Dziembowski for useful discussions. The work of the
first author was supported by funding from NSF grants CNS-
1350619, CNS-1414119, and CNS-1413920, and funding from
Qatar Computing Research Institute, and funding from the Euro-
pean Union Seventh Framework Programme (FP7/2007-2013) un-
der grant agreement number 259426. The work of the second au-
thor was supported by funding from ISF grant no. 1790/13 and by
the European Union Seventh Framework Programme (FP7/2007-
2013) under grant agreement number 293843. The work of
the third author was supported by funding from the European
Union Seventh Framework Programme (FP7/2007-2013) under
grant agreement number 240258.
205
8. REFERENCES
[1] A. Shamir, R. Rivest, and L. Adleman, “Mental poker.” The
Mathematical Gardener., pp. 37–43, 1981.
[2] A. C. Yao, “Protocols for secure computations,” in 23rd
Annual Symposium on Foundations of Computer Science
(FOCS). IEEE, Nov. 1982, pp. 160–164.
[3] O. Goldreich, S. Micali, and A. Wigderson, “How to play any
mental game, or a completeness theorem for protocols with
honest majority,” in 19th Annual ACM Symposium on Theory
of Computing (STOC), A. Aho, Ed. ACM Press, 1987.
[4] M. Andrychowicz, S. Dziembowski, D. Malinowski, and
L. Mazurek, “Secure multiparty computations on bitcoin.” in
IEEE Security and Privacy, 2014.
[5] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash
system,” 2008, http://bitcoin.org/bitcoin.pdf.
[6] M. Green, “Poker is hard, especially for cryptographers,”
http://blog.cryptographyengineering.com/2012/04/
poker-is-hard-especially-for.html, 2013.
[7] M. Jakobsson, D. Pointcheval, and A. Young, “Secure
mobile gambling,” in Cryptographers’ Track — RSA 2001,
ser. LNCS, D. Naccache, Ed., vol. 2020. Springer, Apr.
2001, pp. 110–125.
[8] A. Back and I. Bentov, “Note on fair coin toss via bitcoin,”
http://arxiv.org/abs/1402.3698, 2013.
[9] M. Andrychowicz, S. Dziembowski, D. Malinowski, and
L. Mazurek, “Fair two-party computations via the bitcoin
deposits.” in First Workshop on Bitcoin Research, FC, 2014.
[10] I. Bentov and R. Kumaresan, “How to use bitcoin to design
fair protocols.” in Crypto (2), 2014, pp. 421–439.
[11] R. Canetti, “Universally composable security: A new
paradigm for cryptographic protocols,” in 42nd Annual
Symposium on Foundations of Computer Science (FOCS).
IEEE, Oct. 2001.
[12] “Bitcoin CVEs,”
https://en.bitcoin.it/wiki/CVEs#CVE-2010-5141.
[13] R. Kumaresan and I. Bentov, “How to use bitcoin to
incentivize correct computations.” in CCS, 2014.
[14] G. Andresen, “Turing complete language vs non-turing
complete.” https:
//bitcointalk.org/index.php?topic=431513.20#msg4882293.
[15] A. Yao, “How to generate and exchange secrets (extended
abstract),” in FOCS, 1986, pp. 162–167.
[16] R. Cleve, “Limits on the security of coin flips when half the
processors are faulty (extended abstract).” in STOC, 1986,
pp. 364–369.
[17] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou,
“Hawk: The blockchain model of cryptography and
privacy-preserving smart contracts,” Cryptology ePrint
Archive, Report 2015/675, 2015,
http://eprint.iacr.org/2015/675.
[18] O. Goldreich, “Foundations of cryptography - vol. 2,” 2004.
[19] S. Barber, X. Boyen, E. Shi, and E. Uzun, “Bitter to better -
how to make bitcoin a better currency.” in FC, 2012.
[20] G. Maxwell, “Zero knowledge contingent payment. 2011,”
https:
//en.bitcoin.it/wiki/Zero_Knowledge_Contingent_Payment.
[21] R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai,
“Universally composable two-party and multi-party secure
computation,” in 34th Annual ACM Symposium on Theory of
Computing (STOC). ACM Press, May 2002, pp. 494–503.
[22] J. A. Garay, J. Katz, R. Kumaresan, and H.-S. Zhou,
“Adaptively secure broadcast, revisited.” ACM Press, 2011,
pp. 179–186.
APPENDIX
A. FORMAL DEFINITIONS
Definition 3 (Honest binding commitments [22]). A (non-
interactive) commitment scheme for message space {Mλ} is a pair
of PPT algorithms S,R such that for all λ ∈ N, all messages m ∈
Mλ, and all random coins ω it holds thatR(m,S(1λ,m;ω), ω) =
1. A commitment scheme for message space {Mλ} is honest-
binding if:
Binding (for an honest sender) For all PPT algorithms A (that
maintain state throughout their execution), the following is negligi-
ble in λ:
Pr

m← A(1λ);
ω ← {0, 1}∗; com← S(1λ,m;ω);
(m′, ω′)← A(com, ω) :
R(m′, com, ω′) = 1
∧
m′ 6= m

Equivocation There is an algorithm S̃ = (S̃1, S̃2) such that for all
PPT A (that maintain state throughout their execution) the follow-
ing is negligible:∣∣∣∣∣∣∣∣∣∣∣∣
Pr
 m← A(1λ);
ω ← {0, 1}∗; com← S(1λ,m;ω) :
A(1λ, com, ω) = 1

−Pr
 (com, st)← S̃1(1
λ);
m← A(1λ); ω ← S̃2(st,m) :
A(1λ, com, ω) = 1

∣∣∣∣∣∣∣∣∣∣∣∣
Equivocation implies the standard hiding property. Also, observe
that binding holds for commitments generated by (S̃1, S̃2). As ob-
served in [10], we can construct highly efficient heuristically secure
honest binding commitment schemes in the programmable random
oracle model. In the following let Hash be a programmable hash
function, and let ω ∈ {0, 1}λ. We describe the algorithms S,R
(algorithms S̃1, S̃2 are obtained by standard oracle programming
techniques).
S(1k,m;ω)
return com := Hash(m‖ω);
R(m, com, ω)
If com
?
= Hash(m‖ω)
return 1;
else return 0;
206
http://bitcoin.org/bitcoin.pdf
http://blog.cryptographyengineering.com/2012/04/poker-is-hard-especially-for.html
http://blog.cryptographyengineering.com/2012/04/poker-is-hard-especially-for.html
https://en.bitcoin.it/wiki/CVEs#CVE-2010-5141
https://bitcointalk.org/index.php?topic=431513.20#msg4882293
https://bitcointalk.org/index.php?topic=431513.20#msg4882293
http://eprint.iacr.org/2015/675
https://en.bitcoin.it/wiki/Zero_Knowledge_Contingent_Payment
https://en.bitcoin.it/wiki/Zero_Knowledge_Contingent_Payment
	Introduction
	Preliminaries
	Secure Cash Distribution
	Realizing SCD
	See-saw Mechanism
	Efficient Poker Protocol
	Conclusions
	References
	Formal Definitions