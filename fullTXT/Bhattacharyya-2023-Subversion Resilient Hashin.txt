Subversion Resilient Hashing: Efficient Constructions and Modular Proofs for Crooked Indifferentiability
1
Subversion Resilient Hashing: Efficient
Constructions and Modular Proofs for Crooked
Indifferentiability
Rishiraj Bhattacharyya, Mridul Nandi, and Anik Raychaudhuri
Abstract—We consider the problem of constructing secure
cryptographic hash functions from subverted ideal primitives.
Hash functions are used to instantiate Random Oracles in
cryptographic protocols. The indifferentiability security notion is
a popular tool to certify the structural soundness of a hash design
for such instantiations. In CRYPTO 2018, Russell, Tang, Yung,
and Zhou introduced the notion of crooked-indifferentiability
to extend this paradigm even when the underlying primitive of
the hashing mode is subverted. They showed that an n-to-n-bit
function implemented using Enveloped XOR construction (EXor)
with 3n+ 1 many independent n-to-n-bit functions and 3n2-bit
random seed can be proven secure asymptotically in the crooked-
indifferentiability setting. Unfortunately, known techniques to
prove crooked-indifferentiability are extremely complicated, and
no practical hashing mode has been analyzed in this setting.
• We introduce new techniques to prove crooked-
indifferentiability. We establish that upper bounding
the subversion probability of a chaining query is
sufficient to argue subversion resistance of a standard
indifferentiable mode of operation. Our technique links
standard indifferentiability and crooked-indifferentiability
and circumvents the complications of proving the
consistency of the simulator in the crooked setting.
• We prove crooked-indifferentiability of the sponge construc-
tion when the underlying primitive is modelled as an n-
to-n-bit random function. Our proofs only require n-bit
randomly chosen but fixed IV and do not mandate any inde-
pendent function requirement. The result naturally extends
to the Merkle-Damgård domain extension with prefix-free
padding. Our results minimize required randomness and
solve the main open problem raised by Russell, Tang, Yung,
and Zhou.
I. INTRODUCTION
We consider the problem of designing Cryptographic Hash
Functions from subverted primitives. Traditionally crypto-
graphic hash functions are designed via applying a domain
extension algorithm on suitable primitives of a smaller domain.
Security of the hash functions is often derived via information-
theoretic arguments assuming the underlying primitives behave
as ideal where the adversary is permitted only to query the
primitives. In practice, however, the implementations of the
primitives may leak more information to the adversary and
possibly even allow malicious tampering. A good example is
University of Birmingham, UK
rishiraj.bhattacharyya@gmail.com
Indian Statistical Institute Kolkata, India and IAI-TCG Crest, Kolkata, India
mridul.nandi@gmail.com
Indian Statistical Institute, Kolkata, India
anikrc1@gmail.com
the Dual-EC tampering attack [15] which led to the withdrawal
of a standardized PRG due to a potential backdoor in the
implementation.
The framework of Kleptography, introduced by Young and
Yung [31], [32] more than twenty years ago, allows a “proud
but curious” adversary to replace a cryptographic implemen-
tation with a crooked version intending to subvert its security
without getting caught. Bellare, Paterson, and Rogaway [6]
revitalized the framework under the name of Algorithmic
Substitution Attack (ASA). They showed that it is possible
to mount an algorithm substitution attack against almost all
known symmetric key encryption schemes to the extent that
the attacker learns the secret key. A series of work has been
done in recent years formalizing approaches to resist algorithm
substitution attacks [2], [4], [5], [19]–[21], [26], [28], [29].
Indifferentiability of Hash Functions and Security against
ASA. Hash functions are ubiquitous in modern cryptography.
Hash functions are widely popular as the drop-in replacements
of Random Oracles (RO) in cryptographic schemes and proto-
cols. To facilitate this application, the notion of indifferentia-
bility from a Random Oracle, introduced by Maurer, Renner,
and Holenstein [24], has been established as a mainstream
security criterion. Indifferentiability from a Random Oracle
implies all security guarantees (like collision resistance) sat-
isfied by a Random Oracle in a single-stage game up to the
indifferentiability bound. Starting from the work of Coron,
Dodis, Malinaud, and Puniya [18], a plethora of results [1],
[9]–[12], [14], [23], [25], [27] have been proven to show
indifferentiability of different constructions based on different
ideal primitives.
Surprisingly, analysis of secure hash functions against ASA
has been scarce. In CRYPTO 2018, Russel, Tang, Yung
and Zhou [30] studied the problem of correcting subverted
Random Oracles. They introduced the notion of Crooked-
Indifferentiability as a replacement for classical indifferen-
tiability for the kleptographic setting. They showed that the
Enveloped XOR construction could be proven secure in this
framework.
Like classical indifferentiability, the game of crooked-
indifferentiability challenges the adversary to distinguish be-
tween two worlds. In the real world, the adversary has access
to the underlying ideal primitive f , and the construction C,
which has subroutine access to f̃ , the subverted implemen-
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
tation of f .1 The implementation f̃ on input an element x
queries the function (possibly adaptively) at maximum q̃ many
points and, based on the transcript, decides the evaluation of
x. As the adversary likes the subversion to go undetected, it is
assumed that f̃ differs from f only on some negligible fraction
(ϵ) of the domain.
In the ideal world, the construction is replaced by a Random
Oracle F . The role of f is played by a simulator with oracle
access to F and the subverted implementation f̃ . The job of
the simulator is to simulate f in such a way that (C f̃ , f)
is indistinguishable from (F , SF,f̃ ). In order to avoid trivial
attacks, the framework allows a public random string R to
be used as the salt in the construction. The string R is fixed
after the adversary publishes the implementation but stays the
same throughout the interaction. All the parties, including the
simulator and the adversary, get R as part of the initialization
input. We note that even in the weaker setting of Random
Oracles with auxiliary input, a random salt is required to prove
security [17], [22].
The notion of crooked-indifferentiability from a Random
Oracle and the composition theorem proved in [30] guarantees
that a construction proved secure in this framework can be
used to replace a Random Oracle in any single-stage game
in the kleptographic setting. While popular hash functions are
the most natural choice for instantiating the Random Oracle,
their suitability is still unknown. We ask, can the popular
hashing modes, for some parameters, achieve this many-fold
stronger security notion? Given the surge of new constructions
in the ASA setting [2]–[4], [16], the importance of the question
cannot be overstated.
Proving a construction secure in the crooked-
indifferentiability setting is an immensely challenging
task. Unlike the classical setting where the adversary is
passive, the crooked-indifferentiability adversary is active
and could subvert any algorithm. The only known crooked-
indifferentiability bound is for the construction called
Enveloped XOR (EXor), depicted in Figure 1. In [30], the
authors using the rejection-sampling technique showed the
security of EXor construction. The instantiation requires
3n + 1 many independent functions and n2 many random
bits. We note, however, that the Enveloped XOR construction
produces an n-bit to n-bit random function. Instantiating
a hash function would require applying domain extension
techniques on top of it, implying more function calls
and possibly more independent random bits. Minimizing
randomness and reducing the number of function calls while
still achieving crooked-indifferentiability was left as the main
challenge in [30].
Finally, the technique of [30], though ingenious, is very
complex. It is difficult to give an intuitive justification for why
the construction and the approach work. The alternative proof
of [13] is also quite involved. Given that we have established
tools to prove indifferentiability in the classical setting, it is
natural to ask whether we can leverage those tools to prove
crooked-indifferentiability.
1The domain extension algorithms are simple, and the correctness of their
implementations are easy to verify.
A. Our Contributions
We introduce new techniques to prove crooked-
indifferentiability and establish security bounds for
popular hashing modes, the sponge construction and the
ubiquitous Merkle-Damgård construction. We elaborate on
our contributions below.
New Techniques for Crooked-Indifferentiability. We present
new techniques to prove Crooked-Indifferentiability. We in-
troduce a new security game called Force-Crook, where
the challenge to the adversary is to produce a message for
which the construction makes a primitive query on a subverted
input. We show that bounding the advantage of the adversary
in the Force-Crook game is sufficient to prove Crooked-
Indifferentiability of constructions secure under the classical
indifferentiability paradigm.
Crooked-Indifferentiability of Popular Hashing Modes.
We apply our techniques to prove the security of popular
hashing modes. Our main contribution is to show that the
sponge construction, instantiated with a random function and
a randomized initial value, is crooked-indifferentiable from
a Random Oracle. The construction uses the same function
at every iteration. The design is identical to the one proven
indifferentiable in [9]. This result positively answers our
quest for a practical crooked-indifferentiable hashing mode.
Moreover, the proof requires only a linear (in terms of the
security parameter) number of random bits and thus answers
the main open question raised by RTYZ [30].
We show that the technique with a minor modification
is sufficient to prove the security of the classical Merkle-
Damgård construction with prefix-free padding. The hash
function uses an n+ 1-to-n-bit compression function.
B. Overview of Our Techniques
Technical Challenges in Crooked-Indifferentiability. The
main challenge in the crooked setting is to prove the random-
ness of the construction’s output. As the underlying primitives
are subverted, the adversary may have full information about
the function on some points without querying the oracles.
Consider the following example. We are given an n-to-n-bit
random function f . By definition, f is classically indifferen-
tiable from a random oracle. Now consider a simple subverted
implementation f̃ of f . The program f̃ honestly implements
f everywhere except at point 0, where it outputs f̃(0) = 0.
Such an f̃ can be easily distinguished from a random oracle.
The established technique to correct the situation would be
the random-masking technique, but that does not work either.
Consider, for example, simple input masking with a random
string R obtained by the function gR(M)
def
= f(M ⊕ R).
As the string R is fixed at the start of the game (after the
adversary submits the subverted implementation), the distin-
guisher can indeed choose the message M = R, resulting
in a distinguishing condition gR(R) = 0. From the above
two examples, one can abstract out the first challenge of
proving crooked-indifferentiability. The output distribution of
the underlying primitive, conditioned on the adversary’s view,
is not uniform for every point. The challenge becomes even
more daunting when we consider an implementation that can
2
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
h(1, ·) h(2, ·) h(3, ·) · · · h(l, ·)
m⊕R1 m⊕R2 m⊕R3 m⊕Rl
+ + · · · + h(0, ·)
(a)
0r
0c
R0
c bits
r bits
R1
m0
f
m1
f
m2
· · ·
· · ·
m`
f
z0
f
z1
f
z2
(b)
Fig. 1. EXor construction (left) and Sponge Construction with random IV (right).
subvert a point based on the function evaluations at that
and possibly some other points. We can no longer assume
function values are independently distributed. Thus the tools
and techniques developed for classical indifferentiability seem
to be useless here.
The Intermediate Game Force-Crook. We found a seem-
ingly obvious but powerful technique to handle subversions.
The difference between the real world in the crooked-
indifferentiability and the real world in the classical indifferen-
tiability setting is only in the oracle of the construction C. In
the crooked setting, C is given oracle access to f̃ whereas, in
the classical setting, C queries the primitive f itself. As long as
no chaining value results in querying f on a crooked point, the
output distributions of these two worlds are identical! In other
words, if for every message M submitted by the adversary to
C, it holds with a high probability that Cf (M) = C f̃ (M),
then (Cf , f) and (C f̃ , f) are indistinguishable. If C is indif-
ferentiable in the classical setting, then that simulator would
work perfectly as the simulator in the crooked setting.
In Section III, we introduce a security game Force-Crook
where the adversary is challenged to find a message where
Cf (M) ̸= C f̃ (M). We show that for a construction proven
indifferentiable from a random oracle in the classical setting
(with security bound δi), the crooked-indifferentiability advan-
tage is bounded by the advantage of winning the Force-Crook
game plus δi.
Bounding Winning Advantage of Force-Crook To bound
the adversary’s success probability of winning the game
Force-Crook, we focus on ensuring all the chaining inputs
remain uncrooked with high probability. Our intuition is to
argue that if a chaining query is uncrooked, the output is
uniform. Given that only a negligible fraction of points are
crooked, when we use random iv, the first chaining inputs are
random and, thus, with high probability, uncrooked. Suppose
only a few bits of the message are injected at every iteration.
Then the following chaining query input is close to being
uniform and, thus with high probability, uncrooked as well.
Now we can repeat this argument throughout the computation
of C. For the sponge and Merkle-Damgård constructions, this
idea in itself is sufficient for handling simple subversion.
We explain it in more detail for the following simplified
setting. Suppose the subverted implementation f̃ is such that
on input a point x, the output of f̃(x) depends only on
the value of f(x), and it is independent of f(y) for all
y ̸= x. Consider the sponge construction based on a random
function f : {0, 1}n → {0, 1}n. By definition of worst-case
subversion by a proud but curious adversary, for all choices
for the function f , at most ϵ fraction of the inputs are crooked
(f̃(x) ̸= f(x)). In addition, there are at most q1 many points
queried by the implementor before producing the subverted
implementation. Hence for every function f , there is a set Sf
of size at least (1 − ϵ)2n − q1 whose members are neither
fixed by the implementor nor subverted. For a randomly
chosen function f and a random string, with overwhelming
probability, the random string will be a member of Sf . If we
set the rate part of the sponge construction to be 1, for both
the choice of m0 ∈ {0, 1}, the first chaining query to f will
be a member of Sf with probability (1− 2ϵ− 2q1
2n ).
We can repeat the above argument inductively. Consider
the lazy sampling framework of random functions. We say a
chaining query xi is good if, for all choices of mi+1 ∈ {0, 1},
the next chaining query xi+1 = f(xi) ⊕ mi+1 is subverted
with low probability (say ϵ
1
2 ). In other words, xi+1 is a
member of Sf with high probability. One can show that
a randomly chosen point is good with high probability. As
f(xi) is uniformly distributed, xi+1 would also be a good
chaining query. For the base case of the induction argument,
we recall that the first chaining query is generated from the
initial random string. For all values of m0 ∈ {0, 1}, it is a
good chaining query with high probability. Thus we get all
the chaining queries would be good, and by extension, all
the chaining queries will be uncrooked with overwhelming
probability.
The matter gets complicated when we consider a general f̃
whose output can depend on adaptively chosen multiple points.
With careful analysis, we extend our arguments to this general
case. In Section IV, we present the analysis in detail.
C. Impact of Our Results
Subversion Agnostic Indifferentiability. We achieve a
strong form of crooked-indifferentiability where the simu-
lator is subversion agnostic. When we establish crooked-
indifferentiability via the Force-Crook game, S does not
even need access to subverted implementation f̃ . While we
show sponge and Merkle-Damgård attain such security, not all
constructions achieve such strong crooked-indifferentiability.
One notable example is the Enveloped Xor construction,
where the simulator must have access to f̃ to achieve
crooked-indifferentiability as formulated in [30]. Thus our
modular proof technique illustrates a simple condition for
3
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
a classical indifferentiable construction to achieve crooked-
indifferentiability.
Crooked vs Classical. A learned reader may observe that a
crooked-indifferentiable construction’s efficiency and security
parameters are worse than what can be proven in the classical
indifferentiability setting. One can wonder about the crooked-
indifferentiability framework’s significance and our results’
impact. In particular, for the sponge construction with n
bit function, we prove crooked indifferentiability security
of asymptotically n/4 bits when at each round, one bit of
message is injected and ϵ ≤ 1/2n/2. In contrast, SHA3,
with each iteration consuming r bits of messages, achieves
(n − r)/2 bits of security in the classical indifferentiability
setting.
However, comparing bit-security without considering the
adversary’s power leads to misleading impressions. While
proving indifferentiability, we aim to achieve independent and
uniformly sampled hash output for every point. The classical
indifferentiability assumes that an adversary is passive and is
content with only black-box access to the underlying primitive.
Thus, the primitive could be modelled as ideal. In particular,
each point is mapped independently following a high-entropy
probability distribution.
In comparison, the adversary in the kleptographic setting is
active. The implementation of the primitive is subverted. The
points are not mapped independently, and for some “small”
yet non-zero fraction of the inputs, the adversary has carefully
chosen the function. We can no longer directly leverage the
randomness of the underlying primitive. It is natural that the
security-efficiency tradeoff achieved in the crooked setting
against such an active adversary is somewhat weaker than what
is accomplished against the passive adversary of the classical
indifferentiability paradigm.
II. NOTATIONS AND PRELIMINARIES
Notations. Let N = {0, 1, . . . } be the set of natural numbers
and {0, 1}∗ be the set of all binary strings. For a positive
integer n, the term {0, 1}n denotes the set of all n-bit binary
strings. If x and y are two strings, xy denotes the concatenated
string. We write x
$←− S to denote the process of choosing x
uniformly at random from a set S and independently from all
other random variables defined so far. For a positive integer l,
we use (l] and [l] to denote the set {1, . . . , k} and {0, 1, . . . , k}
respectively.
Class of Functions. HD,R denotes the set of all functions from
D to R. Fm,n denotes the set of all functions from {0, 1}m
to {0, 1}n. f : (k] × Df → Rf denotes a family of k many
functions from Df to Rf . We often use the shorthand f to
denote the family {f1 := f(1, ·), . . . , fk := f(k, ·)} when the
function family is given as oracles.
For any tuples of pairs τ = ((x1, y1), . . . , (x|τ |, y|τ |)) we
write D(τ) (called domain of τ ) to denote the set {xi : 1 ≤
i ≤ |τ |}. We write τj = ((x1, y1), . . . , (xj , yj)). We say a
function f agrees with τ if for all (x, y) ∈ τ , f(x) = y. For
every x ∈ Df , α ∈ Rf , we use fx→α to denote the following
function:
fx→α(y) =
{
f(y) if x ̸= y
α if x = y
.
Security Games. The results are proven in the framework of
code-based games [7]. A game G consists of a main oracle
and zero or more stateful oracles O1, O2, . . . , On. If a game G
is implemented using a function f , we write G[f ] to denote the
game. The success probability of algorithm A in the game G
is defined by SuccA,G
def
= Pr
[
GA = 1
]
. The query complexity
of A is the number of queries made by A to its oracles.
Definition 1 (Domain Extension). Let D ⊇ Df . A domain
extender C with oracle access to a family of functions f :
(k] × Df → R is an algorithm that implements the function
H = Cf : D → R.
During the computation of Cf (M), the f query inputs made
by C are called the chaining queries.
Adversaries and Distinguishing Advantage. An adversary
A is an algorithm possibly with access to oracles O1, . . . ,Ok
denoted by AO1,...,Ok . The adversaries considered in this
paper are computationally unbounded. The complexities of
these algorithms are measured solely on the number of queries
they make. An algorithm A having access to an oracle is
called a q-query algorithm if it makes at most q queries to
its oracle. Similarly, an oracle algorithm having access to two
oracles is called a (q1, q2)-query algorithm if it makes at most
q1 and q2 queries to its first and second oracles, respectively.
Adversarial queries and the corresponding responses are stored
in a transcript τ . D(τ) denotes the list of inputs (queries) in
the transcript.
Definition 2 (Distinguishing Advantage). Let F k and Gk
be two k-tuples of probabilistic oracle algorithms for some
positive integer k. We define the advantage of an adversary
A at distinguishing F k from Gk as
∆A(F
k ; Gk)
def
=
∣∣Pr[AF1,F2,...,Fk = 1]− Pr[AG1,G2,...,Gk = 1]
∣∣ .
A. Classical Indifferentiability
An oracle construction CO(·, ·) with a randomized initial
value (IV) first fixes the IV R (chosen randomly from an
initial value space). Afterwards, on input M , the construction
C interacts with the oracle O, and finally, it returns an output,
denoted as CO(R,M). When the initial value space is a
singleton (i.e., degenerated), we call C an oracle construction.
An (IV-based) oracle construction C is called F-compatible if
the domains and ranges of C and F (an ideal primitive) are the
same. Now we state the definition of indifferentiability of an
oracle construction as stated in [18], [24] in our terminologies.
In the following definition, adversary A and simulator S
have independent, private random coins. Construction C has
the random initial vector R, sampled at the start and fixed
throughout the game. The adversary A and the simulator S
receive R as input.
4
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
Definition 3 (Indifferentiability). Let F be an ideal primitive
and CP be an F-compatible oracle construction. C is said to
be ((qP , qC , qsim), ε)-indifferentiable from an ideal primitive
F if there exists a qsim-query algorithm SF (called simulator)
such that for any (qP , qC)-query algorithm A, it holds that
∆A(R)
(
(P,CP (R, ·)) ; (SF (R, ·),F)
)
< ε.
where R is the random initial vector of the construction C,
chosen uniformly from the initial coin space and provided to
the adversary A, simulator S.
In the above definition, one may include the adversary
and simulator’s complexity (time, query etc.). However, for
information-theoretic security analysis, we may ignore their
time complexities.2 A popular indifferentiability treatment for
hash functions considers F to be an n-bit random oracle
that returns independent and uniform n-bit strings for every
distinct query. However, the hash function CP can be defined
through different types of primitives P (a random oracle, or a
random permutation πn, chosen uniformly from the set of all
permutations over {0, 1}n).
P C S F
A
Fig. 2. The indifferentiability security notion. The real world consists of the
construction C and the underlying ideal primitive P . The ideal world consists
of the ideal primitive F and the simulator S. The construction C has oracle
access to the underlying primitive P . The simulator S has oracle access to
F . When C has a random IV R, the distinguisher A and the simulator S
receive R as input. The distinguisher A interacts either with the real world
or with the ideal world.
B. Modeling Subversion Algorithms and Crooked-
Indifferentiability
We recall the related terms and notations introduced in [30]
in our terminologies.
Implementer. A (q, q̃) implementer is a q-query oracle al-
gorithm AO. A outputs the description of another oracle
algorithm F̃O. The algorithm F̃O makes at most q̃ many
queries to its oracle. We call F̃ the implementation. We let
τ̃ denote the transcript of oracle queries of A. The transcript
τ̃ is hardwired in F̃ , and all the q̃ queries made by F̃ are
different from D(τ̃).
The implementation F̃ is correct if for all f ∈ HDf ,Rf
and
for all x ∈ Df , f̃(x) def
= F̃ f (x) = f(x).
2one can easily extend the concrete setup to an asymptotic setup.
Let ⟨Fn, Pn⟩n∈N be a sequence of primitives and C(n) be a
polynomial time Fn-compatible oracle algorithm. CPn(n) is said
to be (computationally) indifferentiable from Fn if there exists a
polynomial-time simulator SFn such that for all polynomial-time
oracle algorithm A, ∆A
(
(Pn, C
Pn(n)) ; (SFn ,Fn)
)
= negl(n).
A subverted implementation f̃ on input x queries
α
(x)
1 , α
(x)
2 , . . . , α
(x)
q̃ , and based on the query-responses
outputs f̃(x). Without loss of generality, we assume
α
(x)
1 = x, that is the first query of f̃(x) is f(x). We use
α ↠f α′ to denote that f̃(α) queries f(α′). Similarly,
α ̸↠f α′, denotes that f̃(α) does not query f(α′). We define
the following two sets: (1) Q̃f (x)
def
= {y | x ↠f y} and (2)−→
Qf (x)
def
= {y | y ↠f x}. Specifically, Q̃f (x) denotes the set
{α(x)
1 , α
(x)
2 , . . . , α
(x)
q̃ }.
−→
Qf (x) denotes the set of all points
whose (subverted) evaluation queries the point x.
Definition 4 (Crooked Implementer). A (q, q̃) implementer
A1 is called ϵ-crooked for a function family HDf ,Rf
, if for
every f ∈ HDf ,Rf
, it holds that
Pr
α
$←−Df
[f̃(α) ̸= f(α)] ≤ ϵ
where f̃ ← Af
1 .
Summary. A (crooked) implementation f̃ , to compute f̃(x),
queries f(α
(x)
1 ), . . . , f(α
(x)
q̃ ) on q̃ many distinct points (α1 =
x) and its decision of whether to subvert f(α) depends on
this transcript and the hardwired string τ̃ . For an ϵ-crooked
implementation, for each f ∈ HDf ,Rf
, for at most ϵ fraction
of x ∈ Df , f(x) is subverted.
Detection Algorithm. Given an implementation, one may
check the algorithm’s correctness by comparing the imple-
mentation’s outputs with a known correct algorithm. More
precisely, we sample α1, . . . , αt
$←− {0, 1}m and then for all
0 ≤ i ≤ l, we check whether f̃(αi) = f(αi) holds. If it does
not hold, the implementation will be discarded. It is easy to see
that for an ϵ-crooked implementation; the subversion would be
detected with a probability of at most tϵ. So for negligible ϵ,
this probability would be negligible for all polynomial function
t, and the implementation can survive for further use.
Crooked Distinguisher. A crooked distinguisher is a two-
stage adversary; the first stage is a crooked implementer and
the second stage is a distinguisher.
Definition 5 (Crooked Distinguisher). We say that a pair
A := (A1,A2) of probabilistic algorithms ((q1, q̃, ϵ), q2)-
crooked distinguisher for HDf ,Rf
if
(i) A1(r) is a ϵ-crooked (q1, q̃) implementer for HDf ,Rf
and
(ii) A2(r, τ̃ , R) is a q2-query distinguisher where r is the
random coin of A, τ̃ is the advice-string, the transcript of the
interaction of A1 with f , and R is the (randomized) initial
vector of the target construction. The random string r and the
advice-string τ̃ are hardwired to A2, and the random IV R is
provided as input.
Crooked-Indifferentiability. Now, we state the crooked-
indifferentiable security definition (as introduced in [30]) in
our notation and terminology. The definition is based on the
following two-stage distinguishing game. The ideal primitives
f and F are sampled. The crooked-distinguisher A (with
random string r as the random coins) runs the first phase
A1. The crooked implementer A1, with oracle access to f ,
5
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
produces a subverted implementation F̃ . Then, a uniformly
random string R is sampled and published as the IV of the
construction C. Finally, A2 is invoked with an internal random
string r, the advice-string τ̃ , and the random IV R as input.
In the real world, A2 interacts with the f ( same from the first
stage) and the construction C f̃ (R, ·). In the ideal world, the
simulator S gets the advice-string τ̃ , the initial value R and
blackbox access to the subverted implementation F̃ as inputs,
along with oracle access of a random oracle F . The simulator
is aimed to simulate f so that the behaviour of (f, C f̃ ) is as
close as (S,F) to the distinguisher A2.
Definition 6 (Crooked-Indifferentiability [30]). Let F be an
ideal primitive and Cf be an IV-based F-compatible ora-
cle construction. The construction C is said to be ((q1, q̃),
(q2, qsim), ϵ, δ)-crooked-indifferentiable from F if there is
a qsim-query algorithm S (called simulator) such that for
all ((ϵ, q1, q̃), q2)-crooked distinguisher (A1(r), A2(r, ·, ·)) for
HDf ,Rf
, we have
∆A2(r,τ̃ ,R)
(
(f, C f̃ (R, ·)) ; (SF,F̃ (τ̃ , R),F)
)
≤ δ (1)
where τ̃ is the advice string of Af
1 . R is the random initial
value of the construction sampled after the subverted imple-
mentation is set.
C(R, ·)F̃f S(τ̃ , R) F
F̃
A2(r, τ̃ , R)
Fig. 3. The crooked-indifferentiability notion. In the first phase of the real
world, A1 interacts with f and returns an oracle algorithm F̃ (which would
be accessed by the construction C in the second phase). In the second phase,
the random initial value R will be sampled and given to construction C and
also to A2. In the ideal world, the simulator SF gets the transcript of the first
phase as an advice string, blackbox access to the subverted implementation
F̃ and the initial value R.
Remark 7. The simulator S gets a blackbox subroutine access
to the algorithm F̃ . The simulator can compute F̃ (x) by
invoking F̃ with input x and responding to the oracle queries
made by F̃ .
Convention on Crooked Distinguishers. Note that there is
no loss in assuming that both A1 and A2 are deterministic (so
we skip the notation r) when we consider a computationally
unbounded adversary. A can fix the best internal random coin
r for which the distinguishing advantage of A2 is maximum.
As the randomness of f,F , the public IV R and the internal
random coins of S are independently sampled from r, the
maximum distinguishing advantage would follow from an
averaging argument.
We also assume that A2 makes all distinct queries distinct
from those made by A1. We skip the notation τ̃ as an input
of A2 as it is fixed throughout the game. As the advice string
is fixed, we consider it part of the transcript. Specifically, the
transcript τ0, view of A2 at the start of the second stage, is
set as the advice string τ̃ .
C. Markov Inequality
Lemma 8. Let X be a non-negative random variable and
a > 0 be a real number. Then it holds that
Pr[X ≥ a] ≤ E(X)
a
.
A simple application of Markov inequality (which is used
repeatedly in this paper) is the following. Consider a joint
distribution of random variables X and Y . Suppose E is
an event for which Pr[(X,Y ) ∈ E] ≤ ϵ. Let f(x) :=
Pr[(X,Y ) ∈ E|X = x] and E1 := {x : f(x) ≥ δ}. It
follows from the definition that E(f(X)) = Pr[E]. Now, we
use Markov’s inequality
Pr[E1] = Pr[f(X) ≥ δ]
≤ E(f(X))/δ
= ϵ/δ.
Note that when X and Y are independent, f(x) = Pr[(x, Y ) ∈
E].
D. Suitable Functions and Sets
Let f : Df → Rf be a function. For a transcript τ , we
define Cf,τ to be the union of the set of subverted points for
the function f and the points fixed by τ .
Definition 9. Cf,τ = {x | x ∈ D(τ) ∨ f̃(x) ̸= f(x)}.
By the definition of ϵ-crooked,
|Cf,τ |
|Df |
≤ ϵτ := ϵ+
|τ |
|Df |
.
At the beginning of the second stage of the crooked-
indifferentiability game, the transcript contains the interaction
of the q1 many queries made by the implementer. We define
ϵ1 = ϵ+
q1
2n
.
Let τ be a (partial) transcript. Recall, we say a function g
agrees on a transcript τ when the transcript holds for the
function g.
Fn,n|τ
def
= {g ∈ Fn,n | g agrees on τ}.
III. FROM CLASSICAL INDIFFERENTIABILITY TO
CROOKED-INDIFFERENTIABILITY
In this section, we establish sufficient conditions to lift
the classical indifferentiability results to the crooked indif-
ferentiability setting. Let f : Df → R and F : D → R
be two random oracles where D ⊇ Df . Let Cf be an F-
compatible construction. We consider a crooked distinguisher
A = (A1,A2).
6
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
C(R, ·)F̃f
A2(r, τ̃ , R)
C(R, ·)f
A2(r, τ̃ , R)
S(τ̃ , R) F
A2(r, τ̃ , R)
Fig. 4. The hybrid: The leftmost picture is the real world of the crooked setting. The middle picture is the real world in the classical setting. The rightmost
picture is the ideal world in the classical setting.
A. Force-Crook game
In this section, we introduce the security game Force-
Crook. Formally the game is defined in Figure 5. The force-
crook advantage of an adversary is defined as
Advforce-crookA,C
def
= SuccA,force-crook[C].
Given a construction C, we define
Insecforce-crookC,(q1,q̃,ϵ),q2
def
= maxAAdvforce-crookA,C .
where the maximum is taken over all ((q1, q̃, ϵ), q2)-crooked-
distinguishers.
Game Force-Crook(C)
1 : f
$←− Fn,n
2 : (τ̃ , ⟨f̃⟩)← Af
1
3 : M ← A(Cf (·,R),f)
2 (τ̃ , R)
4 : if Cf (M) ̸= C f̃ (M)
5 : return 1
6 : else
7 : return 0
Fig. 5. The Force-Crook game
B. Achieving Crooked-Indifferentiability
Our main technique to prove the security of sponge and
prefix-free Merkle-Damgård constructions results from Theo-
rem 10. The idea is depicted in Figure 4. Suppose C is in-
differentiable from F (the advantage of distinguishing middle
and rightmost worlds is small). If the Force-Crook advantage
is small, then the advantage of distinguishing between the
leftmost and the middle-world is small. Then the classical
simulator S successfully acts as the simulator in the real world
of the crooked setting.
Theorem 10. Let Cf : D → R be a hash function built
on primitive f : Df → R. Let Cf be ((qP , qC , qsim), δi)-
indifferentiable from a random oracle F . Cf is ((q1, q̃),
(q2, qsim), ϵ, δc)-crooked-indifferentiable from F where
δc ≤ δi + Insecforce-crookC,(q1,q̃,ϵ),q2
and q1 + q2 ≤ qP .
Proof. From the definitions and using triangle inequality, we
get
δc ≤ δi +∆A2(r,τ̃ ,R)
(
(f, C f̃ (R, ·)) ; (f, Cf (R, ·))
)
.
In order to prove the theorem, we need to show
∆A2(r,τ̃ ,R)
(
(f, C f̃ (R, ·)) ; (f, Cf (R, ·))
)
≤ Insecforce-crookC,(q1,q̃),(q2,qs)
.
Let BAD denote the event A2(r, τ̃ , R) makes a query to C f̃
(or Cf ) oracle with input M such that
Cf (R,M) ̸= C f̃ (R,M).
Now unless BAD is set, the outputs of the oracles in both the
world (f, C f̃ (R, ·)) and (f, Cf (R, ·)) are exactly the same.
Thus we get
Pr[A(f,Cf̃ (R,·))
2 (r, τ̃ , R) = 1 ∩ ¬BAD]
= Pr[A(f,Cf (R,·))
2 (r, τ̃ , R) = 1 ∩ ¬BAD].
(2)
We derive, using Definition 2, triangle inequality, and Equa-
tion 2
∆A2(r,τ̃ ,R)
(
(f, C f̃ (R, ·)) ; (f, Cf (R, ·))
)
=
∣∣∣∣Pr[A(f,Cf̃ (R,·))
2 (r, τ̃ , R) = 1]−
Pr[A(f,Cf (R,·))
2 (r, τ̃ , R) = 1]
∣∣∣
≤
∣∣∣∣Pr[A(f,Cf̃ (R,·))
2 (r, τ̃ , R) = 1 ∩ BAD]−
Pr[A(f,Cf (R,·))
2 (r, τ̃ , R) = 1 ∩ BAD]
∣∣∣+∣∣∣∣Pr[A(f,Cf̃ (R,·))
2 (r, τ̃ , R) = 1 ∩ ¬BAD]−
Pr[A(f,Cf (R,·))
2 (r, τ̃ , R) = 1 ∩ ¬BAD]
∣∣∣
=
∣∣∣∣Pr[A(f,Cf̃ (R,·))
2 (r, τ̃ , R) = 1 ∩ BAD] −
Pr[A(f,Cf (R,·))
2 (r, τ̃ , R) = 1 ∩ BAD]
∣∣∣
≤ Pr[BAD ] .
The last inequality follows as both Pr[A(f,Cf̃ (R,·))
2 (r, τ̃ , R) =
1 ∩ BAD] and Pr[A(f,Cf (R,·))
2 (r, τ̃ , R) = 1 ∩ BAD] are num-
bers between 0 and Pr[BAD ]. Finally, if BAD happens then
A2(r, τ̃ , R) wins the game Force-Crook. Thus
Pr[BAD] ≤ Insecforce-crookC,(q1,q̃),(q2,qs)
.
The theorem follows.
7
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
Procedure Sponge
// random string R, Message m ∈ {0, 1}ℓ
1 : x = (xa, xc) = R
2 : for i = 0 to
⌈
ℓ
r
⌉
− 1 do
3 : (xa, xc) = f(xa ⊕mi, xc)
4 : endfor
5 : for i = 0 to
⌈s
r
⌉
− 1 do
6 : Append xa to output
7 : (xa, xc) = f(xa, xc)
8 : endfor
0r
0c
R0
c bits
r bits
R1
m0
f
m1
f
m2
· · ·
· · ·
m`
f
z0
f
z1
f
z2
Fig. 6. Crooked-Indifferentiable Sponge Construction
IV. CROOKED-INDIFFERENTIABILITY OF SPONGE
CONSTRUCTION
A. Sponge Construction based on Random Functions
In this section, we show that the sponge construction
[8] based on an n-to-n-bit random function can be proved
crooked-indifferentiable from a random oracle when initialized
with a random IV.
Sponge Construction. The details of the parameters of the
sponge construction we consider are listed below.
TARGET HASH FUNCTION. The construction implements a
FIL-hash function H : {0, 1}ℓ → {0, 1}s.
PRIMITIVES. The underlying primitive of the construction is
an n-to-n bit function f : {0, 1}n → {0, 1}n. In the security
proof, f is modelled as a random oracle.
PUBLIC RANDOMNESS. The public randomness is R
$←−
{0, 1}n.
PADDING. We use the same padding scheme as the original
sponge construction, where it is required that the last message
block is non-zero.
CONSTRUCTION. The chaining value of the sponge construc-
tion is divided into two parts, rate (length denoted by r) and
capacity (length denoted by c). The message is divided into
r-bit blocks. The construction works in two phases, absorbing
and squeezing. In one round of the absorbing phase, one r-bit
message block is xored with the rate part of the chaining value.
The function f is then applied to the result (of the xor) to get
the chaining value of the next round. The construction enters
the squeezing phase once all the input message blocks are
processed. At each round, the rate part of the chaining value
is stored as the output block, followed by the application of
f on the whole chaining value. The algorithm stops once we
have s bits of output. The construction is described in Figure
6.
q1 Number of f queries made by the implementor A1
q̃ Number of f queries made by f̃
q2 Number of queries made by the distinguisher A2
qsim Number of F queries made by the simulator S
ϵ Fraction of subverted points under f̃
Fig. 7. Recalling the notations
Our main result in this section is Theorem 11. We recall
the notations in Figure 7.
Theorem 11. Let f : {0, 1}n → {0, 1}n be a random function
and Cf : {0, 1}ℓ → {0, 1}s be the sponge construction. Let
r be the rate part, and c = n − r be the capacity part of
the chain. Then there exists a simulator S such that for all
((q1, q̃, ϵ), q2)-crooked distinguishers A = (A1,A2), it holds
that
Advcrooked-indiff
A,(C,f)
≤ O
(
2r × σ ×
(
ϵ
1
2
1 +
q̃
2
n
4
+ ϵ
1
2
1 +
σ
2n
+
σ
2
n
2
))
where ϵ1 = ϵ + q1
2n , σ is the total number of blocks in the
queries made by A2. The simulator makes O(σ) queries.
The rest of the section is dedicated to proving Theo-
rem 11. First, we recall the result of Bertoni, Daemen, Peeters,
and Van Assche [9] to find the classical Indifferentiability
bound of the sponge construction. Then we shall bound the
Insecforce-crookC,(q1,q̃),(q2,qs)
, the advantage of any distinguisher against
our construction in the Force-Crook game. Finally, using
Theorem 10, we shall get Theorem 11.
Classical Indifferentiability of Sponge with Random Func-
tion. We recall the classical indifferentiability result of sponge
mode from [9] in our notations and parameters.
Theorem 12 (Theorem 1 in [9]). Let f : {0, 1}n → {0, 1}n
be a random function. The sponge construction instantiating
Cf : {0, 1}ℓ → {0, 1}s is (q, qsim, δi)-indifferentiable from a
random oracle for qsim = O(σ) and δi = O(σ
2
2c ) where σ is
the total number of queries made by the distinguisher.
We note that in [9], the above theorem is proved to hold for
any fixed IV. Thus we can conclude that the theorem holds
for a randomly chosen and then fixed IV, as required in our
case.
B. Bounding Probability of Winning Force-Crook: Sponge on
Random Functions
Now we bound Insecforce-crookC,(q1,q̃),(q2,qs)
. We shall prove the
following lemma which summarizes the main findings of this
section. We recall the notations in Figure 7.
8
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
Lemma 13. Let C be the sponge construction with random-
ized IV. Let r be the rate part, and c = n− r be the capacity
part of the chain. It holds that
Insecforce-crookC,(q1,q̃),(q2,qs)
≤ O
(
2r × σ ×
(
ϵ
1
2
1 +
q̃
2
n
4
+ ϵ
1
2
1 +
σ
2n
+
σ
2
n
2
))
where σ = q2(ℓ+ s) + qS .
1) The Setup of Bounding Adversary’s Advantage.: The
main idea of our proof is to bound the probability that the
adversary can produce a message such that a chaining query
is subverted. We need the following definition.
Definition 14 (Robust Point). A point x ∈ {0, 1}n is said to
be a (r, ϵ1)-robust point with respect to a transcript τ , if
1) x /∈ D(τ).
2) Define yζ = f(x)⊕ ζ0n−r for ζ ∈ {0, 1}r. It holds that
Pr
f←Fn,n|τ
 ∨
ζ∈{0,1}r
yζ ∈ Cf,τ
 ≤ 2r
(
ϵ
1
2
1 +
|τ |
2n
+
|τ |
2
n
2
)
.
Popular Points. Consider a point x ∈ Df \ D(τ). x is called
favourite of y with respect to τ if
Pr
f
$←−Fn,n|τ
[y ↠f x] ≥ 1
2
n
2
.
Definition 15. x is popular with respect to τ if
Pr
y
[x is favourite of y] >
1
2
n
4
.
Recall that the subversion algorithm f̃ makes at most q̃
many queries; for all y ∈ Df , it holds that |f̃(y)| ≤ q̃. Using
an averaging argument, we get the following lemma.
Lemma 16. For all transcript τ , it holds that the number of
popular points is at most q̃2
3n
4 .
Definition 17 (Good Point). A point x is (r, ϵ1)-good with
respect to τ if it is (r, ϵ1) robust and not popular with respect
to τ .
The following lemma is a corollary of Lemma 16 and the
definition of the ϵ-crooked implementor. It says a random point
is good with high probability.
Lemma 18. Let τ be a transcript. It holds that
Pr
x
$←−Df
[x is not (r, ϵ1) good with respect to τ ]
≤ ϵ
1
2
1 +
|τ |
2n
+
q̃
2
n
4
.
Proof. Define yζ = f(x) ⊕ ζ0n−r for ζ ∈ {0, 1}r. From the
definition of ϵ crooked implementor,
Pr
x
$←−Df ,f←Fn,n|τ
 ∨
ζ∈{0,1}r
yζ ∈ Cf,τ
 ≤ 2rϵ1.
By an averaging argument,
Pr
x
$←−Df
 Pr
f←Fn,n|τ
 ∨
ζ∈{0,1}r
yζ ∈ Cf,τ
 > 2rϵ
1
2
1
 ≤ ϵ
1
2
1 .
We derive,
Pr
x
$←−Df
[x is not (r, ϵ1) good with respect to τ ]
= Pr
x
$←−Df
[x is not (r, ϵ1) robust with respect to τ ] +
Pr
x
$←−Df
[x is popular with respect to τ ]
≤ ϵ
1
2
1 +
|τ |
2n
+
q̃
2
n
4
.
Next, we wish to ensure that all possible chaining values
generated from a good point also become good points. We
need the following definition.
Definition 19. Let x be an (r, ϵ1)-good point with respect to
τ . We say y is eligible for (τ, x) if
1) y is an (r, ϵ1)-good point with respect to τ .
2) for τ ′ = τ ∪ (x, y), it holds that y is (r, ϵ1)-good point
with respect to τ ′.
Now we are ready to state our main tool.
Proposition 20. Let x be ϵ1-good point with respect to τ .
Pr
y
$←−Df
[y is not eligible with respect to (τ, x)]
≤ ϵ
1
2
1 +
|τ |
2n
+
q̃ + 2r
2
n
4
.
Proof. The idea of the proof is to show that if we sample a
point uniformly at random from Df , then by Lemma 18, with
high probability, the point is (r, ϵ1)-good with respect to τ .
That means
Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(f(y)⊕ b′0n−r ∈ Cf,τ ′)

≤ 2r
(
ϵ
1
2
1 +
|τ |
2n
+
|τ |
2
n
2
)
.
Now, if it also holds that (f(y) ⊕ b′0n−r) ̸↠ x for any b′ ∈
{0, 1}r, the point y will remain ϵ1-good with respect to τ ∪
(x, y). To prove it formally, we consider the following events.
1) y-is-bad: y is not (r, ϵ1)-good with respect to τ .
2) x-is-queried: Pr
f
$←−Fn,n|τ
[(f(y)⊕ b′0n−r) ↠ x] ≥ 1
2
n
2
for some b′ ∈ {0, 1}r.
The following lemma (to be proved in Section IV-C) says that
if the above two events do not occur, then f(y) is an (r, ϵ1)-
good point with respect to τ ′.
9
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
Lemma 21. Suppose y is such that the event
¬y-is-bad∧¬x-is-queried holds. Then it holds that
y is (r, ϵ1)-good with respect to τ ′ = τ ∪ (x, y).
Pr
f
$←−Γτ′
 ∨
b′∈{0,1}r
(f(y)⊕ b′0n−r ∈ Cf,τ ′)

≤ 2r
(
ϵ
1
2
1 +
|τ |+ 1
2n
+
|τ |+ 1
2
n
2
)
.
Thus to prove Proposition 20, we need to bound the probability
of the events y-is-bad and x-is-queried. By Lemma 18,
Pr
y
$←−Df
[y-is-bad] ≤ ϵ
1
2
1 +
|τ |
2n
+
q̃
2
n
4
.
Finally, by the definition of popular points,
Pr
y
$←−Df
[x-is-queried] = 2r Pr
z
$←−Df
[x is favourite of z] ≤ 2r
2
n
4
.
This finishes the proof of Proposition 20.
Bounding Probability of Winning Force-Crook. We are
ready to bound the success probability of any adversary in
the Force-Crook game against the sponge construction when
the underlying primitive is a random function f : {0, 1}n →
{0, 1}n. Specifically, we shall show that the adversary can not
force a crooked chaining input for any query made by C.
Bad events. Recall that the adversary makes at most q2 many
queries to the oracle Cf . Each such query leads to ℓ+s many
calls (referred to as chaining queries) to f made by C. We con-
sider these chaining queries to be a sequence of σ = q2(ℓ+s)
many queries. By saying ith query, we denote the ith chaining
query from this sequence. We consider the following bad
events. The first bad event (CrookedFirstInput) occurs
if, for any message, the first chaining value is crooked. We
set the second bad event (BadChain) if for some message
queried by the distinguisher, we get a chaining value that is
not (r, ϵ1)-good as defined in Definition 17.
1) CrookedFirstInput. We say a bad event occurs if for
the initial random R, for some m0 ∈ {0, 1}r,
Pr
f
$←−Γτ̃
[R⊕m00
n−r ∈ Cf,τ̃ ] ≥ 2r
(
ϵ
1
2
1 +
q1
2n
)
.
2) BadChain. We say the ith chaining query xi raises bad
event (denoted by BadChaini) if xi is not (r, ϵ1)-good
with respect to the (up to that query) transcript τ . We
define BadChain
def
= ∪σi=1BadChaini.
Note that, for standard indifferentiability proofs, we usually
consider a bad event when a chaining query input collides with
some unchained query (made by the adversary to the oracle
f ) input. In our setting, such unchained queries are part of the
transcript, and the definition of good points ensures that the
chaining query does not result in such collisions.
Bounding Probabilities of Bad Events. First, we bound the
probability of CrookedFirstInput. From the definition of
ϵ-subversion, when the probabilities are taken over f
$←− Γτ̃
and x
$←− Df
Pr [x ∈ Cf,τ̃ ] ≤ ϵ1.
By an averaging argument, we get that
Pr
R
$←−Df
[
Pr
f
$←−Γτ̃
[R ∈ Cf,τ̃ ] > ϵ
1
2
1
]
≤ ϵ
1
2
1 .
Thus we bound
Pr
R
$←−Df
[CrookedFirstInput] ≤ 2rϵ
1
2
1 . (3)
Next, we bound Pr[BadChain]. For this case, we derive
Pr[BadChain] =Pr[BadChain1]+
σ∑
j=2
Pr[BadChainj |
j−1∧
j′=1
¬BadChainj′ ].
We start with bounding Pr[BadChain1]. As R is uniformly
chosen, from Lemma 18
Pr[BadChain1]
= Pr
R
$←−Df
[R is not (r, ϵ1) -good with respect to. τ̃ ]
≤ ϵ
1
2
1 +
q1
2n
+
q̃
2
n
4
.
Consider the ith chaining query xi where i > 1. Let τi denote
the transcript up to ith query. We find the chaining query xk,
queried before xi (k < i) such that
xi = f(xk)⊕ b0n−r for some b ∈ {0, 1}r.
Given
∧i−1
j′=1 ¬BadChainj′ , we conclude xk is (r, ϵ1)-good.
If f(xk)⊕ b0n−r is not (r, ϵ1)-good with respect to τk+1, this
means f(xk)⊕b0n−r was not eligible with respect to (τk, xk)
for some b ∈ {0, 1}r. Using Proposition 20, for f $←− Γτk ,
Pr
 ∨
b∈{0,1}r
(f(xk)⊕ b0n−r) is not eligible w.r.t. (τk, xk)

≤ 2r
(
ϵ
1
2
1 +
q̃ + 2r
2
n
4
+
k
2n
)
.
Thus we get
Pr
BadChainj |
j−1∧
j′=1
¬BadChainj′

≤ 2r
(
ϵ
1
2
1 +
q̃ + 2r
2
n
4
+
j
2n
)
.
Taking sum over all j we get
Pr[BadChain] ≤ 2r
(
σϵ
1
2
1 +
σ(q̃ + 2r)
2
n
4
+
σ2
2n
)
. (4)
Bounding the Force-Crook Advantage. Let Wi denote the
event that the input to the ith query is crooked.
Pr[A wins the game Force-Crook]
≤ Pr[CrookedFirstInput] + Pr[BadChain]+
σ∑
i=1
Pr[Wi | ¬CrookedFirstInput
∧
¬BadChain].
10
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
As we already have the bound on the probabilities of the bad
events, we need to bound
Pr
[
Wi | ¬CrookedFirstInput
∧
¬BadChain
]
.
Consider the ith chaining query xi where i > 1. We find the
chaining query xk previous to xi (k < i). As ¬BadChain
holds, xk is (r, ϵ′)-good with respect to the partial transcript
τk.
Pr
f
$←−Γτk
 ∨
b∈{0,1}r
(
f(xk)⊕ b0n−r ∈ Cf,τk
)
≤ 2r
(
ϵ
1
2
1 +
k
2n
+
k
2
n
2
)
.
This implies
Pr
f
$←−Γτk
[xi ∈ Cf,τk ] ≤ 2r
(
ϵ
1
2
1 +
k
2n
+
k
2
n
2
)
≤ 2r
(
ϵ
1
2
1 +
i
2n
+
i
2
n
2
)
.
As the responses of all the f queries are answered truthfully,
for a f
$←− Γτk , f ∪ τk is a uniform random element of Γτ̃ .
Thus we get, for f $←− Γτ̃
Pr[xi ∈ Cf,τ̃ | ¬CrookedFirstInput ∧ ¬BadChain]
≤ 2r
(
ϵ
1
2
1 +
i
2n
+
i
2
n
2
)
.
Taking the sum over all i, we get
σ∑
i=1
Pr
f
$←−Γτ̃
[Wi | ¬CrookedFirstInput ∧ ¬BadChain]
≤
σ∑
i=1
2r
(
ϵ
1
2
1 +
i
2n
+
i
2
n
2
)
≤ 2r
(
σϵ
1
2
1 +
σ2
2n
+
σ2
2
n
2
)
.
(5)
Finally, adding Inequalities (3),(4), and (5) we get
Pr[A wins the game Force-Crook]
≤ O
(
2r × σ ×
(
ϵ
1
2
1 +
(q̃ + 2r)
2
n
4
+ ϵ
1
2
1 +
σ
2n
+
σ
2
n
2
))
.
This finishes the proof of Lemma 13 and thus the proof of
Theorem 11.
C. Proof of Lemma 21
Proof. Lemma 21 considers a transcript τ and points
x, y ∈ {0, 1}n. Suppose y is such that the condi-
tion (¬y-is-bad∧¬x-is-queried) holds. The condition
(¬y-is-bad) implies that y is a (r, ϵ1)-good point with respect
to τ . The lemma says that y is a (r, ϵ1)-good point with respect
to τ ′ = τ ∪ (x, y).
Given the conditions and following Definition 17, we get that
y is (r, ϵ1)-robust with respect to τ and y is not popular. By
Definition 14 we have
Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(f(y)⊕ b′0n−r ∈ Cf,τ )

≤ 2r
(
ϵ
1
2
1 +
|τ |
2n
+
|τ |
2
n
2
)
.
Our target is to bound the probability that y is not (r, ϵ1)-
good with respect to τ ′. Let Yb′ denote f(y)⊕ b′0n−r. First,
we bound the probability (over f
$←− Γτ ′ ) that Yb′ is not a
(r, ϵ1)-robust point with respect to τ ′ = τ ∪ (x, y). We have
two cases: i) Yb′ = x for some b′ ∈ {0, 1}r, ii) Yb′ ∈ Cf,τ for
some b′ ∈ {0, 1}r. By union bound
Pr
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ ′)

≤ Pr
 ∨
b′∈{0,1}r
(Yb′ = x)
+ Pr
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )
 .
(6)
The term Pr[
∨
b′∈{0,1}r (Yb′ = x)] is bounded above by 2r
2n .
For the second term, we can bound the probability (over
f
$←− Γτ ′ ) as
Pr
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )

≤ Pr
 ∨
b′∈{0,1}r
(Yb′ ↠f x)
+
Pr
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )
∧ ∧
b′∈{0,1}r
(Yb′ ̸↠f x)
 .
(7)
Bounding Pr
[(∨
b′∈{0,1}r (Yb′ ∈ Cf,τ )
)
∧∧
b′∈{0,1}r (Yb′ ̸↠f x)
]
.
Similar to the first case, we show the probability is identical
for both the transcripts.
Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )
∧ ∧
b′∈{0,1}r
(Yb′ ̸↠f x)

=
∑
z
Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )
∧
∧
b′∈{0,1}r
(Yb′ ̸↠f x)
∧
f(x) = z
 .
11
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
The last term is equal to
2n Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )
∧
∧
b′∈{0,1}r
(Yb′ ̸↠f x)
∧
f(x) = y

= Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )
∧
∧
b′∈{0,1}r
(Yb′ ̸↠f x)
∣∣∣f(x) = y

= Pr
f
$←−Γτ′
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )
∧
∧
b′∈{0,1}r
(Yb′ ̸↠f x)
 .
Bounding Pr
[∨
b′∈{0,1}r (Yb′ ↠f x)
]
. We first show that the
probability that Yb′ queries x is the same for all the transcripts
irrespective of where the value of f(x) is set. In other words,
we shall establish that the probability that Yb′ queries x is the
same in both transcripts τ and τ ′.
Pr
f
$←−Fn,n|τ
 ∧
b′∈{0,1}r
(Yb′ ̸↠f x)

=
∑
z
Pr
f
$←−Fn,n|τ
 ∧
b′∈{0,1}r
(Yb′ ̸↠f x)
∧
f(x) = z

= 2n Pr
f
$←−Fn,n|τ
 ∧
b′∈{0,1}r
(Yb′ ̸↠f x)
∧
f(x) = y

= Pr
f
$←−Fn,n|τ
 ∧
b′∈{0,1}r
(Yb′ ̸↠f x)
 ∣∣∣ f(x) = y

= Pr
f
$←−Γτ′
 ∧
b′∈{0,1}r
(Yb′ ̸↠f x)
 .
Now taking the complement
Pr
f
$←−Γτ′
 ∨
b′∈{0,1}r
(Yb′ ↠f x)

= 1− Pr
f
$←−Γτ′
 ∧
b′∈{0,1}r
(Yb′ ↠f x)

= 1− Pr
f
$←−Fn,n|τ
 ∧
b′∈{0,1}r
(Yb′ ↠f x)

= Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(Yb′ ↠f x)
 .
The Final Derivation. Now we are ready to bound
Pr
f
$←−Γτ′
[
∨
b′∈{0,1}r (Yb′ ∈ Cf,τ ′)]. In the following deriva-
tion, we use inequality 6 in the first step, inequality 7 in the
second step, and the above two cases in the third step.
Pr
f
$←−Γτ′
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ ′)

≤ Pr
f
$←−Γτ′
 ∨
b′∈{0,1}r
(Yb′ = x)
+
Pr
f
$←−Γτ′
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )

≤ 2r
2n
+ Pr
f
$←−Γτ′
 ∨
b′∈{0,1}r
(Yb′ ↠f x)
+
Pr
f
$←−Γτ′
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )
∧ ∧
b′∈{0,1}r
(Yb′ ̸↠f x)

The last line derives to
=
2r
2n
+ Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(Yb′ ↠f x)
+
Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )
∧ ∧
b′∈{0,1}r
(Yb′ ̸↠f x)

≤ 2r
2n
+ Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(Yb′ ↠f x)
+
Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )

≤ 2r
2n
+
2r
2
n
2
+ 2r
(
ϵ
1
2
1 +
|τ |
2n
+
|τ |
2
n
2
)
.
In the last line we used, as the event (¬y-is-bad) holds, for
f
$←− Fn,n|τ ,
Pr
 ∨
b′∈{0,1}r
(Yb′ ∈ Cf,τ )
 ≤ 2r
(
ϵ
1
2
1 +
|τ |
2n
+
|τ |
2
n
2
)
.
and as the event (¬x-is-queried) holds
Pr
f
$←−Fn,n|τ
 ∨
b′∈{0,1}r
(Yb′ ↠f x)
 ≤ 2r
2
n
2
.
V. CROOKED-INDIFFERENTIABILITY OF
MERKLE-DAMGÅRD
In this section, we show that the classical Merkle-Damgård
construction using n+1-to-n-bit compression function f and
instantiated with a random initialization vector is crooked-
indifferentiable from a random oracle.
12
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
Merkle-Damgård Construction. The details of the param-
eters of Merkle-Damgård construction are listed below. The
construction is shown in Figure 8
pad(M) = M1 M2 M3 · · · Mµ
fh1 = R f
h2
f
h3
f
hµ
· · · Cf (M)
Fig. 8. Merkle-Damgård mode of operation with random IV
TARGET HASH FUNCTION. The construction implements a
hash function H : {0, 1}µ → {0, 1}n.
PRIMITIVES. The underlying primitive of the construction is
an n+ 1-to-n bit function f : {0, 1}n+1 → {0, 1}n.
PUBLIC RANDOMNESS. The public randomness is
R
$←− {0, 1}n .
MESSAGE PREPROCESSING. The indifferentiability of
Merkle-Damgård requires the message space to be prefix-
free. We assume the same. Note if we consider the fixed
input length hash function, we do not need any prefix-free
padding. The input message M ∈ {0, 1}µ is parsed as bits
M1M2 . . .Mµ.
Our main result in this section is Theorem 22.
Theorem 22. Let f : {0, 1}n+1 → {0, 1}n be a random
function and Cf : {0, 1}µ → {0, 1}n be the Merkle-Damgård
construction. There exists a simulator S such that for all
((q1, q̃, ϵ), q2)-crooked distinguisher A = (A1,A2)
Advcrooked-indiff
A,(C,f)
≤ O
(
σ ×
(
ϵ
1
2
1 +
q̃
2
n
4
+ ϵ
1
2
1 +
σ
2n
+
σ
2
n
2
))
where ϵ1 = ϵ + q1
2n q2 is the total number of construction
queries made by A2 and σ is the total number of blocks in
the queries made by A2.
The Theorem follows from Theorem 23 and Lemma 24.
Classical Indifferentiability of Merkle-Damgård Construc-
tion. We recall the classical indifferentiability result of
Merkle-Damgård mode from [18] in our notations.
Theorem 23 (Theorem 3.1 in [18]). Prefix-free Merkle-
Damgård mode instantiating Cf : {0, 1}µ → {0, 1}n is
(q2, qsim, δi)-indifferentiable from a random oracle for qsim =
O(σ2) and δi = O(σ
2
2n ) where σ is the total number of blocks
in the queries made by the distinguisher.
Bounding Probability of Winning Force-Crook.
Lemma 24. Let C be the Merkle-Damgård construction
considered in this section.
Insecforce−crookC,(q1,q̃),(q2,qs)
≤ O
(
σ ×
(
ϵ
1
2
1 +
q̃
2
n
4
+ ϵ
1
2
1 +
σ
2n
+
σ
2
n
2
))
where σ = q2µ+ qS .
The proof of the lemma works exactly as the proof of
Lemma 13. The only difference is in the parameters of the
definitions. We skip the proof.
VI. CONCLUDING DISCUSSION
We wish to finish the paper with some discussion on the
possibility and challenges of extending our proof to sponge
construction with permutations. Finally, we present some
research directions we find interesting.
A. Sponge Construction Based on Permutation
The reader may note that the sponge construction in practice
is based on a fixed permutation where the adversary is allowed
to make inverse queries. We attempted to extend our proof for
the permutations as well but could not solve one key issue.
One main step (Proposition 20) in our proof was to show that
a good point y with respect to a partial transcript τ remains a
good point if another good point x is mapped to y. In order to
prove that we argued that the queries of f̃(y) and f̃(f(y)) are
independent from the preimage of y. Thus we could include
a good point and extend the transcript without invoking bad.
This argument does not hold when f is a permutation.
In that case f̃ can indeed make f−1 queries. Extending
the transcript with good points and simultaneously handling
inverse queries seem to require a different technique. One
could try adding additional ingredients like xoring independent
random strings in each iteration. But that would increase the
number of random strings to be linear with the message length,
and the resulting construction would not be practical.
B. Conclusion and Future Research Directions
Subversion Resistance of hash function is an important
security property when used to replace random oracles in the
kleptographic setting. This work is the first to analyze the
security of practically used hashing modes in the crooked in-
differentiability framework. Our techniques show how to prove
crooked indifferentiability when the underlying primitive is
modelled as a random function. The first natural research
problem would be to consider the crooked indifferentiability
of sponge construction in the random permutation model.
It would also be interesting to consider proving crooked
indifferentiability of the ideal cipher constructions like the
Feistel Network. Finally, extending crooked indifferentiability
to the multi-stage setting like reset indifferentiability would
also be interesting.
ACKNOWLEDGEMENTS
We sincerely thank the reviewers of this and the previ-
ous versions of the work for their insightful comments on
the content and the presentation of the paper. Their inputs
significantly improved the work. Part of this work was done
when RB was in NISER, India. RB is supported by EPSRC
EP/R007128/1. For the purpose of open access, the authors
has applied a Creative Commons Attribution (CC BY) license
to any accepted manuscript version arising.
REFERENCES
[1] Andreeva, E., Mennink, B., Preneel, B.: On the indifferentiability of
the Grøstl hash function. In: Garay, J.A., Prisco, R.D. (eds.) SCN
10. LNCS, vol. 6280, pp. 88–105. Springer, Heidelberg (Sep 2010).
https://doi.org/10.1007/978-3-642-15317-4 7 I
13
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
[2] Ateniese, G., Francati, D., Magri, B., Venturi, D.: Public immuniza-
tion against complete subversion without random oracles. In: Deng,
R.H., Gauthier-Umaña, V., Ochoa, M., Yung, M. (eds.) ACNS 19.
LNCS, vol. 11464, pp. 465–485. Springer, Heidelberg (Jun 2019).
https://doi.org/10.1007/978-3-030-21568-2 23 I
[3] Ateniese, G., Kiayias, A., Magri, B., Tselekounis, Y., Venturi, D.:
Secure outsourcing of cryptographic circuits manufacturing. In: Provable
Security - 12th International Conference, ProvSec 2018, Jeju, South
Korea, October 25-28, 2018, Proceedings. pp. 75–93 (2018), https:
//doi.org/10.1007/978-3-030-01446-9 5 I
[4] Ateniese, G., Magri, B., Venturi, D.: Subversion-resilient signatures:
Definitions, constructions and applications. Theor. Comput. Sci. 820,
91–122 (2020), https://doi.org/10.1016/j.tcs.2020.03.021 I
[5] Bellare, M., Hoang, V.T.: Resisting randomness subversion: Fast de-
terministic and hedged public-key encryption in the standard model.
In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015, Part II.
LNCS, vol. 9057, pp. 627–656. Springer, Heidelberg (Apr 2015).
https://doi.org/10.1007/978-3-662-46803-6 21 I
[6] Bellare, M., Paterson, K.G., Rogaway, P.: Security of symmetric en-
cryption against mass surveillance. In: Garay, J.A., Gennaro, R. (eds.)
CRYPTO 2014, Part I. LNCS, vol. 8616, pp. 1–19. Springer, Heidelberg
(Aug 2014). https://doi.org/10.1007/978-3-662-44371-2 1 I
[7] Bellare, M., Rogaway, P.: The security of triple encryption and a
framework for code-based game-playing proofs. In: Vaudenay, S. (ed.)
EUROCRYPT 2006. LNCS, vol. 4004, pp. 409–426. Springer, Heidel-
berg (May / Jun 2006). https://doi.org/10.1007/11761679 25 II
[8] Bertoni, G., Daemen, J., Peeters, M., Assche, G.: Sponge functions.
ECRYPT Hash Workshop 2007 (01 2007) IV-A
[9] Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: On the indif-
ferentiability of the sponge construction. In: Smart, N.P. (ed.) EURO-
CRYPT 2008. LNCS, vol. 4965, pp. 181–197. Springer, Heidelberg
(Apr 2008). https://doi.org/10.1007/978-3-540-78967-3 11 I, I-A, IV-A,
IV-A, 12, IV-A
[10] Bhattacharyya, R., Mandal, A.: On the indifferentiability of fugue and
luffa. In: Applied Cryptography and Network Security - 9th International
Conference, ACNS 2011, Nerja, Spain, June 7-10, 2011. Proceedings.
pp. 479–497 (2011), https://doi.org/10.1007/978-3-642-21554-4 28 I
[11] Bhattacharyya, R., Mandal, A., Nandi, M.: Indifferentiability charac-
terization of hash functions and optimal bounds of popular domain
extensions. In: Progress in Cryptology - INDOCRYPT 2009, 10th
International Conference on Cryptology in India, New Delhi, India,
December 13-16, 2009. Proceedings. pp. 199–218 (2009), https://doi.
org/10.1007/978-3-642-10628-6 14 I
[12] Bhattacharyya, R., Mandal, A., Nandi, M.: Security analysis of the
mode of JH hash function. In: Hong, S., Iwata, T. (eds.) Fast Software
Encryption, 17th International Workshop, FSE 2010,. Lecture Notes in
Computer Science, vol. 6147, pp. 168–191. Springer (2010) I
[13] Bhattacharyya, R., Nandi, M., Raychaudhuri, A.: Crooked indifferen-
tiability of enveloped XOR revisited. In: Progress in Cryptology -
INDOCRYPT 2021 - 22nd International Conference on Cryptology in
India, Jaipur, India, December 12-15, 2021, Proceedings. pp. 73–92
(2021), https://doi.org/10.1007/978-3-030-92518-5 4 I
[14] Chang, D., Nandi, M.: Improved indifferentiability security analy-
sis of chopMD hash function. In: Nyberg, K. (ed.) FSE 2008.
LNCS, vol. 5086, pp. 429–443. Springer, Heidelberg (Feb 2008).
https://doi.org/10.1007/978-3-540-71039-4 27 I
[15] Checkoway, S., Niederhagen, R., Everspaugh, A., Green, M., Lange,
T., Ristenpart, T., Bernstein, D.J., Maskiewicz, J., Shacham, H.,
Fredrikson, M.: On the practical exploitability of dual EC in
TLS implementations. In: Proceedings of the 23rd USENIX Secu-
rity Symposium, San Diego, CA, USA, August 20-22, 2014. pp.
319–335 (2014), https://www.usenix.org/conference/usenixsecurity14/
technical-sessions/presentation/checkoway I
[16] Chow, S.S.M., Russell, A., Tang, Q., Yung, M., Zhao, Y., Zhou, H.:
Let a non-barking watchdog bite: Cliptographic signatures with an
offline watchdog. In: Public-Key Cryptography - PKC 2019 - 22nd
IACR International Conference on Practice and Theory of Public-Key
Cryptography, Beijing, China, April 14-17, 2019, Proceedings, Part I.
pp. 221–251 (2019), https://doi.org/10.1007/978-3-030-17253-4 8 I
[17] Coretti, S., Dodis, Y., Guo, S., Steinberger, J.P.: Random oracles and
non-uniformity. In: Nielsen, J.B., Rijmen, V. (eds.) EUROCRYPT 2018,
Part I. LNCS, vol. 10820, pp. 227–258. Springer, Heidelberg (Apr / May
2018). https://doi.org/10.1007/978-3-319-78381-9 9 I
[18] Coron, J.S., Dodis, Y., Malinaud, C., Puniya, P.: Merkle-Damgård
revisited: How to construct a hash function. In: Shoup, V. (ed.)
CRYPTO 2005. LNCS, vol. 3621, pp. 430–448. Springer, Heidelberg
(Aug 2005). https://doi.org/10.1007/11535218 26 I, II-A, V, 23
[19] Degabriele, J.P., Farshim, P., Poettering, B.: A more cautious approach
to security against mass surveillance. In: Leander, G. (ed.) FSE 2015.
LNCS, vol. 9054, pp. 579–598. Springer, Heidelberg (Mar 2015).
https://doi.org/10.1007/978-3-662-48116-5 28 I
[20] Degabriele, J.P., Paterson, K.G., Schuldt, J.C.N., Woodage, J.: Back-
doors in pseudorandom number generators: Possibility and impossibil-
ity results. In: Robshaw, M., Katz, J. (eds.) CRYPTO 2016, Part I.
LNCS, vol. 9814, pp. 403–432. Springer, Heidelberg (Aug 2016).
https://doi.org/10.1007/978-3-662-53018-4 15 I
[21] Dodis, Y., Ganesh, C., Golovnev, A., Juels, A., Ristenpart, T.: A formal
treatment of backdoored pseudorandom generators. In: Oswald, E.,
Fischlin, M. (eds.) EUROCRYPT 2015, Part I. LNCS, vol. 9056, pp.
101–126. Springer, Heidelberg (Apr 2015). https://doi.org/10.1007/978-
3-662-46800-5 5 I
[22] Dodis, Y., Guo, S., Katz, J.: Fixing cracks in the concrete: Random
oracles with auxiliary input, revisited. In: Coron, J.S., Nielsen, J.B. (eds.)
EUROCRYPT 2017, Part II. LNCS, vol. 10211, pp. 473–495. Springer,
Heidelberg (Apr / May 2017). https://doi.org/10.1007/978-3-319-56614-
6 16 I
[23] Dodis, Y., Reyzin, L., Rivest, R.L., Shen, E.: Indifferentiability of
permutation-based compression functions and tree-based modes of op-
eration, with applications to MD6. In: Dunkelman, O. (ed.) FSE 2009.
LNCS, vol. 5665, pp. 104–121. Springer, Heidelberg (Feb 2009).
https://doi.org/10.1007/978-3-642-03317-9 7 I
[24] Maurer, U.M., Renner, R., Holenstein, C.: Indifferentiability, impos-
sibility results on reductions, and applications to the random oracle
methodology. In: Naor, M. (ed.) TCC 2004. LNCS, vol. 2951, pp. 21–
39. Springer, Heidelberg (Feb 2004). https://doi.org/10.1007/978-3-540-
24638-1 2 I, II-A
[25] Mennink, B.: Indifferentiability of double length compression functions.
In: Stam, M. (ed.) 14th IMA International Conference on Cryptography
and Coding. LNCS, vol. 8308, pp. 232–251. Springer, Heidelberg (Dec
2013). https://doi.org/10.1007/978-3-642-45239-0 14 I
[26] Mironov, I., Stephens-Davidowitz, N.: Cryptographic reverse firewalls.
In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015, Part II.
LNCS, vol. 9057, pp. 657–686. Springer, Heidelberg (Apr 2015).
https://doi.org/10.1007/978-3-662-46803-6 22 I
[27] Naito, Y.: Indifferentiability of double-block-length hash function with-
out feed-forward operations. In: Pieprzyk, J., Suriadi, S. (eds.) ACISP
17, Part II. LNCS, vol. 10343, pp. 38–57. Springer, Heidelberg (Jul
2017) I
[28] Russell, A., Tang, Q., Yung, M., Zhou, H.S.: Cliptography: Clipping
the power of kleptographic attacks. In: Cheon, J.H., Takagi, T. (eds.)
ASIACRYPT 2016, Part II. LNCS, vol. 10032, pp. 34–64. Springer,
Heidelberg (Dec 2016). https://doi.org/10.1007/978-3-662-53890-6 2 I
[29] Russell, A., Tang, Q., Yung, M., Zhou, H.S.: Generic semantic security
against a kleptographic adversary. In: Thuraisingham, B.M., Evans, D.,
Malkin, T., Xu, D. (eds.) ACM CCS 2017. pp. 907–922. ACM Press
(Oct / Nov 2017). https://doi.org/10.1145/3133956.3133993 I
[30] Russell, A., Tang, Q., Yung, M., Zhou, H.S.: Correcting subverted
random oracles. In: Shacham, H., Boldyreva, A. (eds.) CRYPTO 2018,
Part II. LNCS, vol. 10992, pp. 241–271. Springer, Heidelberg (Aug
2018). https://doi.org/10.1007/978-3-319-96881-0 9 I, I-A, I-C, II-B,
II-B, 6
[31] Young, A., Yung, M.: The dark side of “black-box” cryptography,
or: Should we trust capstone? In: Koblitz, N. (ed.) CRYPTO’96.
LNCS, vol. 1109, pp. 89–103. Springer, Heidelberg (Aug 1996).
https://doi.org/10.1007/3-540-68697-5 8 I
[32] Young, A., Yung, M.: Kleptography: Using cryptography against cryp-
tography. In: Fumy, W. (ed.) EUROCRYPT’97. LNCS, vol. 1233, pp.
62–74. Springer, Heidelberg (May 1997). https://doi.org/10.1007/3-540-
69053-0 6 I
Rishiraj Bhattacharyya received his PhD from Indian Statistical Institute,
Kolkata in 2011. He is currently working at the University of Birmingham,
UK. Rishiraj is interested in applied probability and cryptography.
14
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply. 
https://doi.org/10.1007/978-3-030-01446-9_5
https://doi.org/10.1007/978-3-030-01446-9_5
https://doi.org/10.1016/j.tcs.2020.03.021
https://doi.org/10.1007/978-3-642-21554-4_28
https://doi.org/10.1007/978-3-642-10628-6_14
https://doi.org/10.1007/978-3-642-10628-6_14
https://doi.org/10.1007/978-3-030-92518-5_4
https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/checkoway
https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/checkoway
https://doi.org/10.1007/978-3-030-17253-4_8
Mridul Nandi received the B.Stat. degree, the M.Stat. degree, and the Ph.D.
degree in computer science from the Indian Statistical Institute, Kolkata,
India, in 1999, 2001, and 2005, respectively. Since 2011, he has been a
Professor with the Applied Statistics Unit, Indian Statistical Institute. He
also holds an honorary adjunct professor position in IAI-TCG CREST. His
current research interests include design, security proof, and cryptanalysis of
symmetric encryption schemes.
Anik Raychaudhuri received his B.Math and M.Math. degree from Indian
Statistical Institute, Bangalore in 2014 and 2017 respectively. He is currently
a PhD student at Indian Statistical Institute, Kolkata. His current research
interests lies primarily in analysing the security of various encryption scheme.
15
This article has been accepted for publication in IEEE Transactions on Information Theory. This is the author's version which has not been fully edited and 
content may change prior to final publication. Citation information: DOI 10.1109/TIT.2023.3238115
© 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 09:17:38 UTC from IEEE Xplore.  Restrictions apply.