A Secure Personal Health Record Sharing System with Key Aggregate Dynamic Searchable Encryption
Citation: Oh, J.; Lee, J.; Kim, M.; Park,
Y.; Park, K.; Noh, S. A Secure
Personal Health Record Sharing
System with Key Aggregate Dynamic
Searchable Encryption. Electronics
2022, 11, 3199. https://doi.org/10.
3390/electronics11193199
Academic Editors: Juan M. Corchado,
Byung-Gyu Kim, Carlos A. Iglesias,
In Lee, Fuji Ren and Rashid
Mehmood
Received: 7 September 2022
Accepted: 30 September 2022
Published: 6 October 2022
Publisher’s Note: MDPI stays neutral
with regard to jurisdictional claims in
published maps and institutional affil-
iations.
Copyright: © 2022 by the authors.
Licensee MDPI, Basel, Switzerland.
This article is an open access article
distributed under the terms and
conditions of the Creative Commons
Attribution (CC BY) license (https://
creativecommons.org/licenses/by/
4.0/).
electronics
Article
A Secure Personal Health Record Sharing System with Key
Aggregate Dynamic Searchable Encryption
Jihyeon Oh 1 , JoonYoung Lee 1 , MyeongHyun Kim 1 , Youngho Park 1,2,* and KiSung Park 3
and SungKee Noh 3
1 School of Electronic and Electrical Engineering, Kyungpook National University, Daegu 41566, Korea
2 School of Electronics Engineering, Kyungpook National University, Daegu 41566, Korea
3 Blockchain Research Section, Electronics and Telecommunications Research Institute, Daejeon 34129, Korea
* Correspondence: parkyh@knu.ac.kr; Tel.: +82-53-950-7842
Abstract: Recently, as interest in individualized health has increased, the Personal Health Record
(PHR) has attracted a lot of attention for prognosis predictions and accurate diagnoses. Cloud servers
have been used to manage the PHR system, but privacy concerns are evident since cloud servers
process the entire PHR, which contains the sensitive information of patients. In addition, cloud
servers centrally manage the PHR system so patients lose direct control over their own PHR and
cloud servers can be an attractive target for malicious users. Therefore, ensuring the integrity and
privacy of the PHR and allocating authorization to users are important issues. In this paper, we
propose a secure PHR sharing system using a blockchain, InterPlanetary File System (IPFS), and
smart contract to ensure PHR integrity and secure verification. To guarantee the patient’s authority
over the management of his/her own PHR, as well as provide convenient access, we suggest a key
aggregate dynamic searchable encryption. We prove the security of the proposed scheme through
informal and formal analyses including an Automated Verification of Internet Security Protocols
and Applications (AVISPA) simulation, Burrows–Abadi–Needham (BAN) logic, and security-model-
based games. Furthermore, we estimate the computational costs of the proposed scheme using a
Multiprecision Integer and Rational Arithmetic Cryptographic Library (MIRACL) and compare the
results with those of previous works.
Keywords: personal health record; key aggregate dynamic searchable encryption; blockchain;
interplanetary file system
1. Introduction
With the increasing interest in and efforts to manage one’s health and prevent disease,
the Personal Health Record (PHR) has attracted a lot of attention from various parties such
as academia, industries, and the government. According to the International Organization
for Standardization (ISO), a PHR is the representation of information related to health,
which can be standalone or an integration of health information from multiple sources.
The ISO also indicates that individuals should be allowed to manage, control, and access
their own PHRs [1]. This means that the PHR is a patient-oriented system [2] and patients
may want to share their PHRs with users such as medical professionals for prognosis
predictions, accurate diagnoses, and health consulting. Due to the storage requirements and
maintenance costs, patients often outsource their PHRs to third-party cloud servers. There
are some cloud-based healthcare applications such as MTBC PHR [3], CapzulePHR [4], and
My Medical [5]
However, cloud servers can be an attractive target for malicious users since a PHR
contains the sensitive information of a patient [6]. If malicious users abuse or modify
a PHR, the patient’s life could be put in danger or compromised due to misdiagnosis.
Patients must be able to decide which users can access their PHRs. Attribute-based search-
able encryption (ABSE), which is the integration of attribute-based encryption (ABE) and
Electronics 2022, 11, 3199. https://doi.org/10.3390/electronics11193199 https://www.mdpi.com/journal/electronics
https://doi.org/10.3390/electronics11193199
https://doi.org/10.3390/electronics11193199
https://creativecommons.org/
https://creativecommons.org/licenses/by/4.0/
https://creativecommons.org/licenses/by/4.0/
https://www.mdpi.com/journal/electronics
https://www.mdpi.com
https://orcid.org/0000-0001-8690-2125
https://orcid.org/0000-0002-8172-6182
https://orcid.org/0000-0003-4891-818X
https://orcid.org/0000-0002-0406-6547
https://orcid.org/0000-0002-6172-9175
https://doi.org/10.3390/electronics11193199
https://www.mdpi.com/journal/electronics
https://www.mdpi.com/article/10.3390/electronics11193199?type=check_update&version=2
Electronics 2022, 11, 3199 2 of 24
searchable encryption (SE), has been utilized to satisfy these requirements. ABSE provides
fine-grained search control by regulating how authorized users acquire trapdoors to search
for encrypted PHRs [7]. However, ABSE does not ensure patient-oriented sharing since it
requires a trusted third party (TTP) to set up the system and allocate keys to entities. In
addition, the decryption key size in ABSE is non-constant, which means that as the amount
of data to be decrypted increases, the size of the decryption key increases [8]. To solve
this problem, key aggregate searchable encryption (KASE) has been proposed for the data
owner (e.g. patient), which generates system parameters and allocates decryption keys to
users [9]. In addition, in KASE, the decryption key is a single constant aggregate key that
has compacted the decryption keys corresponding to the data. Therefore, KASE is suitable
for a PHR sharing system since it ensures the patient’s authority over his/her PHR and
solves the key management problem.
Although cryptosystems are used in cloud-based systems for the privacy of patients,
there are still non-negligible drawbacks. Storing PHRs on cloud servers means that patients
delegate the management rights to the cloud server so patients lose their self-determined
control over their personal information [10]. In addition, cloud servers are organized
centrally, where storage is typically owned and managed by a single entity. Since cloud
servers are usually not credible, they can steal or reveal PHRs by dishonestly performing
malicious operations and can provide forged search results to users [11]. So, the existence
of a centralized cloud server leads to the single-point-of-failure problem.
Researchers have considered a blockchain as a prospective solution to handle the
problems in cloud-based systems [12–15]. A blockchain is a peer-to-peer (P2P) decentralized
network that provides transparency, provenance, auditability, and security features, which
are advantageous in data-sharing applications [16]. A blockchain eliminates the need
for a third party by making the system secure and completely decentralized. However,
there are limitations for managing all PHRs on the network since storing large volumes
of data is expensive for a blockchain [17,18]. In addition, it does not guarantee scalability,
which is an important challenge in blockchains. In order to alleviate the storage problem
of blockchains, an InterPlanetary File System (IPFS) has been introduced. An IPFS is a
distributed content-addressable file system, where for each uploaded PHR, IPFS allocates a
unique hash as an identifier. By storing this identifier on the blockchain and using it as a
pointer, the IPFS can overcome the storage limitations inherent in blockchains.
In this paper, we propose a secure PHR sharing system by applying a blockchain and
an IPFS. We use KASE to ensure that patients retain authority over their records. However,
existing KASE schemes do not consider dynamic data search sharing tasks, which can incur
considerable computational costs since users must make repeated data request trapdoors.
Therefore, we suggest a key aggregate dynamic searchable encryption using a Linear Secret
Sharing Scheme (LSSS). The proposed system can ensure patient-oriented sharing.
1.1. Motivation, Methodology, and Contributions
A PHR contains the sensitive information of patients so it is necessary to restrict access
to users. ABSE has been utilized as a solution but it does not ensure that patients main-
tain authority over data management. In addition, ABSE suffers from key management
problems since the number of keys linearly increases depending on the complexity of the
corresponding access policy. Researchers have utilized KASE as a countermeasure but their
proposed schemes did not consider dynamic searches, which cause severe computational
costs for data requests. In addition, they still depend on cloud servers for data manage-
ment, which eliminates patients’ self-determined control over their personal information.
Guaranteeing patients’ rights and reducing unnecessary communication between users in
PHR sharing systems are indeed challenges. Therefore, we propose a secure PHR sharing
system model. We utilize a blockchain and an IPFS to share the PHRs in a decentralized
manner and handle the problems in cloud-based systems. We combine the KASE and
LSSS to provide convenient keyword searches for users to obtain data. The proposed
scheme provides essential security requirements such as the right to manage personal data,
Electronics 2022, 11, 3199 3 of 24
data integrity, transparency, and mutual authentication so our scheme has novel aspects
compared to other previous works. The main contributions are summarized as follows.
• We propose a secure PHR sharing system that ensures patients’ authority over their
personal records by suggesting a key aggregate dynamic searchable encryption. Thus,
patients can manage and regulate access to their own PHRs.
• We provide dynamic searches for allowing users to obtain specific PHRs with low
computational costs. We support dynamic searches using LSSS. In the proposed
scheme, users can generate a trapdoor with various keywords at the same time to
acquire a PHR.
• The proposed scheme utilizes a blockchain to provide data integrity and prevent the
single point of failure. In addition, we utilize a smart contract to realize the secure and
effective keyword searches and trapdoor verification.
• We store PHRs using an IPFS, which is a decentralized data storage system. Since the
IPFS is a content-addressable protocol generating unique hash values for stored PHRs,
it ensures the security of PHRs and avoids duplications.
1.2. Organization
The rest of the paper is organized as follows. We briefly cover previous works in
Section 2. Section 3 presents the system models and interprets the conceptual aspect to
assist with understanding this paper. Section 4 proposes a secure PHR sharing scheme.
We prove the security of the proposed scheme in Sections 5 and 6, including the BAN
logic, AVISPA simulation tool, INDistinguishability against the Chosen Plaintext Attack
(IND-CPA), INDistinguishability against the Chosen Keyword Attack (IND-CKA), and
INDistinguishability against the Keyword Guessing Attack (IND-KGA). We analyze and
compare the performance of the proposed scheme and existing schemes in Section 7.
Section 8 presents the conclusions of this paper.
2. Related Works
Over the past few years, many studies have been conducted on secure PHR sharing us-
ing access control cryptosystems. In 2013, Li et al. [19] proposed a cloud-computing-based
PHR sharing system using ABE since PHRs should only be available to authorized users.
In 2015, Liu et al. [20] proposed a PHR sharing system based on cloud computing that
employed ciphertext-policy attribute-based signcryption scheme. They suggested a method
where the data owner signs the PHR with his/her own private key to protect the unau-
thorized modification of the PHR. They claimed that this scheme provided confidentiality
through indistinguishable against chosen ciphertext attacks. However, Rao [21] proved that
Lie et al.’s claim was incorrect and ccould not offer confidentiality in indistinguishability of
ciphertexts under a selective encryption predicate and adaptive chosen ciphertext attack
(IND-sEP-CCA2) security model. To supplement this problem, Rao proposed a cloud-based
PHR sharing system that provides confidentiality using the IND-sEP-CCA2 model. How-
ever, these schemes [19–21] did not consider dynamic keyword search processes to access
PHRs, which can cause considerable computational costs to users.
To address this problem, Zhang et al. [22] proposed a cloud-based PHR sharing system
that provided dynamic keyword searches. However, Peng et al. [23] mentioned that Zhang
et al.’s scheme was inefficient for queries since the ciphertexts of different data owners were
matched against the same query. By considering these problems, Peng et al. suggested
an enhanced scheme based on [22]; however, Sun et al. [24] mentioned that Peng et al.’s
scheme was vulnerable to keyword guessing and equivalence test attacks. Liu et al. [25]
presented an ABSE-based signcryption scheme for PHR sharing using LSSS. Xu et al. [26]
proposed a PHR sharing system that used two cloud servers. They mentioned that privacy
issues can occur in single-server system since cloud servers can compromise stored data
using secret keys. However, they still suffered from the single-server problem since the
whole system regarding or relevant to the sensitive PHR information was stored on a cloud
server. This means that cloud servers can collude to abuse the stored PHRs. In addition,
Electronics 2022, 11, 3199 4 of 24
these existing schemes [22,23,25,26] managed PHRs on centralized cloud servers, thus they
can also suffer from the single-point-of-failure problem.
To overcome this problem, Wang et al. [27] presented a blockchain-based PHR sharing
system. They stored the verification values on the blockchain to match the search results
from the cloud server. Zhang et al. [28] proposed a blockchain-based hierarchical PHR shar-
ing system. They considered search result auditing and verification through the blockchain
by regarding the cloud server and auditor as malicious entities. They also allowed the
users to delegate decryption keys hierarchically to their groups for alleviating the burden
of the key distribution task of authority. However, in this system, users delegated decryp-
tion keys to their groups without mutual authentication, which could lead to PHR leak
problems. Zhang et al. [29] proposed a distributed PHR sharing scheme based on ABE
and a blockchain. They adopted both a blockchain and cloud servers to overcome the
limited storage capacity of the blockchain. However, these schemes [27–29] still used cloud
servers to manage the enormous volumes of PHRs, thus the single-point-of-failure problem
remained due to the centralized nature of the cloud server.
To mitigate these issues, Madine et al. [30] proposed a blockchain-based PHR archi-
tecture with an IPFS. In addition, Wang et al. [31] proposed a PHR sharing system using a
consortium blockchain and an IPFS. They also utilized a smart contract to realize personal-
ized access control. Wu et al. [32] suggested a blockchain-enabled PHR sharing system with
access control. They considered mutual evaluation for the individual-centric transaction
network and access control decisions. Hussien et al. [33] suggested a blockchain-based
access control scheme for PHR sharing. However, existing PHR sharing schemes [30–33]
rely on TTP to share PHRs, which does not guarantee a patient-centered system.
In 2020, Niu et al. [34] proposed a blockchain-based medical data sharing system using
KASE in the Internet of Things environment. However, their scheme was vulnerable to
privileged-insider attacks and did not provide secure mutual authentication. In addition,
they did not consider dynamic keywords, which incurred significant computational costs
to users. Niu et al. also relied on cloud servers to store data, which led to the single-point-
of-failure problem. Thus, we propose a fully decentralized secure PHR sharing scheme
that ensures patients’ self-determined control over their personal information. In addition,
the proposed scheme realizes convenient PHR searches using key aggregate dynamic
searchable encryption.
3. Preliminaries
In this section, we present the system models and cover the conceptual aspect referred
to in this paper.
3.1. System Models
We consider the following network, threat, and security models to design and analyze
the proposed scheme.
3.1.1. Network Model
The proposed secure PHR sharing model is depicted in Figure 1. In this figure, we
have four entities: data owner, data user, IPFS, and blockchain.
Electronics 2022, 11, 3199 5 of 24
Figure 1. Network model of the proposed scheme.
• Data owner (DO): The DO manages his/her own PHR for self-directed health care.
The DO generates the system parameters for his/her own PHR and controls the access
rights of the DU using an aggregate key. The DO uploads the encrypted PHR to the
IPFS and generates and uploads the smart contract to the blockchain for realizing the
secure verification of the trapdoor.
• Data user (DU): The DU is the person that wants to access the PHR of the DO. To
obtain the read rights of the PHR, the DU requests the aggregate key from the DO.
The DU can obtain the aggregate key by mutual authentication with the DO. The DU
can request and receive the PHR by communicating with the blockchain and IPFS. For
the PHR decrypted using the aggregate key, the DU can verify the integrity through
the received verification value from the blockchain.
• IPFS: IPFS is a P2P decentralized database. In the proposed system, the IPFS stores
the encrypted PHR of the DO and returns a unique hash address for the stored PHR
as an identifier. In addition, when the DU requests the PHR through the identifier, the
IPFS returns the corresponding results to the DU.
• Blockchain: The architecture of the blockchain is a public permissionless blockchain
since all network parties can access the smart contract in the blockchain. The proposed
system employs the Practical Byzantine Fault Tolerance (PBFT) consensus algorithm
for the validation of transactions and generation of blocks. The blockchain implements
the stored smart contract when the DU sends the trapdoor. Then, the blockchain
transmits the identifier and verification value as a result.
The overall communication flows of the network are summarized as follows.
1. The DO generates the system parameters for his/her own PHR and the DO and DU
generate their own public and private key pairs with the system parameters. Then,
the DO encrypts the PHR and uploads it to the IPFS.
2. The IPFS stores the received PHR. Then, the IPFS generates and sends an unique
hash address as an identifier for the received PHR to the DO. The DO calculates the
keyword ciphertexts corresponding to the PHR and verification values. Then, the DO
generates the smart contract using the keyword, identifier, and verification value, and
uploads the smart contract to the blockchain.
3. The DU requests the aggregate key for reading the DO’s PHR by sending the DU’s
credentials.
Electronics 2022, 11, 3199 6 of 24
4. The DO verifies the DU’s credentials, and if the DU is valid, the DO generates and
sends the aggregate key and secret value to the DU.
5. The DU generates the trapdoor using the keyword and received secret value. Then,
the DU sends the trapdoor to the blockchain to obtain the identifier and verification
value for the encrypted PHR.
6. The blockchain checks the validity of the DU, and if the DU is validated, the blockchain
sends the corresponding PHR’s identifier and verification values to the DU as a result.
7. The DU sends a request for the PHR to the IPFS using the received identifier.
8. The IPFS sends the encrypted PHR to the DU by matching the identifier in the
database. The DU decrypts the received PHR using the aggregate key. Then, the DU
checks whether the PHR is the data of the DO using the verification value. If it is
correct, the process is successfully completed.
3.1.2. Threat Model
We adopt the broadly accepted Dolev–Yao (DY) threat model [35] to evaluate the
security of the proposed scheme. In the DY model, each network entity communicates
and exchanges messages through an insecure channel. This model also recognizes that an
adversary A can eavesdrop or intercept the transmitted messages between the network
entities. With this message, A can modify, forge, and insert the malicious content into the
messages and delete or replay them during communication. A can perform various attacks
such as impersonation, replay, and man-in-the-middle (MITM) attacks [36,37].
3.1.3. Security Model
Under the threat model in Section 3.1.2, the scheme must satisfy the following security
requirements:
• Data privacy: The PHR contains the sensitive information of the DO. If the PHR is
leaked, the DO’s life life could be put in danger or compromised. The PHR ciphertext
does not reveal any information about the plaintext to the adversary. Thus, data
confidentiality and integrity must be ensured in the PHR sharing system. We prove
data privacy using the IND-CPA model.
• Ciphertext privacy: The keyword ciphertext does not expose any information about
the corresponding keywords to the adversary who is the unauthorized user. We prove
ciphertext privacy using the IND-CKA model.
• Trapdoor privacy: For secure PHR sharing, only the authorized DU can access the
PHR, i.e., the trapdoor with the received secret values can be generated. The trapdoor
does not disclose any information about the corresponding keywords to the adversary
who is not authorized by the DO. Using the IND-KGA model, we demonstrate that
the proposed scheme ensures trapdoor privacy.
In our scheme, games using the IND-CPA, IND-CKA, and IND-KGA models are
defined as follows.
Definition 1 (Data privacy). We denote the semantic security for data privacy using the following
IND-CPA model. In this game, the advantage of the adversary is defined as AdvIND−CPA
A =
|Pr[δ′ = δ]− 1
2 |. This game is secure against IND-CPA if |Pr[δ′ = δ]− 1
2 | ≤ ε is satisfied for all
attacks, where ε is a negligible probability.
• Init. Adversary A selects a challenge set S∗ ⊆ {1, . . . , n} that A wants to attack.
• Setup. Simulator X executes the setup phase and sends the public parameters to A.
• Phase 1. A queries the aggregate key AK for set S′ ⊆ S∗ to X . Then, X performs the
aggregate key request phase and sends AK to A.
• Challenge. A picks two plaintext PHR0 and PHR1, where |PHR0| = |PHR1|, from a set
of possible plaintexts belonging to class i∗ and submits them to X . X flips the coin δ ∈ {0, 1},
encrypts PHRδ in the data upload phase and sends the ciphertext to A.
Electronics 2022, 11, 3199 7 of 24
• Phase 2. A repeats Phase 1 for S′ ⊆ S̄∗, that is, the aggregate sets that contain data classes
apart from those in the target set S∗.
• Guess. A outputs a guess δ′ of δ to X . If δ′ = δ, A wins the game.
Definition 2 (Ciphertext privacy). Here, we demonstrate the game for ciphertext privacy using
the IND-CKA model. The adversary’s advantage in this game is defined as AdvIND−CKA
A =
|Pr[δ′ = δ]− 1
2 |. If |Pr[δ′ = δ]− 1
2 | ≤ ε is met, this game is secure against the IND-CKA model.
• Init. Adversary A chooses a challenge set S∗ ⊆ {1, . . . , n} that A wants to attack.
• Setup. Simulator X executes the setup phase and returns the public parameters to A.
• Phase 1. First, A sends an aggregate key request query to X . X implements the aggregate
key request phase and returns AK toA. Then, A transmits the trapdoor query for the keyword
wl . If S∗ ⊆ S, X executes the data request phase and responds with the trapdoor.
• Challenge. A chooses two keywords w0 and w1, where |w0| = |w1| and of a challenge set S∗,
to X . X flips the coin δ ∈ {0, 1} and responds with the ciphertext for wδ in the data upload
phase to A.
• Phase 2. A repeats Phase 1 with the restriction that neither w0 nor w1 are used.
• Guess. A outputs a guess δ′ of δ to X . If δ′ = δ, A wins the game.
Definition 3 (Trapdoor privacy). Here, we demonstrate the game using the IND-KGA model to
prove trapdoor security. In this game, AdvIND−KGA
A = |Pr[δ′ = δ]− 1
2 | is the advantage of A. If
AdvIND−KGA
A ≤ ε, this game is secure against the IND-KGA model. This game for the proposed
scheme is defined as follows.
• Init. Adversary A gives to the simulator X a challenge set S∗ ⊆ {1, . . . , n}.
• Setup. X executes the setup phase and returns the results to A.
• Phase 1. A first sends an aggregate key request query to X . X executes the aggregate key
request phase and sends AK to A. Then, A sends the ciphertext query for the keyword wl . If
S∗ ⊆ S, X executes the data upload phase and responds with the ciphertext.
• Challenge. A submits two equal-length keywords w0 and w1 to X within S∗. X flips the coin
δ ∈ {0, 1} and responds with the trapdoor for wδ in the data request phase to A.
• Phase 2. A repeats Phase 1 with the restriction that neither w0 nor w1 are used.
• Guess. A outputs a guess δ′ of δ to X . If δ′ = δ, A wins the game.
3.2. Bilinear Maps
A bilinear map is a pairing-based cryptosystem. Let G and GT be the multiplicative
cyclic groups with a large prime order q. The bilinear map e : G × G → GT satisfies the
following properties.
• Bilinearity: For ∀a, b ∈ G and ∀x, y ∈ Z∗q , we have e(ax, by) = e(a, b)xy.
• Non-degeneracy: ∃a, b ∈ G, e(a, b) 6= 1.
• Computability: ∀a, b ∈ G, e(a, b) can be computed in polynomial time.
3.3. Linear Secret-Sharing Scheme (LSSS)
A secret-sharing scheme Π [38] realizing access policies on a set of parties P is linear
over Zq if the following conditions are satisfied:
• For each party, the shares of a secret s ∈ Zq form a vector over Zq.
• There is an l × φ matrixM called the share-generating matrix on Π and a function ρ
that maps each row ofM to a specific party in P . During the generation of the shares,
we give consideration to the column vector ~v = (s, r2, . . . , rφ)⊥, where r2, . . . , rφ ∈ Zq.
Then, l shares a vector of s, which is equal toM·~v. In addition, the share λj =Mj ·~v
belongs to ρ(j), whereMj is the jth row ofM.
We denote that As is an authorized set of the access structure T , As ∈ T , and I is
defined as the set of rows where labels of I are in S, such as I = {i|i ∈ {1, . . . , l}, ρ(i) ∈ S}.
Electronics 2022, 11, 3199 8 of 24
Then, there exists coefficients {bi}i ∈ I that recover secret s by ∑i∈I biλi = ∑i∈I bi(M·~v) =
∑i∈I(biMi) ·~v = (1, 0, . . . , 0) · (s, r2, . . . , rφ) = s.
3.4. Computational Assumption
Let e : G × G → GT be a bilinear map, g be a generator of G, and a, b, c, z ∈ Z∗q be
chosen randomly. With this establishment, the assumptions used in this paper are defined
as follows.
3.4.1. Decisional Diffie–Hellman (DDH) Assumption
The DDH assumption is that it is difficult for a probabilistic polynomial time adversary
A to distinguish (ga, gb, gab) from (ga, gb, gz). The advantage ε of A is defined as follows:
|Pr[A(ga, gb, gab) = 1]− Pr[A(ga, gb, gz) = 1]| ≥ ε
If there is no way thatA can decide whether gz = gab, that is, deciding whether z = ab
or z ∈ Z∗q with a non-negligible advantage, the DDH assumption holds.
3.4.2. Decisional Bilinear Diffie–Hellman (DBDH) Assumption
Under the DBDH assumption, an adversaryA cannot distinguish (ga, gb, gc, e(g, g)abc)
from (ga, gb, gc, e(g, g)z) in probabilistic polynomial time. The advantage ε of A is defined
as follows.
|Pr[A(ga, gb, gc, e(g, g)abc) = 1]− Pr[A(ga, gb, gc, e(g, g)z) = 1]| ≥ ε
IfA cannot decide whether e(g, g)z = e(g, g)abc, which is determining whether z = abc
or z ∈ Z∗q with a non-negligible advantage, the DBDH assumption is valid.
3.5. Blockchain
A blockchain is a distributed ledger technology that maintains a list of growing records.
These records called blocks are chronologically linked using the cryptographic hashes of
the previous blocks along with the timestamps and lists of transactions. Due to its chained
structure, any included data cannot be changed unconstitutionally without the modification
of all subsequent frames. In addition, each node of the blockchain network holds a copy of
the chain to prevent a single point of failure. These properties make it difficult to change the
transaction history, and the blockchain provides traceability, accountability, transparency,
and provenance. Depending on the requirements and goals to be met, the blockchain can
be classified into public/private and permissionless/permissioned types [39,40].
• Public permissionless blockchain: every node can participate in the consensus pro-
cess, read and write the transactions, and maintain the ledgers.
• Public permissioned blockchain: the nodes are permitted to read or convert the state
of the ledger with approved performing consensus, that is, only authorized nodes in
the network can write in the ledger.
• Private permissionless blockchain: only authorized nodes are allowed to participate;
the read and write abilities are owned by authorized nodes; all transactions can be
conducted privately, and if necessary, the transaction can be opened for verification.
• Private permissioned blockchain: only authorized nodes can access, perform opera-
tions over the distributed ledger, and participate in the consensus process.
A smart contract is a computerized transaction protocol that executes the terms of a
contract [41]. If a specific pre-defined condition is met, the smart contract is automatically
implemented on the blockchain, and the contact with the smart contract is documented
on the blockchain as a transaction. The smart contract can realize interoperability and
flexible control over the blockchain system. Therefore, the proposed system adopted a
Electronics 2022, 11, 3199 9 of 24
blockchain and a smart contract to ensure the integrity of PHRs and provide secure verifi-
cation mechanisms. The proposed scheme employed a public permissionless blockchain
since anyone could access the blockchain. In addition, we adopted the PBFT consensus
algorithm to realize consistency and synchronization in terms of transaction validation,
block generation, and the voting process in the distribution network.
3.6. InterPlanetary File Systems
An InterPlanetary File System (IPFS) [42] is a P2P distributed file system for storing
and accessing files. When content is uploaded to the IPFS, the IPFS returns a unique hash
of content, called a content identifier (CID). The CID indicates the content address in the
IPFS, which is based on the content itself, rather than the location of the content. Thus,
anyone who has the CID can access the corresponding content. Since the IPFS connects
all computing devices to share and access files, there are no authorized nodes, which
eliminates the no single-point-of-failure problem and the nodes do not need to trust each
other. Content-based addressing in an IPFS is constructed using the SHA-256 cryptographic
hash, and this hash function creates an identifier for a certain file in the InterPlanetary
Name System (IPNS). With this unique feature, the IPFS can maintain the same path for
updated files with identifiers.
4. Proposed Scheme
We propose a secure PHR sharing scheme with key aggregate dynamic searchable
encryption. The proposed scheme comprises six phases: the setup, key-generation, data
upload, aggregate key request, data retrieval, and data request phases. The notations used
in this paper can be found in Table 1 and the six phases are described in the following
subsections.
Table 1. Notation.
Notation Description
DO, DU Data owner/data user
(sko, pko) Data owner’s private key and public key
(sku, pku) Data user’s private key and public key
n Maximum number of PHRs
m Maximum number of keywords
W Keyword set for document
W ′ Search keyword set
I Index of search keyword set
PHRi i-th PHR
w Keyword
α, t, ro, ru, Ru Random number
T1, T2, T3 Timestamp
4T Maximum transmission delay
AK Aggregate key
Try1, Try2 Trapdoor
e Bilinear map e : G × G → GT
h One-way hash function {0, 1}∗ → Zq
|| Concatenation operator
⊕ Bitwise exclusive-or operator
4.1. Setup Phase
The DO generates the bilinear parameters (q,G,GT , e) and sets the maximum num-
ber of PHRs and keywords as n and m, respectively. Then, the DO chooses a gener-
ator g ∈ G, a random number α ∈ Zq, and a hash function h : {0, 1}∗ → Zq. The
DO computes gi = gαi ∈ G for i = {1, . . . , n, n + 2, . . . , 2n}. Finally, the DO publishes
{q,G,GT , e, g, n, m, {gi}1≤i≤2n,i 6=n+1, h}.
Electronics 2022, 11, 3199 10 of 24
4.2. Key Generation Phase
In this phase, the DO and DU generate the private and public key pairs for secure
PHR sharing. The DO and DU compute (sko, pko) = (sko, gsko ) and (sku, pku) = (sku, gsku),
respectively.
4.3. Data Upload Phase
The DO uploads the PHR to the IPFS for health care. This phase is briefed in Figure 2
and the detailed steps are given below.
DO IPFS
Generate t ∈ Zq
Compute PHRi
c = gt
cm1 = (pko · gi)
t
cm2 = PHRi · e(g1, gn)t
{c, cm1, cm2}−−−−−−−−−−−−−→
Store {c, cm1, cm2}
Compute the identifier CIDi
{CIDi}←−−−−−−−−−−−−−
Select ~v = {t, z2, . . . , zφ}
Compute (λ1, . . . , λl)
T =M·~v
Compute for ∀wy ∈W(y = 1, . . . , m′)
cw1 = gh(wy)·h(sko)·t
cw2 = g~λ
Veri fi = h(PHRi)
Generate the smart contract using
{c,M, cw1, cw2, Veri fi, CIDi}
Upload the smart contract in the
blockchain
Figure 2. Data upload phase.
Step 1: The DO generates t ∈ Zq and computes c = gt, cm1 = (pko · gi)
t, cm2 = PHRi ·
e(g1, gn)t for the PHRi. Then, the DO sends {c, cm1, cm2} to the IPFS.
Step 2: The IPFS stores {c, cm1, cm2} in the database and computes the identifier CIDi.
Then, the IPFS sends {CIDi} to the DO.
Step 3: The DO selects ~v = {t, z2, . . . , zφ}, where z2, . . . , zφ ∈ Zq, and l × φ matrixM. The
DO computes (λ1, . . . , λl)
T = M ·~v, and calculates cw1 = gh(wy)·h(sko)·t, cw2 = g~λ,
Veri fi = h(PHRi) for ∀wy ∈W(y = 1, . . . , m′), where m′ is the number of keywords
about PHRi. Then, the DO generates the smart contract using {c,M, cw1, cw2, Veri fi,
CIDi} and uploads it to the blockchain.
4.4. Aggregate Key Request Phase
The DU requests the aggregate key to the DO for reading the PHR. Figure 3 indicates
this phase and the details are as follows.
Step 1: The DU generates ru and T1. The DU computes PIDu = h(IDu||sku), TIDu =
h(IDu) ⊕ ru, U1 = g(TIDu ||sku), U2 = pk(TIDu ||sku)
o , VIDu = PIDu ⊕ h(U2), Sigu =
h(PIDu||U2||pku||T1) · sku(modq). Then, the DU sends {U1, VIDu, Sigu, T1, S} to the
DO through a public channel.
Step 2: After receiving the message, the DO checks |T1 − T∗1 | ≤ 4T. Then, the DO com-
putes U∗2 = Usko
1 , PID∗u = VIDu ⊕ h(U∗2 ), and checks gSigu ?
= pkh(PID∗u ||U∗2 ||pku ||T1)
u .
If it is correct, the DO computes PIDo = h(IDo||sko), TIDo = h(IDo) ⊕ ro, O1 =
g(TIDo ||sko), O2 = U(TIDo ||sko)
1 , VIDo = PIDo⊕ h(O2), Sigo = h(PIDo||PID∗u||O2||T2) ·
sko(modq), Vou = h(PIDo||PID∗u||O2||T2), AK = ∏j∈S gsko
n+1−j, O3 = (AK||h(sko))⊕
h(O2||PIDo||PID∗u). Then, the DO sends {O1, Sigo, VIDo, Vou, O3, T2} to the DU.
Electronics 2022, 11, 3199 11 of 24
Step 3: Upon receiving the message, the DU checks |T2 − T∗2 | ≤ 4T. Then, the DU
computes O∗2 = O(TIDu ||sku)
1 , PID∗o = VIDo ⊕ h(O∗2), V∗ou = h(PID∗o ||PIDu||O∗2 ||T2),
and checks whether gSigo ?
= pkh(PID∗o ||O∗2 ||pko ||T2)
o and V∗ou
?
= Vou. If it is valid, the DU
obtains the secret values by computing (AK||h(sko)) = O3 ⊕ h(O∗2 ||PID∗o ||PIDu).
DO DU
Generate ru and T1
Compute
PIDu = h(IDu||sku)
TIDu = h(IDu)⊕ ru
U1 = g(TIDu ||sku), U2 = pk(TIDu ||sku)
o
VIDu = PIDu ⊕ h(U2)
Sigu = h(PIDu||U2||pku||T1) · sku(modq)
{U1, VIDu, Sigu, T1, S}
←−−−−−−−−−−−−−
Check |T1 − T∗1 | ≤ 4T
Compute
U∗2 = Usko
1
PID∗u = VIDu ⊕ h(U∗2 )
Check gSigu ?
= pkh(PID∗u ||U∗2 ||pku ||T1)
u
Generate ro and T2
Compute
PIDo = h(IDo||sko)
TIDo = h(IDo)⊕ ro
O1 = g(TIDo ||sko), O2 = U(TIDo ||sko)
1
VIDo = PIDo ⊕ h(O2)
Sigo = h(PIDo||O2||pko||T2) · sko(modq)
Vou = h(PIDo||PID∗u||O2||T2)
AK = ∏j∈S gsko
n+1−j
O3 = (AK||h(sko))⊕ h(O2||PIDo||PID∗u)
{O1, Sigo, VIDo, Vou, O3, T2}−−−−−−−−−−−−−→
Check |T2 − T∗2 | ≤ 4T
Compute
O∗2 = O(TIDu ||sku)
1
PID∗o = VIDo ⊕ h(O∗2)
V∗ou = h(PID∗o ||PIDu||O∗2 ||T2)
Check gSigo ?
= pkh(PID∗o ||O∗2 ||pko ||T2)
o and V∗ou
?
= Vou
Compute
(AK||h(sko)) = O3 ⊕ h(O∗2 ||PID∗o ||PIDu)
Figure 3. Aggregate key request phase.
4.5. Data Retrieval Phase
The DU requests the PHR’s location to the blockchain. The proposed scheme considers
the dynamic search for the convenience of the PHR search so the DU sends the trapdoor
to the blockchain only once. Figure 4 denotes this phase, and we interpret the detailed
steps below.
Step 1: The DU generates Ru ∈ Zq and T3, and computes Try1 = gh(wy)·Ru ·h(sko), Try2 = gRu
for ∀wy ∈W ′(y = 1, . . . , φ′), where φ′ is the number of search keywords. Then, the
DU sends {Try1, Try2, I, T3} to the blockchain, where I = y : wy ∈W ′.
Step 2: With the received message, the blockchain checks |T3 − T∗3 | ≤ 4T and implements
the smart contract. The blockchain computes by ∈ Zq satisfying ∑y∈I by · My =
(1, 0, . . . 0) and checks whether ∏y∈I(e(Try1, cw2))
by ?
= e(Try2, cw1). If it is correct, the
blockchain sends all matched CIDi and Veri fi to the DU.
Electronics 2022, 11, 3199 12 of 24
DU Blockchain
Generate Ru ∈ Zq and T3
Compute for ∀wy ∈W ′(y = 1, . . . , φ′)
Try1 = gh(wy)·Ru ·h(sko)
Try2 = gRu
I = y : wy ∈W ′
{Try1, Try2, I, T3}
−−−−−−−−−−−−−→
Check |T3 − T∗3 | ≤ 4T
The smart contract is implemented as fol-
lows
Compute by ∈ Zq satisfying ∑y∈I by ·My =
(1, 0, . . . 0)
Check ∏y∈I(e(Try1, cw2))
by ?
= e(Try2, cw1)
Send all matched CIDi and Veri fi
{CIDi, Veri fi}←−−−−−−−−−−−−−
Figure 4. Data retrieval phase.
4.6. Data Request Phase
The DU requests the PHR to the IPFS with the received identifier. Then, the DU
decrypts the encrypted PHR using the aggregate key. We denote this phase in Figure 5, and
describe the detailed steps below.
DU IPFS
{CIDi}−−−−−−−−−−−−−→
Find encrypted PHR matched with CIDi
{c, cm1, cm2}←−−−−−−−−−−−−−
Compute
PHR∗i = cm2 ·
e(AK·∏j∈S,j 6=i gn+1−j+i ,c)
e(∏j∈S gn+1−j ,cm1)
Check h(PHR∗i ) = Veri fi
Figure 5. Data request phase.
Step 1: The DU sends the identifier CIDi to the IPFS for the PHR that the DU wants.
Step 2: The IPFS finds the encrypted document, which is matched with CIDi. Then, the
IPFS sends {c, cm1, cm2} to the DU.
Step 3: After receiving the message, the DU computes PHR∗i = cm2 ·
e(AK·∏j∈S,j 6=i gn+1−j+i ,c)
e(∏j∈S gn+1−j ,cm1)
.
Then, the DU checks whether h(PHR∗i ) = Veri fi. If it is valid, the DU obtains the
right PHR, and the process of the proposed PHR sharing system is successfully
completed.
5. Informal Security Analysis
We indicate the security features of the proposed scheme, including impersonation,
replay, MITM, and insider attacks. In addition, we prove that the proposed scheme ensures
correctness, perfect forward secrecy, anonymity, and mutual authentication.
5.1. Impersonation Attack
An adversary A tries to masquerade as the DU to obtain PHRi. In this case, A needs
CIDi and AK corresponding to PHRi. As mentioned in Section 3.1.2, A can utilize the
transmitted message. A eavesdrops {U1, VIDu, Sigu, T1, S} and {Try1, Try2, I, T3}. Then,
A attempts to send {U′1, VID′u, Sig′u, T′1, S′} and {Tr′y1, Tr′y2, I′, T′3} to obtain AK and CIDi,
respectively. However, it is impossible for A since A did not have knowledge about the
DU’s real identity IDu and the secret key sku. Thus, the proposed scheme is secure against
the impersonation attacks.
Electronics 2022, 11, 3199 13 of 24
5.2. Replay Attack
With the ability described in Section 3.1.2, A intercepts the transmitted messages.
A interrupts {U1, VIDu, Sigu, T1, S} and {Try1, Try2, I, T3} and resends them to the DO
and blockchain for obtaining the PHRi. However, the DO and blockchain check the
transmission delay time and the freshness of the message, which is encrypted with random
nonces {ru, Ru} so A cannot obtain the PHRi. Therefore, our scheme has resistance against
replay attacks.
5.3. Man-in-the-Middle (MITM) Attack
In this attack, A interrupts the transmitted messages {U1, VIDu, Sigu, T1, S} and
{Try1, Try2, I, T3} and modifies them to {U′1, VID′u, Sig′u, T′1, S′} and {Tr′y1, Tr′y2, I′, T′3}. Un-
fortunately, it is computationally impossible for A since these messages are made up of
the DU’s identity IDu, secret key sku, and aggregate key AK. Hence, the proposed scheme
prevents the MITM attack.
5.4. Insider Attack
This attack supposes that A is an insider that receives the authorization from the DO.
A attempts to impersonate another legitimate DU to know what kind of person the DU is by
obtaining the PHRi. For this,A endeavors to generate the messages {U1, VIDu, Sigu, T1, S}
and {Try1, Try2, I, T3} with the DU’s IDu and sku. However, A cannot compute them since
the corresponding values of the DU are unknown. Thus, the proposed scheme is secure
against the insider attacks.
5.5. Correctness
5.5.1. Dynamic Keyword
In Section 4.5, the blockchain checks whether the DU sends the correct trapdoor using
the aggregate key. We prove it arithmetically as follows.
∏
y∈I
e(Try1, cw2)
by = e(gh(wy)·Ru ·h(sko), g~λ)by
= e(g, g)h(wy)·Ru ·h(sko)·~λ·by
= e(g, g)h(wy)·Ru ·h(sko)·(M·~v)·by
= e(g, g)h(wy)·Ru ·h(sko)·(∑y∈I by ·My)·~v
= e(g, g)h(wy)·Ru ·h(sko)·(1,0,...,0)·~v
= e(g, g)h(wy)·Ru ·h(sko)·t
= e(gRu , gh(wy)·h(sko)·t) = e(Try2, cw1)
5.5.2. PHR
As described in Section 4.6, the DU can obtain the PHR of the DO by decrypting with
the aggregate key AK. Then, the DU compares the obtained PHR with Veri fi to determine
whether it is the correct value. For correctness, the PHRi can be obtained as follows.
PHR∗i = cm2 ·
e(AK ·∏j∈S,j 6=i gn+1−j+i, c)
e(∏j∈S gn+1−j, cm1)
= cm2 ·
e(∏j∈S gsko
n+1−j ·∏j∈S,j 6=i gn+1−j+i, gt)
e(∏j∈S gn+1−j, (pko · gi)t)
= cm2 ·
e(∏j∈S gn+1−j+i, gt)
e(∏j∈S gn+1−j+i, gt)
· 1
e(gn+1, gt)
= PHRi ·
e(g1, gn)t
e(gn+1, gt)
= PHRi
Electronics 2022, 11, 3199 14 of 24
5.6. Perfect Forward Secrecy
In this attack, A can have the keys sku of the DU. With this value, A tries to acquire
the PHRi. For this, A needs the aggregate key AK so A makes effort to generate the
message {U1, VIDu, Sigu, T1, S}. Nevertheless, A cannot calculate it since A did not have
knowledge about the DU’s real identity IDu and secret key sku. For this reason, our scheme
provides the perfect forward secrecy.
5.7. Anonymity
In the proposed scheme, each entity cannot trust each other so they hide the real
identity {IDo, IDu} with {sko, ro, sku, ru} and perform the mutual authentication through
the pseudo identity {PIDo, PIDu}. Although A tries to obtain the real identity from the
pseudo identity, it is computationally impossible because of the collision-resistant property
of the hash function. Therefore, the proposed scheme ensures the anonymity of each entity.
5.8. Mutual Authentication
In Section 4.4, it was shown that the DO and DU check the validity of each other before
issuing the aggregate key AK. The DU generates the signature Sigu that can represent the
DU and sends {U1, VIDu, Sigu, T1, S} to the DO. After checking the transmission delay
time, the DO checks whether gSigu ?
= pkh(PID∗u ||U∗2 ||pku ||T1)
u . If it is correct, the DU’s validity is
verified from the DO. Then, the DO sends {O1, Sigo, VIDo, Vou, O3, T2} with the signature
Sigo. With the received message, the DU checks whether gSigo ?
= pkh(PID∗o ||O∗2 ||pko ||T2)
o and
V∗ou
?
= Vou. If this condition is approved, the validity of the DO is verified to the DU.
Consequently, the DO and DU mutually authenticate so the proposed scheme provides
mutual authentication.
6. Formal Security Analysis
In this section, we conduct a formal analysis to evaluate the security of the proposed
scheme using the AVISPA simulation tool, BAN logic, IND-CPA, IND-CKA, and IND-KGA.
6.1. AVISPA Simulation Tool
AVISPA is a security analysis tool for protocols in security-sensitive wireless envi-
ronments [43]. For confirming security, many authentication schemes have been widely
used [44–46]. We simulated the proposed scheme with the AVISPA tool based on the DY
threat model to identify the security issues against replay and MITM attacks. To analyze our
scheme, we shaped the actions of each participant using High-Level Protocols Specification
Language (HLPSL), a role-based language. The HLPSL2IF translator coverts HLPSL into
Intermediate Format (IF) and inputs the IF into the back-end. Then, the back-ends outputs
the Output Format (OF) as the security analysis results against four components including
the On-the Fly-Model-Checker (OFMC), SAT-based Model-Checker (SATMC), CL-based
Attack Searcher (CL-AtSe), and Tree-Automata-based Protocol Analyzer (TA4SP).
We simulated the proposed scheme on the OFMC and CL-AtSe back-ends since they
provide bitwise exclusive-OR operations. The simulated results on the OFMC and CL-AtSe
were identified as SAFE or UNSAFE by estimating the security issues against replay and
MITM attacks. In Figure 6, the OF indicates that the proposed scheme is “SAFE” in both
the OFMC and CL-AtSe back-ends. Therefore, our scheme completely attains the specific
security goals and withstands the attacks in a wireless environment.
Electronics 2022, 11, 3199 15 of 24
Figure 6. AVISPA evaluation results.
6.2. Formal Security Analysis using BAN Logic
BAN logic is a mathematical proof method for secure mutual authentication, which
is widely used in authentication schemes [47–49]. We proved that the proposed scheme
provides mutual authentication in Section 4.4. We describe the notations of BAN logic in
Table 2, indicate the goals of this analysis, present all considered assumptions, and provide
corresponding proof.
Table 2. BAN Logic Notation.
Notation Description
scky Secret key
K| ≡ Y K believes statement Y
#Y Statement Y is fresh
K / Y K receives statement Y
K| ∼ Y K once said Y
K ⇒ Y K controls statement Y
< Y >S Statement Y is combined with secret statement S
{Y}scky Statement Y is masked by scky
K
scky←→ Q K and Q share scky to communicate with each other
6.2.1. Rules
The rules of the BAN logic are as follows.
• Message meaning rule (MMR):
K| ≡ K
scky←→ Q, K / {Y}scky
K| ≡ Q| ∼ Y
• Nonce verification rule (NVR):
K| ≡ #(Y), K| ≡ Q| ∼ Y
K| ≡ Q| ≡ Y
• Jurisdiction rule (JR):
K| ≡ Q| ⇒ Y, K| ≡ Q| ≡ Y
K| ≡ Y
• Freshness rule (FR):
K| ≡ #(Y)
K| ≡ #(Y, S)
Electronics 2022, 11, 3199 16 of 24
• Belief rule (BR):
K| ≡ (Y, S)
K| ≡ Y
6.2.2. Goals
We establish the goals for proving mutual authentication as follows:
Goal 1: DO| ≡ DO AK←→ DU
Goal 2: DU| ≡ DO AK←→ DU
Goal 3: DO| ≡ DU| ≡ DO AK←→ DU
Goal 4: DU| ≡ DO| ≡ DO AK←→ DU
6.2.3. Idealized Forms
The idealized forms in the proposed scheme are as follows:
M1: DU → DO : {U2, T1}PIDu
M2: DO→ DU : {AK, O2, T2}PIDo
6.2.4. Assumptions
The assumptions to achieve the BAN logic are as follows:
A1: DO| ≡ (DO PIDu←→ DU)
A2: DO| ≡ #(T1)
A3: DU| ≡ (DO PIDo↔ DU)
A4: DU| ≡ #(T2)
A5: DO| ≡ DU ⇒ (DU AK↔ DO)
A6: DU| ≡ DO⇒ (DU AK↔ DO)
6.2.5. Proof
We prove the guarantee of mutual authentication by attaining the goals using notations,
idealized forms, and assumptions. We execute the proof according to the following steps:
Step 1: S1 can be obtained from M1.
S1 : DO / {U2, T1}PIDu
Step 2: S2 can be obtained by applying the MMR with A1.
S2 : DO| ≡ DU| ∼ {U2, T1}PIDu
Step 3: S3 can be gained from the FR with S2 and A2.
S3 : DO| ≡ #(U2, T1)
Step 4: S4 can be acquired by applying the NVR with S2 and S3.
S4 : DO| ≡ DU| ≡ (U2, T1)
Step 5: S5 can be obtained from M2.
S5 : DU / {AK, O2, T2}PIDo
Electronics 2022, 11, 3199 17 of 24
Step 6: S6 can be gained from MMR with S5 and A3.
S6 : DU| ≡ DO| ∼ {AK, O2, T2}PIDo
Step 7: S7 can be obtained by applying FR with S6 and A4.
S7 : DU| ≡ #(AK, O2, T2)
Step 8: S8 can be obtained from NVR with S6 and S7.
S8 : DU| ≡ DO| ≡ (AK, O2, T2)
Step 9: S9 and S10 can be obtained from S4 and S8 since O3 = (AK||h(sko))⊕ h(O2||PIDo||
PIDu).
S9 : DO| ≡ DU| ≡ (DO AK←→ DU) (Goal 3)
S10 : DU| ≡ DO| ≡ (DO AK←→ DU) (Goal 4)
Step 10: S11 and S12 can be obtained by applying JR from S9, S10, A5, and A6.
S11 : DO| ≡ (DU AK←→ DO) (Goal 1)
S12 : DU| ≡ (DO AK←→ DU) (Goal 2)
Therefore, the DO and DU authenticate securely in the aggregate key request phase of the
proposed scheme.
6.3. IND-CPA Security
Theorem 1. When an adversary A can win the game with a non-negligible advantage ε in a
probability polynomial time, A can solve the DBDH assumption’s difficult problem with ε/2.
Proof. We prove this security game according to Definition 1 and Section 3.4.2. Assume
there isA that can break our scheme with advantage ε. Then, we build a simulatorX to play
the DBDH game with advantage ε/2. The simulation process is as follows. Challenger B
randomly selects a random number a, b, c, z ∈ Zq and a generator g ∈ G. Then, B randomly
tosses a coin to obtain a random value µ ∈ {0, 1}. B sets if µ = 0, then Z = e(g, g)abc, which
is (ga, gb, gc, e(g, g)abc); otherwise Z = e(g, g)z, which means (ga, gb, gc, e(g, g)z). Then, B
sends the results to X that plays the DBDH game.
Init. The simulator X runs the adversary A to create a challenge set S∗ ⊆ {1, . . . , n}
that A wants to attack. Then, A sends it to X .
Setup. X computes the public parameters {gi = gαi}1≤i≤2n,i 6=n+1 and sets the instance
of the DBDH game as α1 = a and αn = b. Then, X sends the public parameters to A.
Phase 1. A requests an aggregate key AK for S ⊆ S∗. X computes AK = ∏j∈S gsko
n+1−j.
Then, X sends AK to A.
Challenge. A submits two equal-length plaintext PHR0 and PHR1 to X with S∗.
X randomly flips a coin to obtain δ ∈ {0, 1}. We set if µ = 0, then Z = e(g, g)abc. In
this case, we let t = c be the instance of the DBDH game, then e(g, g)abc = e(g, g)ab·t =
e(ga, gb)t = e(g1, gn)t and cm2 = PHRδ · e(g, g)abc. Otherwise, if µ = 1, then Z = e(g, g)z
and cm2 = PHRδ · e(g1, gn)z. X computes c = gt, cm1 = (pko · gi)
t and sends {c, cm1, cm2}
to A.
Phase 2. A repeats Phase 1 to obtain the aggregate key, which is associated with the
data sets S ⊆ S̄∗.
Electronics 2022, 11, 3199 18 of 24
Guess. A guesses δ′ of δ. If δ′ = δ, we set X outputs 0, otherwise, it outputs 1. X
outputs 0 means that Z = e(g, g)abc and A can obtain the practical ciphertext. Then, the
advantage is ε and we can obtain Pr[δ′ = δ|Z = e(g, g)abc] = 1
2 + ε. X outputs 1 means
that Z = e(g, g)z and A obtains invalid ciphertext. So, there is no advantage in guessing
the correct δ′ and A obtains Pr[δ 6= δ|Z = e(g, g)z] = 1
2 . Therefore, the probability Pr of a
successful game is
Pr =
1
2
Pr[A(g, ga, gb, gc, e(g, g)abc) = 1]
+
1
2
Pr[A(g, ga, gb, gc, e(g, g)z) = 1]− 1
2
=
1
2
Pr[δ′ = δ|Z = (g, g)abc]
+
1
2
Pr[δ′ 6= δ|Z = e(g, g)z]− 1
2
=
1
2
× (
1
2
+ ε) +
1
2
× 1
2
− 1
2
=
ε
2
(1)
Therefore, our scheme ensures IND-CPA security.
6.4. IND-CKA Security
Theorem 2. If an adversaryA can win the game with a non-negligible advantage ε in a probability
polynomial time, A can solve the DDH assumption’s difficult problem with ε/2.
Proof. Let an adversary A break our scheme with advantage ε. Then, we construct a
simulatorX to play the DDH game with advantage ε/2. The simulation process is described
as follows. Challenger B randomly selects a, b, z ∈ Zq and a generator g ∈ G. Then, B
randomly tosses a coin to obtain a random value µ ∈ {0, 1}. If µ = 0, then Z = gab, which
is (ga, gb, gab); otherwise Z = gz, which means (ga, gb, gz). Then, B sends the results to X
that plays the DDH game.
Init. The simulator X executes the adversary A to create a challenge set S∗ ⊆
{1, . . . , n}. Then, A sends it to X .
Setup. X generates the public parameters {gi}1≤i≤2n,i 6=n+1. Then, X returns them to A.
Phase 1. A requests the aggregate key AK for S ⊆ S∗. X computes AK = ∏j∈S gsko
n+1−j.
Then, X sends AK to A. In addition, A sends the trapdoor query for the keyword wl . If
S∗ ⊆ S, X executes the data request phase and sends {Try1, Try2} to A.
Challenge. A submits two keywords w0 and w1, where |w0| = |w1| and of a challenge
set S∗ to X . X randomly tosses a coin to obtain δ ∈ {0, 1}. If µ = 0, then Z = gab. In this
case, we let t = ab, then gab = gt and c = gt = gab, cw1 = gh(wy)·h(sko)·t = gh(wy)·h(sko)·ab.
Otherwise, if µ = 1, then Z = gz and c = gt = gz, cw1 = gh(wy)·h(sko)·t = gh(wy)·h(sko)·z.
Then, X computes cw2 = g~v and sends {c, cw1, cw2} to A.
Phase 2. A repeats Phase 1 to obtain the aggregate key and trapdoor under the
restriction that neither w0 nor w1 are used.
Guess. A guesses δ′ of δ. If δ′ = δ, X outputs 0, otherwise, it outputs 1. In addition,
X outputs 0 is the representation of Z = gab and A can obtain the practical ciphertext.
Then, the advantage is ε so we can obtain Pr[δ′ = δ|Z = gab] = 1
2 + ε. X outputs 1 is
the indication that Z = gz and A obtains invalid ciphertext. So, there is no advantage in
guessing the correct δ′ and Pr[δ′ 6= δ|Z = gz] = 1
2 can be obtained. So, the probability Pr
of a successful game is
Pr =
1
2
Pr[A(g, ga, gb, gab) = 1]
+
1
2
Pr[A(g, ga, gb, gz) = 1]− 1
2
Electronics 2022, 11, 3199 19 of 24
=
1
2
Pr[δ′ = δ|Z = gab] +
1
2
Pr[δ′ 6= δ|Z = gz]− 1
2
=
1
2
× (
1
2
+ ε) +
1
2
× 1
2
− 1
2
=
ε
2
(2)
Therefore, our scheme ensures IND-CKA security.
6.5. IND-KGA Security
Theorem 3. The difficult problem of the DDH assumption can be solved when an adversary A can
win the game with ε in a probability polynomial time. Then, a non-negligible advantage is ε/2.
Proof. Suppose that an adversary A can break our scheme with advantage ε. Then, we
form a simulator X to play the DDH game with advantage ε/2. The simulation process
is described as follows. Challenger B randomly selects a, b, z ∈ Zq and g ∈ G. Then, B
randomly tosses a coin to obtain a random value µ ∈ {0, 1}. If µ = 0, then Z = gab, which
is (ga, gb, gab); otherwise Z = gz which means (ga, gb, gz). Then B sends the results to X
that plays the DDH game.
Init. The simulator X executes the adversary A to create a challenge set S∗ ⊆
{1, . . . , n}. Then, A sends it to X .
Setup. X generates the public system parameters {gi}1≤i≤2n,i 6=n+1. Then, X returns
them to A.
Phase 1. A requests aggregate key AK for S ⊆ S∗. X computes AK = ∏j∈S gsko
n+1−j.
Then, X sends AK to A. In addition, A sends the ciphertext query for the keyword wl . If
S∗ ⊆ S, X executes Data upload phase and sends {c, cw1, cw2} to A.
Challenge. A submits two equal-length keywords w0 and w1 to X within S∗. X
randomly tosses a coin to obtain δ ∈ {0, 1}. If µ = 0, then Z = gab. In this case, we let
Ru = ab, then gab = gRu and Try1 = gab·h(wδ)·h(sko), Try2 = gab. Otherwise, if µ = 1, then
Z = gz and Try1 = gz·h(wδ)·h(sko), Try2 = gz. Then, X sends {Try1, Try2} to A.
Phase 2. A repeats Phase 1 to obtain the aggregate key under the restriction that
neither w0 nor w1.
Guess. A guesses δ′ of δ. If δ′ = δ, X outputs 0, otherwise, it outputs 1. In addition,
X outputs 0 is the representation of Z = gab, and A can obtain the practical trapdoor. Then,
the advantage is ε, so we can get Pr[δ′ = δ|Z = gab] = 1
2 + ε. X outputs 1 is the indication
that Z = gz, and A obtains invalid trapdoor. So, there is no advantage in guessing the
correct δ′, and it can be obtained Pr[δ′ 6= δ|Z = gz] = 1
2 . So, the probability Pr of a
successful game is
Pr =
1
2
Pr[A(g, ga, gb, gab) = 1]
+
1
2
Pr[A(g, ga, gb, gz) = 1]− 1
2
=
1
2
Pr[δ′ = δ|Z = gab] +
1
2
Pr[δ′ 6= δ|Z = gz]− 1
2
=
1
2
× (
1
2
+ ε) +
1
2
× 1
2
− 1
2
=
ε
2
(3)
Therefore, our scheme ensures IND-KGA security.
7. Security and Performance Analysis
In this section, we compare the security and performance of the proposed scheme
to the related schemes [25,28,31] in terms of security features, computational costs, and
communication costs.
Electronics 2022, 11, 3199 20 of 24
7.1. Security Features
We present the security properties of the proposed scheme and existing schemes [25,28,31].
As shown in Table 3, the related schemes suffer from security vulnerability problems, including
perfect forward secrecy and mutual authentication. In contrast, our scheme is secure against
various attacks in DY threat model, and ensures perfect forward secrecy, anonymity, mutual
authentication, correctness, access control, dynamic search, data verification, and the DO’s
authority over his/her own PHR. Therefore, our scheme provides more security features
compared to the related schemes.
Table 3. Security Features.
Security Features Liu et al. [25] Zhang et al. [28] Wang et al. [31] Ours
SF1 ◦ ◦ ◦ ◦
SF2 ◦ ◦ ◦ ◦
SF3 ◦ ◦ ◦ ◦
SF4 ◦ ◦ ◦ ◦
SF5 × × × ◦
SF6 − ◦ ◦ ◦
SF7 × × × ◦
SF8 ◦ ◦ ◦ ◦
SF9 ◦ ◦ ◦ ◦
SF10 ◦ ◦ ◦ ◦
SF11 × × × ◦
SF12 × × × ◦
◦: Secure; ×: Insecure; −: Not considered; SF1: Impersonation attack; SF2: Replay attack; SF3: MITM attack; SF4:
Insider attack; SF5: Perfect forward secrecy; SF6: Anonymity; SF7: Mutual authentication; SF8: Correctness; SF9:
Access control; SF10: Dynamic search; SF11: Data verification; SF12: DO’s authority over his/her own PHR.
7.2. Computational Costs
We conducted a testbed experiment on cryptographic computation using MIRACL [50]
on a personal computer (PC). The detailed performance of the PC was “Ubuntu 18.04.4 LTS
with memory 8GiB, processor: Intel Core i7-4790 @ 3.60GHz × 4, CPU Architecture: 64-bit”.
We measured the average run time of 100 runs for a hash operation Th ≈ 0.003 ms, a bilinear
pairing operation Tb ≈ 6.575 ms, a scalar point multiplication operation Tsm ≈ 2.373 ms,
an exponentiation operation Te ≈ 0.819 ms, an addition operation Ta ≈ 0.013 ms, and a
symmetric key encryption/decryption Ts ≈ 0.001 ms. Table 4 shows the measurement
results. α is the number of search keywords and β is the size of the PHR dataset. The
compared schemes provide a dynamic keyword search, and some schemes [28,31] do not
consider data verification. Thus, to verify the performance of the dynamic keyword search,
Figure 7 denotes the results obtained for different numbers of returned PHRs: β = 1,
β = 10, β = 30, and β = 50. As shown in Figure 7, the existing schemes [25,28,31] exhibited
higher computational costs than the proposed scheme. Furthermore, they did not satisfy
some security features, such as mutual authentication and perfect forward secrecy. In
contrast, the proposed scheme has lower computational costs and provides many security
features that are not provided by the existing schemes.
Table 4. Computational Costs Comparison.
Scheme Total Execution Time (ms)
[25] α(4Th + 10Tb + 10Te + 13Tsm) + β(Th + 2Tb + 4Te + 4Tsm) ≈ 104.801α + 25.921β
[28] α(4Th + 13Tb + 22Te + 17Tsm + Ta) + β(Th + Te + Ts + 2Tsm) ≈ 143.859α+ 5.569β
[31] α(Th + 13Tb + 19Tsm + 5Te + 2Ta) + βTs ≈ 134.686α + 0.001β
Ours α(Th + 4Tb + 8Te + 4Tsm) + β(2Tb + 3Tsm) ≈ 22.732α + 21.343β
Electronics 2022, 11, 3199 21 of 24
0 50 100 150 200 250 300
0
1
2
3
4
5
·104
Number of Search Keywords
C
om
pu
ta
ti
on
C
os
ts
(m
s)
β = 1
Liu et al. (2018)
Zhang et al. (2022)
Wang et al. (2022)
Ours
0 50 100 150 200 250 300
0
1
2
3
4
5
·104
Number of Search Keywords
C
om
pu
ta
ti
on
C
os
ts
(m
s)
β = 10
Liu et al. (2018)
Zhang et al. (2022)
Wang et al. (2022)
Ours
0 50 100 150 200 250 300
0
1
2
3
4
5
·104
Number of Search Keywords
C
om
pu
ta
ti
on
C
os
ts
(m
s)
β = 30
Liu et al. (2018)
Zhang et al. (2022)
Wang et al. (2022)
Ours
0 50 100 150 200 250 300
0
1
2
3
4
5
·104
Number of Search Keywords
C
om
pu
ta
ti
on
C
os
ts
(m
s)
β = 50
Liu et al. (2018)
Zhang et al. (2022)
Wang et al. (2022)
Ours
Figure 7. Computation costs comparison as the number of search keywords increases [25,28,31].
7.3. Communication Costs
The communication costs of the proposed scheme are compared with [25,28,31]. We
set the bit size of the hash function, identity, timestamp, random number, index, an elliptic
curve point, G, GT , symmetric encryption/decryption, and attribute set to 160 bits, 128 bits,
32 bits, 160 bits, 32 bits, 320 bits, 512 bits, 1024 bits, 256 bits, and 32T bits, respectively.
Table 5 indicates the comparison results of the communication costs. In the data retrieval
and request phases, the exchanged messages {Try1, Try2, I, T3}, {CIDi, Veri fi}, {CIDi}, and
{c, cm1, cm2} needed 1088 bits, 320 bits, 160 bits, and 2048 bits, respectively. The existing
schemes [25,28,31] had higher costs than the proposed scheme. Therefore, we have lower
costs and ensure more security requirements than the existing schemes [25,28,31].
Table 5. Communication Costs Comparison.
Scheme Communication Costs Number of Messages
[25] 2T + 5792 bits 2
[28] T + 7552 bits 5
[31] T + 4576 bits 5
Ours 3616 bits 4
8. Conclusions
We proposed a secure PHR sharing system by applying a blockchain and an IPFS to
ensure integrity and solve the single-point-of-failure problem. We suggested key aggregate
dynamic searchable encryption using LSSS to provide the authority of data owners and
reduce the unnecessary computation for users. In addition, we considered mutual authenti-
Electronics 2022, 11, 3199 22 of 24
cation and data verification to realize securing sharing between network entities. With the
proposed scheme, the data owner can encrypt and upload his/her own PHR with unique
system parameters and assign the read rights to data users with an aggregate key through
mutual authentication. The data user can obtain the encrypted PHR by communicating
with the blockchain and IPFS, and the data user can verify the integrity of the decrypted
PHR ciphertext with the aggregate key. We proved the security of the proposed scheme
through information and formal analyses including BAN logic, the AVISPA tool and the
IND-CPA, IND-CKA, and IND-KGA models. In addition, we performed a comparison of
previous works using MIRACL. We demonstrated that our scheme provides more efficient
and secure sharing compared to existing schemes. As a result, the proposed scheme pro-
vides essential security requirements such as rights related to personal data, data integrity,
transparency, mutual authentication, and convenience of search so our scheme has novelty
compared to other previous works. Therefore, the proposed scheme can be applied in a
practical PHR sharing system and will ensure secure and efficient sharing by providing
the authority of the patient and ensuring the confidence of the data user. Since the scope
of the proposed scheme is how data owners share their PHR without TTP, we focused
on the method of secure PHR sharing through mutual authentication. So, we have an
issue to overcome in terms of verifying the identity before mutual authentication between
the data owner and user. In the future, we will cover the identity verification for more
systematic patient-oriented systems. In addition, we plan to test the proposed scheme on
the blockchain and IPFS implementations. Then, we will evaluate the feasibility of the
proposed scheme in a practical PHR sharing system.
Author Contributions: Conceptualization, J.O., J.L., and K.P.; software, J.L. and M.K.; validation, Y.P.;
formal analysis, J.O. and M.K.; investigation, J.L. and M.K.; writing—original draft preparation, J.O.;
writing—review and editing, Y.P., K.P., and S.N.; supervision, Y.P.; funding acquisition, K.P. and S.N.
All authors have read and agreed to the published version of the manuscript.
Funding: This research was supported in part by the National Research Foundation of Korea (NRF)
and funded by the Ministry of Education under grant 2020R1I1A3058605, and in part by the Ko-
rean Government through the Electronics and Telecommunications Research Institute—ETRI (Core
Technology Research on Trust Data Connectome) under Grant 22ZR1330.
Conflicts of Interest: The authors declare no conflict of interest.
References
1. ISO. Health Informatics—Capacity-Based ehealth Architecture Roadmap—Part 2: Architectural Components and Maturity Model; Technical
Report (ISO/TRTR14639-2); ISO: Geneva, Switzerland, 2014. Available online: https://www.iso.org/standard/54903.html
(accessed on 13 April 2022).
2. Deng, F.; Wang, Y.; Peng, L.; Xiong, H.; Geng, J.; Qin, Z. Ciphertext-policy attribute-based signcryption with verifiable outsourced
designcryption for sharing personal health records. IEEE Access 2018, 6, 39473–39486. [CrossRef] [CrossRef]
3. MTBC PHR: Personal Health Records for Patients. Available online: https://phr.mtbc.com/phrdefault.aspx (accessed on
13 April 2022). [CrossRef]
4. Capzule PHR: Your Family Health Data in One App. (Personal Medical/Health Records). Available online: https://www.
capzule.com/ (accessed on 13 April 2022). [CrossRef]
5. My Medical—The Personal Medical Record for You, The Patient. Available online: http://mymedicalapp.com/ (accessed on
13 April 2022). [CrossRef]
6. Garg, N.; Wazid, M.; Das, A.K.; Singh, D.P.; Rodrigues, J.J.P.C.; Park, Y. BAKMP-IoMT: Design of blockchain enabled authenticated
key management protocol for internet of medical things deployment. IEEE Access 2020, 8, 95956–95977. [CrossRef]
7. Morales-Sandoval, M.; Cabello, M.H.; Marin-Castro, H.M.; Compean, J.L.G. Attribute-based encryption approach for storage,
sharing and retrieval of encrypted data in the cloud. IEEE Access 2020, 8, 170101–170116. [CrossRef]
8. Banerjee, S.; Roy, S.; Odelu, V.; Das, A.K.; Chattopadhyay, S.; Rodrigues, J.J.P.C.; Park, Y. Multi-authority CP-ABE-based user
access control scheme with constant-size key and ciphertext for IoT deployment. J. Inf. Secur. Appl. 2020, 53, 102503. [CrossRef]
9. Cui, B.; Liu, Z.; Wang, L. Key-aggregate searchable encryption (KASE) for group data sharing via cloud storage. IEEE Trans.
Comput. 2016, 65, 2374–2385. [CrossRef] [CrossRef]
10. Kim, M.; Lee, J.; Oh, J.; Park, K.; Park, Y.; Park, K. Blockchain based energy trading scheme for vehicle-to-vehicle using
decentralized identifiers. Appl. Energy 2022, 322, 119445. [CrossRef]
https://www.iso.org/standard/54903.html
https://ieeexplore.ieee.org/abstract/document/8412089
http://doi.org/10.1109/ACCESS.2018.2843778
https://phr.mtbc.com/phrdefault.aspx
http://dx.doi.org/10.1109/ACCESS.2018.2843778
https://www.capzule.com/
https://www.capzule.com/
http://dx.doi.org/10.1109/ACCESS.2018.2843778
http://mymedicalapp.com/
http://dx.doi.org/10.1109/ACCESS.2018.2843778
https://ieeexplore.ieee.org/abstract/document/9097179
https://ieeexplore.ieee.org/abstract/document/9199107
https://www.sciencedirect.com/science/article/pii/S2214212619310178
https://ieeexplore.ieee.org/abstract/document/7004815
http://dx.doi.org/10.1109/ACCESS.2020.2995917
http://dx.doi.org/10.1109/ACCESS.2020.3023893
Electronics 2022, 11, 3199 23 of 24
11. Chen, CM.; Tie, Z.; Wang, E.K.; Khan, M.K.; Kumar, S.; Kumari, S. Verifiable dynamic ranked search with forward privacy over
encrypted cloud data. Peer-to-Peer Netw. Appl. 2021, 14, 2977–2991. [CrossRef] [CrossRef]
12. Yu, S.; Park, Y. A robust authentication protocol for wireless medical sensor networks using blockchain and physically unclonable
functions. IEEE Internet Things J. 2022, 9, 20214–20228. [CrossRef] [CrossRef]
13. Chattaraj, D.; Bera, B.; Das, A.K.; Rodrigues, J.J.P.C.; Park, Y. Designing fine-grained access control for software-defined networks
using private blockchain. IEEE Internet Things J. 2022, 9, 1542–1559. [CrossRef] [CrossRef]
14. Chen, CM.; Deng, X.; Kumar, S.; Kumari, S.; Islam, S.K. Blockchain-based medical data sharing schedule guaranteeing security of
individual entities. J. Ambient Intell. Humaniz. Comput. 2021. [CrossRef]
15. Park, K.; Lee, J.; Das, A.K.; Park, Y. BPPS:Blockchain-enabled privacy-preserving scheme for demand-response management in
smart grid environments. IEEE Trans. Dependable Secur. Comput. 2022, Early access. [CrossRef] [CrossRef]
16. Son, S.; Lee, J.; Park, Y.; Park, Y.; Das, A.K. Design of blockchain-based lightweight V2I handover authentication protocol for
VANET. IEEE Trans. Netw. Sci. Eng. 2022, 9, 1346–1358. [CrossRef] [CrossRef]
17. Kumar, P.; Kumar, R.; Srivastava, G.; Gupta, G.P.; Tripathi, R.; Gadekallu, T.R.; Xiong, N.N. PPSF: A privacy-preserving and
secure framework using blockchain-based machine-learning for IoT-driven smart cities. IEEE Trans. Netw. Sci. Eng. 2021, 8,
2326–2341. [CrossRef] [CrossRef]
18. Kim, M.; Yu, S.; Lee, J.; Park, Y.; Park, Y. Design of Secure Protocol for Cloud-Assisted Electronic Health Record System Using
Blockchain. Sensors 2020, 20, 2913. [CrossRef]
19. Li, M.; Yu, S.; Zheng, Y.; Ren, K.; Lou, W. Scalable and secure sharing of personal health records in cloud computing using
attribute-based encryption. IEEE Trans. Parallel Distrib. Syst. 2013, 24, 131–143. [CrossRef] [CrossRef]
20. Liu, J.; Huang, X.; Liu, J.K. Secure sharing of personal health records in cloud computing: Ciphertext-policy attribute-based
signcryption. Future Gener. Comp. Syst. 2015, 52, 67–76. [CrossRef] [CrossRef]
21. Rao, Y. A secure and efficient ciphertext-policy attribute-based signcryption for personal health records sharing in cloud
computing. Future Gener. Comp. Syst. 2017, 67, 133–151. [CrossRef] [CrossRef] [PubMed]
22. Zhang, W.; Lin, Y.; Xiao, S.; Wu, J.; Zhou, S. Privacy preserving ranked multi-keyword search for multiple data owners in cloud
computing. IEEE Trans. Comput. 2016, 65, 1566–1577. [CrossRef] [CrossRef]
23. Peng, T.; Lin, Y.; Yao, X.; Zhang, W. An efficient ranked multi-keyword search for multiple data owners over encrypted cloud
data. IEEE Access 2018, 6, 21924–21933. [CrossRef] [CrossRef]
24. Sun, J.; Hu, S.; Nie, X.; Walker, J. Efficient ranked multi-keyword retrieval with privacy protection for multiple data owners in
cloud computing. IEEE Syst. J. 2020, 14, 1728–1739. [CrossRef] [CrossRef]
25. Liu, Z.; Liu, Y.; Fan, Y. Searchable attribute-based signcryption scheme for electronic personal health record. IEEE Access 2018, 6,
76381–76394. [CrossRef] [CrossRef]
26. Xu, C.; Wang, N.; Zhu, L.; Sharif, K.; Zhang, C. Achieving searchable and privacy-preserving data sharing for cloud-assisted
e-healthcare system. IEEE Internet Things J. 2019, 6, 8345–8356. [CrossRef] [CrossRef]
27. Wang, S.; Zhang, D.; Zhang, Y. Blockchain-based personal health records sharing scheme with data integrity verifiable. IEEE
Access 2019, 7, 102887–102901. [CrossRef] [CrossRef]
28. Zhang, J.; Yang, Y.; Liu, X.; Ma, J. An efficient blockchain-based hierarchical data sharing for Healthcare Internet of Things. IEEE
Trans. Ind. Inform. 2022, 18, 7139–7150. [CrossRef] [CrossRef]
29. Zhang, L.; Zhang, T.; Wu, Q.; Mu, Y.; Rezaeibagha, F. Secure decentralized attribute-based sharing of personal health records with
blockchain. IEEE Internet Things J. 2022, 9, 12482–12496. [CrossRef] [CrossRef]
30. Madine, M.M.; Salah, K.; Jayaraman, R.; Yaqoob, I.; Al-Hammadi, Y.; Ellahham, S.; Calyam, P. Fully decentralized multi-party
consent management for secure sharing of patient health records. IEEE Access 2020, 8, 225777–225791. [CrossRef] [CrossRef]
31. Wang, Y.; Zhang, A.; Zhang, P.; Qu, Y.; Yu, S. Security-aware and privacy-preserving personal health record sharing using
consortium blockchain. IEEE Internet Things J. 2022, 9, 12014–12028. [CrossRef] [CrossRef]
32. Wu, G.; Wang, S.; Ning, Z.; Li, J. Blockchain-enabled privacy-preserving access control for data publishing and sharing in the
internet of medical things. IEEE Internet Things J. 2022, 9, 8091–8104. [CrossRef] [CrossRef]
33. Hussien, H.M.; Yasin, S.M.; Udzir, N.I.; Ninggal, M.I.H. Blockchain-based access control scheme for secure shared personal health
records over decentralised storage. Sensors 2021, 21, 2462. [CrossRef] [CrossRef]
34. Niu, J.; Li, X.; Gao, J.; Han, Y. Blockchain-based anti-key-leakage key aggregation searchable encryption for IoT. IEEE Internet
Things J. 2020, 7, 1502–1518. [CrossRef] [CrossRef]
35. Dolev, D.; Yao, A. On the security of public key protocols. IEEE Trans. Inf. Theory 1983, 29, 198–208. [CrossRef] [CrossRef]
36. Wazid, M.; Das, A.K.; Choo, K.-K.R.; Park, Y. SCS-WoT: Secure communication scheme for web of things deployment. IEEE
Internet Things J. 2022, 9, 10411–10423. [CrossRef] [CrossRef] [PubMed]
37. Oh, J.; Lee, J.; Kim, M.; Park, Y.; Park K.; Noh, S. A secure data sharing based on key aggregate searchable encryption in
fog-enabled IoT environment. IEEE Trans. Netw. Sci. Eng. 2022, Early access. [CrossRef] [CrossRef]
38. Beimel, A. Secure Schemes for Secret Sharing and Key Distribution; Technion-Israel Institute of Technology, Faculty of Computer
Science: Haifa, Israel, 1996. [CrossRef]
39. Hunhevicz, J.J.; Hall, D.M. Do you need a blockchain in construction? Use case categories and decision framework for DLT
design options. Adv. Eng. Inform. 2020, 45, 101094. [CrossRef] [CrossRef]
https://link.springer.com/article/10.1007/s12083-021-01132-3
http://dx.doi.org/10.1016/j.jisa.2020.102503
https://ieeexplore.ieee.org/abstract/document/9766168
http://dx.doi.org/10.1109/TC.2015.2389959
https://ieeexplore.ieee.org/abstract/document/9452113
http://dx.doi.org/10.1016/j.apenergy.2022.119445
http://dx.doi.org/10.1007/s12083-021-01132-3
https://ieeexplore.ieee.org/abstract/document/9744547
http://dx.doi.org/10.1109/JIOT.2022.3171791
https://ieeexplore.ieee.org/abstract/document/9681379
http://dx.doi.org/10.1109/JIOT.2021.3088115
https://ieeexplore.ieee.org/abstract/document/9456995
http://dx.doi.org/10.1007/s12652-021-03448-7
https://www.mdpi.com/1424-8220/20/10/2913#cite
https://ieeexplore.ieee.org/abstract/document/6171175
http://dx.doi.org/10.1109/TNSE.2022.3142287
https://www.sciencedirect.com/science/article/pii/S0167739X14002076
http://dx.doi.org/10.1109/TNSE.2021.3089435
https://www.sciencedirect.com/science/article/pii/S0167739X16302746
http://dx.doi.org/10.3390/s20102913
http://www.ncbi.nlm.nih.gov/pubmed/32455635
https://ieeexplore.ieee.org/abstract/document/7130597
http://dx.doi.org/10.1109/TPDS.2012.97
https://ieeexplore.ieee.org/abstract/document/8344568
http://dx.doi.org/10.1016/j.future.2014.10.014
https://ieeexplore.ieee.org/abstract/document/8811828
http://dx.doi.org/10.1016/j.future.2016.07.019
https://ieeexplore.ieee.org/abstract/document/8515007
http://dx.doi.org/10.1109/TC.2015.2448099
https://ieeexplore.ieee.org/document/8716522
http://dx.doi.org/10.1109/ACCESS.2018.2828404
https://ieeexplore.ieee.org/abstract/document/8778648
http://dx.doi.org/10.1109/JSYST.2019.2933346
https://ieeexplore.ieee.org/abstract/document/9693298
http://dx.doi.org/10.1109/ACCESS.2018.2878527
https://ieeexplore.ieee.org/abstract/document/9657067
http://dx.doi.org/10.1109/JIOT.2019.2917186
https://ieeexplore.ieee.org/abstract/document/9294064
http://dx.doi.org/10.1109/ACCESS.2019.2931531
https://ieeexplore.ieee.org/abstract/document/9638510
http://dx.doi.org/10.1109/TII.2022.3145851
https://ieeexplore.ieee.org/abstract/document/9662435
http://dx.doi.org/10.1109/JIOT.2021.3137240
https://www.mdpi.com/1424-8220/21/7/2462
http://dx.doi.org/10.1109/ACCESS.2020.3045048
https://ieeexplore.ieee.org/abstract/document/8915860
http://dx.doi.org/10.1109/JIOT.2021.3132780
https://ieeexplore.ieee.org/document/1056650
http://dx.doi.org/10.1109/JIOT.2021.3138104
https://ieeexplore.ieee.org/abstract/document/9583609
http://dx.doi.org/10.3390/s21072462
http://www.ncbi.nlm.nih.gov/pubmed/33918266
https://ieeexplore.ieee.org/abstract/document/9881907
http://dx.doi.org/10.1109/JIOT.2019.2956322
http://dx.doi.org/10.1109/TIT.1983.1056650
https://www.sciencedirect.com/science/article/pii/S147403462030063X
http://dx.doi.org/10.1109/JIOT.2021.3122007
Electronics 2022, 11, 3199 24 of 24
40. Tan, W.K.A.; Sundarakani, B. Assessing blockchain technology application for freight booking business: A case study from
technology acceptance model perspective. J. Glob. Oper. Strateg. Sourc. 2021, 14, 202–223. [CrossRef]
41. Szabo, N. Formalizing and securing relationships on public networks. First Monday 1997, 2. Available online: https://firstmonday.
org/ojs/index.php/fm/article/view/548 (accessed on 13 April 2022).
42. IPFS is the Distributed Web. Available online: https://ipfs.io/ (accessed on 13 April 2022). [CrossRef]
43. Viganò, L. Automated security protocol analysis with the AVISPA tool. Electron. Notes Theor. Comput. Sci. 2006, 155, 61–86.
[CrossRef]
44. Lee, J.; Yu, S.; Park, K.; Park, Y.; Park, Y. Secure three-factor authentication protocol for multi-gateway IoT environments. Sensors
2019, 19, 2358. [CrossRef] [CrossRef]
45. Liu, X.; Guo, Z.; Ma, J.; Song, Y. A secure authentication scheme for wireless sensor networks based on DAC and Intel SGX. IEEE
Internet Things J. 2022, 9, 3533–3547. [CrossRef]
46. Kwon, D.; Park, Y.; Park, Y. Provably secure three-factor-based mutual authentication scheme with PUF for wireless medical
sensor networks. Sensors 2021, 21, 6039. [CrossRef] [CrossRef]
47. Shashidhara, R.; Nayak, S.K.; Das A.K.; Park, Y. On the design of lightweight and secure mutual authentication system for global
roaming in resource-limited mobility networks. IEEE Access 2021, 9, 12879–12895. [CrossRef] [CrossRef]
48. Chen, CM.; Deng, X.; Gan, W.; Chen, J.; Islam, S.K. A secure blockchain-based group key agreement protocol for IoT. J. Supercomput.
2021, 77, 9046–9068. [CrossRef] [CrossRef]
49. Lee, J.; Kim, G.; Das, A.K.; Park, Y. Secure and efficient honey list-based authentication protocol for vehicular ad hoc networks.
IEEE Trans. Netw. Sci. Eng. 2021, 8, 2412–2425. [CrossRef] [CrossRef] [PubMed]
50. MIRACL Cryptographic SDK: Multiprecision Integer and Rational Arithmetic Cryptographic Library. Available online: https:
//github.com/miracl/MIRACL (accessed on 13 April 2022). [CrossRef]
https://www.emerald.com/insight/content/doi/10.1108/JGOSS-04-2020-0018/full/html
https://firstmonday.org/ojs/index.php/fm/article/view/548
https://firstmonday.org/ojs/index.php/fm/article/view/548
https://ipfs.io/
http://dx.doi.org/10.1016/j.aei.2020.101094
http://dx.doi.org/10.1108/JGOSS-04-2020-0018
https://www.mdpi.com/1424-8220/19/10/2358
http://dx.doi.org/10.5210/fm.v2i9.548
https://ieeexplore.ieee.org/abstract/document/9490363
https://www.mdpi.com/1424-8220/21/18/6039
http://dx.doi.org/10.1016/j.entcs.2005.11.052
https://ieeexplore.ieee.org/abstract/document/9319149
http://dx.doi.org/10.3390/s19102358
https://link.springer.com/article/10.1007/s11227-020-03561-y
http://dx.doi.org/10.1109/JIOT.2021.3097996
https://ieeexplore.ieee.org/abstract/document/9468344
http://dx.doi.org/10.3390/s21186039
http://www.ncbi.nlm.nih.gov/pubmed/34577245
https://github.com/miracl/MIRACL
https://github.com/miracl/MIRACL
http://dx.doi.org/10.1109/ACCESS.2021.3050402
	Introduction
	Motivation, Methodology, and Contributions
	Organization
	Related Works
	Preliminaries
	System Models
	Network Model
	Threat Model
	Security Model
	Bilinear Maps
	Linear Secret-Sharing Scheme (LSSS)
	Computational Assumption
	Decisional Diffie–Hellman (DDH) Assumption
	Decisional Bilinear Diffie–Hellman (DBDH) Assumption
	Blockchain
	InterPlanetary File Systems
	Proposed Scheme
	Setup Phase
	Key Generation Phase
	Data Upload Phase
	Aggregate Key Request Phase
	Data Retrieval Phase
	Data Request Phase
	Informal Security Analysis
	Impersonation Attack
	Replay Attack
	Man-in-the-Middle (MITM) Attack
	Insider Attack
	Correctness
	Dynamic Keyword
	PHR
	Perfect Forward Secrecy
	Anonymity
	Mutual Authentication
	Formal Security Analysis
	AVISPA Simulation Tool
	Formal Security Analysis using BAN Logic
	Rules
	Goals
	Idealized Forms
	Assumptions
	Proof
	IND-CPA Security
	IND-CKA Security
	IND-KGA Security
	Security and Performance Analysis
	Security Features
	Computational Costs
	Communication Costs
	Conclusions
	References