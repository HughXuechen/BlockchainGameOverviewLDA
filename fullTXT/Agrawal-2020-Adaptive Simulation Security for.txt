Adaptive Simulation Security for Inner Product Functional Encryption
Adaptive Simulation Security for Inner
Product Functional Encryption
Shweta Agrawal1, Benoît Libert2,3(B), Monosij Maitra1, and Radu Titiu3,4
1 IIT Madras, Chennai, India
2 CNRS, Laboratoire LIP, Lyon, France
3 ENS de Lyon, Laboratoire LIP (U. Lyon, CNRS, ENSL, Inria, UCBL),
Lyon, France
benoit.libert@ens-lyon.fr
4 Bitdefender, Bucharest, Romania
Abstract. Inner product functional encryption (IPFE) [1] is a popular
primitive which enables inner product computations on encrypted data.
In IPFE, the ciphertext is associated with a vector x, the secret key is asso-
ciated with a vector y and decryption reveals the inner product 〈x, y〉.
Previously, it was known how to achieve adaptive indistinguishability
(IND) based security for IPFE from the DDH, DCR and LWE assumptions
[8]. However, in the stronger simulation (SIM) based security game, it
was only known how to support a restricted adversary that makes all its
key requests either before or after seeing the challenge ciphertext, but
not both. In more detail, Wee [46] showed that the DDH-based scheme
of Agrawal et al. (Crypto 2016) achieves semi-adaptive simulation-based
security, where the adversary must make all its key requests after see-
ing the challenge ciphertext. On the other hand, O’Neill showed that all
IND-secure IPFE schemes (which may be based on DDH, DCR and LWE)
satisfy SIM based security in the restricted model where the adversary
makes all its key requests before seeing the challenge ciphertext.
In this work, we resolve the question of SIM-based security for IPFE
by showing that variants of the IPFE constructions by Agrawal et al.,
based on DDH, Paillier and LWE, satisfy the strongest possible adaptive
SIM-based security where the adversary can make an unbounded num-
ber of key requests both before and after seeing the (single) challenge
ciphertext. This establishes optimal security of the IPFE schemes, under
all hardness assumptions on which it can (presently) be based.
Keywords: Functional encryption · Inner-products · Simulation-based
security · Standard assumptions
1 Introduction
Functional Encryption (FE) [15,37] is a modern cryptographic paradigm that
allows fine-grained access to encrypted data, unlike traditional public-key encryp-
tion, where decryption offers all-or-nothing access to data. In FE, a secret key
c© International Association for Cryptologic Research 2020
A. Kiayias et al. (Eds.): PKC 2020, LNCS 12110, pp. 34–64, 2020.
https://doi.org/10.1007/978-3-030-45374-9_2
http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-45374-9_2&domain=pdf
https://doi.org/10.1007/978-3-030-45374-9_2
Adaptive Simulation Security for Inner Product Functional Encryption 35
skf corresponds to function f , and ciphertext ct(x) corresponds to some input
x from the domain of f . Given a function key skf and a ciphertext ct(x), a user
can run the decryption algorithm to learn f(x). Security of FE guarantees that
beyond f(x), nothing about x is revealed.
Functional encryption has been studied extensively, yielding a plethora of con-
structions that achieve various tradeoffs between generality, security and hard-
ness assumptions. Assuming the existence of the powerful multilinear maps [22]
or indistinguishability obfuscation [23], FE can be constructed for all polynomial
sized circuits achieving the strongest possible definition of security [23,24]. How-
ever, from standard assumptions, which is the focus of this work, constructions
are only known for restricted classes of functionalities or achieving restricted
notions of security. We discuss each of these aspects next.
On the Definition of Security. In the papers that introduced functional encryp-
tion [15,37], the authors discussed the subtleties involved in formulating the
right definition of security for FE. Traditionally, an “indistinguishability” (IND)
style definition had been used for constructing various special cases of functional
encryption, which roughly requires that no efficient adversary that has oracle
access to the key generation algorithm should be able to distinguish between
encryptions of two messages x0 and x1. However, [15] showed that this notion
was too weak for functional encryption in some cases. Specifically, they gave an
FE construction that could be proved secure with respect to the IND security
requirement, but was intuitively insecure.
[15,37] proposed the study of simulation-based (SIM) security which asks that
the view of the adversary be simulated by a simulator that is given access to pairs
(fi, fi(x�)) where fi are the functions for which the adversary requests keys, and
x� is the challenge message. SIM security captured the intuition that nothing
about x� be revealed except for the function output value, and ruled out the
insecure scheme that IND security could not. However, it was soon shown that
for general functionalities, SIM-based security is impossible to achieve [7,15].
Additionally, other restricted notions of security have also been studied, that
limit either (i) the number of key requests – bounded collusion FE [26], (ii) the
“type” of key requests – one sided FE or “predicate encryption” where the adver-
sary may only request keys for functions f such that f(x�) = 0 [10,28], or (iii)
that allow for part of the input vector to be public – public index or “attribute-
based encryption” [6,14,28,29,31]. While these restricted notions are meaningful
for different applications, it remains desirable to obtain security in an unre-
stricted security game, if only for specialized functionalities.
Restricting the Functionality. Aside from different security notions, construc-
tions of FE also vary in the functionality they support. Many special cases of
FE have been studied before and since its formalization as an abstract primitive
[15,37] – identity-based encryption (IBE) [13,42] fuzzy identity-based encryption
[5,41] attribute-based encryption (ABE) [27,29,31] predicate encryption (PE)
[28,30,31], bounded-key functional encryption [25,26]. However, excepting [30],
the security of all these schemes was restricted in one of the three ways discussed
above.
36 S. Agrawal et al.
Abdalla, Bourse, De Caro and Pointcheval [1] introduced the primitive of
inner product functional encryption (IPFE). In IPFE the ciphertext is associated
with a vector x, the secret key is associated with a vector y and decryption
reveals 〈x,y〉. Since its introduction, IPFE has been studied extensively [1,8,11,
12,17,19,43,44] due to its feasibility under well-established assumptions [1,8],
its natural applications [1] and extensions [2,3,18,21], its use as a building block
for more advanced functionalities [3,4,9,32,33], and the fact that it admits an
unrestricted security definition (more on this below).
Security of IPFE. Abdalla et al. [1] constructed practical schemes for IPFE under
well studied hardness assumptions like the Decisional Diffie-Hellman (DDH) and
Learning With Errors (LWE). Their constructions achieved security in a game
which did not place any restriction on the number or type of key requests, nor
necessitated making any part of the input public. Given the paucity of schemes
that achieve these features, this was good news.
However, despite its positive features, the security game considered by [1]
had shortcomings – their constructions were only proven to be selectively secure
in the IND model, which means that the adversary has to announce the chal-
lenge messages before it even sees the public key of the scheme. This result
was improved by Agrawal, Libert and Stehlé [8] who constructed adaptive AD-
IND functional encryption for the same inner product functionality, under DDH,
LWE and also from Paillier’s Decision Composite Residuosity (DCR). Thus, the
result of [8] established optimal security of IPFE in the IND-based game, from
all hardness assumptions on which it can (presently) be based.
In the domain of SIM-based security for IPFE, much less is known. On one
hand, O’Neill [37] showed that for IPFE,1 IND security implies SIM security in
a model where the adversary is restricted to making all its key queries before it
sees the challenge ciphertext. On the other hand, Wee [46] recently proved that
the DDH-based FE scheme from [8] achieves simulation-based security in a model
where the adversary is restricted to making all its key queries after it sees the
challenge ciphertext, in the so-called semi-adaptive game. Datta et al. [20] subse-
quently extended Wee’s ideas so as to prove simulation-security against adaptive
adversaries in predicate encryption schemes [30] based on bilinear maps [34–36].
In the IPFE setting, known proofs of SIM security break down in the natural
adaptive model where the adversary is allowed to make key queries adaptively,
both before and after seeing the challenge ciphertext. Moreover, Wee’s result is
not generic and only applies to the DDH-based construction of [8] as well as in
specific pairing-based constructions of predicate encryption.
For a functionality as basic as IPFE, this state of affairs is quite dissatisfying.
Specifically, the following fundamental question remains to be answered:
Is it possible to achieve the strongest notion of security, namely AD-SIM
security for IPFE, which permits the adversary an unbounded number of key
requests before and after seeing the (single) challenge ciphertext? Moreover, can
1 Or, more generally, the class of preimage sampleable functinalities of which inner
product is a special case.
Adaptive Simulation Security for Inner Product Functional Encryption 37
we achieve AD-SIM security from all the assumptions on which IPFE can be based,
namely DDH (in groups without a bilinear map), DCR and LWE?
In the present work, we resolve this question in the affirmative.
Our Results. In this work, we prove adaptive simulation-security (AD-SIM) for
an unbounded number of key queries and a single challenge ciphertext, for IPFE
schemes, based on the DDH, DCR and LWE assumptions. We place no restrictions
on when the adversary may query for keys with respect to the challenge cipher-
text. Thus, our security game achieves the “best of” both security games consid-
ered by Wee [46] and O’Neill [37], where the former permits post-challenge key
requests but not pre, and the latter permits pre-challenge key requests but not
post. By providing constructions under all assumptions on which IPFE schemes
may presently be based, we improve a result by Wee [46], which achieved semi-
adaptive SIM based security for DDH-based IPFE.
In more detail, we prove that the DDH based scheme of Agrawal et al. [8]
(unmodified) achieves AD-SIM rather than just AD-IND security. Next, we show
how to modify the DCR based scheme of [8] so that it satisfies AD-SIM security.
Finally, we construct a new scheme for IPFE mod p based on LWE which leverages
the LWE scheme of [8] (almost) generically to achieve AD-SIM security. Note that
the impossibility from [15] rules out AD-SIM for many challenge messages, but
our proofs work for a single challenge message (as does [46]). Moreover, [7] shows
that AD-SIM security for one challenge message is impossible for all circuits, but
this does not contradict our results since our proofs apply for a restricted class
of functionality. Since our schemes achieve the strongest possible SIM security
notion for IPFE under all assumptions on which it can currently be based, we
finally settle the question of optimal security for IPFE.
Technical Overview. Next, we provide a technical overview of our constructions
in turn.
DDH-Based IPFE: The DDH-based IPFE scheme of Agrawal et al. [8] was shown
to provide indistinguishability-based security against adaptive adversaries (or
AD-IND security for short). Later on, Abdalla et al. [3] proved it simulation-
secure against selective adversaries. Wee [46] subsequently gave a proof of semi-
adaptive simulation-based security for the same construction. Here, we show that
the scheme can actually be proved simulation-secure against adaptive adversaries
without any modification.
In Wee’s proof [46], the simulator can create a dummy challenge ciphertext as
an encryption of the all-zeroes vector. In the semi-adaptive setting, the simulated
challenge ciphertext does not have to be consistent with pre-challenge queries
because functional key queries are only allowed after the challenge phase. For a
post-challenge key query y ∈ Z
�
q, the simulator has to respond with a key that
decrypts the dummy ciphertext to the value zy = fy (x�) = 〈y,x�〉 supplied by
the oracle. To do this, it can embed the value zy = 〈x�,y〉 in the modified secret
key which is obtained as an appropriate shift of the actual secret key. Namely,
if the master public key is gs · ht ∈ G
� and the master secret key consists of
38 S. Agrawal et al.
(s, t) ∈R Z
�
q × Z
�
q, the real functional secret key for y ∈ Z
�
q is comprised of
(sy , ty ) = (〈s,y〉, 〈t,y〉). In order to “program” zy = 〈x�,y〉 in the simulated
post-challenge keys, the simulator can define
s′
y := 〈s,y〉 + α · zy mod q t′y := 〈t,y〉 + β · zy mod q,
for carefully chosen coefficients α, β ∈ Zq. From the adversary’s view, this is
equivalent to changing the master secret key into s′ = s + α · x� mod q and
t′ = t+β ·x� mod q, which is consistent with the master public key and responses
to key queries for all vectors y. Using a careful analysis, it was shown [46] that,
under the DDH assumption, the simulation is indistinguishable from the real
experiment, even if the message x� is adaptively chosen after seeing the public
parameters, but before making any key query.
In order to prove simulation-based security for adaptive adversaries, we use
the same approach as [46], but we modify the generation of the simulated cipher-
text. Now, the dummy ciphertext should not only decrypt to the values dictated
by the oracle under post-challenge keys, but it also needs to be consistent with
responses to pre-challenge queries. To achieve this, our simulator answers pre-
challenge key queries by running the real functional key generation algorithm.
For each key query y ∈ Z
�
q, it replies with (sy , ty ) = (〈s,y〉, 〈t,y〉). In the chal-
lenge phase, the simulator has to create a ciphertext that is compatible with all
the pre-challenge queries without having access to the challenge message x� ∈ Z
�
q.
For this purpose, it encrypts an arbitrary dummy message x̄ that satisfies the
relations 〈x̄,y〉 = 〈x�,y〉 mod q, for any pre-challenge query y ∈ Z
�
q. Our obser-
vation is that, although the DDH-based scheme of [8] encrypts vectors x ∈ Z
�
with small entries (because functional secret keys only make it possible to recover
the inner product 〈x,y〉 when it lives in a polynomial-size interval), the dummy
message does not have to be small. This implies that, given the function evalua-
tion {zy = fy (x�) = 〈x�,y〉}y corresponding to all pre-challenge queries y, the
simulator can easily compute a compatible dummy message using linear algebra
over Zq. Once the simulator is committed to the challenge ciphertext, it has to
“program” the post-challenge functional keys in such a way that they decrypt
the dummy ciphertext to the real function evaluations zy = fy (x�) = 〈x�,y〉.
Given a post-challenge query y ∈ Z
�
q and the corresponding function evaluation
zy = 〈x�,y〉, the value zy is embedded in the simulated functional key in such
a way that the difference zy − 〈x̄,y〉 between zy and the function evaluation
fy (x̄) serves as a shift of the real actual key: namely, the simulator returns
sky = (s′
y , t′y ), where
s′
y := 〈s,y〉 + α · (zy − 〈x̄,y〉) mod q (1.1)
t′
y := 〈t,y〉 + β · (zy − 〈x̄,y〉) mod q.
By exploiting the linearity properties of the scheme, the shift terms α·(zy −〈x̄,y〉)
and β ·(zy −〈x̄,y〉) ensure that sky = (s′
y , t′y ) will decrypt the dummy ciphertext
to the oracle-supplied zy . As in [46], we can prove that this shift of post-challenge
keys is equivalent to a shift of the master secret key from the adversary’s view:
Adaptive Simulation Security for Inner Product Functional Encryption 39
namely, msk = (s, t) is traded for msk′ = (s′, t′), where s′ = s + α · (x� − x̄)
and t′ = t + β · (x� − x̄). By applying complexity leveraging argument in a
statistical setting (as previously done in, e.g., [11,45,46]), we can prove that
the two master secret keys of (s′, t′) and (s, t) are identically distributed in the
adversary’s view, even if the adversary chooses x� adaptively, after having seen
the public parameters and responses to pre-challenge queries.
DCR-Based IPFE: The above ideas can be adapted to the Composite Residuos-
ity assumption (DCR) [38] so as to prove simulation-based security in (a variant
of) the Paillier-based construction of Agrawal et al. [8]. One difficulty is that
functional secret keys sy = 〈s,y〉 have to be computed over the integers since
the group order is hidden. When we want to prove that the simulation is indistin-
guishable from the real experiment, this makes it harder to create simulated func-
tional secret keys s′
y := 〈s,y〉+α·(zy −〈x̄,y〉) that are statistically indistinguish-
able from the real keys sy := 〈s,y〉. In particular, since the functional secret keys
are computed over Z, the simulator cannot easily compute a small-norm dummy
message x̄ which is consistent with responses to pre-challenge queries (indeed,
it does not have a short basis for the lattice induced by these queries). However,
the simulator can still use the pre-challenge queries to compute a dummy mes-
sage x̄ ∈ Z
� with large entries. Although x̄ ∈ Z
� does not fit in Z
�
N , we can still
encrypt x̄ mod N and obtain a simulated ciphertext which is compatible with
responses to pre-challenge queries. When it comes to simulating post-challenge
keys, we can have the simulator compute s′
y := 〈s,y〉 + α · (zy − 〈x̄,y〉) and
argue that, from the adversary’s view, this is equivalent to trading the master
secret key s ∈ Z
� for s′ := s + α · (x� − x̄). By computing an upper bound for
‖x� − x̄‖∞, we can increase the magnitude of the master secret key s ∈ Z
� so as
to make sure that the statistical distance between s ∈ Z
� and s′ ∈ Z
� negligible.
This is actually possible by sampling the entries of the master secret key s ∈ Z
�
from a large interval, so that its bitlength becomes O(�3 · λ3/polylog(λ)) if � is
the dimension of encrypted vectors.
LWE-Based IPFE mod p: We now outline our adaptation of the LWE-based
construction for IPFE [8] to achieve adaptive SIM-based security. We focus on
the construction of IPFE modulo a prime p, [8, Sec 4.2], where the ciphertext
contains a vector x ∈ Z
�
p, the key contains a vector y ∈ Z
�
p and decryption
reveals 〈x,y〉 mod p. Our construction is generic except that it requires the
underlying scheme IPFE to satisfy the property that functional keys for vectors
that are linearly dependent on previously queried vectors may be computed as
the linear combination of previously returned keys. In more detail, say that the
adversary queries vectors y1, . . . ,yk ∈ Z
�
p and then submits a query y such that
y =
∑
j∈[k]kj · yj (mod p), for some kj ∈ Zp. Then, the secret key sky ∈ Z
m
can be computed as sky =
∑
j∈[k]kj · skyj
∈ Z
m. This property is satisfied by the
LWE-based construction that evaluates inner products over Zp in [8, Sec 4.2].
Since secret keys of linearly dependent vectors are computed as linear com-
binations of previously returned keys2, it suffices to consider an adversary that
2 As in [8], this results in a stateful key generator.
40 S. Agrawal et al.
only requests for �−1 linearly independent keys. Let us refer to the key requests
made in the pre-challenge phase as ypre and those in the post-challenge phase as
ypost.
To begin, we set L = 2� and instantiate the adaptive IND secure IPFE of [8,
Sec 4.2] with message length L. Given a message vector x ∈ Z
�
p, we extend it to
x̂ ∈ Z
L
p to make one slot corresponding to each independent key queried up to
� − 1 keys. The simulated challenge ciphertext c∗ encrypts the extended vector
̂̄x = (x̄,−r1, . . . ,−r�−1, 1) for a dummy message x̄, where {ri ← Zp}i∈[�−1]
are chosen uniformly at random, while simulating the setup phase of the real
protocol.
Pre-challenge keys for vectors ypre ∈ Z
�
p are handled as in the real scheme. In
more detail, for the ith independent pre-challenge key ypre
i the underlying IPFE
scheme is used to compute keys for the vector (ypre
i , ei, ri), where ei ∈ Z
�−1
p
is the i-th canonical vector and {ri ← Zp}i∈[�−1] are as above. The challenge
ciphertext is handled by computing a message x̄ that is consistent with only the
keys associated with the pre-challenge vectors ypre. For handling post-challenge
queries, let Δi = 〈x� − x̄,ypost
i 〉 be the difference in decryption using the
i-th post-challenge key corresponding to a linearly independent vector ypost
i . To
compensate this difference, we extend the vector ypost
i to (ypost
i , ei,Δi+ri). Note
that the randomizer ri in the i-th slot of the extended message vector hides Δi
in the i-th post-challenge key.
For post challenge keys, the decryption outputs
〈x̄,ypost
i 〉 + 〈−ri, 1〉 + 〈1,Δi + ri〉 = 〈x̄,ypost
i 〉 + Δi = 〈x�,ypost
i 〉
as desired. It is easy to verify that this also works if a post-challenge vector ypost
is a linear combination of possibly any arbitrary subset of pre-challenge and
post-challenge keys queried so far. As for pre-challenge queries, the simulated
keys properly decrypt the simulated ciphertext since the ri simply get cancelled
(i.e., Δi = 0). Also, note that the simulated keys work for any honestly generated
ciphertext since this contains 0 in the extended slots and do not “activate” the
extended slots in the keys. For the detailed proof, please see Sect. 5.
DCR-Based IPFE mod N : In the description of our construction from LWE, we
assumed that the modulus p is prime. However, the same technique can also
be applied to the Paillier-based construction of [8, Section 5.2], which evaluates
inner products over ZN . As a result, it provides a simulation-secure IPFE with
stateful key generation for inner products over ZN , whereas our scheme in Sect. 4
is stateless but computes inner products over Z. When we switch to composite
moduli N = pq, we need to take into account that ZN is not a field when the
simulator has to solve a linear system over ZN in order to compute a dummy
message. Fortunately, inversion over ZN is always possible with overwhelming
probability when factoring N is hard.
Adaptive Simulation Security for Inner Product Functional Encryption 41
2 Preliminaries
In this section we define the preliminaries that we require in this work.
Notation . We begin by defining the notation that we will use throughout the
paper. We use bold letters to denote vectors and the notation [1, n] or [n] or
{1, . . . , n} interchangeably to denote the set of first n positive integers. We denote
by U([n]) the uniform distribution over the set [n] and u ←↩ D or u ← D
interchageably to sample an element u from distribution D. Concatenation is
denoted by the symbol ‖ or | interchangeably. We say a function f(n) is negligible,
denoted by negl(n), if it is O(n−c) for all c > 0. We say an event occurs with
overwhelming probability if its probability is 1 − negl(n).
2.1 Useful Lemmas
We will rely on a few simple but useful lemmas, which are stated hereunder.
Lemma 1. Let M,m be positive integers, M = m · q + r with 0 ≤ r < m.
The statistical distance between the distributions (U(ZM ) mod m) and U(Zm) is
bounded by Δ(U(ZM ) mod m,U(Zm)) ≤ r
M .
Proof. Let M = mq + r, with 0 ≤ r < m. Observe that for i ∈ Zm we can
compute the number of integers of the form i + jm, smaller than M − 1, by
�M−1−i
m 	+1 which is also equal to �q+ r−1−i
m 	+1. So the probability of getting
i ∈ Zm by sampling from U(ZM ) mod m is equal to q+1
M if i < r or equal to q
M
if i ≥ r. So the statistical distance that we want to evaluate is equal to:
Δ =
1
2
⎛
⎝
∑
i<r
∣
∣
∣
∣
q + 1
M
− 1
m
∣
∣
∣
∣ +
∑
i≥r
∣
∣
∣
∣
q
M
− 1
m
∣
∣
∣
∣
⎞
⎠ =
r(m − r)
Mm
≤ r
M
.
��
Lemma 2. Let a, b, c ∈ Z such that b > a. We have Δ
(
U[a,b], Uc+[a,b]
) ≤ |c|
b−a ,
where U[α,β] is the uniform distribution on [α, β] ∩ Z.
Lemma 3. For any A ∈ R
m×n, let α := maxi,j |ai,j |. Then, we have the inequal-
ity det(AA�) ≤ (n · α2)m.
Proof. Since AA� ∈ R
m×m is positive definite, we know that it has positive
eigenvalues λ1, λ2, . . . , λm ≥ 0. By the mean inequality, we have m
√
λ1λ2 · · · λm ≤
λ1+···+λm
m . This can be interpreted as det(AA�) ≤
(
TrAA�
m
)m
and the right
hand side term can be bounded by (nα2)m. ��
Lemma 4. Let Y ∈ Z
k×� be a full rank matrix such that maxi,j |yij | ≤ Y .
There exists an efficient algorithm that finds a basis {x1,x2, . . . ,x�−k} ⊂ Z
� of
the lattice Y⊥ := {x ∈ Z
� : Y · x = 0} such that
‖xj‖∞ ≤ (
√
kY )k , j ∈ {1, . . . , � − k}.
42 S. Agrawal et al.
Proof. We assume w.l.o.g. that Y = [A|B], for a full rank matrix A ∈ Z
k×k
and for some B ∈ Z
k×(�−k) such that maxi,j |ai,j | ≤ Y and maxi,j |bi,j | ≤ Y . If
x = (z1, . . . , zk, λ1, . . . , λ�−k)� satisfies Y · x = 0, Cramer’s rule implies
zi =
−1
detA
�−k∑
j=1
λj · detAij ,
where the matrix Aij ∈ Z
k×k is obtained by replacing the i-th column of A by
the j-th column of B. By choosing (λ1, λ2, . . . , λ�−k) ∈ Z
�−k from the set
{detA · (1, 0, . . . , 0),detA · (0, 1, . . . , 0), . . . ,detA · (0, 0, . . . , 1)},
we obtain the desired basis. Concretely, for every j ∈ {1, 2, . . . , �−k}, we define
xj = (−detA1j ,−detA2j , . . . ,−detAkj , ej · detA) ∈ Z
�.
By using Lemma 3 we get the bounds on the size of each basis vector xj . ��
Corollary 1. Let a full rank Y ∈ Z
k×� such that |yij | ≤ Y and z ∈ Z
k. If there
exists a solution x0 ∈ Z
� to the system Y · x0 = z, then there exists an efficient
algorithm that computes a solution x ∈ Z
� such that ‖x‖∞ ≤ (� − k) · (√kY )k.
Proof. By Lemma 4, we can efficiently find a basis {x1, . . . ,x�−k} of the lattice
Y⊥ such that ‖xj‖∞ ≤ (
√
kY )k. Reducing the solution x0 modulo this basis, we
obtain x := x0 mod Y⊥ such that ‖x‖∞ ≤ ∑�−k
k=1 ‖xj‖∞ ≤ (� − k) · (√kY )k. ��
2.2 Functional Encryption
Definition 1. A Functional Encryption (FE) scheme over a class of
functions F = {f : X → Z} consists of the PPT algorithms
(Setup,KeyGen,Encrypt,Decrypt):
Setup(1λ,F) : Outputs a public key mpk and a master secret key msk.
Keygen(msk, f) : Given the master secret key and a functionality f ∈ F , the
algorithm outputs a secret key skf .
Encrypt(mpk,x) : On input the public key and a message x ∈ X from the mes-
sage space, the algorithm outputs a ciphertext c.
Decrypt(mpk, skf , c) : Given a ciphertext and a secret key corresponding to some
functionality f ∈ F , the algorithm outputs z ∈ Z.
Correctness: We require that for (mpk,msk) ← Setup(1λ,F), for all x ∈ X , all
f ∈ F , c ← Encrypt(mpk,x) and skf ← Keygen(msk, f), with overwhelming
probability, we have Decrypt(mpk, skf , c) = f(x).
In some cases, we will also give a state st as input to algorithm Keygen, so
that a stateful authority may reply to key queries in a way that depends on the
queries that have been made so far. In that situation, algorithm Keygen may
additionally update state st.
Adaptive Simulation Security for Inner Product Functional Encryption 43
2.3 Security
Next, we define security of functional encryption. Security comes in two flavours
– indistinguishability-based and simulation-based – we define each in turn.
Indistinguishability-based security. We first define the weaker notion of
indistinguishability-based security [15]. In this notion, one asks that no efficient
adversary be able to differentiate encryptions of x0 and x1 without obtaining
secret keys skf such that f(x0) �= f(x1).
Definition 2 (Indistinguishability-based security). A functional encryp-
tion scheme FE = (Setup,Keygen,Encrypt,Decrypt) provides semantic security
under chosen-plaintext attacks (or IND-CPA security) if no PPT adversary has
non-negligible advantage in the following game, where q1 ≤ q ∈ poly(λ):
1. The challenger runs (mpk,msk) ← Setup(1λ) and the master public key mpk
is given to the adversary A.
2. The adversary adaptively makes secret key queries to the challenger.
At each query, adversary A chooses a function f ∈ F and obtains
skf ← Keygen(msk, f).
3. Adversary A chooses distinct messages x0,x1 subject to the restriction that,
if {fi}q1
i=1 denotes the set of secret key queries made by A at Stage 2, it holds
that fi(x0) = fi(x1) for each i ∈ {1, . . . , q1}. Then, the challenger flips a
fair coin β ←↩ {0, 1} and computes c� ← Encrypt(mpk,xβ) which is sent as a
challenge to A.
4. Adversary A makes further secret key queries for arbitrary functions f ∈ F .
However, it is required that f(x0) = f(x1) at each query f ∈ {fq1+1, . . . , fq}.
5. Adversary A eventually outputs a bit β′ ←↩ {0, 1} and wins if β′ = β.
The adversary’s advantage is defined to be AdvA(λ) := |Pr[β′ = β]−1/2|, where
the probability is taken over all coin tosses.
Definition 2 captures adaptive security in that the adversary is allowed to
choose the messages x0,x1 at Stage 3.
As pointed out in [15], indistinguishability-based security is not fully satis-
factory in general as it may fail to rule out constructions that are intuitively
insecure. They argue that, whenever it is possible at all, one should prefer a
stronger notion of simulation-based security. We recall this notion hereunder.
Simulation-based security: For a FE scheme defined as above, a PPT
adversary A = (A1, A2) and a PPT simulator Sim = (Setup�,KeyGen�
0,
Encrypt�,KeyGen�
1), consider the following experiments:
44 S. Agrawal et al.
ExpRealFE,A(1λ)
1. (mpk,msk) ← Setup(1λ,F)
2. (x�, st) ← A
Keygen(msk,·)
1 (mpk)
3. c ← Encrypt(mpk,x�)
4. α ← A
KeyGen(msk,·)
2 (mpk, c, st)
ExpIdealFE,A(1λ)
1. (mpk�,msk�) ← Setup�(1λ,F)
2. (x�, st) ← A
Keygen�
0(msk�,·)
1 (mpk�)
Let V = {(fi, fi(x�), skfi
)}k
i=1
3. (c�, st′) ← Encrypt�(mpk�,msk�,V, 1|x�|)
4. α ← A
KeyGen�
1(msk�,st′,·)
2 (mpk�, c�, st)
In the Ideal experiment above, the {fi ∈ F}k
i=1 are the functionalities for
which the adversary requests their corresponding keys, {skfi
}k
i=1. An FE scheme
achieves adaptive simulation-based (AD-SIM) security if there exists a PPT
simulator Sim such that, for any PPT adversary A, the Real and the Ideal exper-
iments are computationally indistinguishable.
We stress that we consider simulators that run in polynomial time. For the
knowledgeable reader, it was shown by Boneh, Sahai and Waters [15] that AD-
SIM-security is impossible to achieve for many challenge messages. While [15]
provided the lower bound for the IBE functionality, the same argument easily
extends to IPFE. Thus, as in [46], our security game must also be restricted to a
single challenge ciphertext. Note that AD-SIM for a single ciphertext implies AD-
IND for a single ciphertext, which in turn implies AD-IND for many ciphertexts
[26]. Hence, AD-SIM for a single ciphertext is still the strongest definition of
security for IPFE.
2.4 Hardness Assumptions
Our first scheme relies on the standard Decision Diffie-Hellman DDH assumption
in ordinary (i.e., non-pairing-friendly) cyclic groups.
Definition 3. In a cyclic group G of prime order p, the Decision
Diffie-Hellman Problem (DDH) in G, is to distinguish the distributions
(g, ga, gb, gab) and (g, ga, gb, gc), with a, b, c ←↩ Zp. The Decision Diffie-
Hellman assumption is the intractability of DDH for any PPT algorithm D.
Our second scheme relies on Paillier’s composite residuosity assumption.
Definition 4 ([38]). Let p, q be prime numbers and N = pq. The Decision
Composite Residuosity (DCR) assumption states that the following two dis-
tributions are computationally indistinguishable:
{
tN0 mod N2 | t0 ← U(Z�
N )
} c≈ {t | t ← U(Z�
N2)}
Our third construction builds on the Learning-With-Errors (LWE) problem,
which is known to be at least as hard as certain standard lattice problems in the
worst case [16,40].
Adaptive Simulation Security for Inner Product Functional Encryption 45
Definition 5. Let q, α,m be functions of a parameter n. For a secret s ∈ Z
n
q ,
the distribution Aq,α,s over Z
n
q × Zq is obtained by sampling a ←↩ Zn
q and an
e ←↩ DZ,αq, and returning (a, 〈a, s〉 + e) ∈ Z
n+1
q . The Learning With Errors
(LWE) problem LWEq,α,m is as follows: For s ←↩ Zn
q , the goal is to distinguish
between the distributions:
D0(s) := U(Zm×(n+1)
q ) and D1(s) := (Aq,α,s)m.
We say that a PPT algorithm A solves LWEq,α if it distinguishes D0(s) and D1(s)
with non-negligible advantage (over the random coins of A and the randomness
of the samples), with non-negligible probability over the randomness of s.
3 Adaptive Simulation-Based Security from DDH
In this section, we first recall the IPFE scheme of [8]. Abdalla et al. [3] pre-
viously showed that this construction provides simulation-based security for
selective adversaries. In [46], Wee gave a proof of simulation-based security for
semi-adaptive adversaries. We provide a proof that handles adaptive adversaries
without any modification in the original scheme.
Setup(1λ, 1�): Choose a cyclic group G of prime order q > 2λ with generators
g, h ←↩ U(G). Then, for each i ∈ {1, . . . , �}, sample si, ti ←↩ U(Zq) and
compute hi = gsi · hti . Define msk := {si, ti}�
i=1 and
mpk :=
(
G, g, h, {hi}�
i=1
)
.
Keygen(msk,y): To generate a key for the vector y = (y1, . . . , y�) ∈ Z
�
q, compute
sky = (sy , ty ) = (
∑�
i=1 si · yi,
∑�
i=1 ti · yi) = (〈s,y〉, 〈t,y〉).
Encrypt(mpk,x): To encrypt a vector x = (x1, . . . , x�) ∈ Z
�
q, sample r ←↩ Zq
and compute
C = gr, D = hr, {Ei = gxi · hr
i }�
i=1.
Return Cx = (C,D,E1, . . . , E�).
Decrypt(mpk, sky , Cx): Given sky = (sy , ty ), compute
Ey = (
�∏
i=1
Eyi
i )/(Csy · Dty ).
Then, compute and output logg(Ey ).
Correctness. Note that
∏�
i=1 Eyi
i = g〈x,y〉·gr〈s,y〉·hr〈t,y〉 = g〈x,y〉·Csy ·Dty , which
implies Ey = g〈x,y〉. The decryption algorithm can thus recover 〈x,y〉 mod q by
solving a discrete logarithm instance in a small interval, by restricting messages
and keys so as to have |〈x,y〉| ≤ L, for some polynomially bounded L = poly(λ).
In this case, the inner product 〈x,y〉 can be recovered in Õ(L1/2) time using [39].
46 S. Agrawal et al.
Theorem 1. The scheme provides simulation-based security against adaptive
adversaries under the DDH assumption.
Proof. To prove the result, we first describe a PPT simulator before showing
that, under the DDH assumption, the adversary cannot distinguish the ideal
experiment from the real experiment.
In both experiments, we know that the adversary A can obtain private keys
for up to � − 1 linearly independent vectors. We assume w.l.o.g. that A makes
private keys queries for exactly � − 1 = �0 + �1 independent vectors, which we
denote by y1, . . . ,y�−1 ∈ Z
�
q. Among these vectors, we denote by y1, . . . ,y�0
the vectors queried by A before the challenge phase while y�0+1, . . . ,y�0+�1
stand for the post-challenge private key queries. In the challenge phase, we
denote by x� = (x�
1, . . . , x
�
� ) ∈ Z
�
q the message chosen by A. The simulator
(Setup�,Keygen�
0,Encrypt
�,Keygen�
1) proceeds in the following way.
Setup�(1λ, 1�): This algorithm is identical to Setup except that ω = logg(h) is
included in the master secret key. It outputs
mpk� :=
(
G, g, h, {hi}�
i=1
)
.
and msk� = (ω, s, t).
Keygen�
0(msk�,y): This algorithm is used to answer private key queries before
the challenge phase and proceeds exactly like Keygen in the real scheme.
Encrypt�(mpk�,msk�,V, {1|x�
i |}�
i=1): This algorithm takes as input mpk�,msk�,
the lengths {1|x�
i |}�
i=1 of all coordinates of x� and a set
V =
{
{yj , zj = 〈x�,yj〉, skyj
}�0
j=1
}
containing all pre-challenge independent queries {yj}�0
j=1, the returned keys
and the corresponding linear function evaluations {zj = 〈x�,yj〉}�0
j=1 for the
challenge message x�. The challenge ciphertext (C�,D�, E�
1 , . . . , E�
� ) is simu-
lated as follows.
1. Letting zpre = (z1, . . . , z�0)
� ∈ Z
�0
q , compute an arbitrary x̄ ∈ Z
�
q such
that Ypre · x̄ = zpre mod q, where
Ypre =
⎡
⎢
⎣
y�
1
...
y�
�0
⎤
⎥
⎦ ∈ Z
�0×�
q .
Note that x̄ = (x̄1, . . . , x̄�)� does not have to be small and can be obtained
via Gaussian elimination.
2. Compute the ciphertext by sampling r, r′ ←↩ U(Zq) uniformly and com-
puting (C�,D�) = (gr, hr′
) as well as
E�
i = gx̄i · C�si · D�ti ∀i ∈ [�].
Adaptive Simulation Security for Inner Product Functional Encryption 47
Output the simulated ciphertext (C�,D�, E�
1 , . . . , E�
� ) together with the state
information st′ = (x̄, r, r′).
Keygen�
1(msk�,y, z = 〈x�,y〉, st′): On input of msk� = (ω, s, t), a post-challenge
query y ∈ Z
�
q, the evaluation z = 〈x�,y〉 of the linear function fy (x�) on the
message x� and the state information st′ = (x̄, r, r′) ∈ Z
�
q ×Z
2
q, this algorithm
computes
t′y = 〈t,y〉 + 1
ω · (r′ − r)
· (〈x̄,y〉 − z) mod q. (3.1)
s′
y = 〈s,y〉 − 1
(r′ − r)
· (〈x̄,y〉 − z) mod q.
and returns sky = (s′
y , t′y ).
Observe that the ciphertext (C�,D�, E�
1 , . . . , E�
� ) produced by Encrypt� is
distributed in such a way that (C�,D�) = (gr, gω·(r+(r′−r))) and
(E�
1 , . . . , E�
� ) = gx̄+ω·(r′−r)·t · (h1, . . . , h�)r,
so that, for any y = (y1, . . . , y�)� ∈ Z
�
q, we have
�∏
i=1
E�
i
yi = g〈x̄,y〉+ω·(r′−r)·〈t,y〉 · (g〈s,y〉 · h〈t,y〉)r,
which implies
�∏
i=1
E�
i
yi/(C�s′
y · D�t′
y ) = gz.
This shows that decrypting the simulated ciphertext (C�,D�, E�
1 , . . . , E�
� ) using
the simulated key sky = (s′
y , t′y ) yields z = 〈x�,y〉, as required.
We now proceed to show that the simulation is computationally indistinguish-
able from the real experiment under the DDH assumption.
The proof uses a sequence of games that begins with a game in which the
challenger interacts with the adversary as in real experiment and ends with a
game where the challenger interacts with the adversary as in the ideal experiment.
For Gamei and Gamej we denote by Advij(A) the advantage of a PPT algorithm
A in distinguishing between Gamei and Gamej . Formally the challenger C flips
a coin b ←↩ {0, 1}. If b = 0 it interacts with the adversary as in Gamei, else it
interacts as in Gamej . At the end of the interaction A will have to make its guess
b′ ∈ {0, 1}. We define Advij(A) :=
∣
∣Pr[b′ = b] − 1
2
∣
∣.
Game0: In this game the challenger interacts with the adversary as in the real
experiment.
Game1: We modify the generation of the ciphertext C�
x = (C�,D�, E�
1 , . . . , E�
� ).
Namely, the experiment B first computes
C� = gr and D� = hr, (3.2)
48 S. Agrawal et al.
for a randomly sampled r ←↩ Zq. Then, it uses msk := {si, ti}�
i=1 to compute
E�
i = gx�
i · C�si · D�ti . (3.3)
It can be observed that C�
x = (C�,D�, E�
1 , . . . , E�
� ) has the same distribution
as in Game 0. We hence have Adv01(A) = 0.
Game2: We modify again the generation of C�
x = (C�,D�, E�
1 , . . . , E�
� ). Namely,
instead of computing the pair (C�,D�) as in (3.2), the experiment samples
r, r′ ←↩ U(Zq) and sets
C� = gr and D� = hr′
.
The ciphertext components (E�
1 , . . . , E�
� ) are still computed as per (3.3).
Under the DDH assumption, this modification should not significantly affect
A’s view and we have Adv12(A) ≤ AdvDDH
B (1λ).
Game3: In this game, the challenger runs exactly the ideal experiment with the
adversary. Lemma5 shows that Adv23(A) = 0.
Combining the above, we find
|Pr[1 ← ExpReal
A (1λ)] − Pr[1 ← ExpIdeal
A (1λ)]| ≤ AdvDDH
B (1λ),
as claimed. ��
Lemma 5. The advantage of an adversary A in distinguishing between Game2
and Game3 is 0.
Proof. To prove the result, we define the following two variants of these games.
Game′
2: This game is identical to Game2 except that, at the outset of the game,
the challenger chooses a random vector Δx ←↩ U(Z�
q). It interacts with A as
in Game2 until the challenge phase, at which point it samples an arbitrary
vector x̄ ∈ Z
�
q satisfying Ypre · x̄ = Ypre · x� mod q, where Ypre ∈ Z
�0×�
q
is the matrix whose rows are the first �0 independent key queries. At this
point, the challenger checks whether Δx = x̄ − x� mod q (we call Guess this
event). If not, it aborts the interaction with A and replaces A’s output with 0.
Otherwise, it proceeds like Game2 and outputs whatever A outputs. Since Δx
is drawn uniformly and independently of A’s view, we have Pr[Guess] = 1/q�.
Game′
3: This game is like Game3, except that, at the very beginning of the game,
the challenger chooses a random Δx ←↩ U(Z�
q). It proceeds like Game3 until
the challenge phase, at which point it samples an arbitrary x̄ ∈ Z
�
q satifying
Ypre · x̄ = zpre mod q. Then, it checks whether Δx = x̄ − x� mod q (we call
Guess this event). If not, it aborts and replaces A’s output with 0. Otherwise,
it proceeds identically to Game3 and outputs the same result as A.
Now, we claim that Game′
2 and Game′
3 are identical. To see this, we first note
that, conditionally on ¬Guess, both games output 0. If Guess occurs, we observe
Adaptive Simulation Security for Inner Product Functional Encryption 49
that Game′
3 is identical to Game′
2 when the master secret key is replaced by
(s′, t′) ∈ Z
�
q × Z
�
q, where
t′i = ti +
1
ω · (r′ − r)
· Δx
= ti +
1
ω · (r′ − r)
· (x̄i − x�
i ) mod q ∀i ∈ [�]
s′
i = si − 1
r′ − r
· Δx
= si − 1
r′ − r
· (x̄i − x�
i ) mod q.
Indeed, (s′, t′) has the same distribution as (s, t) conditionally on mpk. By con-
struction, we also have 〈s′,y〉 = 〈s,y〉 and 〈t′,y〉 = 〈t,y〉 in all pre-challenge
queries y ∈ Z
�
q. Moreover, we have
gx̄+ω·(r′−r)·t · (h1, . . . , h�)r = gx�+ω·(r′−r)·t′ · (h1, . . . , h�)r.
Finally, answering post-challenge queries y ∈ Z
�
q using (s′, t′) gives exactly the
distribution (3.1). This implies that the games are indeed identical, therefore
Adv′
23 = 0.
To conclude, notice that any adversary A that can distinguish between Game2
and Game3 can be used to distinguish between Game′
2 and Game′
3, with a loss
factor of q� in the advantage:
Adv′
23 =
1
q�
· Adv23(A)
This holds since the probability that A outputs the correct bit b′ when distin-
guishing between Game′
2 and Game′
3 is equal to:
Pr[b′ = b] = Pr[b′ = b|Guess] · Pr[Guess] + Pr[b′ = b|Guess] · Pr[Guess]
which is equivalent to:
Pr[b′ = b] − 1
2
=
(
Pr[b′ = b|Guess] − 1
2
)
· Pr[Guess]
By considering the equality in absolute value, we get the desired relation between
the advantages. ��
While efficient and based on a standard assumption, the scheme of [8] is
restricted to the evaluation of inner products confined in a small interval. In
the next section, we show that our proof can be adapted to the Paillier-based
constructions of [8,11], which make it possible to evaluate inner products over
exponentially large intervals.
50 S. Agrawal et al.
4 Adaptive Simulation-Based Security for Inner Products
over Z from DCR
This section shows that a variant of the Paillier-based IPFE scheme of Agrawal
et al. [8] can also be proved simulation-secure for adaptive adversaries. Like the
first DCR-based construction of [8], it evaluates inner products over the integers.
Our variant differs from [8] in that master secret keys are no longer sampled from
a Gaussian distribution but are rather sampled uniformly in a large interval.
In [11], Benhamouda et al. also considered secret keys sampled from a uniform
distribution over an interval. Their motivation was to obtain indistinguishability-
based security under chosen-ciphertext attacks for adaptive adversaries. Our goal
differs from theirs in that we do not consider chosen-ciphertext attacks but rather
focus on achieving simulation-based security. To this end, we have to sample
master secret keys from a significantly larger interval.
The reason why we need larger master secret keys is that, in the challenge
phase, our simulator has to sample a dummy message x̄ ∈ Z
� that should satisfy
an equation of the form Ypre · x̄ = zpre ∈ Z
k, for some given Ypre ∈ Z
k×�
and zpre ∈ Z
k, in order to be consistent with responses zpre = (z1, . . . , zk) to
all pre-challenge queries. For lack of a short basis for the lattice Y⊥
pre := {x ∈
Z
� : Ypre · x = 0}, our simulator can only sample a dummy message x̄ ∈ Z
�
with large entries. At each post-challenge query y ∈ Z
�, the simulator has to
“program” the returned functional secret key in such a way that it decrypts the
simulated ciphertext to the value z = 〈x�,y〉 dictated by the oracle. For this
purpose, the “programmed” key sk′
y must consist of the sum (over Z) of the real
key sky = 〈s,y〉 and a multiple of the difference z − 〈x̄,y〉 between the function
evaluation fy (x̄) = 〈x̄,y〉 and the oracle value z = 〈x�,y〉. Since z − 〈x̄,y〉 may
be large over Z, we need to sample the entries of s ∈ Z
� from a sufficiently wide
interval so as to “drown” the statistical discrepancy between the distributions of
the master secret s ∈ Z
� and its shifted variant s′ = s+γ ·(x�−x̄) ∈ Z
� for which
sk′
y = 〈s′,y〉. Since RSA moduli should asymptotically contain λ3/polylog(λ)
bits to resist factorization attacks, we need to sample each entry of s ∈ Z
� from
an interval of cardinality O(2�2·λ3/polylog(λ)). Despite somewhat large secret keys,
the scheme remains computationally efficient as only one exponentiation with a
large exponent sky suffices to decrypt. We see it as an interesting open problem
to obtain shorter keys while retaining simulation-based security.
Setup(1λ, 1�,X, Y ): Choose safe primes p = 2p′ + 1 and q = 2q′ + 1 with p′,
q′ also primes, such that �XY < N/2, where N = pq. Sample g′ ← U(Z∗
N2)
and set g := g′2N mod N2. Next for each i ∈ [�] sample si ← U([−S, S] ∩
Z), where S = 2λ+�−1 · X̄�−1 · �N2 and X̄ := X + � · (√�Y )� and then
compute hi = gsi mod N2. Define msk := s = (s1, . . . , s�)� ∈ Z
� and mpk :=(
N, g, {hi}�
i=1,X, Y
)
.
Keygen(msk,y): To generate a secret key from the vector y ∈ [−Y, Y ]� using
msk = s = (s1, . . . , s�)�, compute sky := 〈s,y〉 = ∑�
i=1 si · yi ∈ Z.
Adaptive Simulation Security for Inner Product Functional Encryption 51
Encrypt(mpk,x): Given the public key mpk, to encrypt a message x ∈ [−X,X]�,
sample r ← U({0, 1, . . . , N/4}) and compute
c0 = gr mod N2, ci = (1 + xiN) · hr
i mod N2 ∀i ∈ [�]
and output c = (c0, {ci}�
i=1) ∈ (
Z
∗
N2
)�+1.
Decrypt(mpk, sky , c): On input of a functional decryption key sky and a cipher-
text c = (c0, c1, . . . , c�), compute
cy = c
−sky
0 ·
�∏
i=1
cyi
i mod N2
Then output log1+N (cy ) =
cy −1 mod N2
N .
Correctness: Suppose that we want to decrypt c = {ci}�
i=0 using sky = 〈s,y〉.
Observe that we have the following equalities modulo N2:
�∏
i=1
cyi
i =
�∏
i=1
(1 + xiN)yi · gr·siyi = (1 + N)〈x,y〉 · gr·〈s,y〉 = (1 + N)〈x,y〉 · c
〈s,y〉
0 ,
so that cy = (1 + N)〈x,y〉 mod N2. Recall that (1 + N)〈x,y〉 = 1 + 〈x,y〉 · N
mod N2, so that computing discrete logarithms in the subgroup generated by
1 + N is easy. This enables the computation of 〈x,y〉 mod N . By the choice of
parameters we have |〈x,y〉| ≤ � · ‖x‖∞‖y‖∞ ≤ � · X · Y < N/2, so we actually
recover 〈x,y〉 computed over Z.
Theorem 2. Under the DCR assumption, the above construction achieves adap-
tive simulation-based security.
Proof. To prove the theorem we first describe the PPT simulator and show that
under the DCR assumption the real experiment is indistinguishable from the
ideal experiment. The simulator proceeds as follows.
Setup�(1λ, 1�,X, Y ): This algorithm chooses safe primes p = 2p′ + 1 and q =
2q′ +1 such that �XY < N/2, and sets N = pq. It samples g′ ← U(Z∗
N2) and
sets g := g′2N mod N2. Next, for each i ∈ [�], it samples si ← U([−S, S]∩Z),
where S = 2λ+�−1 · X̄�−1 · �N2 and X̄ := X + � · (√�Y )�, and computes
hi = gsi mod N2. It defines the master secret key msk� = (s, p, q), where
s = (s1, . . . , s�)�, and the master public key mpk� =
(
N, g, {hi}�
i=1,X, Y
)
.
Keygen�
0(msk�,y): This algorithm is used to generate all the pre-challenge func-
tional decryption queries. To generate a secret key for y ∈ [−Y, Y ]�, it com-
putes and outputs sky := 〈s,y〉 = ∑�
i=1 si · yi ∈ Z.
Encrypt�(mpk�,msk�, {(y1, z1), (y2, z2), . . . , (yk, zk)}): Given mpk�, msk� and
all the pre-challenge pairs (yj , zj) ∈ [−Y, Y ]� × Z, where zj = 〈x�,yj〉 ∈ Z
and x� is the challenge message, it first computes a dummy message x̄ ∈ Z
�
such that 〈x̄,yj〉 = zj for all j ∈ [k] by applying Corollary 1. Note that
52 S. Agrawal et al.
‖x̄‖∞ ≤ (� − k) · (√kY )k ≤ � · (√�Y )�. Next, it samples a ← U(Z∗
N ) and
b ← U(ZN ′), where N ′ = p′q′, and computes
c�
0 = (1 + aN) · gb mod N2, c�
i = (1 + x̄iN) · (c�
0)
si mod N2 ∀i ∈ [�].
It outputs the simulated ciphertext c� =
(
c�
0, {c�
i }�
i=1
) ∈ (
Z
∗
N2
)�+1 together
with the state information st := (x̄, a,N ′).
Keygen�
1(msk�, (y, z = 〈y,x�〉), st): This algorithm handles post-challenge key
queries as follows. Upon receiving a pair (y, z = 〈x�,y〉), it first computes
u, v ∈ Z such that uN + vN ′ = 1 and γ := (a−1 mod N) · vN ′ mod NN ′
then computes and outputs
sk′
y := 〈s,y〉 − γ · (z − 〈x̄,y〉) ∈ Z.
In order to prove that the real experiment is computationally indistinguish-
able from the ideal experiment, we use a sequence of games. We denote by
Advij(A) the advantage of an adversary A in distinguishing between Gamei and
Gamej . More precisely, a challenger C flips a coin b ← {0, 1}. If b = 0 the chal-
lenger interacts with the adversary A as in Gamei while, if b = 1, it interacts as
in Gamej . At the end of the interaction, A outputs b′ ∈ {0, 1}. The advantage is
defined as Advij(A) :=
∣
∣Pr[b′ = b] − 1
2
∣
∣.
Game0: This is the real game in which the challenger generates the parameters
and interacts with the adversary as in the real experiment.
Game1: This game is exactly as the previous one except that the challenge
ciphertext is computed as follows: r ← U({0, 1, . . . , N/4}) is sampled and
c�
0 = gr mod N2, c�
i = (1 + x�
i N) · (c�
0)
si mod N2, for i ∈ [�]
This is possible since the challenger knows the secret key msk =
({si}�
i=1
)
.
Notice that Game0 is identical to Game1. So, Adv01(A) = 0.
Game2: In this game, we modify the computation of c�
0. In the challenge
phase, the challenger samples r ← U(ZN ′), where N ′ = p′q′, and com-
putes c�
0 := gr mod N2. By Lemma1, the statistical distance between
U({0, 1, 2, . . . , N/4}) mod N ′ and U(ZN ′) is < 1
p + 1
q , which is negligible.
Hence, Game1 and Game2 are statistically indistinguishable. More precisely,
we have Adv12(A) < 1/p + 1/q.
Game3: The game is like Game2, except that c�
0 is generated by sampling
t ←↩ U(Z∗
N2) and computing c�
0 := t2 mod N2. Under the DCR assumption,
Game2 and Game3 are computationally indistinguishable. Indeed, in Game2,
as long as g has order N ′, the distribution {gr | r ←↩ U(ZN ′)} is the uniform
distribution in the subgroup of 2N -th residues. The DCR assumption implies
that the latter distribution computationally indistinguishable from the distri-
bution {t2 mod N2 | t ←↩ U(Z∗
N2)}. Since a random 2N -th residue g generates
the entire subgroup of 2N -th residues with probability ϕ(N ′)
N ′ = 1− 1
p′ − 1
q′ + 1
N ′ ,
we obtain (
1 − 1
p′ − 1
q′ +
1
N ′
)
· Adv23(A) ≤ AdvDCR(B).
Adaptive Simulation Security for Inner Product Functional Encryption 53
Game4: In this game, we sample a ← U(Z∗
N ) and b ← U(ZN ′) and compute
c�
0 := (1 + aN) · gb mod N2. Observe that {t2 mod N2 | t ←↩ U(Z∗
N2)} is the
same as the distribution {(1+αN) ·gβ mod N2 | α ←↩ U(ZN ), β ←↩ U(ZN ′)}.
Therefore the statistical distance between the view of the adversary in Game3
and Game4 is bounded by Δ(a, α) < 1
p + 1
q . So, these games are statistically
indistinguishable and Adv34(A) < 1/p + 1/q.
Game5: This is the ideal experiment where the adversary interacts with the
simulator. Lemma6 shows that Game5 and Game4 are statistically indistin-
guishable, which yields the stated result.
Putting the above altogether, we obtain that a PPT adversary A that can
distinguish between the real and the ideal experiment implies an efficient DCR
distinguisher B such that
AdvReal-Ideal(A) = |Pr[1 ← ExpReal
A (1λ)] − Pr[1 ← ExpIdeal
A (1λ)]|
≤ N ′
ϕ(N ′)
· AdvDCR
B (1λ) +
2
p
+
2
q
+ 2−λ.
��
Lemma 6. The advantage of any distinguisher between Game4 and Game5 is
statistically negligible and Adv45(A) ≤ 2−λ.
Proof. In order to prove the claim, we simultaneously define Game′
4 and Game′
5
as follows. For each k ∈ {4, 5}, define Game′
k identically to Gamek except that,
at the outset of the game, the challenger samples Δx ←↩ U([−X̄, X̄]�), where
X̄ = X + � · (√�Y )�. Before generating the challenge ciphertext, the challenger
uses Corollary 1 to compute x̄ ∈ Z
� such that Ypre · x̄ = Ypre · x�, where Ypre is
the matrix obtained by stacking up the (linearly independent) transposed vectors
y� occurring in pre-challenge queries. If Δx = x� − x̄ (we call this event Guess),
the challenger proceeds as in Gamek. Otherwise, the challenger aborts the game
and replaces A’s output b′ by a random bit. We claim that any adversary A
that can distinguish between Game4 and Game5 with advantage Adv45(A) can
be used to distinguish between Game′
4 and Game′
5 with advantage
Adv′
45(A) =
1
(2X̄)�
· Adv45(A). (4.1)
Indeed, the probability that A outputs the correct bit b′ when distinguishing
between Game′
4 and Game′
5 is equal to
Pr[b′ = b] = Pr[b′ = b|Guess] · Pr[Guess] + Pr[b′ = b|Guess] · Pr[Guess]
which is equivalent to
Pr[b′ = b] − 1
2
=
(
Pr[b′ = b|Guess] − 1
2
)
· Pr[Guess]
By considering the equality in absolute value, we obtain (4.1).
54 S. Agrawal et al.
Next, we claim that Adv′
45(A) ≤ (2X̄)−� · 2−λ, which implies that Game4
and Game5 are indistinguishable. To see this, observe that, when Guess occurs,
Game′
5 is identical to a modification of Game′
4 where the master secret key has
been replaced by
s′
i = si − γ · Δxi ∈ Z, ∀i ∈ [�]
where γ = (a−1 mod N) · vN ′ mod NN ′ is determined by the Bézout coefficient
v for which uN + vN ′ = 1 (and thus vN ′ = 1 mod N) and the element a ∈ Z
∗
N
which used to compute c�
0 = (1 + aN) · gb mod N2 in the challenge ciphertext.
(Note that a and v can be chosen by the challenger at the beginning of the game,
so that we can define a game where the challenger uses {s′
i}i instead of {si}i).
With this new master secret key s′ = (s′
1, . . . , s
′
�), we have gsi = gs′
i mod N2
for all i ∈ [�] and 〈s,y〉 = 〈s′,y〉 for all pre-challenge queries y ∈ Z
�. We thus
obtain
Adv′
45(A) ≤ Δ(s′, s) ≤ (2X̄)−� · 2−λ,
where the last inequality follows from the fact that
Δ(s′, s) ≤
�∑
i=1
Δ(s′
i, si)
Lemma 2≤ � · ‖γ · Δx‖∞
2S
≤ NN ′ · X̄
2λ+� · X̄�−1 · N2
≤ (2X̄)−� · 2−λ.
��
The above DCR-based construction is stateless and evaluates inner products
over Z. In Sect. 5, we describe a generic construction of simulation-secure IPFE
with stateful key generation, which allows evaluating inner products modulo a
prime or a composite. This generic construction can be instantiated under the
DCR and LWE assumptions.
5 Adaptive Simulation-Based Security for Inner Products
Mod P from LWE
In this section we construct an adaptively simulation secure FE scheme
(AdSimIPFE) for inner products modulo some prime p. In more detail, the mes-
sages and keys are chosen from Z
�
p and the inner product is computed over Zp.
We denote our scheme by AdSimIPFE = (Setup,Keygen,Encrypt,Decrypt).
Our construction is based on the scheme of Agrawal et al. [8] for inner products
modulo a prime p satisfying adaptive indistinguishability from LWE. We denote
this scheme by IPFE = (IPFE.Setup, IPFE.Keygen, IPFE.Encrypt, IPFE.Decrypt),
and require it to support messages and keys of length L = 2�.
Our construction is generic except that it requires the underlying scheme
IPFE to satisfy the property that functional keys for vectors that are linearly
dependent on previously queried vectors may be computed as the linear com-
bination of previously returned keys. In more detail, say that sky ∈ Z
m.3
3 The precise ring in which sky lives is not important. We choose this to be Z for
concreteness and compatibility with [8].
Adaptive Simulation Security for Inner Product Functional Encryption 55
Say that the adversary queries vectors y1, . . . ,yk ∈ Z
�
p and then submits a
query y such that y =
∑
j∈[k]kj · yj (mod p),∀kj ∈ Zp. Then, the secret key
sky is computed as sky =
∑
j∈[k]kj · skyj
∈ Z
m. This property is satisfied by the
LWE-based construction that evaluates inner products over Zp in [8, Sec 4.2].
In the description hereunder, we assume that the modulus p is prime. How-
ever, the construction can also be applied to the Paillier-based construction of
[8, Section 5.2], which evaluates inner products over ZN . As a result, it provides
a simulation-secure IPFE with stateful key generation for inner products over
ZN , whereas our scheme in Sect. 4 is stateless but computes inner products over
Z. When we switch to composite moduli N = pq, we need to take into account
that ZN is not a field when the simulator has to solve a linear system over ZN
in order to compute a dummy message. Fortunately, inversion over ZN is always
possible with overwhelming probability when factoring N is hard.
5.1 Construction
Below, we provide our construction of AdSimIPFE.
Setup(1λ, 1�, p): Given the security parameter λ, the supported message and key
lengths � and a prime integer p, do the following:
1. Set L = 2� and obtain (IPFE.mpk, IPFE.msk) ← IPFE.Setup(1λ, 1L, p).
2. Output (mpk,msk) := (IPFE.mpk, IPFE.msk).
Keygen(msk,y, st): Given the msk, a vector y = (y1, . . . , y�)� ∈ Z
�
p to obtain a
key and an internal state st, do the following:
1. Parse the master secret key as msk = IPFE.msk.
2. The internal state st contains tuples
(
ŷj ,yj , skyj
, rj
)
for some j ∈ [�−1]
corresponding to (a subset of the) key queries made so far. If no queries
have been made before y, st is empty.
3. If |st|= i−1 for i ∈ [�−1] and y =
∑i−1
j=1 kj·yj (mod p) for some kj ∈ Zp,
j ∈ [i − 1], set ŷ =
∑i−1
j=1 kj · ŷj(mod p) and compute the secret key as
IPFE.skŷ ← IPFE.Keygen(IPFE.msk, ŷ). Set sky := IPFE.skŷ .
4. Else, if |st| = i − 1 for some i ∈ [� − 1], set yi = y. Then, construct
the extended vector ŷi = (yi, ei, ri) ∈ Z
L
p , where ei ∈ Z
�−1
p is the i-
th canonical vector and ri ← Zp is chosen uniformly at random. Next,
compute a secret key IPFE.skŷ i
← IPFE.Keygen(IPFE.msk, ŷi) and set
sky := IPFE.skŷ i
. Update the internal state as st ← st∪{(ŷi,yi, sky i
, ri)}.
5. Output the secret key sky .
Encrypt(mpk,x): Given the mpk and a message x = (x1, . . . , x�) ∈ Z
�
p to encrypt,
do the following:
1. Parse the master public key as mpk = IPFE.mpk.
2. Construct the extended vector x̂ = (x,0, 0) ∈ Z
L
p , where 0 ∈ Z
�−1
p is the
all-zeroes vector.
3. Compute a ciphertext IPFE.ct ← IPFE.Encrypt(IPFE.mpk, x̂).
4. Output the ciphertext c := IPFE.ct.
56 S. Agrawal et al.
Decrypt(mpk, sky , c): Given mpk, a secret key sky and a ciphertext c, do the
following:
1. Parse the secret key as sky = IPFE.skŷ and the ciphertext as c = IPFE.ct.
2. Compute and output z = IPFE.Decrypt(IPFE.skŷ , IPFE.ct).
Correctness. The correctness of AdSimIPFE is implied by the correctness of the
underlying IPFE scheme as follows. For a message vector x and the i-th linearly
independent vector y ∈ Z
�
p, let x̂ = (x,0, 0), ŷ = (y, ei, ri) ∈ Z
L
p . When y ∈ Z
�
p
is linearly dependent on the previously queried vectors {yj ∈ Z
�
p}j∈[i−1] for some
i ∈ [� − 1], we have ŷ =
∑i−1
j=1 kj · ŷj (mod p) =
∑i−1
j=1 kj · (
yj , ej , rj
)
(mod p).
The Decrypt algorithm takes mpk, sky = IPFE.skŷ and c = IPFE.ct as input,
where we have the following.
IPFE.skŷ ← IPFE.Keygen(IPFE.msk, ŷ)
IPFE.ct ← IPFE.Encrypt(IPFE.mpk, x̂)
Hence, the correctness of IPFE decryption algorithm forces the output to be
IPFE.Decrypt(IPFE.skŷ , IPFE.ct) = 〈x̂, ŷ〉 = 〈(x,0, 0), (y, ei, ri)〉 = 〈x,y〉 ∈ Zp
as desired.
Efficiency. The efficiency of AdSimIPFE is inherited from the efficiency of the
underlying IPFE scheme. The ciphertext and secret key sizes grow proportionally
to L = 2� = O(�).
5.2 Proof of Security for AdSimIPFE
Theorem 3. The AdSimIPFE scheme achieves adaptive simulation based secu-
rity, as long as the underlying IPFE scheme satisfies full adaptive indistinguisha-
bility based security.
Proof. We assume w.l.o.g. that A makes secret key queries for linearly inde-
pendent vectors only. In particular, we assume that A issues secret key queries
for Qpre independent vectors in the pre-challenge phase, which we denote by
ypre
1 , . . . ,ypre
Qpre
∈ Z
�
p while the i-th vector for the post-challenge independent
secret key query is denoted as ypost
i ∈ Z
�
p such that i ∈ [� − 1] \ [Qpre]. Note
that this simplification implies that there are no repetition in the key queries.
We denote by x� =(x�
1, . . . , x
�
� ) ∈ Z
�
p the message chosen by A in the challenge
phase.
The Simulator: To simulate the real world scheme, the simulator uses the fol-
lowing tuple of PPT algorithms: (Setup�,Keygen�
0,Encrypt
�,Keygen�
1). Note that
Keygen�
0 and Keygen�
1 denote the simulated key generation algorithms to answer
secret key queries in the pre-challenge and post-challenge phases respectively.
The simulator then proceeds as follows.
Adaptive Simulation Security for Inner Product Functional Encryption 57
Setup�(1λ, 1�, p): This algorithm is identical to Setup except that the simulator
also samples ri ← Zp for all i ∈ [�−1] and maintains the internal state as the
set of tuples st� = {(·, ·, ·, ri)}i∈[�−1]. In particular, it outputs the key pair as
(mpk�,msk�) := (IPFE.mpk, IPFE.msk) while keeping st� to itself.
Keygen�
0(msk�,ypre, st�): This algorithm runs almost identical to Keygen. In
particular, on input a pre-challenge vector ypre, it does the following:
1. The internal state st� contains tuples
(
ŷpre
j ,ypre
j , sky pre
j
, rj
)
for some j ∈
[� − 1] corresponding to (a subset of the) key queries made so far. If no
query has been made before ypre, st� is empty.
2. If |st| = i − 1 for some i ∈ [� − 1], set ypre
i = ypre. Then, construct the
extended vector ŷpre
i = (ypre
i , ei, ri) ∈ Z
L
p . Next, compute a secret key
IPFE.skŷ pre
i
← IPFE.Keygen(IPFE.msk, ŷpre
i ) and set sky pre
i
:= IPFE.skŷ pre
i
.
Update the internal state as st� ←
(
st�∪{
(ŷpre
i ,ypre
i , sky pre
i
, ri)
}) \
{
(·, ·, ·, ri)
}
.
3. Output the simulated secret key as sky pre
i
.
Encrypt�(mpk�,msk�,V, {1|x�
i |}�
i=1, st
�): This algorithm takes mpk� = IPFE.mpk,
msk�, the lengths {1|x�
i |}i∈[�] of all coordinates of the challenge message x�
as input, the internal state st� and a set
V =
{(
ypre
j , zprej = 〈x�,ypre
j 〉, sky pre
j
)
j∈[Qpre]
}
containing all pre-challenge independent queries {ypre
j }j∈[Qpre], the returned
keys and the corresponding linear function evaluations {zprej =
〈x�,ypre
j 〉}j∈[Qpre] for the challenge message x�. The challenge ciphertext c� is
simulated as follows.
1. Letting zpre = (zpre1 , . . . , zpreQpre
)� ∈ Z
Qpre
p , it computes an arbitrary solution
x̄ = (x̄1, . . . , x̄�)� ∈ Z
�
p of the system Ypre · x̄ = zpre (mod p), where
Ypre =
[
ypre
1 || . . . ||ypre
Qpre
]� ∈ Z
Qpre×�
p .
Note that x̄ can be obtained via Gaussian elimination over Zp.
2. Construct the extended message vector ̂̄x = (x̄,−r, 1) ∈ Z
L
p , where r =
(r1, . . . , r�−1) ∈ Z
�−1
p .4
3. Compute a ciphertext IPFE.ct ← IPFE.Encrypt(IPFE.mpk, ̂̄x).
4. Output the simulated ciphertext c∗ := IPFE.ct.
Keygen�
1(msk�,ypost
i , zposti , st�): On input a post-challenge vector ypost
i ∈ Z
�
p,
where i ∈ {Qpre+1, . . . , �−1}, the linear function evaluation zposti = 〈x�,ypost
i 〉
for the challenge message x� ∈ Z
�
p and internal state st�, it does the following:
1. The internal state st� now contains Qpre tuples of the form(
ŷpre
j ,ypre
j , sky pre
j
, rj
)
and tuples of the form
(
ŷpost
k ,ypost
k , sky post
k
, rk
)
for
4For readability, we denote −r =(−r1, . . . , −r�−1) = r′ ∈ Z
�−1
p such that r + r′ =
0 mod p.
58 S. Agrawal et al.
some k ∈ [� − 1] \ [Qpre] corresponding to (a subset of the) post-
challenge key queries made so far. If i = Qpre + 1, then st� ={(
ŷpre
j ,ypre
j , sky pre
j
, rj
)
j∈[Qpre]
, (·, ·, ·, rk)k∈[�−1]\[Qpre]
}
.
2. Construct the extended vector ŷpost
i = (ypost
i , ei,Δi + ri), where
ei ∈ Z
�−1
p is the i-th canonical vector, and Δi = zposti − 〈x̄,ypost
i 〉.
Next, compute a secret key IPFE.skŷ post
i
← IPFE.Keygen(IPFE.msk, ŷpost
i )
and set sky post
i
:= IPFE.skŷ post
i
. Update the internal state as st� ←
(
st� ∪
{(
ŷpost
i ,ypost
i , sky post
i
, ri
) })
\ {
(·, ·, ·, ri)
}
.
3. Output the simulated secret key as sky post
i
.
The Hybrids. We now prove that the simulation is computationally indistin-
guishable from the real experiment assuming full indistinguishability of IPFE.
The proof proceeds via a sequence of games (Game0,Game1,Game2,Game3).
Game0 describes the interaction between the challenger and the adversary as in
real experiment ExpReal
AdSimIPFE,A(1λ) while Game3 describes the same as in the
ideal experiment ExpIdeal
AdSimIPFE,A(1λ).
In the following, let Ei denote the event that A wins in Gamei. To prove
the result, we will show that Pr[E0] = Pr[E1] = Pr[E2] and |Pr[E2] − Pr[E3]| ≤
negl(λ), which implies |Pr[E0] − Pr[E3]| ≤ negl(λ).
Game0: In this game the challenger interacts with the adversary as in the real
experiment.
Game1: In this game the setup phase is modified as follows. Beside computing
(mpk,msk) as in the real experiment, the challenger now also precomputes
ri ← Zp,∀i ∈ [� − 1] for answering at most � − 1 linearly independent key
queries as well as the challenge ciphertext query. It maintains an internal
state st� = {(·, ·, ·, ri)}i∈[�−1].
Game2: In this game the challenger changes the way the post-challenge keys are
generated. It generates the pre-challenge keys as in Game1 with the precom-
puted randomness in st�. It also generates the challenge ciphertext as before.
As for post-challenge queries, they are answered as follows.
1. The challenger first computes x̄ ∈ Z
�
p that is consistent with the Qpre key
vectors it encountered in the pre-challenge phase. In particular, letting
zpre = (zpre1 , . . . , zpreQpre
)� ∈ Z
Qpre
p corresponding to the function evaluations
{zprej }j∈[Qpre] on pre-challenge keys, it computes x̄ ∈ Z
�
p such that
Ypre · x̄ = zpre(mod p), where Ypre =
[
ypre
1 || . . . ||ypre
Qpre
]� ∈ Z
Qpre×�
p .
2. For all i ∈ [� − 1] \ [Qpre], the i-th post-challenge vector ypost
i is now
extended as ŷpost
i = (ypost
i , ei,Δi + ri), where Δi = zposti − 〈x̄,ypost
i 〉.
3. The secret key is computed as IPFE.skŷ post
i
← IPFE.Keygen(IPFE.
msk, ŷpost
i ).
Adaptive Simulation Security for Inner Product Functional Encryption 59
4. The internal state is updated as
st� ←
(
st� ∪
{ (
ŷpost
i ,ypost
i , sky post
i
, ri
)})
\ {
(·, ·, ·, ri)
}
.
Game3: In this game the challenger computes everything as before in Game2
except that the challenge ciphertext is modified as follows. Instead of encrypt-
ing the extended message x̂� = (x�,0, 0), the challenger now encrypts
̂̄x = (x̄,−r, 1) to compute c� := IPFE.ct ← IPFE.Encrypt(IPFE.mpk, ̂̄x).
We now prove the following lemmas in order to complete the proof.
Lemma 7. We have Pr[E0] = Pr[E1].
Proof. The change introduced here is only conceptual, where for all i ∈ [� − 1],
the randomness ri ∈ Zp are precomputed in the setup phase. Thus, the lemma
follows trivially. ��
Lemma 8. We have Pr[E1] = Pr[E2].
Proof. We note that Game2 only differs from Game1 in the treatment of post-
challenge queries. Specifically, the simulator B simulates A’s view in the two
games as follows.
1. On input (1λ, 1�, p) from A, B sets L = 2� and computes IPFE.Setup(1λ, 1L, p)
to obtain (IPFE.mpk, IPFE.msk). It sets (mpk,msk) = (IPFE.mpk, IPFE.msk),
computes ri ← Zp, for all i ∈ [� − 1] to maintain its internal state as st� =
{(·, ·, ·, ri)}i∈[�−1]. Finally, it sends mpk to A.
2. When A requests a pre-challenge key for ypre
i , B first computes the extended
vector ŷpre
i = (ypre
i , ei, ri) ∈ Z
L
p , where ei ∈ Z
�−1
p is the i-th canon-
ical vector. Using msk = IPFE.msk, it then obtains a secret key for
ŷpre
i as IPFE.skŷ pre
i
← IPFE.Keygen(IPFE.msk, ŷpre
i ). B then updates st� ←
(
st� ∪ {
(ŷpre
i ,ypre
i , sky pre
i
, ri)
})
\{
(·, ·, ·, ri)
}
, sets sky pre
i
= IPFE.skŷ pre
i
and sends
sky pre
i
to A.
3. When A requests a challenge ciphertext for a message x� ∈ Z
�
p, B first
computes an extended message x̂� = (x�,0, 0) ∈ Z
L
p , where 0 ∈ Z
�−1
p is
the all-zero vector. Using mpk = IPFE.mpk, it then obtains a ciphertext as
IPFE.ct ← IPFE.Encrypt(IPFE.mpk, x̂�), sets c� = IPFE.ct and sends c� to A.
4. In the post-challenge phase, when A queries a key for a vector ypost
i ∈ Z
�
p,
with i ∈ [� − 1] \ [Qpre], for which the corresponding function evaluation is
zposti = 〈x�,ypost
i 〉, the challenger B responds as follows:
– To simulate A’s view in Game1, B computes the extended vector ŷpost
i =
(ypost
i , ei, ri).
– To simulate A’s view in Game2, B first computes x̄ ∈ Z
�
p as described
in Game2 such that x̄ is consistent the Qpre pre-challenge key vectors. It
then extends the vector ypost
i as ŷpost
i = (ypost
i , ei,Δi + ri), where Δi =
〈x� − x̄,ypost
i 〉.
60 S. Agrawal et al.
Using msk = IPFE.msk, B obtains a secret key for ŷpost
i as IPFE.skŷ post
i
←
IPFE.Keygen(IPFE.msk, ŷpost
i ) and sets sky post
i
= IPFE.skŷ post
i
. It then updates
its internal state as st� ←
(
st� ∪ {
(ŷpost
i ,ypost
i , sky post
i
, ri)
})
\ {
(·, ·, ·, ri)
}
and
sends sky post
i
to A.
Recall that the only change between the two games is the way post-challenge
keys are generated. In particular, the last co-ordinate of the i-th post-challenge
key vector is set to ri in Game1 while it is set to (ri +Δi) in Game2. Note that
each ri is chosen uniformly in Zp in the setup phase and is unique for each post
challenge key query i ∈ [� − 1] \ [Qpre]. Hence, the computation ri + Δi being
done modulo p, it follows that the two distributions {ri | ri ← Zp}i∈[�−1]\[Qpre]
and {ri + Δi | ri ← Zp,Δi ∈ Zp}i∈[�−1]\[Qpre] are perfectly indistinguishable.
Further, any post-challenge key sky post in Game2 always correctly decrypts
any honestly generated ciphertext because such a ciphertext contains 0 ∈ Z
�
p in
its extended slots, which nullifies the extended slots of the keys. The two games
are thus perfectly indistinguishable, which implies Pr[E1] = Pr[E2]. ��
Lemma 9. We have |Pr[E2] − Pr[E3]| ≤ negl(λ).
Proof. Let us assume that |Pr[E2] − Pr[E3]| is non-negligible. We then construct
an adversary B that breaks the indistinguishability-based security of the under-
lying IPFE scheme as follows:
1. On input (1λ, 1�, p) from A, B sets L = 2� and relays (1λ, 1L, p) to the IPFE
challenger. Upon receiving IPFE.mpk, it sets mpk� = IPFE.mpk and randomly
chooses ri ← Zp for all i ∈ [� − 1] to maintain the internal state as st� =
{(·, ·, ·, ri)}i∈[�−1]. It sends mpk� to A.
2. When A requests a pre-challenge key for ypre
i , B computes the extended vector
ŷpre
i = (ypre
i , ei, ri) ∈ Z
L
p , where ei ∈ Z
�−1
p is the i-th canonical vector. It then
queries the IPFE challenger with ŷpre
i for a secret key and receives IPFE.skŷ pre
i
.
Then, B updates st� ←
(
st� ∪ {
(ŷpre
i ,ypre
i , sky pre
i
, ri)
})
\ {
(·, ·, ·, ri)
}
, sets
sky pre
i
= IPFE.skŷ pre
i
and sends sky pre
i
to A.
3. When A requests a challenge ciphertext, B sets zpre = (zpre1 , . . . , zpreQpre
)� ∈
Z
Qpre
p and then computes an arbitrary solution x̄ = (x̄1, . . . , x̄�)� ∈ Z
�
p of the
linear system Ypre · x̄ = zpre(mod p), where
Ypre =
[
ypre
1 || . . . ||ypre
Qpre
]� ∈ Z
Qpre×�
p .
Next, it constructs the extended message vector ̂̄x = (x̄,−r, 1) ∈ Z
L
p , where
r = (r1, . . . , r�−1) ∈ Z
�−1
p to output x0 = (x�,0, 0) ∈ Z
L
p and x1 = ̂̄x as
the pair of challenge messages to the IPFE challenger. The latter returns a
challenge ciphertext IPFE.ct and B sets c� = IPFE.ct, which is returned to A.
4. When A requests for a post-challenge key for ypost
i ∈ Z
�
p, i ∈ [� − 1] \ [Qpre]
with its corresponding function evaluation zposti , B computes Δi = zposti −
〈x̄,ypost
i 〉 and the extended vector ŷpost
i = (ypost
i , ei,Δi + ri). It then queries
Adaptive Simulation Security for Inner Product Functional Encryption 61
the IPFE challenger with ŷpost
i for a secret key and receives IPFE.skŷ post
i
. Then,
B updates
st� ←
(
st� ∪
{ (
ŷpost
i ,ypost
i , sky post
i
, ri
)})
\ {
(·, ·, ·, ri)
}
,
sets sky post
i
= IPFE.skŷ post
i
and sends sky post
i
to A.
5. B outputs the same bit as A.
Note that the ciphertext c� encodes the message x0 = (x�,0, 0) ∈ Z
L
p in Game2
and x1= ̂̄x = (x̄,−r, 1)∈ Z
L
p in Game3. The message x̄ in both games is com-
puted maintaining the consistency with all the pre-challenge keys {sky pre
i
}i∈[Qpre].
Thus, upon decryption of c�, it yields 〈x0, ŷ
pre
i 〉 = 〈x�,ypre
i 〉 = zpre (mod p) in
Game2 as well as 〈x1, ŷ
pre
i 〉 = 〈x̄,ypre
i 〉 + 〈−r, ei〉 + ri = zpre (mod p) in Game3
as required. Further, note that in both games, for each i ∈ [�−1]\ [Qpre], the i-th
post-challenge key sky post
i
is a secret key for the vector ŷpost
i = (ypost
i , ei,Δi + ri),
where
Δi = zposti − 〈x̄,ypost
i 〉,
which implies Δi + 〈x̄,ypost
i 〉 = zposti . Hence, upon decrypting c�, we have
〈x0, ŷ
post
i 〉 = 〈x�,ypost
i 〉 + 〈0, ei〉 + 0 · (Δi + ri) = zposti (mod p),
in Game2, and
〈x1, ŷ
post
i 〉 = 〈x̄,ypost
i 〉 + 〈−r, ei〉 + 1 · (Δi + ri) = zposti (mod p)
in Game3, as required. This proves that B is an admissible IPFE adversary in the
indistinguishability-based security game. If the IPFE challenger returned a chal-
lenge ciphertext for the vector x0, A’s view is as in Game2. Otherwise, A’s view is
the same as in Game3. Consequently, B breaks the adaptive indistinguishability-
based security of the scheme if A can distinguish between the two games with
noticeable advantage. ��
Acknowledgements. Part of this work was funded by the French ANR ALAM-
BIC project (ANR-16-CE39-0006) and by BPI-France in the context of the national
project RISQ (P141580). This work was also supported by the European Union
PROMETHEUS project (Horizon 2020 Research and Innovation Program, grant
780701).
References
1. Abdalla, M., Bourse, F., De Caro, A., Pointcheval, D.: Simple functional encryption
schemes for inner products. In: Katz, J. (ed.) PKC 2015. LNCS, vol. 9020, pp. 733–
751. Springer, Heidelberg (2015). https://doi.org/10.1007/978-3-662-46447-2_33
2. Abdalla, M., Catalano, D., Fiore, D., Gay, R., Ursu, B.: Multi-input functional
encryption for inner products: function-hiding realizations and constructions with-
out pairings. In: Shacham, H., Boldyreva, A. (eds.) CRYPTO 2018. LNCS, vol.
10991, pp. 597–627. Springer, Cham (2018). https://doi.org/10.1007/978-3-319-
96884-1_20
https://doi.org/10.1007/978-3-662-46447-2_33
https://doi.org/10.1007/978-3-319-96884-1_20
https://doi.org/10.1007/978-3-319-96884-1_20
62 S. Agrawal et al.
3. Abdalla, M., Gay, R., Raykova, M., Wee, H.: Multi-input inner-product functional
encryption from pairings. In: Coron, J.-S., Nielsen, J.B. (eds.) EUROCRYPT 2017.
LNCS, vol. 10210, pp. 601–626. Springer, Cham (2017). https://doi.org/10.1007/
978-3-319-56620-7_21
4. Agrawal, S., Bhattacherjee, S., Phan, D.-H., Stehlé, D., Yamada, S.: Efficient public
trace and revoke from standard assumptions. In: ACM-CCS (2017)
5. Agrawal, S., Boyen, X., Vaikuntanathan, V., Voulgaris, P., Wee, H.: Functional
encryption for threshold functions (or fuzzy IBE) from lattices. In: Fischlin, M.,
Buchmann, J., Manulis, M. (eds.) PKC 2012. LNCS, vol. 7293, pp. 280–297.
Springer, Heidelberg (2012). https://doi.org/10.1007/978-3-642-30057-8_17
6. Agrawal, S., Freeman, D.M., Vaikuntanathan, V.: Functional encryption for inner
product predicates from learning with errors. In: Lee, D.H., Wang, X. (eds.) ASI-
ACRYPT 2011. LNCS, vol. 7073, pp. 21–40. Springer, Heidelberg (2011). https://
doi.org/10.1007/978-3-642-25385-0_2
7. Agrawal, S., Gorbunov, S., Vaikuntanathan, V., Wee, H.: Functional encryption:
new perspectives and lower bounds. In: Canetti, R., Garay, J.A. (eds.) CRYPTO
2013. LNCS, vol. 8043, pp. 500–518. Springer, Heidelberg (2013). https://doi.org/
10.1007/978-3-642-40084-1_28
8. Agrawal, S., Libert, B., Stehlé, D.: Fully secure functional encryption for inner
products, from standard assumptions. In: Robshaw, M., Katz, J. (eds.) CRYPTO
2016. LNCS, vol. 9816, pp. 333–362. Springer, Heidelberg (2016). https://doi.org/
10.1007/978-3-662-53015-3_12
9. Agrawal, S., Rosen, A.: Functional encryption for bounded collusions, revis-
ited. In: Kalai, Y., Reyzin, L. (eds.) TCC 2017. LNCS, vol. 10677, pp.
173–205. Springer, Cham (2017). https://doi.org/10.1007/978-3-319-70500-2_7.
http://eprint.iacr.org/
10. Agrawal, S.: Stronger security for reusable garbled circuits, general definitions and
attacks. In: Katz, J., Shacham, H. (eds.) CRYPTO 2017. LNCS, vol. 10401, pp.
3–35. Springer, Cham (2017). https://doi.org/10.1007/978-3-319-63688-7_1
11. Benhamouda, F., Bourse, F., Lipmaa, H.: CCA-secure inner-product functional
encryption from projective hash functions. In: Fehr, S. (ed.) PKC 2017. LNCS, vol.
10175, pp. 36–66. Springer, Heidelberg (2017). https://doi.org/10.1007/978-3-662-
54388-7_2
12. Bishop, A., Jain, A., Kowalczyk, L.: Function-hiding inner product encryption. In:
Iwata, T., Cheon, J.H. (eds.) ASIACRYPT 2015. LNCS, vol. 9452, pp. 470–491.
Springer, Heidelberg (2015). https://doi.org/10.1007/978-3-662-48797-6_20
13. Boneh, D., Franklin, M.: Identity-based encryption from the Weil pairing. SIAM
J. Comput. 32(3), 586–615 (2003)
14. Boneh, D., et al.: Fully key-homomorphic encryption, arithmetic circuit ABE and
compact garbled circuits. In: Nguyen, P.Q., Oswald, E. (eds.) EUROCRYPT 2014.
LNCS, vol. 8441, pp. 533–556. Springer, Heidelberg (2014). https://doi.org/10.
1007/978-3-642-55220-5_30
15. Boneh, D., Sahai, A., Waters, B.: Functional encryption: definitions and challenges.
In: Ishai, Y. (ed.) TCC 2011. LNCS, vol. 6597, pp. 253–273. Springer, Heidelberg
(2011). https://doi.org/10.1007/978-3-642-19571-6_16
16. Brakerski, Z., Langlois, A., Peikert, C., Regev. O., Stehlé, D.: On the classical
hardness of learning with errors. In: STOC (2013)
17. Castagnos, G., Laguillaumie, F., Tucker, I.: Practical fully secure unrestricted inner
product functional encryption modulo p. In: Peyrin, T., Galbraith, S. (eds.) ASI-
ACRYPT 2018. LNCS, vol. 11273, pp. 733–764. Springer, Cham (2018). https://
doi.org/10.1007/978-3-030-03329-3_25
https://doi.org/10.1007/978-3-319-56620-7_21
https://doi.org/10.1007/978-3-319-56620-7_21
https://doi.org/10.1007/978-3-642-30057-8_17
https://doi.org/10.1007/978-3-642-25385-0_2
https://doi.org/10.1007/978-3-642-25385-0_2
https://doi.org/10.1007/978-3-642-40084-1_28
https://doi.org/10.1007/978-3-642-40084-1_28
https://doi.org/10.1007/978-3-662-53015-3_12
https://doi.org/10.1007/978-3-662-53015-3_12
https://doi.org/10.1007/978-3-319-70500-2_7
http://eprint.iacr.org/
https://doi.org/10.1007/978-3-319-63688-7_1
https://doi.org/10.1007/978-3-662-54388-7_2
https://doi.org/10.1007/978-3-662-54388-7_2
https://doi.org/10.1007/978-3-662-48797-6_20
https://doi.org/10.1007/978-3-642-55220-5_30
https://doi.org/10.1007/978-3-642-55220-5_30
https://doi.org/10.1007/978-3-642-19571-6_16
https://doi.org/10.1007/978-3-030-03329-3_25
https://doi.org/10.1007/978-3-030-03329-3_25
Adaptive Simulation Security for Inner Product Functional Encryption 63
18. Chotard, J., Dufour Sans, E., Gay, R., Phan, D.H., Pointcheval, D.: Decentralized
multi-client functional encryption for inner product. In: Peyrin, T., Galbraith, S.
(eds.) ASIACRYPT 2018. LNCS, vol. 11273, pp. 703–732. Springer, Cham (2018).
https://doi.org/10.1007/978-3-030-03329-3_24
19. Datta, P., Dutta, R., Mukhopadhyay, S.: Functional encryption for inner product
with full function privacy. In: Cheng, C.-M., Chung, K.-M., Persiano, G., Yang,
B.-Y. (eds.) PKC 2016. LNCS, vol. 9614, pp. 164–195. Springer, Heidelberg (2016).
https://doi.org/10.1007/978-3-662-49384-7_7
20. Datta, P., Okamoto, T., Takashima, K.: Adaptively simulation-secure attribute-
hiding predicate encryption. In: Peyrin, T., Galbraith, S. (eds.) ASIACRYPT 2018.
LNCS, vol. 11273, pp. 640–672. Springer, Cham (2018). https://doi.org/10.1007/
978-3-030-03329-3_22
21. Datta, P., Okamoto, T., Tomida, J.: Full-hiding (unbounded) multi-input inner
product functional encryption from the k -linear assumption. In: Abdalla, M.,
Dahab, R. (eds.) PKC 2018. LNCS, vol. 10770, pp. 245–277. Springer, Cham (2018).
https://doi.org/10.1007/978-3-319-76581-5_9
22. Garg, S., Gentry, C., Halevi, S.: Candidate multilinear maps from ideal lattices.
In: Johansson, T., Nguyen, P.Q. (eds.) EUROCRYPT 2013. LNCS, vol. 7881, pp.
1–17. Springer, Heidelberg (2013). https://doi.org/10.1007/978-3-642-38348-9_1
23. Garg, S., Gentry, C., Halevi, S., Raykova, M., Sahai, A., Waters, B.: Candidate
indistinguishability obfuscation and functional encryption for all circuits. In: FOCS
(2013)
24. Garg, S., Gentry, C., Halevi, S., Zhandry, M.: Functional encryption without obfus-
cation. In: Kushilevitz, E., Malkin, T. (eds.) TCC 2016. LNCS, vol. 9563, pp. 480–
511. Springer, Heidelberg (2016). https://doi.org/10.1007/978-3-662-49099-0_18
25. Goldwasser, S., Kalai, Y.T., Popa, R.A., Vaikuntanathan, V., Zeldovich, N.:
Reusable garbled circuits and succinct functional encryption. In: STOC, pp. 555–
564 (2013)
26. Gorbunov, S., Vaikuntanathan, V., Wee, H.: Functional encryption with bounded
collusions via multi-party computation. In: Safavi-Naini, R., Canetti, R. (eds.)
CRYPTO 2012. LNCS, vol. 7417, pp. 162–179. Springer, Heidelberg (2012).
https://doi.org/10.1007/978-3-642-32009-5_11
27. Gorbunov, S., Vaikuntanathan, V., Wee, H.: Attribute-based encryption for cir-
cuits. In: STOC (2013)
28. Gorbunov, S., Vaikuntanathan, V., Wee, H.: Predicate encryption for circuits from
LWE. In: Gennaro, R., Robshaw, M. (eds.) CRYPTO 2015. LNCS, vol. 9216, pp.
503–523. Springer, Heidelberg (2015). https://doi.org/10.1007/978-3-662-48000-
7_25
29. Goyal, V., Pandey, O., Sahai, A., Waters, B.: Attribute-based encryption for fine-
grained access control of encrypted data. In: ACM-CCS (2006)
30. Katz, J., Sahai, A., Waters, B.: Predicate encryption supporting disjunctions, poly-
nomial equations, and inner products. In: Smart, N. (ed.) EUROCRYPT 2008.
LNCS, vol. 4965, pp. 146–162. Springer, Heidelberg (2008). https://doi.org/10.
1007/978-3-540-78967-3_9
31. Lewko, A., Okamoto, T., Sahai, A., Takashima, K., Waters, B.: Fully secure
functional encryption: attribute-based encryption and (hierarchical) inner prod-
uct encryption. In: Gilbert, H. (ed.) EUROCRYPT 2010. LNCS, vol. 6110, pp.
62–91. Springer, Heidelberg (2010). https://doi.org/10.1007/978-3-642-13190-5_4
32. Lin, H.: Indistinguishability obfuscation from SXDH on 5-linear maps and locality-
5 PRGs. In: Katz, J., Shacham, H. (eds.) CRYPTO 2017. LNCS, vol. 10401, pp.
599–629. Springer, Cham (2017). https://doi.org/10.1007/978-3-319-63688-7_20
https://doi.org/10.1007/978-3-030-03329-3_24
https://doi.org/10.1007/978-3-662-49384-7_7
https://doi.org/10.1007/978-3-030-03329-3_22
https://doi.org/10.1007/978-3-030-03329-3_22
https://doi.org/10.1007/978-3-319-76581-5_9
https://doi.org/10.1007/978-3-642-38348-9_1
https://doi.org/10.1007/978-3-662-49099-0_18
https://doi.org/10.1007/978-3-642-32009-5_11
https://doi.org/10.1007/978-3-662-48000-7_25
https://doi.org/10.1007/978-3-662-48000-7_25
https://doi.org/10.1007/978-3-540-78967-3_9
https://doi.org/10.1007/978-3-540-78967-3_9
https://doi.org/10.1007/978-3-642-13190-5_4
https://doi.org/10.1007/978-3-319-63688-7_20
64 S. Agrawal et al.
33. Lin, H., Vaikuntanathan, V.: Indistinguishability obfuscation from DDH-like
assumptions on constant-degree graded encodings. In: FOCS (2016)
34. Okamoto, T., Takashima, K.: Hierarchical predicate encryption for inner-products.
In: Matsui, M. (ed.) ASIACRYPT 2009. LNCS, vol. 5912, pp. 214–231. Springer,
Heidelberg (2009). https://doi.org/10.1007/978-3-642-10366-7_13
35. Okamoto, T., Takashima, K.: Fully secure functional encryption with general rela-
tions from the decisional linear assumption. In: Rabin, T. (ed.) CRYPTO 2010.
LNCS, vol. 6223, pp. 191–208. Springer, Heidelberg (2010). https://doi.org/10.
1007/978-3-642-14623-7_11
36. Okamoto, T., Takashima, K.: Adaptively attribute-hiding (hierarchical) inner prod-
uct encryption. In: Pointcheval, D., Johansson, T. (eds.) EUROCRYPT 2012.
LNCS, vol. 7237, pp. 591–608. Springer, Heidelberg (2012). https://doi.org/10.
1007/978-3-642-29011-4_35
37. O’Neill, A.: Definitional issues in functional encryption. Cryptology ePrint Archive,
Report 2010/556 (2010). http://eprint.iacr.org/
38. Paillier, P.: Public-key cryptosystems based on composite degree residuosity classes.
In: Stern, J. (ed.) EUROCRYPT 1999. LNCS, vol. 1592, pp. 223–238. Springer,
Heidelberg (1999). https://doi.org/10.1007/3-540-48910-X_16
39. Pollard, J.: Kangaroos, monopoly and discrete logarithms. J. Cryptol. 13, 433–447
(2000). https://doi.org/10.1007/s001450010010
40. Regev, O.: On lattices, learning with errors, random linear codes, and cryptography.
J. ACM 56(6), 1–40 (2009)
41. Sahai, A., Waters, B.: Fuzzy identity-based encryption. In: Cramer, R. (ed.) EURO-
CRYPT 2005. LNCS, vol. 3494, pp. 457–473. Springer, Heidelberg (2005). https://
doi.org/10.1007/11426639_27
42. Shamir, A.: Identity-based cryptosystems and signature schemes. In: Blakley, G.R.,
Chaum, D. (eds.) CRYPTO 1984. LNCS, vol. 196, pp. 47–53. Springer, Heidelberg
(1985). https://doi.org/10.1007/3-540-39568-7_5
43. Tomida, J., Abe, M., Okamoto, T.: Efficient functional encryption for inner-product
values with full-hiding security. In: Bishop, M., Nascimento, A.C.A. (eds.) ISC
2016. LNCS, vol. 9866, pp. 408–425. Springer, Cham (2016). https://doi.org/10.
1007/978-3-319-45871-7_24
44. Tomida, J., Takashima, K.: Unbounded inner product functional encryption from
bilinear maps. In: Peyrin, T., Galbraith, S. (eds.) ASIACRYPT 2018. LNCS, vol.
11273, pp. 609–639. Springer, Cham (2018). https://doi.org/10.1007/978-3-030-
03329-3_21
45. Wee, H.: Dual system encryption via predicate encodings. In: Lindell, Y. (ed.) TCC
2014. LNCS, vol. 8349, pp. 616–637. Springer, Heidelberg (2014). https://doi.org/
10.1007/978-3-642-54242-8_26
46. Wee, H.: Attribute-hiding predicate encryption in bilinear groups, revisited. In:
Kalai, Y., Reyzin, L. (eds.) TCC 2017. LNCS, vol. 10677, pp. 206–233. Springer,
Cham (2017). https://doi.org/10.1007/978-3-319-70500-2_8
https://doi.org/10.1007/978-3-642-10366-7_13
https://doi.org/10.1007/978-3-642-14623-7_11
https://doi.org/10.1007/978-3-642-14623-7_11
https://doi.org/10.1007/978-3-642-29011-4_35
https://doi.org/10.1007/978-3-642-29011-4_35
http://eprint.iacr.org/
https://doi.org/10.1007/3-540-48910-X_16
https://doi.org/10.1007/s001450010010
https://doi.org/10.1007/11426639_27
https://doi.org/10.1007/11426639_27
https://doi.org/10.1007/3-540-39568-7_5
https://doi.org/10.1007/978-3-319-45871-7_24
https://doi.org/10.1007/978-3-319-45871-7_24
https://doi.org/10.1007/978-3-030-03329-3_21
https://doi.org/10.1007/978-3-030-03329-3_21
https://doi.org/10.1007/978-3-642-54242-8_26
https://doi.org/10.1007/978-3-642-54242-8_26
https://doi.org/10.1007/978-3-319-70500-2_8
	Adaptive Simulation Security for Inner Product Functional Encryption
	1 Introduction
	2 Preliminaries
	2.1 Useful Lemmas
	2.2 Functional Encryption
	2.3 Security
	2.4 Hardness Assumptions
	3 Adaptive Simulation-Based Security from DDH
	4 Adaptive Simulation-Based Security for Inner Products over Z from DCR
	5 Adaptive Simulation-Based Security for Inner Products Mod P from LWE
	5.1 Construction
	5.2 Proof of Security for AdSimIPFE
	References