Traceable Scheme of Public Key Encryption with Equality Test
����������
�������
Citation: Zhu, H.; Xue, Q.; Li, T.; Xie,
D. Traceable Scheme of Public Key
Encryption with Equality Test.
Entropy 2022, 24, 309. https://
doi.org/10.3390/e24030309
Academic Editor: Jaesung Lee
Received: 11 February 2022
Accepted: 15 February 2022
Published: 22 February 2022
Publisher’s Note: MDPI stays neutral
with regard to jurisdictional claims in
published maps and institutional affil-
iations.
Copyright: © 2022 by the authors.
Licensee MDPI, Basel, Switzerland.
This article is an open access article
distributed under the terms and
conditions of the Creative Commons
Attribution (CC BY) license (https://
creativecommons.org/licenses/by/
4.0/).
entropy
Article
Traceable Scheme of Public Key Encryption with Equality Test
Huijun Zhu 1,2,3,*, Qingji Xue 1,3, Tianfeng Li 1,3 and Dong Xie 4
1 School of Digital Media and Art Design, Nanyang Institute of Technology, Nanyang 473004, China;
xue_qj@sina.com (Q.X.); 3071066@nyist.edu.cn (T.L.)
2 State Key Laboratory of Networking and Switching Technology, Beijing University of Posts and
Telecommunications, Beijing 100876, China
3 Graphic Image and Intelligent Processing in Henan Province, International Joint Laboratory,
Nanyang Institute of Technology, Nanyang 473000, China
4 School of Computer and Information, Anhui Normal University, Wuhu 241002, China; xiedong@ahnu.edu.cn
* Correspondence: zhuhj121@nyist.edu.cn
Abstract: Public key encryption supporting equality test (PKEwET) schemes, because of their special
function, have good applications in many fields, such as in cloud computing services, blockchain,
and the Internet of Things. The original PKEwET has no authorization function. Subsequently, many
PKEwET schemes have been proposed with the ability to perform authorization against various
application scenarios. However, these schemes are incapable of traceability to the ciphertexts. In
this paper, the ability of tracing to the ciphertexts is introduced into a PKEwET scheme. For the
ciphertexts, the presented scheme supports not only the equality test, but also has the function of
traceability. Meanwhile, the security of the proposed scheme is revealed by a game between an
adversary and a simulator, and it achieves a desirable level of security. Depending on the attacker’s
privileges, it can resist OW-CCA security against an adversary with a trapdoor, and can resist IND-
CCA security against an adversary without a trapdoor. Finally, the performance of the presented
scheme is discussed.
Keywords: public key encryption; equality test; blockchain; cloud server
1. Introduction
With the continuous development of the Internet of Things (IoT), the security of data
has gotten more attention. In order to ensure the security of data, data are stored on a
server by encryption. However, it is inconvenient for effective application when the data
are encrypted, making it impossible to search within encrypted data. Therefore, searchable
encryption (SE) is presented [1]. The aim of SE is to produce a tag related to ciphertext,
and to classify the ciphertexts. Since this primitive approach was proposed, many cryp-
tographers have studied it extensively and deeply [2–6]. However, the same ciphertext
cannot be classified and stored by SE schemes. A new cryptographic primitive approach
emerged as the times required, namely the public key encryption supporting equality test
(PKEwET) [7]. In this paper, traceability is introduced into the PKEwET scheme.
1.1. Related Work
The PKEwET scheme resolves the problem of data matching in many application
environments, such as in cloud computing, health service systems, and IoT. It can compare
the consistency of the ciphertexts without the secret key. Recently, the research scope of
PKEwET has focused on the three aspects of authorization, security scheme, and efficiency
of the PKEwET scheme. Some progress in PKEwET is reviewed as follows:
For the authorization, Tang et al. and Huang et al. proposed PKEwET schemes
supporting authorization from the user and ciphertext, respectively [8–13]. Then, Ma et
al. extended the authorization mechanism to multi-user environments [14]. For more
convenient application, Ma et al. proposed four types of authorization policies, namely
Entropy 2022, 24, 309. https://doi.org/10.3390/e24030309 https://www.mdpi.com/journal/entropy
https://doi.org/10.3390/e24030309
https://doi.org/10.3390/e24030309
https://creativecommons.org/
https://creativecommons.org/licenses/by/4.0/
https://creativecommons.org/licenses/by/4.0/
https://www.mdpi.com/journal/entropy
https://www.mdpi.com
https://doi.org/10.3390/e24030309
https://www.mdpi.com/journal/entropy
https://www.mdpi.com/article/10.3390/e24030309?type=check_update&version=2
Entropy 2022, 24, 309 2 of 21
user level, ciphertext level, user-specific ciphertext level, and ciphertext-to-user level autho-
rization [15]. To simplify the maintenance of public key certificates, Ma et al. introduced
the equality test algorithm into an identity-based encryption scheme [16]. For more conve-
nient application to smart cities, Yang et al. proposed a filtered equality test scheme [17].
Later, Wang et al. combined signcryption and an equality test [18]. Recently, Duong et al.
presented new lattice-based PKEwET schemes [19].
For the security, in 2016, Lee et al. improved the scheme of Ma, and proposed a new
scheme that achieved IND-CCA security [20], and presented an equality test scheme based
on the standard model for the first time [21]. In 2017, Wang et al. and Huang et al. proposed
a PKEwET scheme from the ciphertext level, and presented the proof of security under the
standard model [22,23]. Subsequently, some other PKEwET schemes based on the standard
model have been proposed [24,25].
For the efficiency of the PKEwET schemes, Lin et al. and Zhu et al. proposed pairing-
free equality test schemes [26,27]. The scheme of Tang was improved upon by Wu et
al. [28,29], where the efficiency of computing increased by 36.7% in encryption and by
39.24% in the test algorithm. In 2018, Qu et al. introduced a certificate-less PKEwET
scheme [30]. This scheme was improved upon by Elhabob et al. [31,32]. In 2019, Wu et
al. combined Zhu et al.’s and Ma et al.’s schemes, and proposed the pairing-free scheme
based identity [33]. In the same year, Lee et al. proposed a new PKEwET scheme, from
generic assumptions in the random oracle model [34]. To reduce the cost of computing and
communication, Ling et al. introduced the group mechanism into a PKEwET algorithm
[35].
For convenience in cloud computing of the PKEwET scheme, key-policy attribute-
based encryption was introduced by Zhu et al. [36]. In 2018, ciphertext-policy attribute-
based encryption was introduced into a PKEwET scheme by Wang et al. [37]. Subsequently,
some improvement schemes were put forward [38–41].
Driven by interests, some users may disclose their own secret keys to non-group users
intentionally or unintentionally. However, it is difficult for the malicious user to be tracked
down by the system. The problem of key abuse brings great security risks to PKEwET
systems. To solve this problem, we introduce a tracking function into a PKEwET system.
1.2. Contributions
In this paper, traceability is introduced into a group ID-based encryption (GIBE)
scheme. The motivation is to make a GIBE supporting traceability and an equality test
function to the ciphertexts. The key contributions can be listed as follows:
• We show that the GIBE algorithm is unable to compare ciphertexts, and has no equality
test function without the secret key sk. To overcome these limitations, we combine
the GIBE and PKEwET algorithms. Additionally, all of PKEwET algorithms are
untraceable to the encrypted ciphertexts, the idea of traceability is introduced into the
PKEwET algorithm, and we propose the traceable GIBE with an equality test scheme
(T-GIBEwET).
• Two types of adversaries are described, and the security of the proposed scheme
is proved in details from two types of adversaries. The presented scheme achieves
a desirable security. With a trapdoor, the T-GIBEwET scheme can resist OW-CCA
security. Without a trapdoor, the T-GIBEwET scheme can resist IND-CCA security.
• The performance of the T-GIBEwET scheme is discussed. Compared to existing
equality test schemes, it is more efficient and more practical in many scenarios.
1.3. Outline of This Paper
The rest of the proposal is organized as follows: some preliminaries, some basic
definitions, assumptions and the security model are presented in Section 2. The details of
the T-GIBEwET scheme are presented in Section 3. The security of the T-GIBEwET scheme
is discussed in Section 4. In Section 5, the performance analysis of the T-GIBEwET scheme
is represented. Finally, the concluding remarks of this paper are summarized in Section 6.
Entropy 2022, 24, 309 3 of 21
2. Preliminaries
In this section, we present the safety objectives, cryptographic assumptions and
security models used in this paper.
2.1. Decisional Bilinear Diffie–Hellman Assumption
The proposed scheme is secure under the decisional bilinear Diffie–Hellman assumption.
In this algorithm, the challenger S picks a, b, c, z ∈ Z∗p and flips coin coin ∈ {0, 1}
randomly.
• If coin = 0, S outputs (g, ga, gb, gc, e(g, g)z).
• Otherwise, S outputs (g, ga, gb, gc, e(g, g)abc).
Then, the adversary A gives a guess of coin.
2.2. Definition of PKEwET
The PKEwET scheme contains four algorithms [7]:
(1) KeyGen (1l): This procedure randomly selects x ∈ Z∗q , and outputs the public/secret
key pair (pk = gx, sk = x), where g is a generator of G.
(2) Encrypt (M, pk): This procedure selects the numbers r ∈ Z∗q randomly. Then, it
outputs the ciphertext CT as follows:
Use r to compute:
C1 = gr
C2 = Mr
C3 = Hash(C1, C2, gxr)⊕ (M ‖ r)
Output the ciphertext CT = (C1, C2, C3).
(3) Decrypt (CT, sk): Given sk and a ciphertext CT, the procedure runs as follows:
M ‖ r = C3 ⊕ Hash(C1, C2, Cx
1 )
If C1 = gr and C2 = Mr, output M; otherwise, return ⊥.
(4) Test (CTi, CTj): Given CTi = (Ci,1, Ci,2, Ci,3), CTj = (Cj,1, Cj,2, Cj,3 the procedure runs
as follows:
T1 = e(Ci,1, Cj,2)
T2 = e(Cj,1, Ci,2)
Then, check whether T1 = T2 holds. If yes, it means that Mi = Mj and output 1.
Otherwise, it means that Mi 6= Mj and output 0.
2.3. Group ID-Based Encryption
A group ID-based encryption scheme consists of the following six algorithms [42]:
(1) Setup (l): With the security parameter l, this procedure exports system public param-
eters sp and msk.
(2) KeyGengroup (sp): With system public parameters sp, this procedure exports the
public key and secret key gsk of group users.
(3) Extract (msk, sp, ID): With a user’s identity ID ∈ {0, 1}∗, this procedure outputs the
public key and secret key dk of users.
(4) Join (gsk, hID): This algorithm is an interactive protocol between the group manager
and the prospective user; it takes the group user’s ID as inputs, and outputs the group
public key gpk.
(5) Encrypt (M, sp, gpki, dkIDi , IDj): This algorithm takes the public keys sp, gpki of the
group manager, dkIDi of the user i, and the receiver’s public key IDj and the message
M as inputs, and outputs a ciphertext CT.
Entropy 2022, 24, 309 4 of 21
(6) Decrypt (CT, gpk, dkIDj ): This algorithm is run by the receiver; it takes the group
public key gpk, the receiver’s secret key dkIDj , and the ciphertext CT as inputs, and
outputs the message M or an error symbol ⊥.
2.4. System Models
Figure 1 illustrates the system model of T-GIBEwET. The system has four roles: the
group manger, the users, the tester, and a trusted third party. The trusted third party
generates the private key dk for users. The group manger generates the group public key
and group secret key for the group users. The group users encrypt and send the private
data to the tester. The tester is authorized and gains a trapdoor gtd.
Figure 1. System Model.
An integrated T-GIBEwET scheme consists of nine algorithms: Setup, KeyGengroup,
Extract, Join, Encrypt, Decrypt, Trace, Auth, and Test.
(1) Setup (l): With the security parameter l, this procedure exports the system public
parameters sp and msk.
(2) KeyGengroup (sp): With system public parameters sp, this procedure exports the
public key and secret key gsk of group users.
(3) Extract (msk, sp, ID): With a user’s identity ID ∈ {0, 1}∗, this procedure outputs the
public key and secret key dk of users.
(4) Join (gsk, hID): This algorithm is an interactive protocol between the group manager
and the prospective user; it takes the group user’s ID as inputs, and outputs the group
public key gpk.
(5) Encrypt (M, sp, gpki, dkIDi , IDj): This algorithm takes the public keys sp and gpki of
the group manager, dkIDi of the user i, the receiver’s public key IDj, and the message
M as inputs, and outputs a ciphertext CT.
(6) Decrypt (CT, gpk, dkIDj ): This algorithm is run by the receiver, it takes the group
public key gpk, the receiver’s secret key dkIDj , and the ciphertext CT as inputs, and
outputs the message M or an error symbol ⊥.
(7) Trace (CT, gsk, hIDi , gpk): This algorithm is run by the group manger; it takes group
secret key gsk, hIDi , gpk, and a ciphertext CT as inputs, and outputs the user’s ID.
(8) Auth (gsk): This algorithm is run by the group manger, and outputs the group
trapdoor gtd.
(9) Test (CTi, CTj, gtd): This algorithm is run by the tester; it takes the two ciphertexts
CTi, CTj and gtd as inputs, and outputs 1 or 0.
Entropy 2022, 24, 309 5 of 21
2.5. Security Models
According to different permissions, we show two kinds of adversaries in our proposal.
• Type− α1 adversary: With a trapdoor, the adversary cannot recover the plaintext after
receiving the challenge ciphertext.
• Type− α2 adversary: Without a trapdoor, the adversary cannot tell by which message
is CT∗ encrypted.
OW-CCA security in T-GIBEwET.
Type− α1 adversary A1 and simulator S ’s game is played as in Figure 2.
Figure 2. OW-CCA security model.
In Figure 2,O1 represents the H1, H2, H3, H4, and H5 queries. O2(ID)
4
= Extract(msk, ID),
O3(M, IDj, gpk, sp, dkIDi )
4
= Encrypt(M, IDj, gpk, sp, dkIDi ), O4(ID, CT)
4
= Decrypt
(dkID, CT), O5(gtd, ·) 4
= Auth(gtd, ·), O6 = O1, O8(M, IDj, gpk, sp, dkIDi ) =
O3(M, IDj, gpk, sp, dkIDi )
4
= Encrypt(M, IDj, gpk, sp, dkIDi ), O10(gtd, ·) = O5(gtd, ·) 4=
Auth(gtd, ·), but
O7(i) =
{
O2(i) i 6= t
⊥ otherwise
and
O9(i, CTi) =
{
O4(i, CTi) CTi 6= CT∗
⊥ otherwise
The advantage of A1 in the aforementioned game is defined as follows:
AdvOW−CCA
PKEwET−FA,A1
(k) =Pr[Mt = M∗t ]
As described in Figure 2, A1 enjoys O1, O2, O3, O4, and O5 queries in Phase 1, and
S answers all queries truthfully. When A1 decides to discontinue queries, S selects a
Entropy 2022, 24, 309 6 of 21
challenge message M and generates the challenge ciphertext CT∗. Then, A1 enjoys O6, O7,
O8, O9, and O10 queries as Phase 1, but the condition is that CT∗ does not appear in O9.
When A1 decides to discontinue queries, A1 guesses M
′
to S .
Definition 1. The T-GIBEwET scheme is OW-CCA security, if all polynomial time and the
advantage of A1 (AdvOW−CCA
T−GIBEwET,A1
(l) =Pr[M = M
′
]) is negligible in the above game.
IND-CCA security in T-GIBEwET.
Type− α2 adversary A2 and simulator S ’s game is played as in Figure 3.
Figure 3. IND-CCA Security Model.
In Figure 3,O1 represents H1, H2, H3, H4, and H5 queries. O2(ID)
4
= Extract(msk, ID),
O3(M, IDj, gpk, sp, dkIDi )
4
= Encrypt(M, IDj, gpk, sp, dkIDi ), O4(ID, CT)
4
= Decrypt
(dkID, CT), O5 = O1, O7(M, IDj, gpk, sp, dkIDi ) = O3(M, IDj, gpk, sp, dkIDi )
4
= Encrypt
(M, IDj, gpk, sp, dkIDi ), but
O6(i) =
{
O2(i) i 6= t
⊥ otherwise
and
O8(i, CTi) =
{
O4(i, CTi) CTi 6= CT∗
⊥ otherwise
The advantage of A2 in the aforementioned game is defined as follows:
AdvIND−CCA
PKEwET−FA,A2
(k) = |Pr[b = b∗]− 1/2|)
As described in Figure 3, A2 enjoys O1, O2, O3, and O4 queries in Phase 1, and S
answers all queries truthfully. When A2 decides to discontinue queries, A2 selects the
Entropy 2022, 24, 309 7 of 21
two challenge messages M0, M1. Given M0 and M1, S outputs CT∗ based on a random
selection of M0 and M1. Then, A2 enjoys O5, O6, O7, and O8 queries as Phase 1, but the
condition is that CT∗ does not appear in O8. When A2 decides to discontinue queries, A2
guesses b
′
to S .
Definition 2. The T-GIBEwET scheme is IND-CCA security, if all polynomial time and the
advantage of A2 (AdvIND−CCA
T−GIBEwET,A2
(l) = |Pr[b = b
′
]− 1/2|) is negligible in the above game.
Definition 3 (Correctness). If a T − GIBEwET scheme is correct, for any sp ← Setup(l),
gsk← KeyGengroup(sp), dk← Extract(msk, sp, ID), gpk← Join(gsk, hID), CTj ← Encrypt
(M, sp, gpki, dkIDi , IDj), CTi ← Encrypt(M, sp, gpk j, dkIDj , IDi) and gtd ← Auth(gsk), the
following conditions must be satisfied:
(1) For any M ∈ M, Decrypt(Encrypt(M, sp, gpk j, dkIDj , IDi), dkIDi ) = M always holds.
(2) For any ciphertexts CTi and CTj, if Decrypt(CTi, dkIDi ) = Decrypt(CTj, dkIDj) 6=⊥, it
holds that
Test(CTi, CTj, gtd) = 1.
(3) For any ciphertexts CTi and CTj, if Decrypt(CTi, dkIDi ) 6= Decrypt(CTj, dkIDj) 6=⊥, it
holds that
Test(CTi, CTj, gtd) = 0.
2.6. Symbols
In this paragraph, we summarize some symbols used in the proposed scheme. These
symbols will assist readers to read and understand the following sections. These symbols
are listed in Table 1.
Table 1. Symbols used in the proposed scheme.
Symbol Description
l A security parameter
G A cyclic group
g The generator of G
M The plaintext
CT The ciphertext
CT∗ The challenge ciphertext
M The message space
Z Set of integers
H A hash function
s The master key (keep it as a secret)
ID A user’s identity
gsk The group secret key (kept as a secret by group manager)
gpk The group public key (share to all users in the group)
dkID A user’s secret key (keep it as a secret)
A The adversary
S The simulator
3. Our Constructions
This section provides the proposed T-GIBEwET scheme as follows.
(1) Setup (l): With the security parameter l, this procedure exports the system pub-
lic parameters sp = (g, G, GT , e, gs, H1, H2, H3, H4, H5). Choose hash functions: H1:
{0, 1}∗ → G∗, H2 : GT → G, H3 : GT → {0, 1}l+l1 , H4, H5 : {0, 1}∗ → {0, 1}l ; here l1
means the length of elements in Zq. The master key msk is s.
(2) KeyGengroup (sp): This procedure randomly selects s1, s2 ∈ Z∗q , and outputs the
group secret key gsk = (s1, s2).
(3) Extract (msk, sp): With a string ID ∈ {0, 1}∗, this procedure outputs the public key
and secret key as follows:
Entropy 2022, 24, 309 8 of 21
• Outputs a public key hID = H1(ID) ∈ G∗.
• Outputs a secret key dkID = hs
ID.
(4) Join (gsk, hID): This procedure outputs the group public key gpk = (hs1
ID, gs1 , gs1s2)
for user ID.
(5) Encrypt (M, sp, gpki, dkIDi , IDj): This procedure selects numbers r1, r2 ∈ Z∗q randomly.
Then, it outputs the ciphertext CT as follows:
Use r1, r2 to compute:
C1 = hs1r1
IDi
C2 = Mr2 H2(U
r1
1 )
C3 = gr1
C4 = gsr2
C5 = hsr1
IDi
C6 = H3(U
r1
2 )⊕ (M ‖ r1)
C7 = H5(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ hs
IDi
)
C8 = H4(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1).
Output the ciphertext CT = (C1, C2, C3, C4, C5, C6, C7, C8),
where:
U1 = e(hs
IDi
, gs1s2)
U2 = e(hIDj , gs).
(6) Decrypt (CT, dkIDj ): Given dkIDj and a ciphertext CT, the procedure runs as follows:
M ‖ r1 = C6 ⊕ H3(e(C3, hs
IDj
))
If C1 = hs1r1
IDi
and C8 = H4(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1), output M;
otherwise, return ⊥.
(7) Trace (CT, dkIDi , sp): Given dkIDi , sp and a ciphertext CT, the procedure runs as follows:
D1 = e(g, C5)
D2 = e(hs
IDi
, C3)
Then, check whether C7 = H5(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ hs
IDi
) and D1 = D2
holds. If yes, it means that CT is encrypted by IDi.
(8) The algorithm from the authorization function and test function:
Suppose CTi (resp. CTj) is a ciphertext of IDi (resp. IDj).
• Auth(gsk): Outputs the group trapdoor gtd = s2.
• Test(CTi, CTj, gtd):
This procedure takes the inputs CTi, CTj and gtd and exports as follows:
Mri,2
i = Ci,2/e(Ci,1, gs)s2
M
rj,2
j = Cj,2/e(Cj,1, gs)s2
Use Mri,2
i and M
rj,2
j to decide whether e(Mri,2
i , Cj,4) = e(M
rj,2
j , Ci,4). If yes, output
1, which means Mi = Mj. Otherwise, export 0, which means Mi 6= Mj.
Theorem 1. According to Definition 3, the above T-GIBEwET scheme is correct.
Proof. We show in turn that the three conditions of Definition 3 are all satisfied.
(1) The first condition is easy to verify.
Entropy 2022, 24, 309 9 of 21
(2) Considering the second condition, for any sp← Setup(l), gsk← KeyGengroup(sp), dk←
Extract(msk, sp, ID), gpk ← Join(gsk, hID), CTj ← Encrypt(M, sp, gpki, dkIDi , IDj),
CTi ← Encrypt(M, sp, gpk j, dkIDj , IDi), the following equalities hold.
Given a group trapdoor gtd = s2 and two ciphertexts CTi = Encrypt
(Mi, sp, gpk j, dkIDj , IDi) and CTj = Encrypt(Mj, sp, gpki, dkIDi , IDj), we can compute
as follows:
Ci,2/e(Ci,1, gs)s2 = Mri,2
i H2(e(hs
IDi
, gs1s2)ri,1)/e(hs1ri,1
IDi
, gs)s2
= Mri,2
i H2(e(hIDi , g)ss1s2ri,1)/e(hIDi , g)ss1s2ri,1 = Mri,2
i
Cj,2/e(Cj,1, gs)s2 = M
rj,2
j H2(e(hs
IDj
, gs1s2)rj,1)/e(h
s1rj,1
IDj
, gs)s2
= M
rj,2
j H2(e(hIDj , g)ss1s2rj,1)/e(hIDj , g)ss1s2rj,1 = M
rj,2
j
Use Mri,2
i to compute e(Mri,2
i , Cj,4) = e(Mri,2
i , gsrj,2) = e(Mi, g)srj,2ri,2 .
Use M
rj,2
j to compute e(M
rj,2
j , Ci,4) = e(M
rj,2
j , gsri,2) = e(Mj, g)sri,2rj,2 . If Mi = Mj, then
e(Mri,2
i , Cj,4) = e(M
rj,2
j , Ci,4), which means Test(CTi, CTj, gtd) = 1.
(3) As for the third condition, we have the following fact:
As in the above calculation, for any message Mi(resp.Mj), if Mi 6= Mj, which means
e(Mi, g)srj,2ri,2 6= e(Mj, g)sri,2rj,2 . Then, Test(CTi, CTj, gtd) = 0 holds.
4. Security Analysis
This section analyzes the security of the scheme and authorization.
Theorem 2. For a type-1 adversary, under the random oracle model, the presented T-GIBEwET
scheme is OW-CCA secure.
Proof. Let A1 be T�ype-1 adversary breaking the T-GIBEwET scheme in polynomial time.
A1 makes at most qH1 > 0 H1-queries, qH2 > 0 H2-queries, qH3 > 0 H3-queries, qH4 > 0
H4-queries, qH5 > 0 H5-queries, qKey > 0 key retrieve queries, qEnc > 0 encryption queries,
and qDec > 0 decryption queries. We give CT∗ to the simulator S . The aim of S is to recover
the plaintext of CT∗ with a non-negligible advantage.
The game between A1 and S is described as follows:
Game G1.0
Setup: S runs the algorithm Setup(1l) to create the system parameters
sp = (g, G, GT , gs, e, H1, H2, H3, H4, H5), runs the algorithm KeyGengroup(sp) to create a
group private key gsk = (s1, s2), runs the algorithm Join(gsk, hID) to create a group public
key gpk = (hs1
ID, gs1 , gs1s2) for user ID, and runs Auth(gsk) to create a group trapdoor
gtd = s2. Then, S randomly selects ID1, ID2 as a challenger sender and a challenger
receiver, respectively. Then, S gives the public key and ID1, ID2 to A1.
Moreover, the challenger S prepares the five hash lists H1, H2, H3, H4, H5 to record all
hash queries and answer the random oracle queries, where all hash lists are empty at the
beginning. If the same input is asked multiple times, the same answer will be returned.
Phase 1: S responds to the queries made by A1 in the following ways:
• H1-query: S maintains a list of 3-tuples (IDi, αi, xi, coini) in H1. When A1, ask for IDi
queries, and S runs as follows:
– If the query IDi already in the H1 list in the form of (IDi, αi, xi, coini), S outputs
H1(IDi) = αi ∈ G∗ to A1.
– Otherwise, S generates coini ∈ {0, 1} randomly. Then, it outputs as follows:
* If coini = 0, S chooses a random number xi ∈ Z∗q and computes αi = gxi toA1.
* Otherwise, S computes αi = hxi
ID2
to A1.
Entropy 2022, 24, 309 10 of 21
– S adds the tuple (IDi, αi, xi, coini) into the H1 list.
• H2-query: S maintains a list of 2-tuples (θi, ϑi) in H2. S chooses ϑi ∈ G randomly,
returns ϑi to A1, and adds the tuple (θi, ϑi) to the H2 list.
• H3-query: S maintains a list of 2-tuples (µi, νi) in H3. S chooses νi{0, 1}l+l1 randomly,
returns µi to A1, and adds the tuple (µi, νi) to the H3 list.
• H4-query: S maintains a list of 2-tuples (ρi, ξi) in H4. S chooses ξi{0, 1}l randomly,
returns ρi to A1, and adds the tuple (ρi, ξi) to the H4 list.
• H5-query: S maintains a list of 2-tuples (φi, ϕi) in H4. S chooses ϕi{0, 1}l randomly,
returns φi to A1, and adds the tuple (φi, ϕi) to the H5 list.
• Extract Query (ID): When inputting IDi, S sends dkIDi = αi to A1. If coini = 1, it
means that ID 6= ID2. Then, S sends ⊥ to A1.
• Encryption Query: S runs an encryption algorithm and outputs CT = Encrypt
(M, ID, gpk, sp, dk).
• Decryption queries: With the CT to the decryption query, S returns M = Decrypt(CT, dk j)
toA1 as follows:
– If coini = 0, S uses the private key and outputs the decryption query to A1.
– Otherwise, S outputs ⊥ to A1.
• Authorization Query: S outputs the group trapdoor s2 to A1.
Challenge: S chooses M∗ ⊂M and r∗1 , r∗2 ∈ {0, 1}l1 . It then outputs CT∗ as follows:
C∗1 = hs1r1
ID1
C∗2 = M∗r2 H2(U
r1
1 )
C∗3 = gr1
C∗4 = gsr2
C∗5 = hsr1
ID1
C∗6 = H3(U
r1
2 )⊕ (M∗ ‖ r1)
C∗7 = H4(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ hs
ID1
)
C∗8 = H4(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ C∗7 ‖ M∗ ‖ r1).
The ciphertext CT∗ = (C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C∗6 , C∗7 , C∗8 ) is output, where:
U1 = e(hs
ID1
, gs1s2)
U2 = e(hID2 , gs)
Finally, it sends CT∗ to A1 as the challenge ciphertext.
Phase 2: A1 performs the same queries as in Phase 1; the constraint is that CT∗ does
not appear in the decryption queries.
Guess: A1 outputs M
′ ⊂M.
Let E1.0 be the event that M
′
= M∗ in Game G1.0. Then, the advantage is:
AdvOW−CCA
T−GPKE−ET,A1
(qH1 , qH2 , qH3 , qH4 , qH5 , qExtr, qEnc, qDec) = Pr[E1.0]
Game G1.1
Setup: S runs the algorithm Setup(1l) to create the system parameters
sp = (g, G, GT , gs, e, H1, H2, H3, H4, H5), runs the algorithm KeyGengroup(sp) to create a
group private key gsk = (s1, s2), runs the algorithm Join(gsk, hID) to create group public
key gpk = (hs1
ID, gs1 , gs1s2) for user ID, and runs Auth(gsk) to create the group trapdoor
gtd = s2. Then, S randomly selects ID1, ID2 as a challenger sender and a challenger
receiver, respectively. Then, S gives the public key and ID1, ID2 to A1.
Moreover, the challenger S prepares the five hash lists H1, H2, H3, H4, H5 to record all
hash queries and answer the random oracle queries, where all hash lists are empty at the
beginning. If the same input is asked multiple times, the same answer will be returned.
Entropy 2022, 24, 309 11 of 21
Phase 1: S responds to the queries made by A1 in the following ways:
• H1-query (ID), H2-query (θi), H3-query (µi), H4-query (ρi), and H5-query (φi) are the
same as in Game G1.0.
• Extract Query (ID): Same as in Game G1.0.
• Encryption Query: S outputs CT to A1 as follows: S chooses r1, r2 ∈ {0, 1}l1 ran-
domly, and performs the H1-query(IDi), H1-query(IDj) to obtain αi, αj, the H2-
query(e(C1, gs)s2 ) to obtain ϑi, the H3-query(e(αj, gs)r1 ) to obtain νi, the H5-query(C1 ‖
C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ hs
IDi
) to obtain ϕi. and the H4-query(C1 ‖ C2 ‖ C3 ‖ C4 ‖
C5 ‖ C6 ‖ C7 ‖ M ‖ r1) to obtain ξi.
C1 = αs1r1
i
C2 = Mr2 ϑi
C3 = gr2
C4 = gsr2
C5 = αsr1
j
C6 = νi ⊕ (M ‖ r1)
C7 = ϕi.
C8 = ξi.
S adds (e(C1, gs)s2 , ϑi) to the H2 list, adds (e(αj, gs)r1 , νi) to the H3 list, adds (C1 ‖
C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1, ξi) to the H4 list, and adds (C1 ‖ C2 ‖ C3 ‖ C4 ‖
C5 ‖ C6 ‖ hs
IDi
, ϕi) to the H5 list.
• Decryption queries: With the CT to the decryption query, S returns M = Decrypt(CT, dk j)
to A1 as follows: S performs the H3(e(αj, gs)r1) to obtain answer νi, and performs the
H4-query(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1) to obtain answer ξi. Then,
S performs
M ‖ r1 = C6 ⊕ νi.
Then, it verifies C1 = αs1r1
i and C8 = ξi. If the verification fails, it returns⊥. Otherwise,
S outputs M to A1.
• Authorization Query: Same as in Game G1.0.
Challenge: S chooses M∗ ⊂ M, W ∈ {0, 1}l+l1 and r1, r2 ∈ {0, 1}l1 . Then, it outputs
CT∗ as follows:
C∗1 = hs1r1
ID1
C∗2 = M∗r2 H2(U
r1
1 )
C∗3 = gr1
C∗4 = gsr2
C∗5 = hsr1
ID1
C∗6 = W ⊕ (M∗ ‖ r1)
C∗7 = H5(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ hs
IDi
)
C∗8 = H4(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ C∗7 ‖ M∗ ‖ r1)
where U1 = e(hs
ID1
, gs1s2). It outputs the ciphertext CT∗ = (C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C∗6 , C∗7 , C∗8 ),
and adds (e(hID2 , gs)r1), W) into H3.
Finally, it sends CT∗ to A1 as the challenge ciphertext.
Phase 2: A1 performs the same queries as in Phase 1, where the constraint is that CT∗
does not appear in the decryption queries.
Entropy 2022, 24, 309 12 of 21
Guess: A1 outputs M
′ ⊂M.
Let E1.1 be the event that M
′
= M∗ in Game G1.1. Then, the advantage is:
Pr[E1.1] = Pr[E1.0].
Game G1.2
Setup: S runs the algorithm Setup(1l) to create the system parameters
sp = (g, G, GT , gs, e, H1, H2, H3, H4, H5), runs the algorithm KeyGengroup(sp) to create
a group private key gsk = (s1, s2), runs the algorithm Join(gsk, hID) to create the group
public key gpk = (hs1
ID, gs1 , gs1s2) for user ID, and runs Auth(gsk) to create the group trap-
door gtd = s2. Then, S randomly select ID1, ID2 as a challenger sender and a challenger
receiver, respectively. Then, S gives the public key and ID1, ID2 to A1.
Moreover, the challenger S prepares the five hash lists H1, H2, H3, H4, , H5 to record
all hash queries and answer the random oracle queries, where all hash lists are empty at
the beginning. If the same input is asked multiple times, the same answer will be returned.
Phase 1: S responds to the queries made by A1 in the following ways:
• The H1-query(ID), H2-query(θi), H5-query(φi), and H4-query(ρi) are the same as in
Game G1.1.
• The H3-query(µi) is the same as in Game G1.1, except that A1 asks e(C3, hs
ID2
).
• Extract Query(ID): Same as in Game G1.1.
• Encryption Query: Same as in Game G1.1.
• Decryption Queries: Same as in Game G1.1.
• Authorization Query: Same as in Game G1.1.
Challenge: S chooses M∗ ⊂M, W∗ ∈ {0, 1}l+l1 and r1, r2 ∈ {0, 1}l1 . Then, it outputs
CT∗ as follows:
C∗1 = hs1r1
ID1
C∗2 = M∗r2 H2(U
r1
1 )
C∗3 = gr1
C∗4 = gsr2
C∗5 = hsr1
ID1
C∗6 = W∗
C∗7 = H5(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ hs
IDi
).
C∗8 = H4(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ C∗7 ‖ M∗ ‖ r1).
where U1 = e(hs
ID1
, gs1s2). It outputs the ciphertext CT∗ = (C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C∗6 , C∗7 , C∗8 ),
and adds (e(hID2 , gs)r1), W∗ ⊕ (M∗ ‖ r1)) into H3.
Finally, it sends CT∗ to A1 as the challenge ciphertext.
Phase 2: A1 performs the same queries as in Phase 1, whereqthe constraint is that CT∗
does not appear in the decryption Queries, and if A1 asks for the decryption of CT∗ =
(C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C
′
6, C∗7 , C∗8 ), where C
′
6 6= C∗6 , S outputs⊥.
Guess: A1 outputs M
′ ⊂M.
Let E1.2 be the event that M
′
= M∗ in Game G1.2.
Because C
′
6 is a random value in Game G1.1 and Game G1.2, the challenge ciphertexts
generated in Game G1.1 and Game G1.2 follow the same distribution. Therefore, if the event
E1 does not occur, Game G1.2 is identical to Game G1.1, and we can figure out
|Pr[E1.2]− Pr[E1.1]| ≤ Pr[E1].
Next, we show that the probability of event E1 occurring in Game G1.2 is negligible.
Entropy 2022, 24, 309 13 of 21
Lemma 1. When the C-BDH problem is intractable, there is a negligible probability that the event
E1 happens in Game G1.2.
Proof. Suppose that Pr[E1] is non-negligible; we can construct a simulator S to break the
C-BDH assumption by using A1’s attacks. With the tuple (e, G, GT , g, ga, gc, gd), the aim is
to obtain e(g, g)acd.
Setup: S randomly selects ID1, ID2 as a challenger sender and a challenger receiver,
respectively. Then, S gives the public key and ID1, ID2 to A1. S runs the algorithm
Setup(1l) to create the system parameters sp = (g, G, GT , gs, e, H1, H2, H3, H4, H5), runs
the algorithm KeyGengroup(sp) to create a group private key gsk = (s1, s2), runs the
algorithm Join(gsk, hID) to create the group public key gpk = (hs1
ID, gs1 , gs1s2) for user ID,
and runs Auth(gsk) to create the group trapdoor gtd = s2.
Phase 1: S responds to the queries made by A1 in the following ways:
• H1-query(ID), H2-query(θi), H5-query(φi), and H4-query(ρi) are same as in Game
G1.1.
• H3-query(µi) is same as in Game G1.1, except that A1 asks e(C3, hs
ID2
)
• Extract Query(ID): Same as in Game G1.1.
• Encryption Query: Same as in Game G1.1, except that for the query (ID2, ∗, ∗), S selects
r1, r2 ∈ {0, 1}l1 randomly and outputs a ciphertext CT = (C1, C2, C3, C4, C5, C6, C7, C8)
as follows:
S performs the H1-query(IDi) and H1-query(IDj) to obtain αi and αj, respectively,
the H2-query(e(C1, gs)s2) to obtain ϑi, the H3-query(e(αj, gs)r1) to obtain νi, the H5-
query(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ hIDs
i
) to obtain ϕi, and the H4-query(C1 ‖ C2 ‖
C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1) to obtain ξi.
C1 = αs1r1
i
C2 = Mr2 ϑi
C3 = gr2
C4 = gsr2
C5 = αsr2
j
C6 = νi ⊕ (M ‖ r1)
C7 = ϕi.
C8 = ξi.
S adds (e(C1, gs)s2 , ϑi) to the H2 list, adds (e(αj, gs)r1 , νi) to the H3 list, and adds
(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1, ξi) to the H4 list.
• Decryption queries: Same as in Game G1.1.
• Authorization Query: Same as in Game G1.1.
Challenge: S chooses M∗ ⊂M, W∗ ∈ {0, 1}l+l1 and r1, r2 ∈ {0, 1}l1 . Then, it outputs
CT∗ as follows:
C∗1 = hs1r1
ID1
C∗2 = M∗r2 H2(U
r1
1 )
C∗3 = gr1
C∗4 = gsr2
C∗5 = hsr1
ID1
C∗6 = W∗
C∗7 = H5(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ hs
ID1
).
Entropy 2022, 24, 309 14 of 21
C∗8 = H4(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ C∗7 ‖ M∗ ‖ r1).
where U1 = e(hs
ID1
, gs1s2). It outputs the ciphertext CT∗ = (C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C∗6 , C∗7 , C∗8 ),
and adds (e(hID2 , gs)r1), W∗ ⊕ (M∗ ‖ r1)) into H3.
Finally, it sends CT∗ to A1 as the challenge ciphertext.
Phase 2: A1 performs the same queries as in Phase 1; the constraint is that CT∗
does not appear in the decryption queries, and if A1 asks for the decryption of CT∗ =
(C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C
′
6, C∗7 , C∗8 ), where C
′
6 6= C∗6 , S outputs ⊥.
Guess: A1 outputs M
′ ⊂M.
Theorem 3. Under the random oracle model, the proposed T-GIBEwET scheme is IND-CCA secure
against a type-2 adversary.
Proof. Let A2 be a type-2 adversary breaking the T-GIBEwET scheme in polynomial time.
A2 makes at most qH1 > 0 H1-queries, qH2 > 0 H2-queries, qH3 > 0 H3-queries, qH4 > 0
H4-queries, qH5 > 0 H5-queries, qKey > 0 key retrieve queries, qEnc > 0 encryption queries,
and qDec > 0 decryption queries. We give CT∗ to the simulator S . The aim of S is to recover
the plaintext of CT∗ with a non-negligible advantage.
The game between A2 and S is described as follows:
Game G2.0
Setup: S runs the algorithm Setup(1l) to create the system parameters
sp = (g, G, GT , gs, e, H1, H2, H3, H4, H5), runs the algorithm KeyGengroup(sp) to create
a group private key gsk = (s1, s2), runs the algorithm Join(gsk, hID) to create the group
public key gpk = (hs1
ID, gs1 , gs1s2) for user ID, and runs Auth(gsk) to create the group trap-
door gtd = s2. Then, S randomly selects ID1, ID2 as a challenger sender and a challenger
receiver, respectively. Then, S gives the public key and ID1, ID2 to A2.
Moreover, the challenger S prepares the five hash lists H1, H2, H3, H4, H5 to record all
hash queries and answer the random oracle queries, where all hash lists are empty at the
beginning. If the same input is asked multiple times, the same answer will be returned.
Phase 1: S responds to the queries made by A2 in the following ways:
• H1-query: S maintains a list of 3-tuples (IDi, αi, xi, coini) in H1. When A2 asks for IDi
queries, S runs as follows:
– If the query IDi is already in the H1 list in the form of (IDi, αi, xi, coini), S outputs
H1(IDi) = αi ∈ G∗ to A2.
– Otherwise, S generates coini ∈ {0, 1} randomly. Then, it outputs as follows:
* If coini = 0, S chooses a random number xi ∈ Z∗q and computes αi = gxi to
A2.
* Otherwise, S computes αi = hxi
ID2
to A2.
– S adds the tuple (IDi, αi, xi, coini) into the H1 list.
• H2-query: S maintains a list of 2-tuples (θi, ϑi) in H2. S chooses ϑi ∈ G randomly,
puts out ϑi to A2 and adds the tuple (θi, ϑi) to the H2 list.
• H3-query: S maintains a list of 2-tuples (µi, νi) in H3. S chooses νi{0, 1}l+l1 randomly,
puts out µi to A2 and adds the tuple (µi, νi) to the H3 list.
• H4-query: S maintains a list of 2-tuples (ρi, ξi) in H4. S chooses ξi{0, 1}l randomly,
puts out ρi to A2 and adds the tuple (ρi, ξi) to the H4 list.
• H5-query: S maintains a list of 2-tuples (φi, ϕi) in H4. S chooses ϕi{0, 1}l randomly,
returns φi to A1 and adds the tuple (φi, ϕi) to the H5 list.
• Extract Query(ID): On input of the IDi, S sends dkIDi = αi to A2. If coini = 1, which
means ID 6= ID2, then S sends ⊥ to A2.
• EncryptionQuery: S runstheencryptionalgorithmandoutputs CT = Encrypt(M, gpk, dk, sp).
• Decryption queries: With the CT in the decryption query, S returns M = Decrypt(CT, dk j)
toA2 as follows:
– If coini = 0, S uses the private key and outputs the decryption query to A2.
Entropy 2022, 24, 309 15 of 21
– Otherwise, S outputs ⊥ to A2.
• Authorization Query: It is not allowed.
Challenge: A2 chooses M0, M1 ⊂ M randomly and sends them to S . Then, S takes
b ∈ {0, 1} and r∗1 , r∗2 ∈ {0, 1}l1 . It then outputs CT∗ as follows:
C∗1 = hs1r1
ID1
C∗2 = Mr2
b H2(U
r1
1 )
C∗3 = gr1
C∗4 = gsr2
C∗5 = hsr1
ID1
C∗6 = H3(U
r1
2 )⊕ (Mb ‖ r1)
C∗7 = H5(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ hs
ID1
).
C∗8 = H4(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ C∗7 ‖ Mb ‖ r1).
Output the ciphertext CT∗ = (C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C∗6 , C∗7 , C∗8 ),
where:
U1 = e(hs
ID1
, gs1s2)
U2 = e(hID2 , gs)
Finally, it sends CT∗ to A2 as the challenge ciphertext.
Phase 2: A2 performs the same queries as in Phase 1, where the constraint are as
follows:
• CT∗ does not appear in the decryption queries.
• In the authorization query, all of the group users cannot be authorized.
Guess: A2 outputs b∗ ∈ {0, 1}.
Let E2.0 be the event that b = b∗ in Game G2.0. Then, the advantage is:
AdvOW−CCA
T−GPKE−ET,A2
(qH1 , qH2 , qH3 , qH4 , qH5 , qExtr, qEnc, qDec) = Pr[E2.0]
Game G2.1
Setup: S runs the algorithm Setup(1l) to create the system parameters
sp = (g, G, GT , gs, e, H1, H2, H3, H4), runs the algorithm KeyGengroup(sp) to create a
group private key gsk = (s1, s2), runs the algorithm Join(gsk, hID) to create the group
public key gpk = (hs1
ID, gs1 , gs1s2) for user ID, and runs Auth(gsk) to create the group trap-
door gtd = s2. Then, S randomly selects ID1, ID2 as a challenger sender and a challenger
receiver, respectively. Then, S gives the public key and ID1, ID2 to A2.
Moreover, the challenger S prepares the four hash lists H1, H2, H3, H4 to record all
hash queries and answer the random oracle queries, where all hash list are empty at the
beginning. If the same input is asked multiple times, the same answer will be returned.
Phase 1: S responds to the queries made by A2 in the following ways:
• H1-query(ID), H2-query(θi), H3-query(µi), H5-query(φi), and H4-query(ρi) are the
same as in Game G2.0.
• Extract Query(ID): Same as in Game G2.0.
• Encryption Query: S outputs CT to A2 as follows:
S chooses r1, r2 ∈ {0, 1}l1 randomly, and performs the H1-query(IDi) and H1-query(IDj)
to obtain αi and αj, respectively, the H2-query(e(C1, gs)s2) to obtain ϑi, the H3-
query(e(αj, gs)r1) to obtain νi, the H5-query(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ hs
IDi
)
to obtain ϕi, and the H4-query(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1) to
obtain ξi.
C1 = αs1r1
i
Entropy 2022, 24, 309 16 of 21
C2 = Mr2 ϑi
C3 = gr2
C4 = gsr2
C5 = αsr1
j
C6 = νi ⊕ (M ‖ r1)
C7 = ϕi
C8 = ξi.
S adds (e(C1, gs)s2 , ϑi) to the H2 list, adds (e(αj, gs)r1 , νi) to the H3 list, adds (C1 ‖
C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1, ξi) to the H4 list, and adds (C1 ‖ C2 ‖ C3 ‖ C4 ‖
C5 ‖ C6 ‖ hs
IDi
, ϕi) to the H5 list.
• Decryption queries: With the CT to the decryption query, S returns M = Decrypt(CT, sk j)
to A2 as follows: S performs the H3(e(αj, gs)r1) to obtain answer νi, and performs the
H4-query(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1) to obtain answer ξi. Then,
S performs
M ‖ r1 = C6 ⊕ νi.
Then, C1 = αs1r1
i and C8 = ξi are verified. If the verification fails, it returns ⊥.
Otherwise, S outputs M to A2.
• Authorization Query: It is not allowed.
Challenge: A2 chooses M0, M1 ⊂ M randomly and sends them to S . Then, S takes
b ∈ {0, 1} , W ∈ {0, 1}l+l1 and r∗1 , r∗2 ∈ {0, 1}l1 . It then outputs CT∗ as follows:
C∗1 = hs1r1
ID1
C∗2 = Mr2
b H2(U
r1
1 )
C∗3 = gr1
C∗4 = gsr2
C∗5 = hsr1
ID1
C∗6 = W ⊕ (Mb ‖ r1)
C∗7 = H5(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ hs
ID1
)
C∗8 = H4(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ C∗7 ‖ Mb ‖ r1)
where U1 = e(hs
ID1
, gs1s2). It outputs the ciphertext CT∗ = (C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C∗6 , C∗7 , C∗8 ),
and adds (e(hID2 , gs)r1), W) into H3.
Finally, it sends CT∗ to A2 as the challenge ciphertext.
Phase 2: A2 performs the same queries as in Phase 1; the constraint are as follows:
• CT∗ does not appear in the decryption queries.
• In the authorization query, all of the group users cannot be authorized.
Guess: A2 outputs b∗ ∈ {0, 1}.
Let E2.1 be the event that b = b∗ in Game G2.1. Then, the advantage is
Pr[E2.1] = Pr[E2.0].
Game G2.2
Setup: S runs the algorithm Setup(1l) to create the system parameters
sp = (g, G, GT , gs, e, H1, H2, H3, H4, H5), runs the algorithm KeyGengroup(sp) to create
a group private key gsk = (s1, s2), runs the algorithm Join(gsk, hID) to create the group
public key gpk = (hs1
ID, gs1 , gs1s2) for user ID, and runs Auth(gsk) to create the group trap-
Entropy 2022, 24, 309 17 of 21
door gtd = s2. Then, S randomly selects ID1, ID2 as a challenger sender and a challenger
receiver, respectively. Then, S gives the public key and ID1, ID2 to A2.
Moreover, the challenger S prepares the five hash lists H1, H2, H3, H4, H5 to record all
hash queries and answers the random oracle queries, where all hash list are empty at the
beginning. If the same input is asked multiple times, the same answer will be returned.
Phase 1: S responds to the queries made by A2 in the following ways:
• H1-query(ID), H2-query(θi), H5-query(φi), and H4-query(ρi) are the same as in Game G2.1.
• H3-query(µi) is the same as in Game G2.1, except that A2 asks e(C3, hs
ID2
).
• Extract Query(ID): Same as in Game G2.1.
• Encryption Query: Same as in Game G2.1.
• Decryption Queries: Same as in Game G2.1.
• Authorization Query: Same as in Game G2.1.
Challenge: A2 chooses M0, M1 ⊂ M randomly and sends them to S . Then, S takes
b ∈ {0, 1}, W∗ ∈ {0, 1}l+l1 and r1, r2 ∈ {0, 1}l1 . It then outputs CT∗ as follows:
C∗1 = hs1r1
ID1
C∗2 = Mr2
b H2(U
r1
1 )
C∗3 = gr1
C∗4 = gsr2
C∗5 = hsr2
ID1
C∗6 = W∗
C∗7 = H5(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ hs
ID1
).
C∗8 = H4(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ C∗7 ‖ Mb ‖ r1)
where U1 = e(hs
ID1
, gs1s2). It outputs the ciphertext CT∗ = (C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C∗6 , C∗7 , C∗8 ),
and adds (e(hID2 , gs)r1), W∗ ⊕ (M∗ ‖ r1)) into H3.
Finally, it sends CT∗ to A2 as the challenge ciphertext.
Phase 2: A2 performs the same queries as in Phase 1, where the constraint is that CT∗
does not appear in the decryption queries, and if A2 asks for the decryption of CT∗ =
(C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C
′
6, C∗7 , C∗8 ), where C
′
6 6= C∗6 , S outputs⊥.
Guess: A2 outputs b∗ ∈ {0, 1}.
Let E2.2 be the event that b = b∗ in Game G2.2.
Because C
′
6 is a random value in Game G2.1 and Game G2.2, the challenge ciphertexts
generated in Game G2.1 and Game G2.2 follow the same distribution. Therefore, if the event
E2 does not occur, Game G2.2 is identical to Game G2.1. And we can figure out that
|Pr[E2.2]− Pr[E2.1]| ≤ Pr[E2].
Next, we show that the probability of event E2 occurring in Game G2.2 is negligible.
Lemma 2. When the C-BDH problem is intractable, there is negligible probability that the event
E2 will happen in Game G2.2.
Proof. Suppose that Pr[E2] is non-negligible; we can construct a simulator S to break the
C-BDH assumption by using theA2’s attacks. With the tuple (e, G, GT , g, ga, gc, gd), the aim
is to obtain e(g, g)acd.
Setup: S randomly select ID1, ID2 as a challenger sender and a challenger receiver,
respectively. Then, S gives the public key and ID1, ID2 to A2. S runs the algorithm
Setup(1l) to create the system parameters sp = (g, G, GT , gs, e, H1, H2, H3, H4, H5), runs
the algorithm KeyGengroup(sp) to create a group private key gsk = (s1, s2), runs the
Entropy 2022, 24, 309 18 of 21
algorithm Join(gsk, hID) to create the group public key gpk = (hs1
ID, gs1 , gs1s2) for user ID,
and runs Auth(gsk) to create the group trapdoor gtd = s2.
Phase 1: S responds to the queries made by A2 in the following ways:
• H1-query(ID), H2-query(θi), H5-query(φi), and H4-query(ρi) are the same as in Game G2.1.
• H3-query(µi) is the same as in Game G2.1, except that A2 asks for e(C3, hs
ID2
).
• Extract Query (ID): Same as in Game G2.1.
• Encryption Query: Same as in Game G2.1, except that for the query (ID2, ∗, ∗), S selects
r1, r2 ∈ {0, 1}l1 randomly and outputs a ciphertext CT = (C1, C2, C3, C4, C5, C6, C7, C8)
as follows:
S performs the H1-query(IDi) and H1-query(IDj) to obtain αi and αj, respectively,
the H2-query(e(C1, gs)s2) to obtain ϑi, the H3-query(e(αj, gs)r1) to obtain νi, the H5-
query(C1 ‖ C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ hs
IDi
) to obtain ϕi, and the H4-query(C1 ‖ C2 ‖
C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1) to obtain ξi.
C1 = αs1r1
i
C2 = Mr2 ϑi
C3 = gr2
C4 = gsr2
C5 = αsr1
j
C6 = νi ⊕ (M ‖ r1)
C7 = ϕi
C8 = ξi.
S adds (e(C1, gs)s2 , ϑi) to the H2 list, adds (e(αj, gs)r1 , νi) to the H3 list, adds (C1 ‖
C2 ‖ C3 ‖ C4 ‖ C5 ‖ C6 ‖ C7 ‖ M ‖ r1, ξi) to the H4 list, and adds (C1 ‖ C2 ‖ C3 ‖ C4 ‖
C5 ‖ C6 ‖ hs
IDi
, ϕi) to the H5 list.
• Decryption Queries: Same as in Game G2.1.
Challenge: A2 chooses M0, M1 ⊂ M randomly and sends them to S . Then, S takes
b ∈ {0, 1}, W∗ ∈ {0, 1}l+l1 , and r1, r2 ∈ {0, 1}l1 . Then, it outputs CT∗ as follows:
C∗1 = hs1r1
ID1
C∗2 = Mr2
b H2(U
r1
1 )
C∗3 = gr1
C∗4 = gsr2
C∗5 = hsr1
ID1
C∗6 = W∗
C∗7 = H5(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ hs
ID1
).
C∗8 = H4(C∗1 ‖ C∗2 ‖ C∗3 ‖ C∗4 ‖ C∗5 ‖ C∗6 ‖ C∗7 ‖ Mb ‖ r1)
where U1 = e(hs
ID1
, gs1s2). It outputs the ciphertext CT∗ = (C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C∗6 , C∗7 , C∗8 ),
and adds (e(hID2 , gs)r1), W∗ ⊕ (Mb ‖ r1)) into H3.
Finally, it sends CT∗ to A2 as the challenge ciphertext.
Phase 2: A2 performs the same queries as in Phase 1, where the constraint is that CT∗
does not appear in the decryption queries, and if A2 asks for the decryption of CT∗ =
(C∗1 , C∗2 , C∗3 , C∗4 , C∗5 , C
′
6, C∗7 , C∗8 ), where C
′
6 6= C∗6 , S outputs⊥.
Guess: A2 outputs b∗ ∈ {0, 1}.
Entropy 2022, 24, 309 19 of 21
5. Performance Comparison
In this section, a performance comparison between the presented T-GIBEwET scheme
and other related schemes is discussed. As illustrated in Table 2, our proposal supports
the traceability function and others do not. In Table 3, the comparison of efficiency with
PKEwET variants is shown. The second to sixth columns reveal the computational efficiency
for the algorithms of encryption, decryption, authorization, testing, and tracing. Compared
to [7,16,17,35], the proposed T-GIBEwET scheme is more efficient than [7,16,17] in the
decryption algorithm and more efficient than [17] in the authorization algorithm. Both
authorization and tracking are supported in this paper.
Table 2. Comparison with other schemes.
Scheme Authorized Ciphertext Test Traceable
[7] -
√
-
[16]
√ √
-
[17]
√ √
-
[35]
√ √
-
T-GIBEwET
√ √ √
Table 3. Comparison of efficiency with other schemes.
Scheme CEnc CDec CAuth CTest CTrac
[7] 3E 3E - 2P -
[16] 5E+2P 2E+2P 0 4P -
[17] (n+2)E+2P (n+1)P+E nE nP -
[35] 5E 2E 0 2E+2P -
[34] 4E 2E 0 2E -
T-GIBEwET 7E+2P E+P 0 2E+4P 2P
E and P are the exponentiation operation and the the pairing operation, respectively, in group G.
6. Conclusions
In this paper we analyzed the PKEwET scheme, pointed out that the PKEwET algo-
rithm is unable to keep track of ciphertexts in the cloud sever, and proposed the a traceable
group ID-based encryption with an equality test scheme (T-GIBEwET). The T-GIBEwET
algorithm is endowed with a special function: the users who are authorized by a trapdoor
can test the ciphertexts in the cloud sever. Moreover, the proposed scheme supports the
traceability function.
To simplify the public key management mechanism, the proposed scheme was de-
signed with ID-based encryption. According to the competence of different users, the
proposal can resist OW-CCA and IND-CCA security. Additionally, the T-GIBEwET scheme
can resist a plaintext space attack.
Compared with other existing works, our proposal is more practical for use in cloud
computing services.
Author Contributions: H.Z. provided the method. Q.X. verified the correctness of the method. H.Z.
and D.X. wrote the first draft of the manuscript. H.Z. and D.X. provided the funding acquisition
and T.L. provided the experiments. All authors contributed equally to this work and approved the
submission. All authors have read and agreed to the published version of the manuscript.
Funding: This work was supported by the National Natural Science Foundation of China (no.
61801004), the National Natural Science Foundation of China (NSFC) (no. 61972050), the Projects of
Henan Provincial Department of Science and Technology (no.212102310297), the Shandong Provin-
cial Key Research and Development Program of China (2018CXGC0701), the Open Foundation of
State Key Laboratory of Networking and Switching Technology (Beijing University of Posts and
Telecommunications) (SKLNST-2019-2-17).
Institutional Review Board Statement: Not applicable.
Entropy 2022, 24, 309 20 of 21
Informed Consent Statement: Not applicable.
Data Availability Statement: Not applicable.
Conflicts of Interest: The authors declare no conflict of interest.
Abbreviations
The following abbreviations are used in this manuscript:
IoT Internet of Things
SE Searchable Encryption
IBEwET ID-Based Encryption with Equality Test
GIBE Group ID-Based Encryption
T-GIBEwET Traceable GIBE with Equality Test Scheme
References
1. Boneh, D.; Crescenzo, G.D.; Ostrovsky, R.; Persiano, G. Public key encryption with keyword search. In Proceedings of the
International Conference on the Theory and Applications of Cryptographic Techniques, Interlaken, Switzerland, 13–17 April
2004; pp. 506–522.
2. Curtmola, R.; Garay, J.A.; Kamara, S.; Ostrovsky, R. Searchable symmetric encryption: Improved definitions and efficient
constructions. J. Comput. Secur. 2011, 19, 895–934. [CrossRef]
3. Wang, C.; Cao, N.; Li, J.; Ren, K.; Lou, W. Secure ranked keyword search over encrypted cloud data. In Proceedings of the 2010
IEEE 30th International Conference on Distributed Computing Systems, Genova, Italy, 21–25 June 2010.
4. Benaloh, J.; Chase, M.; Horvitz, E. Patient controlled encryption: Ensuring privacy of electronic medical records. In Proceedings
of the 2009 ACM Workshop on Cloud Computing Security, Chicago, CA, USA, 9–13 November 2009; pp. 103–114.
5. Ma, M.; He, D.; Kumar, N. Certificateless Searchable Public Key Encryption Scheme for Industrial Internet of Things. IEEE Trans.
Ind. Inform. 2018, 14, 759–767. [CrossRef]
6. Wang, Y.; Sun, S.F.; Wang, J. Achieving Searchable Encryption Scheme with Search Pattern Hidden. IEEE Trans. Serv. Comput.
2020. [CrossRef]
7. Yang, G.; Tan, C.H.; Huang, Q. Probabilistic public key encryption with equality test. In Proceedings of the Cryptographers Track
at the RSA Conference, San Francisco, CA, USA, 1–5 March 2010; Springer: Berlin, Germany, 2010; pp. 119–131.
8. Tang, Q. Towards public key encryption scheme supporting equality test with fine-grained authorization. In Proceedings
of the Australasian Conference on Information Security and Privacy, Melbourne, VIC, Australia, 11–13 July 2011; Springer:
Berlin/Heidelberg, Germany, 2011; pp. 389–406.
9. Tang, Q. Public key encryption schemes supporting equality test with authorisation of different granularity. Int. J. Appl. Cryptogr.
2012, 2, 304–321. [CrossRef]
10. Tang, Q. Public key encryption supporting plaintext equality test and user-specified authorization. Secur. Commun. Netw. 2012, 5,
1351–1362. [CrossRef]
11. Huang, K.; Tso, R.; Chen, Y. A New Public Key Encryption with Equality Test. In Proceedings of the International Conference on
Network and System Security, New York, NY, USA, 3–5 November 2015; pp. 550–557.
12. Huang, K.; Tso, R.; Chen, Y. PKE-AET: Public Key Encryption with Authorized Equality Test. Br. Comput. Soc. 2015, 2686–2697.
[CrossRef]
13. Huang, K.; Yu-Chi, C. Semantic Secure Public Key Encryption with Filtered Equality Test. In Proceedings of the 2015 12th
International Joint Conference on e-Business and Telecommunications (ICETE), Alsace, France, 20–22 July 2015; pp. 327–334.
14. Ma, S.; Zhang, M.; Huang, Q.; Yang, B. Public key encryption with delegated equality test in a multi-user setting. Comput. J. 2015,
58, 986–1002. [CrossRef]
15. Huang, S.M.Q.; Zhang, M.; Yang, B. Efficient Public Key Encryption With Equality Test Supporting Flexible Authorization. IEEE
Trans. Inf. Forensics Secur. 2015, 10, 458–470.
16. Ma, S. Identity-based encryption with outsourced equality test in cloud computing. Inform. Sci. 2016, 328, 389–402. [CrossRef]
17. Yang, M.; Wang, E. Identity-Based Encryption with Filtered Equality Test for Smart City Applications. Sensors 2019, 19, 3046.
18. Wang, Y.; Pang, H.; Deng, R. Securing messaging services through efficient signcryption with designated equality test. Inf. Sci.
2019, 490, 146–165. [CrossRef]
19. Duong, D.H.; Fukushima, K.; Kiyomoto, S.; Roy, P.S.; Susilo, W. Lattice-based public key encryption with equality test in standard
model, revisited. arXiv 2020, arXiv:2005.03178.
20. Lee, T.; San, L.; Seo, J.H.; Huaxiong, W. Semi-generic construction of public key encryption and identity-based encryption with
equality test. Inf. Sci. 2016, 373, 419–440. [CrossRef]
21. Lee, H.T.; Ling, S.; Seo, J.H.; Wang, H.; Youn, T.Y. Public Key Encryption with Equality Test in the Standard Model. Inf. Sci. 2020,
516, 89–108. [CrossRef]
22. Huang, K.; Tso, R.; Chen, Y.C. Somewhat semantic secure public key encryption with filtered-equality-test in the standard model
and its extension to searchable encryption. J. Comput. Syst. Sci. 2017, 89, 400–409. [CrossRef]
http://doi.org/10.3233/JCS-2011-0426
http://dx.doi.org/10.1109/TII.2017.2703922
http://dx.doi.org/10.1109/TSC.2020.2973139
http://dx.doi.org/10.1504/IJACT.2012.048079
http://dx.doi.org/10.1002/sec.418
http://dx.doi.org/10.1093/comjnl/bxv025
http://dx.doi.org/10.1093/comjnl/bxu026
http://dx.doi.org/10.1016/j.ins.2015.08.053
http://dx.doi.org/10.1016/j.ins.2019.03.039
http://dx.doi.org/10.1016/j.ins.2016.09.013
http://dx.doi.org/10.1016/j.ins.2019.12.023
http://dx.doi.org/10.1016/j.jcss.2017.06.001
Entropy 2022, 24, 309 21 of 21
23. Wang, Y.; Pang, H.; Tran, N.H. CCA Secure encryption supporting authorized equality test on ciphertexts in standard model and
its applications. Inf. Sci. 2017, 414, 289–305. [CrossRef]
24. Zhang, K.; Chen, J.; Lee, H. Efficient Public Key Encryption with Equality Test in The Standard Model. Theor. Comput. Sci. 2019,
755, 65–80. [CrossRef]
25. Elhabob, R.; Zhao, Y.; Sella, I.; Xiong, H. Public Key Encryption with Equality Test for Heterogeneous Systems in Cloud
Computing. KSII Trans. Internet Inf. Syst. 2019, 13, 4742–4770.
26. Lin, X.J.; Qu, H.; Zhang, X. Public Key Encryption Supporting Equality Test and Flexible Authorization without Bilinear Pairings.
Comput. Commun. 2021, 170, 190–199. [CrossRef]
27. Zhu, H.; Wang, L.; Ahmad, H.; Niu, X. Pairing-free equality test over short ciphertexts. Int. J. Distrib. Sens. Netw. 2017, 13,
1550147717715605. [CrossRef]
28. Wu, L.; Zhang, Y.; Choo, K. Efficient and secure identity-based encryption scheme with equality test in cloud computing. Future
Gener. Comput. Syst. 2017, 73, 22–31 [CrossRef]
29. Wu, L.; Zhang, Y.; Choo, K. Efficient Identity-Based Encryption Scheme with Equality Test in Smart City. IEEE Trans. Sustain.
Comput. 2018, 3, 44–55. [CrossRef]
30. Qu, H.; Zhen, Y.; Lin, X. Certificateless Public Key Encryption with Equality Test. Inf. Sci. 2018, 462, 76–92. [CrossRef]
31. Elhabob, R.; Zhao, Y.; Hassan, A.; Xiong, H. PKE-ET-HS: Public Key Encryption with Equality Test for Heterogeneous Systems in
IoT. Wirel. Pers. Commun. 2020, 113, 313–335. [CrossRef]
32. Elhabob, R.; Zhao, Y.; Sella, I.; Xiong, H. An efficient certificateless public key cryptography with authorized equality test in IIoT.
J. Ambient. Intell. Humaniz. Comput. 2020, 11, 1065–1083. [CrossRef]
33. Wu, L.; Zhang, Y.; Choo, K.R.; He, D. Pairing-Free Identity-Based Encryption with Authorized Equality Test in Online Social
Networks. Int. J. Found. Comput. Sci. 2019, 30, 647–664. [CrossRef]
34. Lee, H.T.; Ling, S.; Seo, J.H.; Wang, H. Public Key Encryption with Equality Test from Generic Assumptions in the Random Oracle
Model. Inf. Sci. 2019, 500, 15–33. [CrossRef]
35. Ling, Y.; Ma, S.; Huang, Q. Group Public Key Encryption with Equality Test Against Offline Message Recovery Attack. Inf. Sci.
2020, 510, 16–32. [CrossRef]
36. Zhu, H.; Wang, L.; Ahmad, H. Key-policy attribute-based encryption with equality test in cloud computing. IEEE Access 2017, 5,
20428–20439. [CrossRef]
37. Wang, Q.; Peng, L.; Hu, X. Ciphertext-Policy Attribute-Based Encryption With Delegated Equality Test in Cloud Computing.
IEEE Access 2018, 6, 760–771. [CrossRef]
38. Eltayieb, N.; Elhabob, R.; Hassan, A. Fine-grained attribute-based encryption scheme supporting equality test. In Proceedings of
the International Conference on Algorithms and Architectures for Parallel Processing, Guangzhou, China, 15–17 November 2018;
Springer: Berlin, Germany, 2018; pp. 220–233.
39. Sun, J.; Bao, Y.; Nie, X. Attribute-hiding predicate encryption with equality test in cloud computing. IEEE Access 2018, 6,
31621–31629. [CrossRef]
40. Cui, Y.; Huang, Q.H.Q.J. Ciphertext-policy attribute-based encrypted data equality test and classification. Comput. J. 2019, 62,
1166–1177. [CrossRef]
41. Lin, X.J.; Wang, Q.; Sun, L. Identity-based encryption with equality test and datestamp-based authorization mechanism. Theor.
Comput. Sci. 2021, 117–132. [CrossRef]
42. Luo, X.; Ren, Y.; Liu, J. Identity-based group encryption. In Proceedings of the Australasian Conference on Information Security
and Privacy, Melbourne, Australia, 4–6 July 2016; Springer: Berlin, Germany, 2016; pp. 87–102.
http://dx.doi.org/10.1016/j.ins.2017.06.008
http://dx.doi.org/10.1016/j.tcs.2018.06.048
http://dx.doi.org/10.1016/j.comcom.2021.02.006
http://dx.doi.org/10.1177/1550147717715605
http://dx.doi.org/10.1016/j.future.2017.03.007
http://dx.doi.org/10.1109/TSUSC.2017.2734110
http://dx.doi.org/10.1016/j.ins.2018.06.025
http://dx.doi.org/10.1007/s11277-020-07190-9
http://dx.doi.org/10.1007/s12652-019-01365-4
http://dx.doi.org/10.1142/S0129054119400185
http://dx.doi.org/10.1016/j.ins.2019.05.026
http://dx.doi.org/10.1016/j.ins.2019.09.025
http://dx.doi.org/10.1109/ACCESS.2017.2756070
http://dx.doi.org/10.1109/ACCESS.2017.2775741
http://dx.doi.org/10.1109/ACCESS.2018.2843565
http://dx.doi.org/10.1093/comjnl/bxz036
http://dx.doi.org/10.1016/j.tcs.2021.02.015
	Introduction
	Related Work
	Contributions
	Outline of This Paper
	Preliminaries
	Decisional Bilinear Diffie–Hellman Assumption
	Definition of PKEwET
	Group ID-Based Encryption
	System Models
	Security Models
	Symbols
	Our Constructions
	 Security Analysis
	Performance Comparison
	Conclusions
	References