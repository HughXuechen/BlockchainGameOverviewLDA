Secure and Efficient Multi-Signature Schemes for Fabric: An Enterprise Blockchain Platform
1782 IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY, VOL. 16, 2021
Secure and Efficient Multi-Signature Schemes for
Fabric: An Enterprise Blockchain Platform
Yue Xiao, Peng Zhang, and Yuhong Liu , Senior Member, IEEE
Abstract— Digital signature is a major component of transac-
tions on Blockchain platforms, especially in enterprise Blockchain
platforms, where multiple signatures from a set of peers need to
be produced to endorse a transaction. However, such process
is often complex and time-consuming. Multi-signature, which
can improve transaction efficiency by having a set of signers
cooperate to produce a joint signature, has attracted extensive
attentions. In this work, we propose two multi-signature schemes,
GMS and AGMS, which are proved to be more secure and
efficient than state-of-the-art multi-signature schemes. Besides,
we implement the proposed schemes in a real Enterprise
Blockchain platform, Fabric. Experiment results show that the
proposed AGMS scheme helps achieve the goal of high transac-
tion efficiency, low storage complexity, as well as high robustness
against rogue-key attacks and k-sum problem attacks.
Index Terms— Multi-signature, Blockchain, Fabric, Schnorr
signature, Gamma signature.
I. INTRODUCTION
AS AN emerging distributed ledger technology,
Blockchain [1] has shown great potential to transform
business and finance fields. Recently, several banks, such
as J.P. Morgan and Banco Santander S.A., have started
to launch Blockchain based platforms in capital markets,
which are characterized by “huge sums of money, multiple
stakeholders and lots of coordination” [2]. As transactions in
capital markets often require approvals from multiple parties,
where each party has to identify whether information matches
transaction history and follows the rules created by the
participants, the approval process is often complex and time
consuming. It is believed that Blockchain can effectively help
cut costs and smooth transactions among multiple parties [2].
It is worth mentioning that Fabric [3], an open-source
permissioned Blockchain platform for enterprise use cases, has
enabled endorsement functions to allow a set of endorsers to
approve the execution of a transaction. Cryptographic digital
signatures have been adopted to guarantee the validity of
Manuscript received February 24, 2020; revised July 3, 2020 and
September 9, 2020; accepted November 6, 2020. Date of publication
December 2, 2020; date of current version December 30, 2020. This work
was supported in part by the National Natural Science Foundation of
China under Grant 61702342 and Grant 61872243. The associate editor
coordinating the review of this manuscript and approving it for publication
was Prof. Nele Mentens. (Corresponding author: Peng Zhang.)
Yue Xiao and Peng Zhang are with the College of Electronics and Infor-
mation Engineering, Shenzhen University, Shenzhen 518060, China (e-mail:
xiaoyue2017@email.szu.edu.cn; zhangp@szu.edu.cn).
Yuhong Liu is with the Department of Computer Engineering, Santa Clara
University, Santa Clara, CA 95053 USA (e-mail: yhliu@scu.edu).
Digital Object Identifier 10.1109/TIFS.2020.3042070
endorsements from all endorsers before a transaction can be
added to the Blockchain ledger.
However, the endorsement process based on cryptographic
digital signatures is often resource consuming, inefficient,
and lack of scalability. In particular, to avoid inconsistency
in transaction states, a signature needs to be collected from
each endorser according to the endorsement policy. The
verification of these signatures consumes large amounts of
computational resources. After verification, these signatures,
which can occupy a significant amount of storage space in a
transaction, will be stored in a block and broadcast over the
entire Blockchain network. Due to the large computation and
communication overhead, the overall throughput of Fabric is
about 100 to 2000 tps, which is very low and easily leads to
network transmission delay.
A promising approach to improve the throughput is multi-
signature [4], which allows a group of users to sign on a single
message, and produces a joint signature that stands for all
signers’ agreement on the message. Generally, a joint signature
has the same length as a single signature, and only needs to be
verified once with the public keys of signers that participate.
Therefore, compared to digital signature, multi-signature has
many advantages such as lower bandwidth, less storage space,
and faster verification. Multi-signature has been applied in
many fields, including distributed certificate authorities [5],
directory authorities [6], and timestamping services [7].
There are three major categories of multi-signature schemes,
as RSA-based, BLS-based, and Schnorr-based multi-signature
schemes. Compared to the other two types of schemes,
the Schnorr-based multi-signature schemes can well balance
the trade off between computational complexity and required
storage space, and therefore attract extensive research atten-
tions recently. For example, based on Schnorr signature [8],
BN multi-signature scheme [9] is designed by adding one more
round in signing algorithm. BCJ multi-signature scheme [10]
is presented to eliminate the adding round by homomorphic
trapdoor commitments. Gregory et al. design Musig multi-
signature scheme [11] to improve BN scheme. One of the most
popular multi-signature schemes is CoSi [7], which introduces
a spanning tree structure to make it easily scale to thousands
of signers. However, CoSi can be easily forged by rogue-
key attacks and k-sum problem attacks [12]. Also, the leader
with excessive power in CoSi may replace the message m to
produce another challenge c�.
In this work, we aim to fill the research gap by propos-
ing secure and efficient multi-signature schemes, which can
1556-6021 © 2020 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
https://orcid.org/0000-0002-3717-427X
XIAO et al.: SECURE AND EFFICIENT MULTI-SIGNATURE SCHEMES FOR FABRIC: AN ENTERPRISE BLOCKCHAIN PLATFORM 1783
decrease the storage of each transaction, improve the trans-
mission rate of block, and shorten the verification and update
time of each node. Our major contributions are described as
follows.
• Based on Gamma signature [13], we propose a secure
multi-signature scheme named GMS (Gamma Multi-
Signature) using proof of possession, which is robust
against rogue-key attacks and k-sum problem attacks.
It also addresses the problem of excessive power of
the leader in CoSi. In addition, the proposed GMS has
achieved strong provable security.
• To further improve the online performance of GMS,
we propose the Advanced Gamma Multi-Signature
(AGMS), a more efficient multi-signature scheme. In par-
ticular, we propose to change the running order of
phases in the signing algorithm to reduce calculation
steps after message arrivals. In addition, by enabling
the key aggregation algorithm to run together with the
signing algorithm, the distributed execution of the key
aggregation algorithm is allowed, which further reduces
the overall execution time.
• Based on the proposed AGMS scheme, we improve the
transaction process in Fabric, for which we deploy the
multi-signature in and aggregate multiple signatures from
endorsers to a joint signature, so as to reduce the size of
the transaction and improve the efficiency of endorsement
and ledger update. The implementation results also show
that our designed transaction process can successfully
improve the efficiency and throughput of Fabric.
The rest of this paper is organized as follows. Related
works are summarized in Section II, followed by preliminaries
in Section III. In Section IV, we discuss the two proposed
multi-signature schemes GMS and AGMS. The corresponding
security analysis and performance analysis are presented in
Section V and VI respectively. Finally, the application to
Fabric is described in Section VII and Section VIII provides
the conclusion.
II. RELATED WORK
According to the difficulty assumptions and basic signa-
ture algorithms, multi-signature schemes can be divided into
RSA-based, BLS-based, Schnorr-based, etc. The details are
described as follows.
A. Multi-Signature Schemes Derived From RSA Signatures
As the implementation of RSA is particularly efficient,
there are some multi-signature schemes proposed under RSA
assumption. Harn et al. [14] propose a multi-signature scheme
based on RSA for the first time, for which the time to generate
and verify multiple signatures depends on the number of
signers. Bellare and Neven [15] propose an identity-based
multi-signature scheme which relies on the RSA assumption
in the random oracle model. The scheme has fast multi-
signature generation and verification, but it takes three rounds
of interactions. Based on [15], Bagherzandi et al. [16] pro-
pose an improved identity-based multi-signature scheme and
aggregation signature scheme under RSA assumptions. The
number of interactive rounds of the scheme is reduced from
three to two. Tsai et al. [17] propose an identity-based
sequential aggregation signature scheme which can be seen as
a generalization of multi-signature, where each signer signs a
different message, and signatures are aggregated in sequence.
Hohenberger et al. [18] construct a synchronized aggregation
signature from RSA, which can be used in Blockchain so that
the creation of a new block can be seen as a synchronization
event. Yu et al. [19] propose the use of multi-signature and
Blockchain to ensure security and privacy of the transmitted
data in the Internet of Things (IoT) scenario. Compared to the
schemes derived from Schnorr signature, length of signatures
in these RSA based schemes is significantly longer for a
similar level of security.
B. Multi-Signature Schemes Derived From BLS Signatures
BLS signature [20] is proposed based on bilinear paring,
where the signature length is just 224-bit compared to the
2048-bit signature in RSA. Based on efficient bilinear parings
and elegant BLS signatures, various multi-signature schemes
[21]–[24] are proposed. Particularly, Ambrosin et al. [23]
propose a novel optimistic aggregation signature scheme called
OAS to design secure collective attestation for Internet of
Things. Boneh et al. [24] also propose a BLS multi-signatures
with public-key aggregation in order to reduce the size of
Bitcoin Blockchain. Compared to the schemes derived from
Schnorr signature, these bilinear pairing based schemes can
further reduce the key and signature sizes. However, as the
bilinear pairing operation is one of the most complex opera-
tions in modern cryptography [25], they also introduce high
computational overhead.
C. Multi-Signature Schemes Derived From Schnorr
Signatures
When one uses a 2048-bit modulus, the corresponding
signature lengths for RSA, BLS, and Schnorr based schemes
are 2048 bits, 224 bits, and 448 bits, respectively. Although
the advantage of BLS signature length is obvious, the high
computational cost can not be ignored. Considering both com-
putation and storage, Schnorr signature [8], one of the best-
known signature algorithms, is a good choice. Many multi-
signature schemes are proposed based on Schnorr signature.
Bellare and Neven [9] have designed BN scheme by adding
one more round in the signing algorithm, where all signers
involved need to exchange their own commitments. It is proved
secure in the plain public-key model. Then, Bagherzandi et al.
[10] propose BCJ scheme to eliminate the adding round by
using homomorphic trapdoor commitments. Gregory et al.
[11] design Musig scheme to improve BN scheme in two
aspects: holding the same key and signature size with Schnorr
signature, and allowing key aggregation. Furthermore, Musig
scheme is also applied to Bitcoin network to support key
aggregation without revealing the individual signer’s public
key.
One of the most popular Schnorr based multi-signature
schemes is CoSi [7], which requires each node to sign the
same message m by communicating and computing bottom-up
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
1784 IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY, VOL. 16, 2021
in a spanning tree structure. The introduction of the spanning
tree structure makes it easy for CoSi to scale up to thousands
of signers. Because of its great scalability, CoSi has served
as a basis for many multi-signature schemes proposed in
later research works [26]–[29]. However, Drijvers et al. [12]
point out that CoSi can be easily forged by rogue-key attacks
and k-sum problem attacks. The leader in CoSi can also
forge a joint signature on another message m� without any
other information. Therefore, mBCJ, a new multi-signature
scheme modified from CoSi, is proposed to defend against
these attacks. Nevertheless, the computation of mBCJ is more
complicated and time-consuming. As a summary, although the
security of CoSi is challenged, it is efficient and scalable.
Although proof of possession can be introduced to improve the
security, it will potentially increase the overall computational
costs.
Therefore, considering both security and efficiency, we turn
to consider other digital signature schemes. Gamma signature
[13], proposed by Yao et al. in 2013, is modified from Schnorr
signature. Different from Schnorr signature, Gamma signature
can be implemented in two corresponding phases: the offline
phase, which pre-computes some partial values without any
information of the message m to be signed, and the online
phase, which produces the final signature after the message
m arrives. Compared to Schnorr signature, Gamma signature
performs better in several aspects: (1) online performance;
(2) flexible and easy deployment in interactive protocols; and
(3) great unforgeability against concurrent interactive attacks.
To our best knowledge, this work is the first multi-signature
scheme based on Gamma signature. Experiment results verify
that better online performance can be achieved when com-
pared to the above mentioned Schnorr-based multi-signature
schemes.
III. PRELIMINARIES
A. Target One-Way Hash Function
Definition 1 (Target One-Way Hash Function [13]): A hash
function H : {0, 1}∗ → ε ⊆ {0, 1}l0 is defined as a (t f , ε f )
target one-way hash function w.r.t. an e-condition Re and a
set D ⊆ {0, 1}l0 , if for any probabilistic poly-time adversary
A, there exists a relationship that
Advtow
H (A)
= Pr
[
Re(d, e, d �, e�) = 0
∣∣∣∣ (m, s)← A1(H, d)
m� ← A2(H, d, m, d �, s)
]
≤ negl(l0),
where for any t-time algorithm A = {A1, A2}, we assume that
e = H (m), e� = H (m�), d, d � ← D, and s is defined as some
state information passed from A1 to A2.
B. Rogue-Key Attack and k-Sum Problem Attack
Rogue-key attack is a very typical attack against multi-
signature schemes including CoSi and BN, allowing a cor-
rupted signer to set his/her own public key arbitrarily such
as X1 = gsk1
1 (
∏n
i=2 Xi )
−1 so that he/she can independently
forge a joint signature on the same messages m for public
keys {X1, . . . , Xn}.
To protect systems against rogue-key attacks, some
researchers choose to use a sophisticated key generation proto-
col. For example, proof of possession, proposed by Ristenpart
and Yilek [30], is a direct way to defend against this attack.
It is established based on the general key registered model,
meaning that the signer is required to provide his/her knowl-
edge of the secret key sk corresponding to the public key pk
through a non-interactive zero knowledge protocol. This proof
is able to stop the corrupted signer forging a joint signature.
It is suitable to be applied in Public Key Infrastructure (PKI),
where each node has its certificate showing the information
about its own public key pk.
In addition, as stated in [12], there exists k-sum problem
attack that belongs to a k-dimensional generalization of the
birthday problem. It can effectively compromise several multi-
signature schemes, such as CoSi [7], Musig [11]. In particular,
the k-sum problem is defined as follows.
Definition 2 (k-Sum Problem [12]): Given a group (Zq ,+),
an arbitrary l0-bit prime q , and k lists L1, · · · , Lk with
an identical size, where elements in each list are sampled
uniformly and randomly from Zq , the k-sum problem aims
to find out k values: x1 ∈ L1, · · · , xk ∈ Lk that satisfy the
equation x1 + · · · + xk ≡ 0 mod q .
We consider that an adversary can successfully launch a k-
sum problem attack if he/she can solve the k-sum problem by
using k lists with length of sL , within a total running time of
τ and certain probability that
Advk-sum
Zq
(A)
= Pr
⎡
⎣x1 + · · · + xk ≡ 0 mod q
∣∣∣∣∣∣
L1, · · · , Lk ∈ Zq
|L1| = · · · = |Lk | = sL
x1 ∈ L1, · · · , xk ∈ Lk
⎤
⎦
≥ negl(l0).
According to the above construction of k-sum problem,
the adversary working as a leader in CoSi needs to simulate
the signing algorithm (k − 1) times to produce different joint
signatures on the same message m, so that it can forge a joint
signature on a new message m� satisfying k-sum problem.
Therefore, an effective way to avoid this attack is to improve
the construction of the signing algorithm.
However, rogue-key attack and k-sum problem attack are
not handled in CoSi. Therefore, we propose to adopt proof
of possession in key generation algorithm and improve sign-
ing algorithm, so that secure multi-signature schemes can
be developed against rogue-key attacks and k-sum problem
attacks.
C. Gamma Signature
The improvements to resist attacks and guarantee security
will inevitably increase the total computational costs. Hence it
is very challenging to consider security and efficiency at the
same time. Nevertheless, if we are able to move part of the
computational overhead from online to offline, an improve-
ment on both security and online efficiency may be achieved
even if the total computational costs (i.e. including both online
and offline) are higher.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
XIAO et al.: SECURE AND EFFICIENT MULTI-SIGNATURE SCHEMES FOR FABRIC: AN ENTERPRISE BLOCKCHAIN PLATFORM 1785
Gamma signature [13] is such an online/offline signature
scheme, which has better online performance compared to
Schnorr signature. In particular, it is implemented in two
corresponding phases: the offline phase, which pre-computes
some partial values without any information of the message
m to be signed, and the online phase, which produces the
final signature after the arrival of message m. The detailed
procedure of Gamma signature is explained as follows.
Parameter Generation: We use Pg(κ) to set up a group G
of order q with generator g1, where q is defined as a prime
with κ-bit, and finally output par = (G, g1, q).
Key Generation: Kg(par) randomly selects sk ∈ [0, q−1],
computes pk = gsk
1 and finally outputs value (pk, sk).
Signing: This algorithm defines two kinds of hash functions:
H0 : {0, 1}∗ → Zq that is modelled as random oracles and H1 :
{0, 1}∗ → Zq that belongs to a target one-way hash function.
A signer runs Sign(par, sk, m) by first randomly selecting a
value v ∈ [0, q − 1] and pre-computing V = gv
1 mod q , c =
H0(V , pk), and v ∗ c. When the message m comes, the signer
can further compute e = H1(m) and s = v ∗ c− e ∗ sk mod q ,
and output σ = (c, s) as a signature on the message m.
Verification: To run Vf(par, pk, m, σ ), the verifier firstly
computes e = H1(m), V = (gs
1 ∗ pke)c−1
mod q , and then
checks whether it satisfies H0(V , pk) = c. If not, the signature
is invalid and the verifier rejects it. Else, the verifier accepts
the signature.
Due to its high online efficiency, Gamma signature is
adopted in this paper as a basis for the proposed multi-
signature schemes. To our best knowledge, this is the first
work that proposes multi-signature schemes based on Gamma
signature.
IV. PROPOSED MULTI-SIGNATURE SCHEMES
As mentioned before, CoSi is an efficient and scalable multi-
signature scheme, but it is easily forged by rogue-key attacks
and k-sum problem attacks. The leader in CoSi can also forge
a joint signature by producing the final challenge c� on another
message m�. It is of great significance to design a new multi-
signature scheme with enhanced security, high scalability, and
efficiency.
A. Gamma Multi-Signature Scheme
With the motivation of constructing a more secure, effi-
cient, and scalable multi-signature scheme, we propose a new
multi-signature scheme. In particular, we introduce proof of
possession to ensure security of the proposed scheme against
rogue-key attacks. To reduce the extra computational costs
introduced by proof of possession, we adopt Gamma signature
[13] as the basis to split the overall computation into online
and offline parts, so that the computational complexity for
the online part is improved when compared to CoSi signature
scheme and make it hard to forge by k-sum problem attacks.
Furthermore, inspired by CoSi, we also adopt the spanning tree
structure to improve the scalability of the proposed scheme.
As a summary, our design goal is to ensure security against the
rogue-key attacks and k-sum problem attacks, while achieving
high online efficiency and scalability.
Fig. 1. The signing algorithm of our GMS scheme (We suppose that signer
Si holds the key pair (pki , ski ), where pki = (yi , πi ), and parent Pi works
as a leader S0. If parent Pi is not a leader, it just works as signer Si . Finally,
the leader S0 outputs (c, S) as the joint signature.).
We firstly propose Gamma Multi-Signature (GMS) scheme.
Assume our proposed multi-signature scheme GMS consists
of six algorithms GMS = {Pg, Kg, KAg, Sign, KVf, Vf} and
adopts four hash functions: H0, H1, H2, H3 : {0, 1}∗ → Zq ,
where H0, H1 are modelled as random oracles and H2, H3
are target one-way hash functions. It works as follows.
Parameter Generation: We use Pg(κ) to set up a group G
of order q with generator g1, where q is defined as a prime
with κ-bit, and finally outputs par = (G, g1, q).
Key Generation: Kg(par) randomly picks sk ∈ [0, q − 1]
as a private key and sets y = gsk
1 as the corresponding public
key. Then, it constructs proof of possession π = (a, d) of
sk, which is to protect against rogue-key attacks, by choosing
r
$← Zq and computing a = H1(g1, gr
1), b = H2(y), and
d = r ∗ a − b ∗ sk mod q . Finally, it sets pk = (y, π) and
outputs (pk, sk). The proof of possession will be checked by
the verifier each time when a new key pair involved to sign is
found. Proof of possession is used to defend against rogue-key
attacks existing in CoSi.
Key Aggregation: Given PK as the set of all public keys,
KAg(PK) parses each public key pki involved to sign in PK
as pki = (yi , πi ), and outputs the aggregated public key as
X̃ =∏
pki∈PK yi .
Signing: We set Ci = {Cij } as the set of children of
one signer Si in the spanning tree structure, and Pi as the
parent of signer Si . Assume S0 to be the root of the tree,
so called the leader. The signer Si runs signing algorithm
Sign(par, ski , m, τ ) in a tree τ for four phases, which is
shown in Fig. 1.
Phase 1: Announcement. When the leader S0 receives a
message m, it starts to multicast the announcement m to its
children top-down in the tree structure.
Phase 2: Commitment. This process is run in a bottom-up
way by each node Si . Specifically, given a node Si , after
receiving the announcement m, Si firstly chooses a random
secret value vi and computes Vi = gvi
1 . Then, Si waits for
each immediate child j ’s partial commitment Ṽi j . When all
the partial commitments are received, Si computes Ṽi =
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
1786 IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY, VOL. 16, 2021
Vi
∏
j∈Ci
Ṽi j . After that, the result Ṽi is send to its parent
Pi unless Si is the leader (i.e. i = 0).
Phase 3: Challenge. The leader S0 waits for each immedi-
ate child’s partial commitment value Ṽ0 j and computes the
final commitment Ṽ = Ṽ0 = V0
∏
j∈C0
Ṽ0 j . So, the collective
challenge is c = H0(g1, Ṽ , X̃). The value c, as a part of the
joint signature, can be sent to the verifier in advance or stored
at the leader. After that, the leader sends the shared challenge
value c back to its children.
Phase 4: Response. When Si receives c, it can compute the
response: si = vi ∗ c − e ∗ ski , where c = H0(g1, Ṽ , X̃)
and e = H3(m), and wait for each partial response s̃i j from
its immediate children j . When all the partial responses are
received, it sets s̃i = si +∑
j∈Ci
s̃i j . After that, the result s̃i
is sent to its parent Pi unless Si is the leader (i.e. i = 0).
Finally, the leader S0 computes the final response S = s̃0 =
s0 +∑
j∈C0
s̃0 j and outputs the joint signature (c, S).
Compared to CoSi, we divide the challenge c into two
independent values c and e, so as to avoid the excessive power
of the leader to replace the message m with m� and pro-
duce another challenge c�. Through this signature algorithm,
the leader is hard to forge a joint signature (c�, S�) by k-sum
problem attacks.
Key Verification: Similar to Gamma signature, given an
input as a public key pk as well as its corresponding proof
of possession such that pk = (y, π), π = (a, d), the key
verification algorithm KVf(par, pk) checks whether it satisfies
that a = H1(g1, V ), where V = (gd
1 yb)a−1
and b = H2(y).
If not, the public key pk is invalid and must be discarded.
Verification: Given an input as a joint signature σ = (c, S)
on an announcement m as well as the aggregated public
key X̃ , Vf(par, X̃, m, σ ) computes e = H3(m) and Ṽ =
(gS
1 X̃ e)c−1
, and then checks whether the equation satisfies
c = H0(g1, Ṽ , X̃). If not, (c, S) is an invalid signature.
Otherwise, it is valid and the verifier accepts it.
B. Advanced Gamma Multi-Signature Scheme
From the signature construction of the proposed GMS, it can
be seen that the generation of a collective challenge c has
nothing to do with the announcement m. Therefore, if the
challenge c can be precomputed offline, we can change the
running order of the above four phases in the signing algorithm
to achieve better online performance. Meanwhile, we choose to
run key aggregation algorithm in Commitment and Challenge
phases, so that it can be executed distributedly. Therefore,
the signing algorithm can be modified and optimized from
GMS. We call this new scheme as Advanced Gamma Multi-
Signature (AGMS).
In AGMS, we define Commitment and Challenge phases
as pre-signing phases or offline signing, where each signer
in a spanning tree structure comes to an agreement (chal-
lenge c) before the announcement m arrives. And then,
Announcement and Response phases are defined as the formal-
signing phases or online signing, where the leader receives the
announcement m to be signed and produces the joint signature
σ = (c, S). The signing algorithm in AGMS is described as
follows.
Fig. 2. The signing algorithm of the proposed AGMS scheme (Text in red
indicates changes from Fig. 1. We suppose that signer Si holds the key pair
(pki , ski ), where pki = (yi , πi ), and parent Pi works as a leader S0. If parent
Pi is not a leader, it just works as signer Si . The key aggregation algorithm
also runs together with the signing algorithm. Finally, the leader S0 outputs
(c, S) as the joint signature.).
Signing: We also set Ci = {Cij } as the set of children of
one signer Si in the spanning tree structure, and Pi as the
parent of signer Si . Assume S0 to be the root of the tree,
so called the leader. The signer Si runs signing algorithm
Sign(par, (pki, ski ), m, τ ) in a tree τ for four phases, which
is shown in Fig. 2.
Phase 1: Commitment. This process is run in a bottom-up
way by each node Si . Specifically, given a node Si , choose
a random secret value vi and compute Vi = gvi
1 . Then, Si
waits for each immediate child j ’s partial commitment Ṽi j
and the partial aggregated public key X̃i j . When all the partial
commitments are received, Si computes Ṽi = Vi
∏
j∈Ci
Ṽi j
and X̃i = yi
∏
j∈Ci
X̃i j . After that, the result Ṽi and X̃i is
sent to its parent Pi unless Si is the leader (i.e. i = 0).
Phase 2: Challenge. The leader S0 waits for each immedi-
ate child’s partial commitment value Ṽ0 j , partial aggregated
public key X̃0 j , and computes the final commitment Ṽ =
Ṽ0 = V0
∏
j∈C0
Ṽ0 j , as well as the aggregated public key
X̃ = X̃0 = y0
∏
j∈C0
X̃0 j . So, the collective challenge is
c = H0(g1, Ṽ , X̃). The value c, as a part of the joint signature,
can be sent to the verifier in advance or stored at the leader.
After that, the leader sends the shared challenge value c back
to its children. All the signers Si store c and precompute their
own partial value vi ∗ c.
Phase 3: Announcement. When the leader S0 receives a
message m, it starts to multicast the announcement m to its
children top-down in the tree structure.
Phase 4: Response. When Si receives announcement m,
it only computes e ∗ ski and adds the previous partial value
vi∗c to attain the individual response: si = vi∗c−e∗ski , where
e = H3(m). Then, it waits for each partial response s̃i j from its
immediate child j . When all the partial responses are received,
it sets s̃i = si+∑
j∈Ci
s̃i j . After that, the result s̃i is sent to its
parent Pi unless Si is the leader (i.e. i = 0). Finally, the leader
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
XIAO et al.: SECURE AND EFFICIENT MULTI-SIGNATURE SCHEMES FOR FABRIC: AN ENTERPRISE BLOCKCHAIN PLATFORM 1787
S0 computes the final response S = s̃0 = s0 +∑
j∈C0
s̃0 j and
outputs the joint signature (c, S).
In summary, we have proposed two multi-signature schemes
GMS and AGMS in this section. GMS focuses on the security
improvement, where the verification algorithm for public key
is deployed to defeat rogue-key attacks, and the signing
algorithm is improved to resist k-sum problem attacks and
avoid the leader modifying the message to produce another
challenge. Meanwhile, the signing algorithm is split into
online and offline parts. Furthermore, AGMS focuses on the
efficiency improvement, where the running order of phases
in signing algorithm is adjusted, and the key aggregation
algorithm is executed distributedly, so as to obtain better online
performance.
V. SECURITY ANALYSIS
In this section, we analyze security of the proposed AGMS
scheme in details. In particular, security of a multi-signature
scheme should satisfy two basic requirements.
First, a multi-signature scheme should be complete. That is,
if we build up a system by Pg(κ), generate a set of public
and private key pairs (pk, sk) by Kg(par), and produce a
joint signature σ on an announcement m representing a set of
signers in a tree τ by Sign(par,SK, m, τ ), then we should
be able to use X̃ , generated from KAg(PK), to successfully
output KVf(par, pk) = 1 and Vf(par, X̃ , m, σ ) = 1. As these
two verification equations are true, the proposed scheme
AGMS satisfy the completeness requirement.
Second, a multi-signature scheme should be unforgeable.
We prove that the proposed scheme AGMS can achieve
unforgeability under current interactive attacks. The analysis
is described as follows.
Lemma 1 (General Forking Lemma [9]): Let C be
a randomized probabilistic algorithm. When given input
(x, h1, · · · , hq , ρ) with access to oracle O of size λ, where
x is generated by the input generator IG; ρ refers to C’s
random tape; h1, · · · , hq are some random chosen values
from Zq ; then C outputs a pair (J, y). Let π be the space
of all the vectors (x, h1, · · · , hq , ρ). Let acc be the prob-
ability that C can successfully output (J, y) when given
inputs (x, h1, · · · , hq , ρ), where J is a non-empty subsets of
{1, · · · , q}.
For a given x , the forking lemma algorithm FC(x) is
described as follows.
FC(x):
Pick a random tape ρ for C
h1, · · · , hq ← O
(J, y)← C(x, h1, · · · , hq , ρ)
if J = 0 then
return (0,⊥,⊥)
h�1, · · · , h�q ← O
(J �, y �)← C(x, h�1, · · · , h�q , ρ)
if J = J � and h J �= h�J �
return (1, y, y �)
else
return (0,⊥,⊥)
We let f rk be the probability that FC successfully outputs
(1, y, y �) as shown below:
f rk = Pr[b = 1 : x ← IG; (b, y, y �)← FC(x)]. (1)
So that we have:
f rk ≥ acc(
acc
q
− 1
λ
). (2)
Lemma 2: Let
∏ = (Pg, Kg, KAg, Sign, KVf, Vf) be a
multi-signature scheme. We define the security of a multi-
signature scheme as the universal unforgeability under a cho-
sen message attack against a set of honest players. We can say
CoSi is (t, qs, q f , N, ε)-secure in the random-oracle model,
if given N as the maximum number of participating signers
that the adversary needs to run at most t time, with the
probability of forgeability of at least ε, making at most qs
signature queries as well as q f random oracle queries.
As CoSi is based on Schnorr signature, we follow the
random oracle model. In CoSi, we only assume H0(Ṽ , m)
are modeled as random oracles, which is only t f , εcr -collision
resistant, so that we may prove CoSi secure in the random
oracle under the discrete algorithm assumption. Differently,
as for AGMS, we follow the so-called general key registered
model [31], where the validity of each public key must be
checked by the signature verifier. In the proposed scheme
AGMS, we only assume H0(g1, Ṽ , X̃) : {0, 1}∗ → {0, 1}κ
and H1(g1, u∗) : {0, 1}∗ → {0, 1}κ are modeled as random
oracles, and define the other two hash functions H2(y∗) :
{0, 1}∗ → {0, 1}κ and H3(m) : {0, 1}∗ → {0, 1}κ as target
one-way hash functions, which are (t f , εcr )-collision resistant
and (t f , εtow)-target one-way, to mitigate the dependency of
provable security on random oracles.
Theorem 1: Suppose that AGMS is (t �, qs, q f , N, ε�)-secure
under the discrete logarithm problem, there exists an algo-
rithm C that if we take uniformly random group elements
X∗, two uniformly random chosen κ-bit strings H0, H1 for
a total of (qs + q f ) times and two target one-way κ-bit
strings H2, H3 as inputs, then, C can successfully output a
tuple (i0, i3,PK, S, i1, i2), satisfying X̃ = ∏
pki∈PK pki and
H0(g1, (gS
1 X̃ i3 )i−1
0 , X̃) = i0. Here, i0 ∈ (H01, · · · , H0 q),
i1 ∈ (H11, · · · , H1 q ), and i2, i3 are the two target one-way
hash values involved in the corresponding set of signers’ public
keys PK. Assume that N is the maximum number of signers
that participate in AGMS. Then, the running time of algorithm
C is at most t �, and algorithm C succeeds with the probability
of ε� such that
ε� ≥ acc(
acc
qs + q f
− 1
2κ
)− εtow (3)
where
acc ≥ (1− qs(2q f +qs−1)
23κ+1 )(ε− N+1
2κ
− N(N − 1)+ 2
2
εcr ).
(4)
Proof: We construct a four-stage game for an algorithm C
around a (t, qs, q f , N, ε)-forger F . Assume that the involved
signers behave honestly. Given the random public key set
PK = (pk1, · · · , pkN ), we simulate the game in the following
steps.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
1788 IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY, VOL. 16, 2021
Setup: Algorithm C initializes par = (G, g1, q)← Pg(κ),
(pk, sk) ← Kg(par), and two empty hash query sets SH0
and SH1 , corresponding to the queries of H0 and H1 respec-
tively such that (dT 1, · · · , dT qs , dT (qs+1), · · · , dT (qs+q f )) ←
({0, 1}κ)qs+q f , (T = 0, 1). Then, we construct a “proof of
possession” of ski . C provides a random tape ρ to F , and
runs F as a signer with the public key pk1 = (y1, π1).
RO Queries: As for CoSi, there only involves one hash value
that consists of the final commitment Ṽ and a message m.
Differently, in the proposed AGMS, there are two independent
hash values to query. For each query set, under the i -th
query (1 ≤ i ≤ q f ) denoted by QT i , (T = 0, 1) from
F , C firstly checks whether the value QT i has been defined
before. If yes, C gives up the repeated value HT (QT i ) = α.
Otherwise, C defines HT (QT i ) = dT (qs+i) , stores the record
( j = qs + i, QT i , HT (QT i ) = dT (qs+i)) in the corresponding
set SHT (T = 0, 1) and then sends the values dT (qs+i) to F .
Signature Queries: With the set of public keys PK =
(pk1, · · · , pkN ) and some messages m, C firstly simulates
each self-signed information π∗ = (d∗, w∗) by randomly
selecting two values d∗, w∗ $← Zq , and then computing u∗ =
(gw∗
1 y∗b∗)d∗−1
, where b∗ = H2(y∗). On input pk∗ = (y∗, π∗)
with the random tape ρ, C makes the query H1(g1, u∗) =
d∗. When there exists H1(g1, u∗i ) that is never defined in
previous queries, C sets H1(Q1i ) = d1i and stores ( j =
i, Q1i , H1(Q1i ) = d1i) in the set SH1 . After receiving X̃ =∏
pki∈PK pki and Ṽ = ∏N
i=1 Vi from C, F simulates a
query c = H0(g1, Ṽ , X̃) that is never defined before, stores
( j = i, Q0i , H0(Q0i ) = d0i) in the set SH0 and sends c to
its children without knowing the message m. C can return
partial queries value c = H0(Q0i ) = d0i firstly. This is
hard for some schemes including CoSi to produce the partial
signature value in advance. Finally, after knowing the message
m, similar to signer Si , C waits for the response s̃i j that
comes from its children j ∈ Ci , proceeds to compute and
send s̃i = si +∑
j∈Ci
s̃i j mod q to its parent, where si =
vi ∗ c − e ∗ ski mod q . Finally, C returns (c, S) as the joint
signature.
We assume that there are several cases that may happen
and cause C to abort the execution. (1) The value Q0 j ←
(g1, Ṽ j , X̃ j ) that F can successfully guess is equal to Q0i ←
(g1, Ṽi , X̃i ) that is already defined before. (2) F successfully
attains the value Q0 j ← (g1, Ṽ j , X̃ j ) that is never defined
before by the birthday paradox. If either of the two cases
happens, we set bad ← true.
Output: Eventually, F outputs a forged multi-signature
(c�, S�) on the message m� for a multiset PK�. Without loss of
generality, we assume the following conditions. (1) All hash
queries that are involved in the verification of the forgery; and
the proof of possession in PK� are made and recorded in sets
ST (T = 0, 1). (2) There do not exist any two different values
Q2i and Q2 j in PK� such that H2(Q2i ) = H2(Q2 j ) = α. (3)
There do not exist any two different values Q3i and Q3 j such
that H3(Q3i ) = H3(Q3 j ) = α. When F ’s forgery is verified
to be true, algorithm C halts and returns (J, (c�, e�, S�,PK�)).
If not, algorithm C returns (0,⊥) and fails to forge a joint
signature.
As we defined above, HT
$← {0, 1}κ (T = 2, 3) is a
(t f , εtow)-target one-way as well as (t f , εcr )-collision resistant
hash function. Let ts denote the running time of a signing
query and tex denote the running time of extracting SK
using the generalized forking lemma FC . Based on the above
description, we can derive that: the event bad ← true happens
with the probability of Pr(bad ← true) ≤ qsq f
23κ + qs(qs−1)
23κ+1 .
Considering that the event bad ← true does not happen,
the probability that C successfully outputs a forged signature
(c� S�) satisfying the above requirements is acc ≥ (1 −
qs(2q f+qs−1)
23κ+1 )(ε− N+1
2κ − N(N−1)+2
2 εcr ). Then, as F is described
above, algorithm C is (t �, ε�)-break the hash property of one-
wayness, where the running time is at most t � = (2N+2)t f +
(2N + 2)qsts + tex + O((N + 1)q f ), and equation (3) and
equation (4) are true.
We further prove the theorem in more details by construct-
ing an algorithm C �. Suppose there is an algorithm C �, given
input group elements X∗ and a signature forger F that is the
same as described above, C � can solve the discrete logarithm
problem in G. Finally, C � successfully outputs a forgery, using
FC defined in Lemma 1. C � proceeds as follows.
We set (1, (c, e, S, N) and (1, (c�, e�, S�, N �) as two differ-
ent outputs of C � associated with the forgery such that:
gS
1 = Ṽ c X̃−e = Ṽ c ∏N
i=1 y−e
i and
gS �
1 = Ṽ �c� X̃ �−e� = Ṽ �c�
∏N �
i=1 y �−e�
i ,
where we set PK = (pk1, · · · , pkN ) and PK� =
(pk �1, · · · , pk �N �) as two sets of public keys involved in F ’s
forgery. According to the construction of C �, we should hold
Ṽ � = Ṽ , c�−1e� �= c−1e, N � = N and y �i = yi (1 ≤ i ≤ N).
Therefore, we have that:
Ṽ = gSc−1
1
N∏
i=1
yc−1e
i , (5)
and
Ṽ = gS �c�−1
1
N∏
i=1
yc�−1e�
i . (6)
Based on equations (5) and (6), it will yield:
gSc−1−S �c�−1
1 =
N∏
i=1
yc�−1e�−c−1e
i =
∏
pki∈PK
(yi )
c�−1e�−c−1e. (7)
Because
X̃ =
∏
yi∈PK
pki = g
∑
pki ∈PK ski
1 , (8)
C � can successfully attain the discrete logarithm of pk1 as
Sc−1−S �c�−1
c�−1e�−c−1e
−∑
pki∈PK\pk1
ski mod q .
That is, if c� = c and e� �= e,the forger F can successfully
extract all SK except its own sk1. Using Lemma 1, we can
compute that the probability for forger F to obtain two differ-
ent outputs, where c� �= c or e� �= e, is f rk ≥ acc( acc
q f +qs
− 1
2κ ).
Thus, the probability of C � in doing so is given as f rk ≥
acc( acc
q f +qs
− 1
2κ )− εtow, where acc satisfies equation (4). The
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
XIAO et al.: SECURE AND EFFICIENT MULTI-SIGNATURE SCHEMES FOR FABRIC: AN ENTERPRISE BLOCKCHAIN PLATFORM 1789
total running time of algorithm C � is at most that of FC plus
O(N) operations. In other words, the proposed scheme AGMS
can achieve unforgeability under current interactive attacks.
VI. PERFORMANCE ANALYSIS
A. Theoretical Analysis
In theory, we briefly compare the proposed schemes
GMS and AGMS with current most popular multi-signature
schemes, including BN [9], CoSi [7], and Musig [11].
The property comparisons of these schemes are summarized
in Table I. First, based on the prototype of Schnorr signature,
these schemes are proved to be standard existential unforge-
able under the adaptive chosen message attacks. However,
BN, CoSi, and Musig involve only one hash value that
consists of the random value and message, meaning that these
schemes do not support to precompute the partial signature
c and are possible to be forged by k-sum problem attacks.
Therefore, it is uncertain whether they can be proved secure
in concurrent interactive protocols. Differently, the proposed
GMS and AGMS are based on Gamma signature, which
involve two different independent hash values, and thus can
be secure against k-sum problem attacks. As the proposed
GMS produces the challenge c after the message m comes,
only the proposed AGMS can achieve provable security in
concurrent interactive protocols. That is to say, the leader in
AGMS can work as a representative of a group of signers
in a spanning tree structure, precompute the challenge c, and
achieve two-round interactive telecommunications with other
individuals or groups in a secure way. AGMS is also the only
scheme that can support the partial signature value c to be
public. Second, as mentioned before, CoSi is easily to be
forged by rogue-key attacks. BN and Musig added one more
round protocol to exchange their individual commitments to
other signers, which is a solution to avoid rogue-key attacks.
But this approach inevitably leads to high communication
and computation overhead. The two proposed schemes, GMS
and AGMS, use proof of possession, which is an efficient
way to avoid rogue-key attacks. Third, with the spanning tree
structure, GMS, AGMS, and CoSi can reach high scalability,
which is hard-to-reach by BN or Musig.
Furthermore, we compare the efficiencies of these multi-
signature schemes in Table II. In particular, Musig needs a very
time-consuming KAg algorithm to construct a more secure
joint signature without revealing individual signer’s public key.
In the Sign algorithm, due to the advantage that the challenge
c can be precomputed offline, the proposed AGMS performs
better in online signing than all other schemes. In the Vf
algorithm, the proposed schemes GMS and AGMS require
one more exponentiation when compared to BN and Musig.
Because of proof of possession, the two proposed schemes
GMS and AGMS also require KVf algorithm against rogue-key
attacks. The total computation of the Sign and Vf algorithms
in these two schemes is only slightly higher than that of CoSi
and Musig, but much less than that of BN. In the signature
domain and X̃ domain, the two proposed schemes require the
smallest space among these multi-signature schemes. Only the
pk domain needs more space than other schemes due to the
proof of possession. In the offline storage, we can suggest
that the signer in other schemes except AGMS to precompute
and store (vi , Vi ). But the signer in AGMS can store (vi , c),
meaning that in terms of offline storage, AGMS only needs G2,
which is much smaller than G×Zq required by other schemes.
In summary, the proposed GMS and AGMS schemes are
comparable to others in terms of efficiency, but AGMS enjoys
the greatest efficiency in online signing and the smallest space
in offline storage, which can avoid the network congestion and
is suitable to be applied in real-time communications.
B. Experimental Analysis
In this subsection, 32 physical machines that consist of
an Intel (R) Core (TM) i7-4790 processor and a RAM
with total memory of 8GB are adopted for testing purpose.
We implement the following schemes through Go1 program-
ming language. We use hash function SHA-512 [32] and SHA-
512 based target one-way hash function [13]. We run each
experiment for 20 times and show the average results. As the
experiment results have significant differences, to show every
value, y-axis in Fig. [3]–[8] and Fig. [10]–[13] has logarithmic
scale.
According to the difficulty assumptions and basic signature
algorithms, we test RSA based multi-signature [18], BLS
based multi-signature [24], and Schnorr based multi-signature,
including CoSi [7] and AGMS. As Gamma signature, the basis
of AGMS, is modified from Schnorr signature, and still based
on the discrete logarithm problem, AGMS is classified to
Schnorr based multi-signature schemes. These experiments
import two Go programming libraries: crypto2 and pbc3. For
the same security level, we define the elliptic curve is NIST P-
224, and modulus for RSA is 2048-bit. Through experiments,
we have validated that the signature lengths for RSA, BLS, and
Schnorr based schemes are 2048 bits, 224 bits, and 448 bits,
respectively, indicating that BLS based signatures will take
up the smallest storage space. However, as shown in Fig. 3,
BLS based signature scheme takes significantly longer running
time than the other two categories for both the signing and
verification processes, as the bilinear pairing operation is time-
consuming. On the other hand, although the time cost for
verification algorithm of RSA based multi-signature is low,
the total time is very close to that of Schnorr-based schemes
(e.g. CoSi, AGMS). In addition, its signature length (2048 bits)
will significantly increase the system storage overhead, and
is usually unacceptable. With a reasonable signature length
(448 bits), the experiment results validate that CoSi and AGMS
yield the shortest running time for the signing process and a
reasonable running time for the verification process. Hence,
the Schnorr based multi-signature schemes CoSi and AGMS
are beneficial for achieving the balance of computational
complexity and required storage space.
Next, the two proposed schemes and CoSi are evaluated
with a total amount of signers ranging from 128 to 16384,
and all the signing nodes are created and connected in a
1http://golang.org/, January, 2015.
2Go cryptography libraries.
3https://github.com/Nik-U/pbc, accessed December, 2018.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
1790 IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY, VOL. 16, 2021
TABLE I
PROPERTIES OF SEVERAL MULTI-SIGNATURE SCHEMES
TABLE II
EFFICIENCIES OF SEVERAL MULTI-SIGNATURE SCHEMES
tree structure. As the random depth of tree may influence the
results, we set the tree depth to 3 and choose the branching
factor according to the number of signers so as to keep it
manageable. These experiments import two Go programming
libraries: cothority4 and onet5. These schemes are based on
elliptic curve 25519, and we ignore the computation time
of key aggregation algorithm. From Fig. 4, we can find
that, the offset among the total running time of signing and
verification algorithms for these schemes is very close when
the number of signers is up to 16384. The results confirm
that the proposed schemes can easily scale up to thousands of
signers as well.
Then, we test the running time of online signing phase
and offline signing phase in the proposed AGMS. In the
proposed AGMS, the online signing phase consists of the
Announcement and Response phases, and the offline signing
phase consists of the Commitment and Challenge phases.
All the configurations remain the same as those in the first
experiment. From the first experiment, we see that the total
running time of signing algorithm of AGMS is very close
to that of CoSi. As the offline signing phase needs a large
amount of elliptic curve exponentiations, it accounts for the
vast majority of the total running time of signing algorithm
in AGMS. Therefore, the online signing part of the proposed
AGMS scheme is very fast. When the number of signers goes
up to 16384, we can find that the online signing time of AGMS
is less than 1 second, accounting for only about 1% of total
running time of signing algorithm. Fig. 5 depicts the results.
4https://github.com/dedis/cothority, accessed February, 2018.
5https://github.com/dedis/onet, accessed February, 2018.
Fig. 3. The running time of signing and verification algorithms of typical
difficulty assumptions based multi-signature schemes (y-axis has logarithmic
scale.).
Finally, as the leader has heavier computation load in
signing algorithm than any other signers, we further test the
computation time on a leader node of CoSi and the proposed
AGMS in signing algorithm. In this experiment, we also divide
signing algorithm into two phases: the former consists of the
Announcement and Response phases, and the latter consists of
Commitment and Challenge phases. The corresponding results
are shown in Fig. 6. We clearly see that it takes much more
time for the latter phases than the former phases, since the
elliptic curve multiplication is much more complicated than
scalar multiplication. Because the Commitment and Challenge
phases can be precomputed in the proposed AGMS scheme,
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
XIAO et al.: SECURE AND EFFICIENT MULTI-SIGNATURE SCHEMES FOR FABRIC: AN ENTERPRISE BLOCKCHAIN PLATFORM 1791
Fig. 4. The total CPU running time of signing and verification algorithms for
CoSi, GMS, and AGMS. (The three algorithms achieve similar CPU running
time, showing that the additional security features of the proposed algorithms
do not sacrifice algorithm efficiency. y-axis has logarithmic scale.).
Fig. 5. The total CPU running time in different phases of signing algorithm
in AGMS (y-axis has logarithmic scale.).
Fig. 6. The CPU running time on a leader node of CoSi and AGMS in
different phases of signing algorithm (y-axis has logarithmic scale.).
while CoSi needs to run all the phases in a sequential way,
the proposed AGMS scheme runs absolutely faster than CoSi
when we only focus on the computation time on a leader node
in online signing phase. The total running time for the online
signing phase of the two schemes are compared in Fig. 7.
Fig. 7. The CPU running time on a leader node of CoSi and AGMS in
online signing phase (y-axis has logarithmic scale.).
Fig. 8. Memory consumption of CoSi and AGMS (y-axis has logarithmic
scale.).
Memory consumption is another factor to evaluate per-
formance. On the group of 32 physical machines with the
above configurations, we test the memory consumption in
signing and verification algorithms of CoSi and AGMS with
a total amount of signers ranging from 128 to 16384. From
Fig. 8, we can see that on one physical machine the memory
consumption of CoSi and AGMS is very similar. Furthermore,
as the vast majority of memory consumption is in offline
signing phase, we have rather low memory consumption in
online signing phase, which is very friendly to low-power
devices.
VII. APPLICATION TO FABRIC
Fabric [3] is a permissioned Blockchain platform, where a
CA (Certificate Authority) is introduced to manage the mem-
bers, and every node needs to make a request for membership
to CA before it joins the network. Digital signature algorithm
ECDSA (Ellipse Curve Digital Signature Algorithm) is widely
adopted in Fabric to guarantee the validity of transactions.
To avoid inconsistency in transaction states, the client needs to
collect enough number of signatures from different endorsers
satisfying the endorsement policy in Fabric. If the endorsement
policy requires a large number of endorsers, the number of
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
1792 IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY, VOL. 16, 2021
Fig. 9. The revised Fabric transaction process.
signatures would be large, and the overhead of signature
verification would be high. In this case, the current mechanism
of Fabric will lead to significant drops of the transaction
efficiency.
Therefore, we try to introduce the proposed AGMS scheme
into Fabric to optimize the current transaction process. In this
paper, we implement the proposed AGMS on Fabric v1.0.
In order to avoid confusion, we name original Fabric v1.0 as
the default Fabric, and Fabric with AGMS as the revised
Fabric. Compared to the default Fabric transaction process,
we adopt our multi-signature scheme AGMS to replace
ECDSA and add one synchronization step to run smoothly in
the revised Fabric transaction process. We assume the client
as Cl, the endorser as Eni , and the orderer as Or . We also
define Ci as the set of children of one endorser Eni , Pi as
the parent of the endorser Eni , and N as the number of
endorsers required by endorsement policy. As shown in Fig. 9,
the revised Fabric transaction process can be described as
follows.
Firstly, CA uses Pg(κ) to output par = (G, g1, q). And
then, each node uses Kg(par) to generate its own pub-
lic/private key pair (pk, sk). Before a node joins the Fabric
network, CA additionally uses KVf(par, pk) to verify the
validity of the node’s identity and its public key. If the result
is true, CA issues a certificate to the node so that it can
successfully join the network. Otherwise, CA rejects the node,
meaning that the node has no right to join the network of
Fabric.
Step 1 (Synchronization): All the endorsers Eni (i =
1, · · · , N) designated by endorsement policy can work as
a sub-group in a spanning tree structure τ . They can syn-
chronize the block information and implement phase 1 of
Sign(par, (pki , ski ), m, τ ). The client Cl works as the leader,
implementing phase 2 of Sign(par, (pki, ski ), m, τ ) to pro-
duce a common challenge c, which acts as a part of the joint
signature and is sent to each endorsers. The aggregated public
key X̃ is also computed in this section by KAg(PK).
Step 2 (Transaction Proposal): When the client Cl needs
to request a transaction m, it firstly implements phase 3 of
Sign(par, (pki , ski ), m, τ ), sending the transaction proposal
of m to the designated endorsers Eni (i = 1, · · · , N) in a
sub-group in a top-down way.
Step 3 (Endorsement): When the endorser Eni receives
a proposal from the client Cl, it first uses KVf(par, pk) to
check validity of the client Cl’s identity, then simulates the
transaction implementation and signs the transaction proposal
with its own private key and the previous common chal-
lenge c. Finally, the endorser Eni implements phase 4 of
Sign(par, (pki, ski ), m, τ ), computing the partial response
value si .
Step 4 (Proposal Response): Then, all the designated
endorsers Eni (i = 1, · · · , N) proceed to implement phase
4 of Sign(par, (pki, ski ), m, τ ), sending back the proposal
response bottom-up. The client Cl only needs to collect
all the proposal responses from its children endorsers j ,
which includes the simulated transaction results and the partial
response values s̃ j . When all the proposal responses are
received, the client Cl checks the transaction results and
computes S = s̃Cl = sCl +∑
j∈CCl
s̃ j . Finally, the client Cl
successfully produces a joint signature σ = (c, S) representing
the client Cl and all the designated endorsers Eni (i =
1, · · · , N). This joint signature can be easily verified by all
nodes including the client Cl itself, so as to check whether it
satisfies the endorsement policy.
Step 5 (Transaction Submission): If the joint signature is
valid, the client Cl sends the final transaction proposal and
response to an orderer Or .
Step 6 (Block Delivery): The orderer Or orders the trans-
actions from different clients into blocks and broadcasts them
on the network;
Step 7 (Ledger Updated): All the nodes on the network need
to use Vf(par, X̃ , m, σ ) to verify the block information and
update synchronously.
Some relevant experiments are shown in Fig. 10, Fig. 11,
Fig. 12 and Fig. 13 respectively. We mainly test the running
time of signing algorithm in different transaction sections on
a client node for the default Fabric and the revised Fabric.
All the configurations are the same as those in Section VI.
We assume that we can set different numbers of endorsers
without limitation and there is no delay in communication.
Fig. 11 shows that, compared to the default Fabric, the revised
Fabric transaction process runs much faster when a transaction
comes. This is because the revised transaction process runs
Step 1 shown in Fig. 10 in advance, which does not exist in the
default Fabric. This step leads to a much faster online signing.
From Fig. 12, in terms of Step 5 to Step 7, as the verification
algorithm of ECDSA is implemented one time for each
endorser, the CPU running time of the default Fabric increases
linearly with the number of endorsers. But in the revised
Fabric, the verification algorithm is only implemented once
regardless of the number of endorsers. Thus, the CPU running
time is almost constant. Therefore, we can take advantage of
this extra time to implement Step 1, and the total time of the
revised Fabric transaction process is still shorter than that of
the default Fabric. The results are shown in Fig. 13. In general,
by applying the proposed multi-signature scheme AGMS to
replace ECDSA in the default Fabric, the revised Fabric
transaction process has faster online signing and verification
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
XIAO et al.: SECURE AND EFFICIENT MULTI-SIGNATURE SCHEMES FOR FABRIC: AN ENTERPRISE BLOCKCHAIN PLATFORM 1793
Fig. 10. The CPU running time of Step 1 on a client node in the revised
Fabric transaction process (y-axis has logarithmic scale.).
Fig. 11. The CPU running time from Step 2 to Step 4 on a client
node between the default Fabric transaction process and the revised Fabric
transaction process (y-axis has logarithmic scale.).
Fig. 12. The CPU running time from Step 5 to Step 7 on a client
node between the default Fabric transaction process and the revised Fabric
transaction process (y-axis has logarithmic scale.).
performance and smaller storage space, so that we can achieve
the goal of improving the transaction efficiency and reducing
the transaction storage in a block.
Please note that although the proposed multi-signature
scheme, AGMS, is implemented on Fabric, a permission
Fig. 13. The total CPU running time on a client node between the default
Fabric transaction process and the revised Fabric transaction process (y-axis
has logarithmic scale.).
based Blockchain platform, AGMS is also useful for per-
missionless Blockchain platforms, as it’s not based on the
assumption of Trusted Authority (TA). Taking a public and
permissionless Blockchain Bitcoin as an example, there exists
Multisig address [33], which is the hash of n public keys
(pk1, pk2, . . . , pkn). To spend funds associated with this
address, one creates a transaction containing signatures from
these n public keys (pk1, pk2, . . . , pkn). Authors in [11] use
multi-signature to aggregate multiple signatures into a joint
one, so as to shrink the size of transaction data associated with
Bitcoin Multisig addresses. Compared to the permissioned
application, without a CA verifying the nodes’ identities
and permitting the entrance to Blockchain, the probability of
attacks would increase. Nevertheless, the attacks can still be
identified by the key verification and signature verification
algorithms, which is guaranteed by the security of the pro-
posed multi-signature schemes.
VIII. CONCLUSION
This paper proposes two multi-signature schemes based on
Gamma signature. Compared to CoSi, the most popular multi-
signature scheme based on Schnorr signature, the proposed
schemes achieves enhanced security, higher online efficiency
and similar scalability. We also apply the proposed AGMS to
improve the transaction process of Fabric, so that the efficiency
and throughput of Fabric are enhanced.
Undoubtedly, there are some limitations for the proposed
multi-signature schemes in real-life implementation. If there
exists tamper or forge in the multi-signature, the joint signature
cannot pass the verification algorithm. However, the nodes
in the tree need to verify the partial responses top-down
to find out the malicious signer, which would increase the
running costs. If the multiple signers are chosen in rotations,
the malicious singer continuously sending wrong responses
would be identified efficiently, leading to negligible attack
probability. In addition, the revised Fabric transaction process
is only suitable for the case where the endorsement policy is
set as “AND”, but not for “OR”, “NOT”. These limitations
will be investigated more in-depth in our future work.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
1794 IEEE TRANSACTIONS ON INFORMATION FORENSICS AND SECURITY, VOL. 16, 2021
REFERENCES
[1] S. Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System.
Accessed: 2008. [Online]. Available: https://bitcoin.org/bitcoin.pdf
[2] JP Morgan Tests Blockchain’s Capital Markets Potential.
The Wall Street Journal. Accessed: 2018. [Online]. Available:
https://blogs.wsj.com/cio/2018/05/16/jp-morgan-tests-blockchains-
capital-markets-potential/
[3] E. Androulaki et al., “Hyperledger fabric: A distributed operating system
for permissioned blockchains,” in Proc. 13th EuroSys Conf., Porto,
Portugal, Apr. 2018, p. 30.
[4] K. Itakura and K. Nakamura, “A public-key cryptosystem suitable for
digital multisignatures,” NEC J. Res. Dev., vol. 71, pp. 1–8, Oct. 1983.
[5] P. Szalachowski, S. Matsumoto, and A. Perrig, “PoliCert: Secure
and flexible TLS certificate management,” in Proc. ACM SIGSAC
Conf. Comput. Commun. Secur. (CCS), Scottsdale, AZ, USA, 2014,
pp. 406–417.
[6] E. Syta, I. Tamas, D. Visher, D. I. Wolinsky, and B. Ford, “Decen-
tralizing authorities into scalable strongest-link cothorities,” CoRR,
vol. abs/1503.08768, pp. 1–15, Jun. 2015.
[7] E. Syta et al., “Keeping authorities,” honest or bust" with decentralized
witness cosigning,” in Proc. IEEE Symp. Secur. Privacy (SP), San Jose,
CA, USA, May 2016, pp. 526–545.
[8] C. P. Schnorr, “Efficient signature generation by smart cards,” J. Cryp-
tol., vol. 4, no. 3, pp. 161–174, Jan. 1991.
[9] M. Bellare and G. Neven, “Multi-signatures in the plain public-key
model and a general forking lemma,” in Proc. 13th ACM Conf. Comput.
Commun. Secur. (CCS), Alexandria, VA, USA, 2006, pp. 390–399.
[10] A. Bagherzandi, J.-H. Cheon, and S. Jarecki, “Multisignatures secure
under the discrete logarithm assumption and a generalized forking
lemma,” in Proc. 15th ACM Conf. Comput. Commun. Secur. (CCS),
Alexandria, VI, USA, 2008, pp. 449–458.
[11] G. Maxwell, A. Poelstra, Y. Seurin, and P. Wuille, “Simple schnorr
multi-signatures with applications to bitcoin,” Des., Codes Cryptogr.,
vol. 87, no. 9, pp. 2139–2164, Sep. 2019.
[12] M. Drijvers et al., “On the security of two-round multi-signatures,”
in Proc. IEEE Symp. Secur. Privacy (SP), San Francisco, CA, USA,
May 2019, pp. 1084–1101.
[13] A. C.-C. Yao and Y. Zhao, “Online/offline signatures for low-power
devices,” IEEE Trans. Inf. Forensics Security, vol. 8, no. 2, pp. 283–294,
Feb. 2013.
[14] L. Harn and T. Kresler, “New scheme for digital multisignatures,”
Electron. Lett., vol. 25, no. 15, pp. 1002–1003, Jul. 1989.
[15] M. Bellare and G. Neven, “Identity-based multi-signatures from RSA,”
in Topics in Cryptology—CT-RSA (Lecture Notes in Computer Sci-
ence), San Francisco, CA, USA, vol. 4377. Berlin, Germany: Springer,
Feb. 2007, pp. 145–162.
[16] A. Bagherzandi and S. Jarecki, “Identity-based aggregate and multi-
signature schemes based on RSA,” in Proc. 13th Int. Conf. Pract. Public
Key Cryptogr. Public Key Cryptogr. (PKC) in Lecture Notes in Computer
Science, Paris, France, vol. 6056, May 2010, pp. 480–498.
[17] J. Tsai, N. Lo, and T. Wu, “New identity-based sequential aggregate
signature scheme from RSA,” in Proc. Int. Symp. Biometrics Secur.
Technol. (ISBAST), Chengdu, China, Jul. 2013, pp. 136–140. [Online].
Available: http://ieeexplore.ieee.org/document/6597680/
[18] S. Hohenberger and B. Waters, “Synchronized aggregate signatures from
the RSA assumption,” in Proc. 37th Annu. Int. Conf. Appl. Cryptograph.
Techn. Adv. Cryptol. (EUROCRYPT) in Lecture Notes in Computer
Science, Tel Aviv, Israel, vol. 10821, Apr./May 2018, pp. 197–229.
[19] M. Yu et al., “Internet of Things security and privacy-preserving method
through nodes differentiation, concrete cluster centers, multi-signature,
and blockchain,” Int. J. Distrib. Sensor Netw., vol. 14, no. 12, Dec. 2018,
Art. no. 155014771881584.
[20] D. Boneh, B. Lynn, and H. Shacham, “Short signatures from the Weil
pairing,” in Proc. 7th Int. Conf. Appl. Cryptol. Inf. Secur. Adv. Cryptol.
(ASIACRYPT) in Lecture Notes in Computer Science, Gold Coast, QLD,
Australia, vol. 2248, Dec. 2001, pp. 514–532.
[21] A. Boldyreva, “Threshold signatures, multisignatures and blind signa-
tures based on the gap-Diffie-Hellman-group signature scheme,” in Proc.
6th Int. Workshop Pract. Public Key Cryptogr. Public Key Cryptogr.
(PKC) in Lecture Notes in Computer Science, Miami, FL, USA,
vol. 2567, Jan. 2003, pp. 31–46.
[22] T. Ristenpart and S. Yilek, “The power of proofs-of-possession: Securing
multiparty signatures against rogue-key attacks,” in Proc. 26th Annu.
Int. Conf. Appl. Cryptograph. Techn. Adv. Cryptol. (EUROCRYPT) in
Lecture Notes in Computer Science, M. Naor, Ed. Barcelona, Spain,
vol. 4515, May 2007, pp. 228–245.
[23] M. Ambrosin, M. Conti, A. Ibrahim, G. Neven, A. Sadeghi, and
M. Schunter, “SANA: Secure and scalable aggregate network attesta-
tion,” in Proc. Conf. Comput. Commun. Secur. (ACM SIGSAC), Vienna,
Austria, E. R. Weippl, S. Katzenbeisser, C. Kruegel, A. C. Myers, and
S. Halevi, Eds., Oct. 2016, pp. 731–742.
[24] D. Boneh, M. Drijvers, and G. Neven, “Compact multi-signatures for
smaller blockchains,” in Proc. 24th Int. Conf. Appl. Cryptol. Inf. Secur.,
Adv. Cryptol. (ASIACRYPT), Brisbane, QLD, Australia, Dec. 2018,
pp. 435–464.
[25] D. He, S. Zeadally, B. Xu, and X. Huang, “An efficient identity-based
conditional privacy-preserving authentication scheme for vehicular ad
hoc networks,” IEEE Trans. Inf. Forensics Security, vol. 10, no. 12,
pp. 2681–2691, Dec. 2015.
[26] B. Alangot, M. Suresh, A. S. Raj, R. K. Pathinarupothi, and
K. Achuthan, “Reliable collective cosigning to scale blockchain with
strong consistency,” in Proc. Workshop Decentralized IoT Secur. Stan-
dards, 2018, pp. 1–6.
[27] E. Kokoris-Kogias, P. Jovanovic, N. Gailly, I. Khoffi, L. Gasser, and
B. Ford, “Enhancing bitcoin security and performance with strong con-
sistency via collective signing,” in Proc. 25th Secur. Symp. (USENIX),
Austin, TX, USA, Aug. 2016, pp. 279–296.
[28] E. Syta et al., “Scalable bias-resistant distributed randomness,” in Proc.
IEEE Symp. Secur. Privacy (SP), San Jose, CA, USA, May 2017,
pp. 444–460.
[29] X. Zhou, Q. Wu, B. Qin, X. Huang, and J. Liu, “Distributed bit-
coin account management,” in Proc. IEEE Trustcom/BigDataSE/ISPA,
Tianjin, China, Aug. 2016, pp. 105–112.
[30] T. Ristenpart and S. Yilek, “The power of proofs-of-possession: Securing
multiparty signatures against rogue-key attacks,” in Proc. 26th Annu.
Int. Conf. Appl. Cryptograph. Techn. Adv. Cryptol. (EUROCRYPT),
Barcelona, Spain, May 2007, pp. 228–245.
[31] A. Bagherzandi and S. Jarecki, “Multisignatures using proofs of secret
key possession, as secure as the Diffie-Hellman problem,” in Proc.
6th Int. Conf. Secur. Cryptogr. Netw. (SCN), Amalfi, Italy, Sep. 2008,
pp. 218–235.
[32] U. D. of Commerce, Secure Hash Standard—SHS: Federal Information
Processing Standards Publication 180-4. CreateSpace Independent Pub-
lishing Platform, Scotts Valley, CA, USA, 2012.
[33] G. Andresen. (Oct. 2011). M-of-N Standard Transactions.
Accessed: Jul. 1, 2020. [Online]. Available: https://github.com/bitcoin/
bips/blob/master/bip-0011.mediawiki
Yue Xiao received the B.S. degree in telecom-
munication engineering from Guangdong Ocean
University, China, in 2017, and the M.S. degree
in information and telecommunication engineering
from Shenzhen University, China, in 2020, where
he is currently pursuing the master’s degree with the
College of Electronics and Information Engineering.
His current research interests include cryptography
technology and security in the Blockchain.
Peng Zhang received the Ph.D. degree in signal and
information processing from Shenzhen University,
China, in 2011. She is currently an Associate Pro-
fessor with the College of Electronics and Informa-
tion Engineering, Shenzhen University. Her current
research interests include cryptography technology
and security in the Blockchain, cloud computing,
and the IoT. She has published more than 30 acad-
emic journal and conference papers.
Yuhong Liu (Senior Member, IEEE) received the
B.S. and M.S. degrees from the Beijing Univer-
sity of Posts and Telecommunications in 2004 and
2007, respectively, and the Ph.D. degree from the
University of Rhode Island in 2012. She is cur-
rently an Associate Professor with the Department
of Computer Engineering, Santa Clara University.
Her research interests include trustworthy computing
and cyber security of emerging applications, such
as online social media, the Internet of Things, and
Blockchain.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:03:28 UTC from IEEE Xplore.  Restrictions apply. 
<<
  /ASCII85EncodePages false
  /AllowTransparency false
  /AutoPositionEPSFiles true
  /AutoRotatePages /None
  /Binding /Left
  /CalGrayProfile (Black & White)
  /CalRGBProfile (sRGB IEC61966-2.1)
  /CalCMYKProfile (U.S. Web Coated \050SWOP\051 v2)
  /sRGBProfile (sRGB IEC61966-2.1)
  /CannotEmbedFontPolicy /Warning
  /CompatibilityLevel 1.4
  /CompressObjects /Tags
  /CompressPages true
  /ConvertImagesToIndexed true
  /PassThroughJPEGImages true
  /CreateJobTicket false
  /DefaultRenderingIntent /Default
  /DetectBlends true
  /DetectCurves 0.0000
  /ColorConversionStrategy /LeaveColorUnchanged
  /DoThumbnails true
  /EmbedAllFonts true
  /EmbedOpenType false
  /ParseICCProfilesInComments true
  /EmbedJobOptions true
  /DSCReportingLevel 0
  /EmitDSCWarnings false
  /EndPage -1
  /ImageMemory 524288
  /LockDistillerParams true
  /MaxSubsetPct 100
  /Optimize true
  /OPM 0
  /ParseDSCComments false
  /ParseDSCCommentsForDocInfo true
  /PreserveCopyPage true
  /PreserveDICMYKValues true
  /PreserveEPSInfo true
  /PreserveFlatness true
  /PreserveHalftoneInfo true
  /PreserveOPIComments true
  /PreserveOverprintSettings true
  /StartPage 1
  /SubsetFonts true
  /TransferFunctionInfo /Remove
  /UCRandBGInfo /Preserve
  /UsePrologue false
  /ColorSettingsFile ()
  /AlwaysEmbed [ true
    /AdobeArabic-Bold
    /AdobeArabic-BoldItalic
    /AdobeArabic-Italic
    /AdobeArabic-Regular
    /AdobeHebrew-Bold
    /AdobeHebrew-BoldItalic
    /AdobeHebrew-Italic
    /AdobeHebrew-Regular
    /AdobeHeitiStd-Regular
    /AdobeMingStd-Light
    /AdobeMyungjoStd-Medium
    /AdobePiStd
    /AdobeSansMM
    /AdobeSerifMM
    /AdobeSongStd-Light
    /AdobeThai-Bold
    /AdobeThai-BoldItalic
    /AdobeThai-Italic
    /AdobeThai-Regular
    /ArborText
    /Arial-Black
    /Arial-BoldItalicMT
    /Arial-BoldMT
    /Arial-ItalicMT
    /ArialMT
    /BellGothicStd-Black
    /BellGothicStd-Bold
    /BellGothicStd-Light
    /ComicSansMS
    /ComicSansMS-Bold
    /Courier
    /Courier-Bold
    /Courier-BoldOblique
    /CourierNewPS-BoldItalicMT
    /CourierNewPS-BoldMT
    /CourierNewPS-ItalicMT
    /CourierNewPSMT
    /Courier-Oblique
    /CourierStd
    /CourierStd-Bold
    /CourierStd-BoldOblique
    /CourierStd-Oblique
    /EstrangeloEdessa
    /EuroSig
    /FranklinGothic-Medium
    /FranklinGothic-MediumItalic
    /Gautami
    /Georgia
    /Georgia-Bold
    /Georgia-BoldItalic
    /Georgia-Italic
    /Helvetica
    /Helvetica-Bold
    /Helvetica-BoldOblique
    /Helvetica-Oblique
    /Impact
    /KozGoPr6N-Medium
    /KozGoProVI-Medium
    /KozMinPr6N-Regular
    /KozMinProVI-Regular
    /Latha
    /LetterGothicStd
    /LetterGothicStd-Bold
    /LetterGothicStd-BoldSlanted
    /LetterGothicStd-Slanted
    /LucidaConsole
    /LucidaSans-Typewriter
    /LucidaSans-TypewriterBold
    /LucidaSansUnicode
    /Mangal-Regular
    /MicrosoftSansSerif
    /MinionPro-Bold
    /MinionPro-BoldIt
    /MinionPro-It
    /MinionPro-Regular
    /MinionPro-Semibold
    /MinionPro-SemiboldIt
    /MVBoli
    /MyriadPro-Black
    /MyriadPro-BlackIt
    /MyriadPro-Bold
    /MyriadPro-BoldIt
    /MyriadPro-It
    /MyriadPro-Light
    /MyriadPro-LightIt
    /MyriadPro-Regular
    /MyriadPro-Semibold
    /MyriadPro-SemiboldIt
    /PalatinoLinotype-Bold
    /PalatinoLinotype-BoldItalic
    /PalatinoLinotype-Italic
    /PalatinoLinotype-Roman
    /Raavi
    /Shruti
    /Sylfaen
    /Symbol
    /SymbolMT
    /Tahoma
    /Tahoma-Bold
    /Times-Bold
    /Times-BoldItalic
    /Times-Italic
    /TimesNewRomanPS-BoldItalicMT
    /TimesNewRomanPS-BoldMT
    /TimesNewRomanPS-ItalicMT
    /TimesNewRomanPSMT
    /Times-Roman
    /Trebuchet-BoldItalic
    /TrebuchetMS
    /TrebuchetMS-Bold
    /TrebuchetMS-Italic
    /Tunga-Regular
    /Verdana
    /Verdana-Bold
    /Verdana-BoldItalic
    /Verdana-Italic
    /Webdings
    /Wingdings-Regular
    /ZapfDingbats
    /ZWAdobeF
  ]
  /NeverEmbed [ true
  ]
  /AntiAliasColorImages false
  /CropColorImages true
  /ColorImageMinResolution 150
  /ColorImageMinResolutionPolicy /OK
  /DownsampleColorImages true
  /ColorImageDownsampleType /Bicubic
  /ColorImageResolution 600
  /ColorImageDepth -1
  /ColorImageMinDownsampleDepth 1
  /ColorImageDownsampleThreshold 1.50000
  /EncodeColorImages true
  /ColorImageFilter /DCTEncode
  /AutoFilterColorImages true
  /ColorImageAutoFilterStrategy /JPEG
  /ColorACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /ColorImageDict <<
    /QFactor 0.15
    /HSamples [1 1 1 1] /VSamples [1 1 1 1]
  >>
  /JPEG2000ColorACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000ColorImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasGrayImages false
  /CropGrayImages true
  /GrayImageMinResolution 150
  /GrayImageMinResolutionPolicy /OK
  /DownsampleGrayImages true
  /GrayImageDownsampleType /Bicubic
  /GrayImageResolution 600
  /GrayImageDepth -1
  /GrayImageMinDownsampleDepth 2
  /GrayImageDownsampleThreshold 1.50000
  /EncodeGrayImages true
  /GrayImageFilter /DCTEncode
  /AutoFilterGrayImages true
  /GrayImageAutoFilterStrategy /JPEG
  /GrayACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /GrayImageDict <<
    /QFactor 0.15
    /HSamples [1 1 1 1] /VSamples [1 1 1 1]
  >>
  /JPEG2000GrayACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000GrayImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasMonoImages false
  /CropMonoImages true
  /MonoImageMinResolution 300
  /MonoImageMinResolutionPolicy /OK
  /DownsampleMonoImages true
  /MonoImageDownsampleType /Bicubic
  /MonoImageResolution 900
  /MonoImageDepth -1
  /MonoImageDownsampleThreshold 1.33333
  /EncodeMonoImages true
  /MonoImageFilter /CCITTFaxEncode
  /MonoImageDict <<
    /K -1
  >>
  /AllowPSXObjects false
  /CheckCompliance [
    /None
  ]
  /PDFX1aCheck false
  /PDFX3Check false
  /PDFXCompliantPDFOnly false
  /PDFXNoTrimBoxError true
  /PDFXTrimBoxToMediaBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXSetBleedBoxToMediaBox true
  /PDFXBleedBoxToTrimBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXOutputIntentProfile (None)
  /PDFXOutputConditionIdentifier ()
  /PDFXOutputCondition ()
  /PDFXRegistryName ()
  /PDFXTrapped /Unknown
  /CreateJDFFile false
  /Description <<
    /ENU ()
  >>
>> setdistillerparams
<<
  /HWResolution [600 600]
  /PageSize [612.000 792.000]
>> setpagedevice