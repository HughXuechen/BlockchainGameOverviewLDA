Sync or Fork: Node-Level Synchronization Analysis of Blockchain
Sync or Fork: Node-Level
Synchronization Analysis of Blockchain
Qin Hu1, Minghui Xu2, Shengling Wang3(B), and Shaoyong Guo4
1 Indiana University - Purdue University Indianapolis, Indianapolis, USA
qinhu@iu.edu
2 The George Washington University, Washington, D.C., USA
mhxu@gwu.edu
3 Beijing Normal University, Beijing, China
wangshengling@bnu.edu.cn
4 Beijing University of Posts and Telecommunications, Beijing, China
syguo@bupt.edu.cn
Abstract. As the cornerstone of blockchain, block synchronization
plays a vital role in maintaining the security. Without full blockchain syn-
chronization, unexpected forks will emerge and thus providing a breeding
ground for various malicious attacks. The state-of-the-art works mainly
study the relationship between the propagation time and blockchain
security at the systematic level, neglecting the fine-grained impact of
peering nodes in blockchain networks. To conduct a node-level synchro-
nization analysis, we take advantage of the large deviation theory and
game theory to study the pull-based propagation from a microscopic
perspective. We examine the blockchain synchronization in a bidirec-
tional manner via investigating the impact of full nodes as responders
and that of partial nodes as requesters. Based on that, we further reveal
the most efficient path to speed up synchronization from full nodes and
design the best synchronization request scheme based on the concept of
correlated equilibrium for partial nodes. Extensive experimental results
demonstrate the effectiveness of our analysis.
Keywords: Block synchronization · Large deviation theory · Game
theory · Correlated equilibrium
1 Introduction
Since the appearance of Bitcoin [1], cryptocurrency as the killer application of
blockchain piques substantial attention from the whole society to the underly-
ing distributed ledger technology. Research on blockchain from all walks of life
indicates its great potential and versatility. It is reported that the blockchain
market size over the globe reaches $3 billion in 2020 and is expected to surge to
$39.7 billion by 2025 [2].
As the infrastructure of blockchain systems, the peer-to-peer network con-
sisting of peering nodes supports the most important operations of informa-
tion dissemination and exchange, including both control and data messages.
c© Springer Nature Switzerland AG 2020
D. Yu et al. (Eds.): WASA 2020, LNCS 12384, pp. 170–181, 2020.
https://doi.org/10.1007/978-3-030-59016-1_15
http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-59016-1_15&domain=pdf
https://doi.org/10.1007/978-3-030-59016-1_15
Sync or Fork: Node-Level Synchronization Analysis of Blockchain 171
To maintain the consistent recognition of the main chain, the synchronization of
newly generated blocks among all nodes becomes extremely important. Other-
wise, unexpected forks will emerge, which might be exploited by malicious clients
to achieve various attacks, such as double spending and selfish mining, and can
even lead to the breakdown of a blockchain system.
To enable the synchronization of blockchain, there exist five types of block
propagation mechanisms [3], i.e., advertisement, header sending, unsolicited
push, relay network, and push-advertisement hybrid. Focusing on the behaviors
of nodes propagating block information, we can summarize them as pull-based
and push-based. In the pull-based propagation, nodes with timely information
of the blockchain, termed as full nodes, respond to the requests of updating
block information from neighboring nodes, named as partial nodes, which can
achieve block synchronization cost-efficiently in an on-demand manner. While
in the push-based one, any node receiving the newly generated block automat-
ically pushes this piece of information to neighbors, which can synchronize the
blockchain network quickly but will cause unnecessary communication among
nodes. Other works about blockchain synchronization mainly study the rela-
tionship between the propagation time and blockchain security at the system-
atic level [4–7], neglecting the fine-grained impact of peering nodes in blockchain
networks.
In this paper, we study the blockchain synchronization in pull-based propa-
gation from a microscopic perspective, using the large deviation theory and game
theory to investigate different roles of peering nodes in synchronizing block infor-
mation. This suggests the feature of node-level analysis of this work. Besides, our
research is bidirectional, which captures the feature of impacts on block synchro-
nization from two main types of nodes in the blockchain, i.e., the full node as
the responder and the partial node as the requester. Specifically, we reveal clues
about three critical questions: How will the full node’s response capability affect
the synchronization? How to efficiently reduce its negative effect on synchroniza-
tion? And how should the partial node to actively achieve the synchronization?
In summary, our contributions in this work include the following three
aspects:
– The impact of full nodes on synchronization is quantitatively characterized
by the concept of response failure rate, which straightforwardly uncovers the
synchronization probability of connected partial nodes.
– The negative impact of full nodes on synchronization can be fast eliminated
via increasing the decay speed of the response failure rate, and the derived
expression of the decay speed indicates that enlarging the response capacity
related parameter is more efficiently than improving the response rate. This
paves a clear path to facilitate synchronization from full nodes.
– The optimal synchronization scheme for the partial node is established based
on the concept of correlated equilibrium, where a Node Synchronization (NS)
problem is formulated to guarantee that the partial node can get synchronized
without unnecessary cost or redundant response from full nodes.
172 Q. Hu et al.
The remaining of this paper is organized as follows. In Sect. 2, we investigate
the most related work on blockchain synchronization. Then we introduce the
node-level synchronization model for both the full node and the partial node in
Sect. 3, where the full node’s response capability is further analyzed in Sect. 4
while the best synchronization request mechanism for the partial node is pre-
sented in Sect. 5. All theoretical analysis are evaluated in Sect. 6. And finally, we
conclude the whole paper in Sect. 7.
2 Related Work
Similar to traditional distributed systems, there are three levels of synchrony
of blockchain networks, namely synchronous, partially synchronous, and asyn-
chronous. As the representative blockchain application, Bitcoin whitepaper [1]
provides an initial analysis on its security against forks and double-spending
attacks with an oversimplified model. Since 2015, Bitcoin consensus algorithm
has been thoroughly investigated considering three levels of synchrony [8,9].
Garay et al. [8] formalize the Bitcoin consensus within a fully synchronous net-
work. Persistence and liveliness are proved to be guaranteed hinging on the
synchronous setting. Pass et al. [9] show that Bitcoin consensus satisfies consis-
tency and liveliness in a partially synchronous network, but consistency cannot
be satisfied in an asynchronous network.
As the most critical factor affecting blockchain synchronization, the prop-
agation time of control messages and data messages is investigated to reveal
how it affects blockchain security against various attacks, such as forks, double
spending, and selfish mining, and how to mitigate the corresponding vulnerabil-
ities. The propagation time is shown as the primary cause for blockchain forks
[4]. In response, researchers propose three methods to speed up propagation:
minimizing verification, pipelining block propagation, and increasing connectiv-
ity. Sompolinsky and Zohar [5] study the relation between higher transaction
rate and the vulnerability to double-spending attacks, which shows that increas-
ing block size and block generation rate can improve the throughput, but will
increase the propagation time so that even weaker attackers can launch double-
spending attacks. Besides, the selfish mining is investigated in a realistic setting
where propagation time is taken into account [6], indicating that it becomes
easier with increasing propagation delay. For PoS-based consensus, Kang et al.
[7] propose a Stackelberg game based incentive mechanism to encourage miners
to propagate blocks, enabling lower propagation delay and higher security level.
For the propagation mechanism in blockchain networks, five popular cat-
egories are summarized in [3], including advertisement, header sending, unso-
licited push, relay network, and push-advertisement hybrid. Early on, the
advertisement-based propagation is adopted by Bitcoin, which has a two-round
message exchange procedure. Afterward, Bitcoin resorts to the header propa-
gation to avoid using inv messages. In unsolicited push propagation, miners
directly broadcast newly-mined blocks. The relay network, adopted by FIBRE
[10], BloXroute [11], and Geeqchain [12], is to distribute relay nodes globally to
Sync or Fork: Node-Level Synchronization Analysis of Blockchain 173
which miners can connect to and exchange information at a high speed. However,
relay nodes are criticized for introducing centralization to blockchain. Ethereum
adopts push and advertisement hybrid propagation by which a node can auto-
matically push messages to
√
n nodes and advertises messages to neighboring
nodes simultaneously [13].
In summary, existing works about blockchain synchronization focus on
macroscopically investigating blockchain protocol to figure out the relationship
between propagation time and security or propose new propagation mechanisms.
However, in this paper, we study the blockchain synchronization from a micro-
scopic and node-level perspective, using the large deviation theory and game
theory to depict blockchain nodes precisely and investigate how nodes’ capabil-
ity affect synchronization.
3 System Model
In this paper, we assume that full nodes are homogeneous in terms of information
request and response performance. Thus, we can shed light on the synchroniza-
tion status of the whole blockchain system via studying the response capability
of any specific full node. And all partial nodes are also assumed to be similar in
terms of interacting with full nodes to get synchronized. As full nodes and par-
tial nodes play different roles in blockchain synchronization, we introduce their
models separately in the following.
3.1 Response Model of the Full Node
Considering that the requests of updating block information from partial nodes
arrive at the full node randomly, we assume that this stochastic event is a Poisson
process with arrival rate λ, which is inspired by the typical model of packet arrival
process in communication networks [14]. It usually takes some time for the full
node to respond and send out the latest block information since the node might
be busy on handling other tasks, which can also be assumed as a Poisson process
with response rate μ. To guarantee that the full node can finish responding to
the requests from partial nodes most of the time, we assume μ > λ. However,
even with this condition, there might still exist some cases where the full node
fails to respond.
To investigate this issue, we define the number of synchronization requests
arrived at the full node and that the node can respond during time period
(t − 1, t) as at and rt, respectively, where t ∈ N
∗. Then we can describe the
request queue at the full node as
Qt = (Qt−1 + at − rt)+,
where (·)+ denotes the positive part of the inside expression.
Next, we focus on the cumulative arrival and response process, denoted as
At = a1 + · · · + at and Rt = r1 + · · · + rt, respectively. Thus, the length of the
174 Q. Hu et al.
request queue until time t at the full node, defined as Lt, will be
Lt = At − Rt. (1)
Generally speaking, since μ > λ, one may expect that Lt would be negative,
making it pointless with the definition of queue length. However, due to the
randomness of the arrival and response process, the queue length can become
positive, which may even overwhelm the response capability of the full node,
leading to the failure of responding synchronization requests. To prepare for the
worst case of response failure in blockchain, we focus on the maximum possible
queue length at the full node when t → ∞, which is defined as L = supt>0 Lt,
and further investigate the possibility of the request queue being over-length,
i.e., L > Γ , where Γ is defined as follows:
Definition 1 (Response capacity). The response capacity Γ of the full node
is the longest queue of synchronization requests that it can process without any
failure.
According to Definition 1, we can know that if L ≤ Γ , the fulll node can
handle all synchronization requests successfully. But if L > Γ , the request queue
is too long for the full node to handle, which will make the partial nodes sending
block synchronization requests fail to achieve the distributed consistency. To
analyze this important event, we introduce the following definition:
Definition 2 (Response failure rate). The response failure rate is the prob-
ability that the longest synchronization request queue arrived at the full node,
i.e., L, exceeds its response capacity Γ , denoted as P (L > Γ ).
With the help of P (L > Γ ), we can capture the full node’s failure of respond-
ing to block synchronization requests in a quantitative manner, which provides us
a more straightforward clue about the synchronization status of the neighboring
partial nodes. Based on this index, we can make adjustment or countermea-
sure in time to avoid unpredictable loss brought by the asynchronous blockchain
information among partial nodes, which will be analyzed in Sect. 4.
3.2 Synchronization Model of the Partial Node
We assume that the number of partial nodes in a blockchain network is N , and
each of them has direct access to multiple full nodes to obtain block synchro-
nization information. Specifically, for any partial node, we denote the set of full
nodes it has direct connections as M = {Mi}, i ∈ {1, · · · ,m}, where m ∈ N
∗ is
the number of full nodes. And the above-defined response failure rate of these
full nodes can be denoted as Pi, i ∈ {1, · · · ,m}.
For a cautious partial node, it may send the synchronization request to all
connected full nodes so as to obtain a higher successful synchronization probabil-
ity. Thus, the synchronization failure event can only happen to this partial node
when all full nodes failed to respond with the latest block information, which
Sync or Fork: Node-Level Synchronization Analysis of Blockchain 175
means that the synchronization failure probability is
∏m
i=1 Pi. And accordingly,
the successful synchronization probability of this partial node is 1 − ∏m
i=1 Pi.
While in a more general case, a normal partial node might need to seriously
consider where to send the synchronization request. First, sending the request
costs communication resource, and thus generously sending the request to all
available full nodes can bring too much burden on the resource consumption for
the partial node. What’s more, with the assumption that all full nodes have the
same new information of the blockchain, it would be enough for the partial node
to receive at least one response and thus other redundant responses become a
waste. With this in mind, we can see that wisely sending the synchronization
request is vital for the partial node, which will be elaborated in Sect. 5.
4 Response Failure Analysis
In this section, we analyze the response failure rate P (L > Γ ) in detail. We
first focus on the derivation of its decay speed I(x), based on which two critical
factors impacting the systematic response are discussed.
We first let Γ = lx with x > 0. Then according to the Cramér’s theorem [15],
for large l, there exists P (L > Γ ) = P (L > lx) ≈ exp(−lI(x)), which indicates
that the probability of L > lx will decay exponentially with the rate I(x) when
l → ∞. In detail, we have
lim
l→∞
1
l
log P (L > lx) = −I(x), (2)
where I(x) is the rate function with the following expression
I(x) = inf
t>0
tΦ∗(
x
t
). (3)
According to the large deviation theory and the calculation process in [16], we
can have the expression of I(x) as:
I(x) = x ln
μ
λ
. (4)
As we mentioned earlier, I(x) reveals the decay speed of response failure rate
P (L > Γ ). In other words, the larger I(x), the sharper decrease of P (L > Γ ),
and thus the more successful the block synchronization for the requested partial
nodes. With this in mind, we desire to enlarge I(x) as much as possible. On one
hand, from the above expression of I(x), one can tell that it is linearly increasing
with the response capacity related parameter x when the ratio of the response
rate μ to the arrival rate λ is fixed. On the other hand, if x is given, we can
see I(x) is logarithmically correlated to μ
λ . Therefore, theoretically speaking,
increasing x is more effective to improve I(x) than increasing μ/λ, which will be
numerically analyzed in Sect. 6.
Considering that x and μ
λ are two main factors impacting the value of I(x),
we study them further in the following. As x is based on the response capacity Γ
176 Q. Hu et al.
and the arrival rate λ is a system-wide parameter which cannot be adjusted, we
mainly focus on Γ and μ since they are more controllable from the perspective of
the full node. In the following, we investigate how to set Γ and μ to meet some
specific system-performance requirements on response failure rate. To this end,
we first denote a response failure tolerance degree as ε ∈ (0, 1], which acts as the
constraint for the failure rate P (L > Γ ). And then we introduce the following
two definitions.
Definition 3 (Effective response capacity). The effective response capacity
Γ ∗(ε) is the minimum capacity that the full node needs to provide to enforce that
the response failure rate will never greater than ε, i.e.,
Γ ∗(ε) = min{Γ : P (L > Γ ) ≤ ε}.
Definition 4 (Effective response rate). The effective response rate μ∗(ε) is
the minimum response rate requirement for the full node to guarantee that the
response failure rate will never greater than ε, i.e.,
μ∗(ε) = min{μ : P (L > Γ ) ≤ ε}.
Further, we have the following theorems to present the specific results of
Γ ∗(ε) and μ∗(ε).
Theorem 1. For ε ∈ (0, 1] and μ > λ, we can calculate Γ ∗(ε) as:
Γ ∗(ε) = − ln ε
ln μ
λ
.
Proof. As we mentioned at the beginning of this section, for l → ∞, we have
P (L > Γ ) ≈ e−lI(x). Then it comes to e−lI(x) ≤ ε according to Definition 3.
Besides, based on (4) and Γ = lx, we can prove that the value of Γ ∗(ε) is − ln ε
ln μ
λ
.
Theorem 2. For ε ∈ (0, 1] and μ > λ, we can calculate μ∗(ε) as:
μ∗(ε) = λe− ln ε
Γ .
Proof. Similar to the proof of Theorem 1, due to P (L > Γ ) ≈ e−lI(x) ≤ ε, we
can have lx ln μ
λ ≥ − ln ε, which leads to the result of μ∗(ε).
5 Correlated Equilibrium Based Node Synchronization
Mechanism
As mentioned earlier, the synchronization of one certain partial node is collec-
tively completed by the surrounding full nodes, which heavily depends on how
many of them the partial node requests. In fact, each full node has a partic-
ular response capability with respect to the synchronization request, which is
well captured by the response failure tolerance degree introduced in the above
Sync or Fork: Node-Level Synchronization Analysis of Blockchain 177
section, and it takes some cost for the partial node to send the synchronization
request to a specific full node. For a reasonable and intelligent partial node, it
is essential to work out an efficient and effective strategy to select the subset
of full nodes as synchronization request targets. In other words, given different
εi (i ∈ {1, · · · ,m}) of all connected full nodes, how should the partial node make
decisions on whether to send the blockchain synchronization request to each of
them?
To solve this problem, we first define that the decision strategy of the partial
node is p = (p1, · · · , pm) with pi ∈ {0, 1}, where 0 (or 1) denotes not sending (or
sending) the synchronization request to the full node Mi. From the perspective
of the partial node, the ultimate goal of this decision is to guarantee that it can
obtain the up-to-date information of the main chain from at least one full node.
Thus, the profit of deciding whether to send the request to one specific full node
Mi is jointly affected by the decisions of sending to other full nodes, which can
be defined as
φi(p) =
pi(1 − εi)∑m
j=1 pj(1 − εi)
.
Note that in the case of p = 0, we define φi(p) = 0.
With Ci denoting the cost of sending the request to Mi, we can define the
utility of this decision as
Ui(p) = αiφi(p) − piCi, (5)
where αi > 0 is a scalar parameter.
On one hand, as a utility-driven decision maker, the partial node desires
to obtain an optimal utility for each individual decision about one specific full
node, which is collectively affected by the decision vector p about all full nodes
and can be described by the following game-theoretic concept named correlated
equilibrium.
Definition 5 (Correlated equilibrium). Denote the strategy space as V =
{0, 1} with the size of V = 2 and a probability distribution over the space Vm as
G(p). Then G(p) is a correlated equilibrium if and only if G(p) makes that for
any decision pi, p
′
i ∈ V, there exists
∑
p−i∈Vm−1
G(pi,p−i)
(
Ui(pi,p−i) − Ui(p′
i,p−i)
)
≥ 0,
where p−i = (p1, · · · , pi−1, pi+1, · · · , pn) denotes other decisions except for pi.
The above definition implies that under the correlated equilibrium G(p),
there is no motivation for the partial node to deviate from the strategy pi about
sending the request to Mi given other strategies p−i. In other words, the par-
tial node can only obtain the maximized utility with respect to the individual
decision via selecting pi according to the decision vector p sampled from the cor-
related equilibrium G(p). It is obvious that there may exist various correlated
equilibria meeting the above-defined constraint.
178 Q. Hu et al.
On the other hand, the partial node cares about the overall utility of all deci-
sions about all surrounding full nodes since it reflects the general synchronization
status of this partial node, which can be calculated as
∑
p∈Vm G(p)
∑m
i=1 Ui(p).
Therefore, we can obtain the best correlated equilibrium for the partial node
considering the global optimization goal, which is summarized as the following
Node Synchronization (NS) problem.
NS Problem:
max :
∑
p∈Vm
G(p)
m∑
i=1
Ui(p) (6)
s.t. : G(p) ≥ 0, ∀p ∈ Vm, (7)
∑
p∈Vm
G(p) = 1, (8)
∑
p−i∈Vm−1
G(pi,p−i)
(
Ui(pi,p−i) − Ui(p′
i,p−i)
)
≥ 0,∀pi, p
′
i ∈ V. (9)
Obviously, the above NS problem is an optimization problem with respect to
the variable G(p), where the optimization object (6) is to maximize the overall
expected utility for all decisions, constraint (7) is a natural requirement for the
probability distribution, constraint (8) refers to that the sum of all probability
distribution is 1, and the last one (9) is directly obtained from the definition
of correlated equilibrium to achieve individual utility maximization. Besides, via
scrutinizing the NS problem, one can find that it is exactly a linear programming
problem with respect to the probability distribution G(p). In fact, there exist a
lot of efficient algorithms to solve the linear programming problem with polyno-
mial time complexity, such as interior point and simplex-based algorithms.
6 Experimental Evaluation
In this section, we first numerically analyze the key factor impacting the response
failure rate P (L > Γ ) , i.e., the decay speed I(x). Further, the proposed corre-
lated equilibrium based node synchronization mechanism is validated to demon-
strate its effectiveness. Specifically, all experiments are carried out using a laptop
running with 2.7 GHz Dual-Core Intel Core i5 processor and 8 GB memory. And
for the sake of statistical confidence, we report average values of all experimental
results via repeating each experiment for 20 times.
6.1 Numerical Analysis of Response Failure Rate
We first plot I(x) changing with the response capacity related parameter x and
the response rate μ in Fig. 1. In particular, we use the difference between μ and
λ, i.e., μ − λ, to capture the impact of μ
λ in (4) on I(x) for easy understanding.
Specifically, we set x ∈ [0, 1], λ = 3 and μ − λ ∈ [0, 10].
Sync or Fork: Node-Level Synchronization Analysis of Blockchain 179
0
1
0.5
10
1
1.5
0.5
2
5
0 0
(a)
0 0.5 1
0
1
2
0 5 10
0
1
2
0 0.5 1
0
1
2
0 5 10
0
1
2
(b)
Fig. 1. Decay speed of the synchronization failure rate.
It can be seen that I(x) increases with the larger x and μ − λ, which means
that we can achieve a higher decay speed for the response failure rate via either
improving the response capacity Γ = lx or enhancing the full node’s response
rate μ given a specific arrival rate λ. Besides, via comparing the first and second
lines of subfigures in Fig. 1(b), one can tell that the decay speed has different
changing trends with respect to x and μ − λ, where the increasing x can lead to
linear change while the increase of μ − λ can only bring logarithmic variation.
Thus, we can conclude that raising the response capacity can achieve a lower
response failure rate more efficiently.
6.2 Evaluation of Node Synchronization Mechanism
Next, we explore the effectiveness of our proposed node synchronization mech-
anism in Sect. 5. In detail, we take the case of m = 8 as an example and focus
on the decision of sending the synchronization request to the full node M1 who
has a varying response failure tolerance degree ε1 ∈ (0, 1) with an interval of
0.1. Other parameters are set as αi = 10, Ci = 5. The request sending decisions
are reported in Fig. 2 with two representative cases, where the response failure
tolerance degrees of all other full nodes, i.e., M2 to Mm, are the same and fixed
as ε−1 = 0.2 and 0.8. It is obvious that the request decision vectors in two cases
are very different. In the case of ε−1 = 0.2 in Fig. 2(a), p1 is 1 until ε1 is larger
than others, which means that sending the request to Mi is a good choice until
its response failure rate is higher than others. And similarly, when ε−1 = 0.8
as shown in Fig. 2(b), p1 keeps to be 1 except for ε1 = 0.9 which is larger than
response failure rates of other full nodes.
Finally, we examine the maximized total utility in the NS problem and evalu-
ate its performance under the impacts of the scalar parameter αi and the cost Ci.
Here the number of full nodes is still set to m = 8. The experimental results are
reported in Fig. 3. From Fig. 3(a), one can see that the maximized total utility
keeps the same as zero until αi = 5, which is because we set Ci = 5 in this exper-
iment and the profit φi ∈ [0, 1]. This means that only when the profit parameter
180 Q. Hu et al.
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
1
 p
1
 p
2
 p
3
 p
4
 p
5
 p
6
 p
7
 p
8
R
eq
ue
st
 d
ec
is
io
n
1 1
1 1 1 1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
(a) ε−1 = 0.2.
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
1
 p
1
 p
2
 p
3
 p
4
 p
5
 p
6
 p
7
 p
8
R
eq
ue
st
 d
ec
is
io
n
1 1 1 1 1 1 1 1
10
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
(b) ε−1 = 0.8.
Fig. 2. Synchronization request decision of the partial node.
αi is larger than the cost, can the partial node obtain a positive overall util-
ity. While within Fig. 3(b), it is shown that the maximized utility first increases
with Ci and then decreases when Ci is too large. This is because with a lower
Ci, the partial node can still obtain a better utility via strategically making the
request decision; while when the cost is too high, even the best decision cannot
compensate the high resource consumption in request sending process.
0 2 4 6 8 10
0
1
2
3
4
5
M
ax
im
iz
ed
 to
ta
l u
til
ity
(a) Impact of αi.
0 2 4 6 8 10
0
1
2
3
4
5
M
ax
im
iz
ed
 to
ta
l u
til
ity
(b) Impact of Ci.
Fig. 3. Maximized total utility of the partial node changing with αi and Ci.
7 Conclusion
In this paper, we take advantage of the large deviation theory and game theory
to study the blockchain synchronization in the pull-based propagation from a
microscopic perspective. To be specific, we investigate the fine-grained impacts
of peering nodes in synchronizing block information at the node level. On one
hand, the full node as the synchronization responder is analyzed based on the
Sync or Fork: Node-Level Synchronization Analysis of Blockchain 181
queuing model, which reveals the most efficient path to speed up synchronization
via increasing the response capacity. On the other hand, the partial node is
inspected as the requester, where the best synchronization request scheme is
designed using the concept of correlated equilibrium. Extensive experiments are
conducted to demonstrate the effectiveness of our analysis.
References
1. Nakamoto, S.: Bitcoin: a peer-to-peer electronic cash system. Technical report,
Manubot (2019)
2. Blockchain market. https://www.marketsandmarkets.com/Market-Reports/
blockchain-technology-market-90100890.html. Accessed 30 May 2020
3. Gervais, A., Karame, G.O., Wüst, K., Glykantzis, V., Ritzdorf, H., Capkun, S.:
On the security and performance of proof of work blockchains. In: Proceedings of
the 2016 ACM SIGSAC Conference on Computer and Communications Security,
pp. 3–16 (2016)
4. Decker, C., Wattenhofer, R.: Information propagation in the bitcoin network. In:
IEEE P2P 2013 Proceedings, pp. 1–10. IEEE (2013)
5. Sompolinsky, Y., Zohar, A.: Secure high-rate transaction processing in bitcoin. In:
Böhme, R., Okamoto, T. (eds.) FC 2015. LNCS, vol. 8975, pp. 507–527. Springer,
Heidelberg (2015). https://doi.org/10.1007/978-3-662-47854-7 32
6. Göbel, J., Keeler, H.P., Krzesinski, A.E., Taylor, P.G.: Bitcoin blockchain dynam-
ics: the selfish-mine strategy in the presence of propagation delay. Perform. Eval.
104, 23–41 (2016)
7. Kang, J., Xiong, Z., Niyato, D., Wang, P., Ye, D., Kim, D.I.: Incentivizing consensus
propagation in proof-of-stake based consortium blockchain networks. IEEE Wirel.
Commun. Lett. 8(1), 157–160 (2018)
8. Garay, J., Kiayias, A., Leonardos, N.: The bitcoin backbone protocol: analysis
and applications. In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015. LNCS,
vol. 9057, pp. 281–310. Springer, Heidelberg (2015). https://doi.org/10.1007/978-
3-662-46803-6 10
9. Pass, R., Seeman, L., Shelat, A.: Analysis of the blockchain protocol in asyn-
chronous networks. In: Coron, J.-S., Nielsen, J.B. (eds.) EUROCRYPT 2017.
LNCS, vol. 10211, pp. 643–673. Springer, Cham (2017). https://doi.org/10.1007/
978-3-319-56614-6 22
10. Bicoin relay network. https://github.com/bitcoinfibre/bitcoinfibre. Accessed 30
May 2020
11. Klarman, U., Basu, S., Kuzmanovic, A., Sirer, E.G.: bloXroute: a scalable trustless
blockchain distribution network whitepaper. IEEE Internet Things J. (2018)
12. Conley, J.P.: The Geeq project white paper (2018)
13. Wüst, K., Gervais, A.: Ethereum eclipse attacks. Technical report, ETH Zurich
(2016)
14. Cao, J., Cleveland, W., Lin, D., Sun, D.: Internet traffic tends to poisson and
independent as the load increases. Technical report, Technical report, Bell Labs
(2001)
15. Ganesh, A.J., O’Connell, N., Wischik, D.J.: Big Queues. Springer, Heidelberg
(2004). https://doi.org/10.1007/978-3-540-39889-9
16. Wang, S., Wang, C., Hu, Q.: Corking by forking: Vulnerability analysis of
blockchain. In: IEEE INFOCOM 2019-IEEE Conference on Computer Commu-
nications, pp. 829–837. IEEE (2019)
https://www.marketsandmarkets.com/Market-Reports/blockchain-technology-market-90100890.html
https://www.marketsandmarkets.com/Market-Reports/blockchain-technology-market-90100890.html
https://doi.org/10.1007/978-3-662-47854-7_32
https://doi.org/10.1007/978-3-662-46803-6_10
https://doi.org/10.1007/978-3-662-46803-6_10
https://doi.org/10.1007/978-3-319-56614-6_22
https://doi.org/10.1007/978-3-319-56614-6_22
https://github.com/bitcoinfibre/bitcoinfibre
https://doi.org/10.1007/978-3-540-39889-9
	Sync or Fork: Node-Level Synchronization Analysis of Blockchain
	1 Introduction
	2 Related Work
	3 System Model
	3.1 Response Model of the Full Node
	3.2 Synchronization Model of the Partial Node
	4 Response Failure Analysis
	5 Correlated Equilibrium Based Node Synchronization Mechanism
	6 Experimental Evaluation
	6.1 Numerical Analysis of Response Failure Rate
	6.2 Evaluation of Node Synchronization Mechanism
	7 Conclusion
	References