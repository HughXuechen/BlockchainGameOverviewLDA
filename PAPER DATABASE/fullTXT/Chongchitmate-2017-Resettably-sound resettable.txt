Resettably-Sound Resettable Zero Knowledge
in Constant Rounds
Wutichai Chongchitmate1(B), Rafail Ostrovsky1, and Ivan Visconti2
1 University of California, Los Angeles, CA, USA
{wutichai,rafail}@cs.ucla.edu
2 Università di Salerno, Fisciano, Italy
visconti@unisa.it
Abstract. In FOCS 2001 Barak et al. conjectured the existence of zero-
knowledge arguments that remain secure against resetting provers and
resetting verifiers. The conjecture was proven true by Deng et al. in FOCS
2009 under various complexity assumptions and requiring a polynomial
number of rounds. Later on in FOCS 2013 Chung et al. improved the
assumptions requiring one-way functions only but still with a polynomial
number of rounds.
In this work we show a constant-round resettably-sound resettable
zero-knowledge argument system, therefore improving the round com-
plexity from polynomial to constant. We obtain this result through the
following steps.
1. We show an explicit transform from any �-round concurrent zero-
knowledge argument system into an O(�)-round resettable zero-
knowledge argument system. The transform is based on techniques
proposed by Barak et al. in FOCS 2001 and by Deng et al. in FOCS
2009. Then, we make use of a recent breakthrough presented by
Chung et al. in CRYPTO 2015 that solved the longstanding open
question of constructing a constant-round concurrent zero-knowledge
argument system from plausible polynomial-time hardness assump-
tions. Starting with their construction Γ we obtain a constant-round
resettable zero-knowledge argument system Λ.
2. We then show that by carefully embedding Λ inside Γ (i.e., essen-
tially by playing a modification of the construction of Chung et al.
against the construction of Chung et al.) we obtain the first constant-
round resettably-sound concurrent zero-knowledge argument sys-
tem Δ.
3. Finally, we apply a transformation due to Deng et al. to Δ obtaining
a resettably-sound resettable zero-knowledge argument system Π,
the main result of this work.
While our round-preserving transform for resettable zero knowledge
requires one-way functions only, both Λ, Δ and Π extend the work of
Chung et al. and as such they rely on the same assumptions (i.e., fami-
lies of collision-resistant hash functions, one-way permutations and indis-
tinguishability obfuscation for P/poly, with slightly super-polynomial
security).
c© International Association for Cryptologic Research 2017
Y. Kalai and L. Reyzin (Eds.): TCC 2017, Part II, LNCS 10678, pp. 111–138, 2017.
https://doi.org/10.1007/978-3-319-70503-3_4
112 W. Chongchitmate et al.
1 Introduction
Private randomness is essential for many cryptographic tasks, including zero-
knowledge (ZK) proofs [24]. A natural question regards the possibility of having
ZK proofs in applications where the computing machine is stateless and not
equipped with a continuous source of randomness.
Resettable zero knowledge. The above question was put forth by Canetti et al. [8].
In particular, they considered a cheating verifier that mounts a reset attack,
where provers are forced to execute the protocol multiple times possibly on
the same inputs and random tapes, and without the ability to maintain states
between executions. These attacks include the case of stateless provers, as well as
provers implemented by devices that can physically be restored to their original
states (e.g., through cloning, battery replacement).
More specifically, in [8], Canetti et al. introduced the notion of resettable
zero knowledge (rZK), in which the zero-knowledge property is required to hold
even against cheating verifiers that can reset the provers to the initial states
therefore forcing them to play again with the same randomnesses. This notion
is closely related to concurrent zero knowledge (cZK) proposed earlier by Dwork
et al. [19] where a cheating verifier can engage in multiple possibly interleaving
concurrent executions (called sessions) of the protocol. rZK is at least as hard to
achieve as cZK since a resetting cheating verifier through specific reset strategies
can emulate interleaving concurrent executions. In [21] Garg et al. showed that
resettable statistical zero knowledge is possible for several interesting languages.
Round complexity of cZK and rZK. Constant-round cZK under plausible hard-
ness assumptions has been a long-standing challenging open question that
received a positive answer in the work of Chung et al. [11] by means of indistin-
guishability obfuscation (iO) [11]. Instead the situation for rZK is worse. Canetti
et al. in [8] constructed rZK proofs in the standard model relying on standard
cryptographic assumptions but with polynomial round complexity1.
The round complexity was then improved to poly-logarithmic in [29]. The
state of affair leaves the following open problem.
Open Problem 1: is there a construction for rZK with sub-logarithmic
rounds?
Resettably-sound zero knowledge. Barak et al. [3] considered the natural opposite
setting, called resettably-sound zero knowledge (rsZK) arguments, where sound-
ness is required to hold even against cheating provers that can reset the verifiers
forcing them to re-use the same random tapes. The standard zero-knowledge
property remains untouched. They showed a constant-round construction assum-
ing collision-resistant hash functions. The recent work of [12] reached optimal
round complexity and assumptions (i.e., 4 rounds and one-way functions).
1 In addition they proposed a mild setup assumption based on bare public keys showing
that it is sufficient for constant-round resettable zero knowledge. Follow up work
optimized round complexity and complexity assumptions for rZK with bare public
keys [16,17,31,34,35].
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 113
The simultaneous resettability conjecture. Barak et al. in [3] conjectured the exis-
tence of a zero-knowledge argument that is secure simultaneously against reset-
ting verifiers and against resetting provers: a resettably-sound resettable zero-
knowledge argument system. The conjecture was proven true by Deng et al. [15]
that presented a construction with a polynomial number of rounds and assuming
collision-resistant hash functions and trapdoor permutations. The computational
assumptions have been improved to one-way functions [4,5,13,14,33], while the
barrier of the polynomial round complexity has remained untouched so far.
Open Problem 2: is there a construction for resettably-sound rZK with
sub-polynomial rounds?
We stress that by relaxing the security against resetting verifiers from zero
knowledge to witness indistinguishability, then constant-round simultaneous
resettability is possible. Indeed just 1 or 2 rounds (i.e., ZAPs) are needed to
obtain proofs, and a larger constant number of rounds is sufficient to obtain
arguments of knowledge [9].
1.1 Our Results
In this paper, we answer the above questions positively. In the main result we
construct a constant-round simultaneous resettable zero-knowledge argument
for NP. Our result requires the existence of families of collision-resistant hash
functions, one-way permutations and indistinguishability obfuscation (iO) for
P/poly (with slightly super-polynomial security). These assumptions are the
same as the ones in [11] that showed a constant-round concurrent zero-knowledge
argument for NP. Our result makes uses of the protocol of [11] twice in some
nested way. More precisely, the first time we use the protocol of [11] Γ is to
obtain a constant-round rZK argument Λ. Then we start again with Γ and we
modify it by using Λ (that is a modification of Γ ) as subprotocol in the oppo-
site direction (i.e., the verifier will prove something to the prover). Therefore we
roughly use the protocol of [11] against the protocol of [11] which is somehow
intriguing. This nested use of the protocol of [11] allows us to obtain a constant-
round resettably-sound concurrent zero-knowledge argument Δ. We can then
apply a compiler due to [15] to Δ therefore obtaining our main argument system
Π that is secure simultaneously against resetting provers and resetting verifiers
needing only a constant number of rounds.
We now give our formal theorems that specify the precise complexity
assumptions.
Theorem 1. Assuming the existence of one-way functions, than any �-round
concurrent zero-knowledge argument system can be transformed in a O(�)-round
resettable zero-knowledge argument system.
Theorem 2. Assuming the existence of collision-resistant hash functions, one-
way permutations and indistinguishability obfuscation for P/poly (with slightly
super-polynomial security), there exists a constant-round resettably-sound reset-
table zero-knowledge argument system for NP.
114 W. Chongchitmate et al.
1.2 Main Tools and Our New Techniques
Our constructions rely on new ideas as well as a combined use of several tech-
niques used in previous results on concurrent, resettable and resettably-sound
zero knowledge. We start by briefly describing the important tools that we use
along with our new techniques for our constructions.
Barak’s non-black-block protocol. The starting point is Barak’s non-black-box
zero-knowledge argument for NP [1] that works as follows. The prover P sends
a commitment c ∈ {0, 1}n of 0 to the verifier V . The verifier V then sends
a uniformly generated random string r ∈ {0, 1}2n. Finally, the prover gives
a witness-indistinguishable universal argument (WIUA) that x ∈ L or there
exists σ ∈ {0, 1}n such that c is a commitment of a program M such that
M(σ) = r2. The soundness follows from the binding of the commitment scheme
and the soundness of the WIUA as any program M committed by the cheating
prover does not have r in its support with overwhelming probability. For the
zero-knowledge property, the simulator uses the code of the adversary. Indeed it
commits to a program M corresponding to the code of V ∗, the cheating verifier.
Let σ be the commitment. We have that M(σ) = r and σ is short compared
to r.
Chung et al.’s constant-round cZK argument. In [11], Chung et al. construct a
constant-round cZK argument by using unique P-certificate systems [10] with
delegatable CRS generation and iO. Informally, a P-certificate system allows
an efficient prover to convince a verifier of the validity of any deterministic
polynomial-time computation M(x) = y using a certificate of fixed (polynomial)
length, independent of the size and the running time of M . The verifier can also
verify the certificate in fixed (polynomial) time, independent of the running time
of M . In a P-certificate system with delegatable CRS generation, the certificate
is generated using a common reference string (CRS) that can be computed by
using resources delegated by the verifier. More specifically, in this P-certificate
system, the P-certificate verifier generates public and private parameters, PP
and κ, and sends PP to the P-certificate prover. The P-certificate prover uses
the public parameter PP and the statement q = (M,x, y) to deterministically
compute a short digest d, whose length is independent of the length of q, and
sends it to the P-certificate verifier. The P-certificate verifier then computes the
CRS from d and κ. Finally, the P-certificate prover computes the certificate from
the CRS and q. The P-certificate system is unique if there exists at most one
accepted certificate for any statement and CRS.
The argument of [11] proceeds similarly to Barak’s argument with the fol-
lowing modifications. In the last step, instead of requiring the prover P to prove
2 Since the size of M may not be known in advance, the commitment is to the hash of
the program M using a hash function h sampled from a family of collision-resistant
hash functions chosen in the beginning of the protocol by the verifier. The soundness
is also based on the collision resistance of h.
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 115
that x ∈ L or there exists σ such that c is a commitment to a program M such
that M(σ) = r, the prover provides a special-sound witness-indistinguishability
proof that x ∈ L or there exists a P-certificate π which certifies that M(σ) = r
for some short string σ. Additionally, P also commits and gives a WIUA proving
that either x ∈ L or there exists a P-certificate for the statement q = (M,σ, r)
before receiving the public parameter PP from V . Note that since the honest
prover of the protocol in [11] has a witness for x ∈ L, it can just ignore CRS,
d and q, and simply commit to zeroes. In order to allow the zero-knowledge
simulator (note that an honest prover will just use the witness for x ∈ L) to
compute the CRS from d and κ, the verifier sends an obfuscated program with κ
embedded inside, that allows the simulator to compute CRS from d committed
earlier. Finally, V also provides a zero-knowledge argument that the obfuscated
program is computed correctly.
The simulator does not know a witness for x ∈ L but is instead able to
commit to the code of the adversary. More formally, the simulator is divided
in two parts: S1, which takes a P-certificates πi in the i-th round as an input,
and interacts with the verifier V ∗, and S2 which, in the i-th round provides
P-certificates certifying that S1 on input (1, π1), . . . , (i − 1, πi−1) outputs mi.
Instead of committing to a program M , using the verifier V ∗’s code, such that
M(σ) = r for some short string σ, the simulator S = (S1, S2) commits to a
program ˜S1. The program, on input (1n, j, s), runs an interaction between S1
and V ∗ for j rounds using s as a seed to generate pseudorandom coins while
having an access to the oracle OVcert which provides P-certificates. This prevents
the nesting of concurrent sessions which may result in the blow-up in the run-
ning time as the expensive part of S consists in generating the P-certificates.
The simulator of the protocol in [11] can therefore succeed in the special-sound
witness-indistinguishability proof for the statement x ∈ L or there exists a P-
certificate π which certifies that ˜S
OVcert
1 (1n, j, s) = r for some short string (1n, j, s)
using the output from the oracle as a witness.
Deng, Goyal and Sahai’s transformation. In [15,25], Deng et al. construct
a hybrid resettably-sound and relaxed concurrent zero-knowledge argument
ΠDGS . Then they apply a series of transformations to achieve simultaneous
resettability.
Relaxed concurrent zero knowledge allows verifiers to interact in multiple
sessions with independent provers. However, the zero-knowledge property only
guarantees for “relaxed” concurrent verifiers whose random coins are fixed in
the beginning of each session, independently of sessions that start after that
session. Note that any concurrent zero-knowledge argument/proof is also relaxed
concurrent zero-knowledge as any relaxed concurrent verifier is also a concurrent
verifier.
Hybrid resettable soundness means that the verifier can be separated into
two parts, V1 and V2. V1 directly interacts with P , may relay some messages
between P and V2, and can be reset by a cheating prover. V2 only interacts with
V1, cannot be reset by a cheating prover, and is responsible to decide whether to
“accept” or “reject” the argument. Moreover, for each determining message (the
116 W. Chongchitmate et al.
first message V2 receives in the protocol), P cannot find two different messages
that P can convince V1 to pass to V2 in each round. We refer to [25] for a precise
definition. Note that any resettably-sound argument is also hybrid resettably
sound by letting V1 behave as V except that instead of accepting the argument,
it sends a message to V2, and V2 always accepts the argument when it receives
a message from V1.
The transformation of Deng et al. uses ZAPs and one-way functions to achieve
simultaneous resettability and only increases the round complexity by a constant
factor. However, the round complexity of ΠDGS is polynomial [15]. Thus, their
simultaneously resettable argument system also requires polynomial rounds.
Inapplicability of the transformation of [15] to the construction of Chung
et al. [11]. Intuitively, one may try to apply the transformation of [15] to the
constant-round concurrent zero-knowledge argument in [11] to get simultaneous
resettability. However, in order for the result of the transformation to be simulta-
neously resettable, it is required that the starting protocol be relaxed concurrent
zero-knowledge and hybrid resettably sound. While the protocol in [11] is concur-
rent zero-knowledge, which implies that it is relaxed concurrent zero-knowledge,
we argue that if the (non-resettable) ZK argument (proving that the obfuscated
program is computed correctly) is not zero-knowledge against resetting verifiers,
then the protocol can not be proved hybrid resettably sound. Two reasons follow
below.
1. Suppose in the extreme case that there exists an adversarial resetting prover
for the argument of [11] that runs a resetting adversary AZK in the (non-
resetting) zero-knowledge subprotocol in which the honest verifier proves that
the obfuscated program is computed correctly. Remember that the zero-
knowledge subprotocol could also be an argument of knowledge admitting
a black-box (rewinding) extractor. By managing to run AZK , the adversarial
resetting prover could succeed in extracting some relevant information (e.g.,
the secret parameter for P-certificate CRS generation, that is used in the
(non-resettable) ZK argument proven by the verifier to prover to guarantee
the correctness of the obfuscated program). However, according to the defin-
ition of hybrid resettable soundness, we need to consider two separate parts
of the verifier V = (V1, V2). One out of V1 and V2 will run as prover of the
ZK argument proving that the obfuscated program is generated correctly. If
the (non-resettable) ZK argument is played by V1 (as a prover), which can be
reset, the malicious prover of the protocol in [11] can run AZK to learn some
relevant information (.e.g, the secret parameter), and this can potentially be
used to generate a certificate for a false statement. On the other hand, if
the (non-resettable) ZK argument is played by V2 (as a prover) then since
the messages of the verifier of this argument are not fixed by a determining
message in the protocol of [11], we have that V2 can receive two different
messages for the same determining message, and thus, even in this case, the
protocol is not hybrid resettably sound.
2. The P-certificate generation in the protocol of [11] cannot be transformed
into a resettably-sound protocol using the techniques of [3]. This is because
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 117
the P-certificate system is not public coin. Recall that the proof of resettable
soundness in [3] uses the reduction to the non-resettable case by starting (by
contradiction) with a (successful) resetting prover. If we repeat here the same
reduction, we have that the non-resetting prover runs all but one session by
simulating the verifier itself. Of course this requires to generate legit verifier
messages under reset attacks. When trying to send the legit verifier messages,
the non-resetting prover may send the obfuscated program of the real verifier
of the reduction to the resetting prover, and the resetting prover may reset
to the step after which it receives the public parameter for the P-certificate.
In that case, the non-resetting prover will not be able to generate a new
obfuscated program as specified in the protocol without knowing the secret
parameter.
Th. 6
Th. 7
Fig. 1. Our transformations of zero-knowledge argument systems
1.3 Our Approach
In order to get a constant-round resettably-sound concurrent zero-knowledge
argument system, we consider the protocol from [11] which is constant round
and concurrent zero knowledge, but not resettably sound. As discussed above,
118 W. Chongchitmate et al.
there are two main problems that separate the protocol of [11] from resettable
soundness: the non-resettable ZK argument for iO and the delegatable CRS gen-
eration of the P-certificate system, which cannot be generated without knowing
the secret parameter generated in the earlier step.
Solving the first problem. We resolve the first problem by constructing a constant-
round resettable ZK argument from the concurrent ZK argument of [11]. This
transformation is implicit in some previous works on the topic [3,15]. We explic-
itly present it here for completion (Fig. 1).
Unlike the concurrent verifier, the resetting verifier can exploit the reuse
of the random tape during the resetting attack by sending different messages in
order to extract additional information from the prover. We prevent such behav-
ior by requiring (1) the verifier to commit to its random tape using a statistically
binding commitment scheme and (2) to provide a zero-knowledge argument that
it actually uses the random tape it has committed to. Note that since the verifier
can reset the prover, a zero-knowledge argument without resettable soundness
cannot be used by the verifier to prove that the verifier uses the committed ran-
dom bits. Thus, the argument system needs to be resettably sound. In order to
preserve the round complexity, this subprotocol must be constant round. This
can be done using the 4-round resettably-sound zero-knowledge argument by
Chung et al. [12]. A similar technique has been used in [26] for resettably-secure
computation.
We note that the constant-round rsZK argument and the commitment scheme
can be constructed from one-way functions, which is assumed for the constant-
round concurrent zero-knowledge argument in [11]. Thus, applying this trans-
formation on the protocol does not require any extra assumption. It turns out
that the technique we use can be generalized to a compiler that works with any
concurrent ZK protocol. The round complexity of the resulting protocol only
increases by a constant factor.
Our compiler turning any concurrent ZK argument into a resettable ZK
argument works as follows. First, we replace the random coin used by the prover
to generate his messages with outputs of a PRF. This step allows a prover with
fixed random tape to send different messages when the resetting verifier changes
its messages after resetting similarly to the technique used in [3] against resetting
provers. Additionally, the verifier commits to its random coins used in each round
at the beginning of the protocol. After sending each message, the verifier gives
a constant-round resettably-sound ZK argument that it uses the random coins
committed in the first round. This modification ensures that the verifier follows
the protocol in every session.
Solving the second problem. In order to solve the second problem, we observe
that while the protocol of [11] is not public-coin, it is “almost public-coin”. By
almost public-coin, we mean that, beside the ZK argument which is replaced by
rZK argument above, there is only one message from the verifier that cannot be
generated independently as public-coin, but depends on a hidden randomness.
Thus, we modify the technique in [3] to resolve the problem in two steps as
follows (Fig. 1).
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 119
First, we consider a modified version of the protocol of [11], in which we can
prove its (non-resettable) soundness. In this protocol, the round in which the
message from V cannot be generated with uniformly random coins is repeated
m times, where m = poly(n) is the upper bound on the running time of a
cheating prover P ∗. More specifically, after receiving the public parameter for
P-certificate, the prover for the modified protocol PS repeatedly commits to
and proves the validity of the digest d of his statement while the verifier VS
repeatedly replies with the obfuscated program verifying the committed value
and output the CRS for the P-certificate. PS then chooses which commitment
and obfuscated program pair PS will use to complete the protocol. Because of the
security of the iO, PS does not learn the secret parameter for the P-certificate
even after m repetitions. Thus, the resulting protocol is still sound.
Then we reduce the resettable soundness of the final protocol to the non-
resettable soundness of the above protocol with polynomial reduction in success
probability as follows. Given a resetting prover P ∗, we construct a non-resetting
prover P ∗
S by internally simulating P ∗ interaction with a verifier V , and ran-
domly choosing which of the m repetitions will lead to accepting transcript. For
other repetitions, P ∗
S will generate the parameters for P-certificate itself to get
around the non-public-coin situation. In the case that P ∗
S guesses the accept-
ing transcript correctly, which occurs with probability 1/m, it will convince the
verifier VS with the accepting transcript from the simulation.
1.4 Open Questions
Unlike the above compiler from concurrent ZK to resettable ZK, our construction
for resettably sound resettable zero knowledge uses in a non-black-box way the
protocol of [11].
Our work leaves open the natural questions of producing a generic round-
preserving transform from cZK to rZK, and of obtaining constant-round
resettably sound resettable zero knowledge under more standard complexity
assumptions.
2 Definitions
A polynomial-time relation R is a relation for which it is possible to verify in
time polynomial in |x| whether R(x,w) = 1. Let us consider an NP-language L
and denote by RL the corresponding polynomial-time relation such that x ∈ L
if and only if there exists w such that RL(x,w) = 1. We will call such a w a valid
witness for x ∈ L. Let λ denote the security parameter. A negligible function ν(λ)
is a non-negative function such that for any constant c < 0 and for all sufficiently
large λ, ν(λ) < λc. We will denote by Prr[X] the probability of an event X over
coins r, and Pr[X] when r is not specified. The abbreviation “PPT” stands for
probabilistic polynomial time. For a randomized algorithm A, let A(x; r) denote
running A on an input x with random coins r. If r is chosen uniformly at random
with an output y, we denote y ← A(x). For a pair of interactive Turing machines
120 W. Chongchitmate et al.
(P, V ), let 〈P, V 〉(x) denotes V ’s output after interacting with P upon common
input x. We say V accepts if 〈P, V 〉(x) = 1 and rejects if 〈P, V 〉(x) = 0. We
denote by view
P (w)
V (x,z) the view (i.e., its private coins and the received messages)
of V during an interaction with P (w) on common input x and auxiliary input
z. We will use the standard notion of computational indistinguishability [23].
We now give definitions for interactive proof/argument systems with all vari-
ants that are useful in this work.
Definition 1 (interactive proofs [24]). An interactive proof system for the
language L, is a pair of interactive Turing machines (P, V ) running on common
input x such that:
– Efficiency: P and V are PPT.
– Completeness: For every λ∈N and for every pair (x,w) such that RL(x,w)=
1,
Pr[〈P (w), V 〉(1λ, x) = 1] = 1.
– Soundness3: There exists a negligible function ν(·) such that for every pair of
interactive Turing machines (P ∗
1 , P ∗
2 )
Pr[(x, z) ← P ∗
1 (1λ) : x /∈ L ∧ 〈P ∗
2 , V 〉(1λ, x) = 1] < ν(λ).
In the above definition we can relax the soundness requirement by considering
P ∗ as PPT. In this case, we say that (P, V ) is an interactive argument system [7].
Definition 2 (zero-knowledge arguments [24]). Let (P, V ) be an interactive
argument system for a language L. We say that (P, V ) is zero knowledge (ZK)
if, for any probabilistic polynomial-time adversary V ∗, there exists a probabilis-
tic polynomial-time algorithm SV ∗ such for all auxiliary inputs z and all pairs
(x,w) ∈ RL the ensembles {viewP (w)
V ∗(x,z)} and {SV ∗(x, z)} are computationally
indistinguishable.
Suppose (P, V ) is used as a sub-protocol of another interactive protocol
(A1, A2) where A1 runs P and A2 runs V . We call a Turing machine A1
α a resid-
ual prover if A1
α runs A1 on inputs α = (α1, . . . , α�) from A2 up to and including
the �th round when A1 invokes P . A residual verifier A2
α is defined similarly by
switching A1 and A2. Note that the residual prover is invoked when simulating
V (for soundness) while the residual verifier is invoked when simulating P (for
zero-knowledge).
Definition 3 (resetting adversary [8]). Let (P, V ) be an interactive proof or
argument system for a language L, t = poly(λ), x̄ = x1, . . . , xt be a sequence of
common inputs and w̄ = w1, . . . , wt the corresponding witnesses (i.e., (xi, wi) ∈
RL) for i = 1, . . . , t. Let r1, . . . , rt be independent random tapes. We say that
3 This version of soundness given by [11] is slightly different from standard version
with one Turing machine P ∗. Separating them makes the proof cleaner while it is
still equivalent to the standard version.
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 121
a PPT V ∗ is a resetting verifier if it concurrently interacts with an unbounded
number of independent copies of P by choosing for each interaction the value
i so that the common input will be xi ∈ x̄, and the prover will use witness
wi, and choosing j so that the prover will use rj as randomness, with i, j ∈
{1, . . . , t}. The scheduling or the messages to be sent in the different interactions
with P are freely decided by V ∗. Moreover we say that the transcript of such
interactions consists of the common inputs x̄ and the sequence of prover and
verifier messages exchanged during the interactions. We refer to view
P (w̄)
V ∗(x̄,z) as
the random variable describing the content of the random tape of V ∗ and the
transcript of the interactions between P and V ∗, where z is an auxiliary input
received by V ∗.
Definition 4 (resettable zero knowledge [8]). Let (P, V ) be an interactive
argument system for a language L. We say that (P, V ) is resettable zero knowl-
edge (rZK) if, for any PPT resetting verifier V ∗ there exists a expected proba-
bilistic polynomial-time algorithm SV ∗ such that the for all pairs (x̄, w̄) ∈ RL the
ensembles {viewP (w̄)
V ∗(x̄,z)} and {SV ∗(x̄, z)} are computationally indistinguishable.
The definition of concurrent zero knowledge can be seen as a relaxation of
the one of resettable zero knowledge. The adversarial concurrent verifier has
the same power of the resetting verifier except it can not ask the prover to run
multiple sessions with the same randomness.
Definition 5 (concurrent adversary). Let (P, V ) be an interactive proof
or argument system for a language L, t = poly(λ), x̄ = x1, . . . , xt be a
sequence of common inputs and w̄ = w1, . . . , wt the corresponding witnesses
(i.e., (xi, wi) ∈ RL) for i = 1, . . . , t. We say that a PPT V ∗ is a concurrent
verifier if it concurrently interacts with an unbounded number of independent
copies of P by choosing for each interaction the value i so that the common
input will be xi ∈ x̄, and the prover will use witness wi. Each copy of P runs
with independent randomness. The scheduling or the messages to be sent in the
different interactions with P are freely decided by V ∗. Moreover we say that the
transcript of such interactions consist of the common inputs x̄ and the sequence
of prover and verifier messages exchanged during the interactions. We refer to
view
P (w̄)
V ∗(x̄,z) as the random variable describing the content of the random tape
of V ∗ and the transcript of the interactions between P and V ∗, where z is an
auxiliary input received by V ∗.
Definition 6 (concurrent zero knowledge [19]). Let (P, V ) be an inter-
active argument system for a language L. We say that (P, V ) is concur-
rent zero knowledge (cZK) if, for any PPT concurrent verifier V ∗ there
exists a probabilistic polynomial-time algorithm SV ∗ such that the for all pairs
(x̄, w̄) ∈ RL the ensembles {viewP (w̄)
V ∗(x̄,z)} and {SV ∗(x̄, z)} are computationally
indistinguishable.
Definition 7 (witness indistinguishability [20]). Let L be a language in NP
and RL be the corresponding relation. An interactive argument (P, V ) for L is
122 W. Chongchitmate et al.
witness indistinguishable (WI) if for every verifier V ∗, every pair (w0, w1) such
that (x,w0) ∈ RL and (x,w1) ∈ RL and every auxiliary input z, the following
ensembles are computationally indistinguishable:
{viewP (w0)
V ∗(x,z)} and {viewP (w1)
V ∗(x,z)}.
Definition 8 (resettable WI [8]). Let L be a language in NP and RL be
the corresponding relation. An interactive argument (P, V ) for L is resettable
witness indistinguishable (rWI) if for every PPT resetting verifier V ∗ every
t = poly(λ), and every pair (w̄0 = (w0
1, . . . , w
0
t ), w̄1 = (w1
1, . . . , w
1
t )) such that
(xi, w
0
i ) ∈ RL and (xi, w
1
i ) ∈ RL for i = 1, . . . , t, and any auxiliary input z, the
following ensembles are computationally indistinguishable:
{viewP (w̄0)
V ∗(x̄,z)} and {viewP (w̄1)
V ∗(x̄,z)}.
In [18], a construction of 2-round resettable witness-indistinguishable proof
based on NIZK proofs has been shown, and then in [27], a non-interactive
resettable witness-indistinguishable proof has been shown by relying on specific
number-theoretic assumptions, and from iO [6].
Let us recall the definition of resettable soundness due to [3].
Definition 9 (resettably-sound arguments [3]). A resetting attack of a
cheating prover P ∗ on a resettable verifier V is defined by the following two-
step random process, indexed by a security parameter λ.
1. Uniformly select and fix t = poly(λ) random-tapes, denoted r1, . . . , rt, for
V , resulting in deterministic strategies V (j)(x) = Vx,rj
defined by Vx,rj
(α) =
V (x, rj , α),4 where x ∈ {0, 1}λ and j ∈ [t]. Each V (j)(x) is called an incar-
nation of V .
2. On input 1λ, machine P ∗ is allowed to initiate poly(λ)-many interactions
with the V (j)(x)’s. The activity of P ∗ proceeds in rounds. In each round P ∗
chooses x ∈ {0, 1}λ and j ∈ [t], thus defining V (j)(x), and conducts a complete
session with it.
Let (P, V ) be an interactive argument for a language L. We say that (P, V )
is a resettably-sound argument for L if the following condition holds:
– Resettable-soundness: For every polynomial-size resetting attack, the proba-
bility that in some session the corresponding V (j)(x) has accepted and x /∈ L
is negligible.
Definition 10 (commitment scheme). Given a security parameter 1λ, a
commitment scheme com is a two-phase protocol between two PPT interactive
algorithms, a sender S and a receiver R. In the commitment phase S on input
4 Here, V (x, r, α) denotes the message sent by the strategy V on common input x,
random-tape r, after seeing the message-sequence α.
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 123
a message m interacts with R to produce a commitment c = com(m). In the
decommitment phase, S sends to R a decommitment information d such that R
accepts m as the decommitment of c.
Formally, we say that com is a perfectly binding commitment scheme if the
following properties hold:
Correctness:
• Commitment phase. Let c = com(m) be the commitment of the message m
given as output of an execution of com where S runs on input a message
m. Let d be the private output of S in this phase.
• Decommitment phase5. R on input m and d accepts m as decommitment
of c.
Statistical (resp. Computational) Hiding [30]: for any adversary (resp.
PPT adversary) A and a randomly chosen bit b ∈ {0, 1}, consider the follow-
ing hiding experiment ExpHidingb
A,com(λ):
• Upon input 1λ, the adversary A outputs a pair of messages m0,m1 that
are of the same length.
• S on input the message mb interacts with A to produce a commitment of
mb.
• A outputs a bit b′ and this is the output of the experiment.
For any adversary (resp. PPT adversary) A, there exist a negligible function
ν, s.t.:
∣
∣
∣ Pr[ExpHiding0A,com(λ) = 1] − Pr[ExpHiding1A,com(λ) = 1]
∣
∣
∣ < ν(λ).
Statistical (resp. Computational) Binding: for every commitment com
generated during the commitment phase by a possibly malicious unbounded
(resp. malicious PPT) sender S∗ there exists a negligible function ν such that
S∗, with probability at most ν(λ), outputs two decommitments (m0, d0) and
(m1, d1), with m0 �= m1, such that R accepts both decommitments.
We also say that a commitment scheme is perfectly binding iff ν(λ) = 0.
In this paper, we consider non-interactive perfectly binding computationally
hiding commitment schemes, which can be constructed from one-to-one one-way
functions [22]. Two-message statistically binding commitment schemes can be
obtained from one-way functions [28,32].
Definition 11 (pseudorandom function (PRF)). A family of functions
{fs}s∈{0,1}∗ is called pseudorandom if for all adversarial PPT machines A, for
every positive polynomial p(), and sufficiently large λ ∈ N, it holds that
|Pr[Afs(1λ) = 1] − Pr[AF (1λ) = 1]| ≤ 1
p(λ)
.
where |s| = n and F denotes a truly random function.
5 In this paper we consider a non-interactive decommitment phase only.
124 W. Chongchitmate et al.
Definition 12 (indistinguishability obfuscation). A uniform machine iO
is an indistinguishability obfuscator for a class of deterministic circuits {Cλ}λ∈N
if it satisfies the following:
– Correctness: For all security parameter λ∈N, for all C ∈Cλ, for all input x,
Pr[Λ ← iO(1λ, C) : Λ(x) = C(x)] = 1.
– Security: For every non-uniform PPT sampleable distribution D and adver-
sary A, there exists a negligible function ν such that for sufficiently large
λ ∈ N, if
Pr[(C1, C2, z) ← D : ∀x,C1(x) = C2(x)] > 1 − ν(λ),
then
Pr[(C1, C2, z) ← D : A(iO(1λ, C1), z) = 1]
−Pr[(C1, C2, z) ← D : A(iO(1λ, C2), z) = 1] ≤ ν(λ).
We say an iO is super-polynomially secure if there is a super-polynomial
function T such that the above condition holds for all adversary A running
in time at most T (λ).
Let RU = {((M,x, t), w) : M accepts (x,w) in t steps}, SU = {(M,x, t) :
∃w, ((M,x, t), w) ∈ RU} and RU (M,x, t) = {w : ((M,x, t), w) ∈ RU}. Let
TM (x,w) denote the number of steps made by M on input (x,w).
Definition 13 (universal argument [2]). A pair of interactive Turing
machines (P, V ) is called a universal argument system if it satisfies the following
properties:
– Efficient verification: There exists a polynomial p such that for any y =
(M,x, t), the total time spent by the (probabilistic) verifier V , on common
input y, is at most p(|y|). In particular, all messages exchanged in the proto-
col have length smaller than p(|y|).
– Completeness via a relatively efficient prover: For every ((M,x, t), w) ∈ RU ,
Pr[〈P (w), V 〉(M,x, t) = 1] = 1.
Furthermore, there exists a polynomial q such that for every ((M,x, t), w) ∈
RU , the total time spent by P (w), on common input (M,x, t), is at most
q(|M | + TM (x,w)) ≤ q(|M | + t).
– Computational soundness: For every polynomial-size circuit family { ˜Pn}n∈N,
and every (M,x, t) ∈ {0, 1}n \ SU , there exists a negligible function ν such
that
Pr[〈 ˜Pn, V 〉(M,x, t) = 1] < ν(n).
– Weak proof-of-knowledge property: For every positive polynomial p there
exists a positive polynomial p′ and a probabilistic polynomial-time oracle
machine E such that the following holds: for every polynomial-size circuit
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 125
family { ˜Pn}n∈N, and every sufficiently long y = (M,x, t) ∈ {0, 1}∗, if
Pr[〈 ˜Pn, V 〉(y) = 1] > 1/p(|y|), then
Prr[∃w = w1 . . . wt ∈ RU (y),∀i ∈ [t], E ˜Pn
r (y, i) = wi] > 1/p′(|y|)
where E
˜Pn
r denotes the function defined by fixing the random-tape of E to r
and providing it with oracle access to ˜Pn.
By abusing the notation, we let E be the oracle machine, running in time
poly(n)·t, that extracts the whole witness. We call E a global proof-of-knowledge
extractor. Note that E is not necessarily polynomial time.
Definition 14 (witness-indistinguishable universal argument [2]). A
universal argument system, (P, V ), is called witness-indistinguishable (WIUA)
if, for every polynomial p, every polynomial-size circuit family {V ∗
n }n∈N, and
every three sequences 〈yn = (Mn, xn, tn)〉n∈N, 〈w1
n〉n∈N and 〈w2
n〉n∈N such that
|yn| = n, tn ≤ p(|xn|) and (yn, w1
n), (yn, w2
n) ∈ RU , the probability ensem-
bles {〈P (w1
n), V ∗
n 〉(yn)}n∈N and {〈P (w2
n), V ∗
n 〉(yn)}n∈N are computationally
indistinguishable.
Theorem 3 [2]. Assuming the existence of families of collision-resistant hash
functions, there exists a 4-round public-coin WIUA.
Definition 15 (special-sound witness-indistinguishable proof [11]). A 4-
round public-coin interactive proof for the language L ∈ NP with witness relation
RL is special-sound with respect to RL, if for any two transcripts (δ, α, β, γ) and
(δ′, α′, β′, γ′) such that the initial two messages, (δ, α) and (δ′, α′), are the same
but the challenges β and β′ are different, there is a deterministic procedure to
extract the witness from the two transcripts and runs in polynomial time. Special-
sound proofs with witness-indistinguishability (WISSP) for languages in NP can
be based on one-way functions.
Definition 16 (ZAP [25]). ZAPs are two round public coin witness indistin-
guishable proofs introduced by Dwork and Naor [18]. ZAPs further have the spe-
cial property that the first message (sent by the prover) can be reused for multiple
proofs. As noted in [3], any ZAP system already has the property of resettable
soundness. Furthermore, resettable witness indistinguishability property can be
obtained by applying the transformation in [8]. We refer to the resulting sys-
tem as an rZAP system having the property of resettable soundness as well as
resettable witness indistinguishability.
2.1 P-Certificate with Delegatable CRS Generation
For c ∈ N, let Lc = {(M,x, y) : M(x) = y within |x|c steps}. Let TM (x) denote
the number of steps made by M on input x.
Definition 17 (P-certificate system [11]). A tuple of PPT algorithms
(Gen,Pcert, Vcert) is a P-certificate system in the CRS model if there exist poly-
nomials lCRS and lπ such that for c, λ ∈ N and q = (M,x, y) ∈ Lc.
126 W. Chongchitmate et al.
– CRS Generation: CRS ← Gen(1λ, c), where Gen runs in time poly(λ). The
length of CRS is bounded by lCRS(λ).
– Proof Generation: π ← Pcert(1λ, c, CRS, q), where Pcert runs in time poly(λ,
|x|, TM (x)) with TM (x) ≤ |x|c. The length of π is bounded by lπ(λ).
– Proof Verification: b = Vcert(1λ, c, CRS, q, π), where Vcert runs in time
poly(λ, |q|).
Completeness: For every c, d, λ ∈ N and q = (M,x, y) ∈ Lc such that |q| ≤ λd,
Pr[CRS ← Gen(1λ, c), π ← Pcert(1λ, c, CRS, q) : Vcert(1λ, c, CRS, q, π) = 1] = 1.
Strong soundness: There exists a super-polynomial function T (λ) = λω(1) and a
super-constant function C(λ) = ω(1) such that for every probabilistic algorithm
P ∗ with running time bounded by T (λ), there exists a negligible function ν such
that for every λ ∈ N and c ≤ C(λ),
Pr
⎡
⎣
(q, st) ← P ∗(1λ, c),
CRS ← Gen(1λ, c),
π ← P ∗(st, CRS)
: Vcert(1λ, c, CRS, q, π) = 1 ∧ q /∈ Lc
⎤
⎦ ≤ ν(λ).
A P-certificate system is two-message if the generation of the CRS Gen also
depends on the statement q, i.e. CRS ← Gen(1λ, c, q). The two-message P-
certificate system can be considered an interactive protocol as follows: the prover
sends q to the verifier; the verifier replies with CRS ← Gen(1λ, c, q); the prover
sends π ← Pcert(1λ, c, CRS, q); the verifier accepts if Vcert(1λ, c, CRS, q, π) = 1.
A two-message P-certificate system has a simple verification procedure if the
verification algorithm Vcert only depends on the security parameter 1λ, the CRS
and the proof π, i.e. it is independent of the statement q and the language index
c. In this case, we denote the verification by Vcert(1λ, CRS, π).
A P-certificate system is unique if for every λ, c ∈ N, CRS, q ∈ {0, 1}∗, there
exists at most one π ∈ {0, 1}∗ such that Vcert(1λ, c, CRS, q, π) = 1.
Note that the uniqueness of a P-certificate holds even against invalid CRS.
Definition 18 (delegatable CRS generation [11]). A two-message P-
certificate (Gen,Pcert,Vcert) has delegatable CRS generation if Gen consists of
three subroutines: SetUp, PreGen and CRSGen, and there exist polynomials ld
and lCRS satisfying the following properties:
– Parameters Generation: (PP,K) ← SetUp(1λ, c), where SetUp is probabilis-
tic and runs in time poly(λ). PP is a public parameter and K is a secret
parameter.
– Statement Processing: d = PreGen(PP, q), where PreGen is deterministic and
runs in time poly(λ, |q|) and the length of d is bounded by ld(λ) independent
of |q|.
– CRS Generation: κ ← CRSGen(PP,K, d), where CRSGen is probabilistic and
runs in time poly(λ) and the length of κ is bounded by lCRS(λ).
Gen outputs CRS = (PP, κ).
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 127
Theorem 4 [11]. Assuming the existence of an indistinguishability obfusca-
tion for P/poly and an injective one-way function (that are super-polynomially
secure), there exists a (super-polynomially secure) two-message P-certificate sys-
tem with (strong) soundness, uniqueness and delegatable CRS generation.
3 Constant-Round Resettable Zero Knowledge
In [11], Chung et al. construct a constant-round concurrent ZK argument assum-
ing the existence of families of collision-resistant hash functions, one-way per-
mutations, and indistinguishability obfuscators for P/poly (with slightly super-
polynomial security). We present it here as follows:
Let com be a non-interactive perfectly binding computationally hiding com-
mitment scheme. As mentioned in [11], the protocol can be modified to work
with a 2-message statistically binding commitment scheme based on one-way
functions [28,32]. Let {Hn}n∈N be a family of collision-resistant hash functions.
Let (Gen,Pcert,Vcert) be a two-message P-certificate system with strong sound-
ness, uniqueness and delegatable CRS generation where Gen consists of subrou-
tines (SetUp,PreGen,CRSGen). Let D = D(n) be a super-constant function such
that D(n) ≤ C(n) for C(·) in Definition 17. Let (PUA, VUA) be a constant-round
public-coin WIUA. Let (PSS , VSS) be a constant-round public-coin WISSP. Let
(PZK , VZK) be a constant-round ZK argument.
Let Πn,c3,PP,K,ρCRSGen
and Π ′
n,c3,κ be programs defined as follows:
Πn,c3,PP,K,ρCRSGen
: on input (d, ρ)
1. If c3 �= com(d; ρ), output ⊥.
2. Output CRSGen(PP,K, d; ρCRSGen).
Π ′
n,c3,κ: on input (d, ρ)
1. If c3 �= com(d; ρ), output ⊥.
2. Output κ.
Let On
Vcert
be a (deterministic) P-certificate oracle which, on input CRS,
outputs a (unique) π such that Vcert(1n, CRS, π) = 1.
Let Emun be a deterministic polynomial-time machine which, on input
(S, y, σ), emulates the execution of the deterministic oracle machine S on input
y with access to the oracle On
Vcert
. Emun simulates On
Vcert
by, on input CRSi in the
ith call from S, checking if πi in σ = (π1, π2, . . .) satisfies Vcert(1n, CRSi, π) = 1.
If so, it returns πi to S, and halts otherwise.
128 W. Chongchitmate et al.
Constant-Round Concurrent Zero-Knowledge Argument Γ [11]
The prover P and the verifier V on common input 1n and x, and private
input w for P :
1. V sends h ← Hn to P .
2. P sends c1 = com(0; ρ1) to V .
3. V sends r ← {0, 1}4n to P .
4. P sends c2 = com(0; ρ2) to V .
5. P and V run (PUA, VUA) for the following statement: either x ∈ L or
there exists S, j ∈ [m], s ∈ {0, 1}n, σ, ρ1, ρ2 such that
– c1 = com(h(S); ρ1) and
– c2 = com(h(q); ρ2) where q = (Emun, (S, (1n, j, s), σ), r).
V rejects if VUA rejects.
6. V runs (PP,K) ← SetUp(1n,D) and sends PP to P .
7. P sends c3 = com(0; ρ3) to V .
8. P and V run (PUA, VUA) so that P proves to V that either x ∈ L or
there exists q, ρ2, ρ3 such that c2 = com(h(q); ρ2) and c3 = com(d; ρ3)
where d = PreGen(PP, q). V rejects if VUA rejects.
9. V computes ̂Π ← iO(Πn,c3,PP,K,ρCRSGen
) and sends ̂Π to P .
10. V and P run (PZK , VZK) so that V proves to P that there exist K,
ρSetUp, ρCRSGen, ρiO such that
– (PP,K) = SetUp(1n,D; ρSetUp) and
– ̂Π = iO(Πn,c3,PP,K,ρCRSGen
; ρiO).
P aborts if VZK rejects.
11. P sends c4 = com(0; ρ4) to V .
12. P and V run (PSS , VSS) so that P proves to V that either x ∈ L or there
exists d, ρ3, ρ4 such that c3 = com(d; ρ3) and c4 = com(CRS; ρ4) where
CRS = (PP, ̂Π(d, ρ3)). V rejects if VSS rejects.
13. P and V run (PSS , VSS) so that P proves to V that either x ∈ L or there
exists CRS, ρ4 and P -certificate π such that c4 = com(CRS; ρ4) and
Vcert(CRS, π) = accept. V accepts if VSS accepts. Otherwise, V rejects.
Theorem 5 [11]. Assuming the existence of families of collision-resistant hash
functions, one-way permutations, and indistinguishability obfuscators for P/poly
that are super-polynomially secure, there exists a constant-round concurrent zero-
knowledge argument for NP.
3.1 From Concurrent ZK to Resettable ZK
Let Γ = (PΓ , VΓ ) be an �-round concurrent ZK argument. We construct a O(�)-
round resettable ZK argument Λ as follows:
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 129
Let com be a non-interactive perfectly binding computationally hiding com-
mitment scheme. Let (PrsZK , VrsZK) be a constant-round resettably-sound ZK
argument with the simulator SimrsZK .
Constant-Round Resettable Zero-Knowledge Argument Λ
The prover P and the verifier V on common input 1n and x, and private
input w for P :
1. V sending m0 = (com(r1), . . . , com(r�)) to P .
2. P chooses a random seed s for a pseudorandom function fs : {0, 1}∗ →
{0, 1}l(n) where l(n) is the upper bound on the size of random bits PΓ
needs in each round of Γ .
3. P and V run Γ with the following modifications:
– For each message mi that VΓ sends in the ith round of Γ , V and P
run (PrsZK , VrsZK) so that V proves to P that mi is computed using
random bits ri committed in m0 in the first round.
– For each message m′
i that PΓ sends in the ith round of Γ , P applies
fs to the transcript so far and uses the output as random bits to
compute m′
i.
3.2 Proofs
Lemma 1. Λ is a resettable ZK argument system.
Proof. First, we consider the protocol ΛF where we replace a pseudorandom
function fs by a truly random function F : {0, 1}∗ → {0, 1}l(n). We argue that
ΛF is indistinguishable from Λ by the reduction to the security of pseudorandom
function as follows. We construct an adversary APRF having access to an oracle
computing either fs or F such that APRF runs Λ (or ΛF ) with the following
modification: for each message m′
i sent by an honest P , APRF asks the oracle
using the transcript of the protocol up to that point as input; it then uses the
oracle output as the random bits to compute m′
i. Finally, APRF runs and outputs
the output of the distinguisher on the view of the protocol. Since APRF runs the
honest P from the beginning to the end, it has access to private parameters of P ,
and thus is able to finish the protocol. Thus, any non-uniform polynomial-size
verifiers must behave in the same way except with negligible probability.
Let V ∗
RES be a resetting verifier in ΛF . We construct a concurrent veri-
fier V ∗
CONC such that for any PCONC there exists PRES such that {viewPRES
V ∗
RES
}
and {viewPCONC
V ∗
CONC
} are computationally indistinguishable as follows: V ∗
CONC runs
V ∗
RES internally and delivers messages between V ∗
RES and PCONC while record-
ing the first message (commitments) of V ∗
RES and every message of PCONC .
130 W. Chongchitmate et al.
Whenever V ∗
RES resets PRES and sends the first message, V ∗
CONC checks if it
has been sent before. If so, V ∗
CONC resends the appropriate responses or continues
the session if necessary. Otherwise, V ∗
CONC starts a new session of PCONC . The
randomness used in this new session is indistinguishable from the randomness
PRES used by applying F to the new transcript (as m0 is different).
Claim. For a fixed seed s and m0, for each i ∈ [�], V ∗
r cannot find two different
messages mi,m
′
i in the ith round such that it can make PRES accepting the ith
resettably-sound ZK argument except with negligible probability.
Proof. Let the first round message m0 = (c1, . . . , c�). Assume for contradiction
that there exists i ∈ [�] such that V ∗
r can find mi �= m′
i and the corresponding
resettably-sound ZK argument that PRES accepts with non-negligible probabil-
ity. In such case, by the resettable soundness of the ZK argument, mi and m′
i are
both computed correctly with respect to the protocol ΛF using the randomness
committed in ci. In other words, there exists a deterministic polynomial-time
function μi such that mi and m′
i have the form mi = μi(ri) with ci = com(ri)
and m′
i = μi(r′
i) with ci = com(r′
i), for some ri �= r′
i. However, this implies
com(ri) = com(r′
i), which contradicts the perfectly binding of com. �
Thus, the transcript of the whole session depends only on s and m0. There-
fore, {viewPRES
V ∗
RES
} and {viewPCONC
V ∗
CONC
} are computationally indistinguishable. �
Lemma 2. Λ is sound.
Proof. Suppose there exists a cheating prover P ∗
RES that can prove a false
theorem x /∈ L with non-negligible probability. Consider the following hybrid
experiments:
Exp0: Run 〈P ∗
RES , VRES〉(1n, x).
Let Exp1,0 be the same as Exp0, and for i = 1, . . . , �,
Exp1,i: Similar to Exp1,i−1 except that the execution of PrsZK(ri) following
the message mi is replaced by the execution of Sim
P ∗
RES,i
rsZK where P ∗
RES,i is the
residual rsZK verifier (note that P ∗
RES runs VrsZK) who has received m0, . . . ,mi
as inputs. Assume for contradiction that there exists a distinguisher D for Exp1,i
and Exp1,i−1. We construct a distinguisher D′ for the (standard) zero-knowledge
property of (PrsZK , VrsZK) as follows. First, we generate r1, . . . , ri−1, ri+1, . . . , r�
uniformly and let c̃i = com(0). Then we produce the transcript for P ∗
RES as in
Λ except that we use c̃i instead of ci = com(ri). By the computational hiding of
com, P ∗
RES cannot distinguish c̃i from ci. Given either {viewPrsZK
VrsZK
} where VrsZK
is run by P ∗
RES,i or Sim
P ∗
RES,i
rsZK , we generate the rest of the transcript for protocol
Λ using rj generated earlier. Finally, D′ runs D on the entire transcript. In
either case, the transcript is computationally indistinguishable to either Exp1,i
or Exp1,i−1. Thus, D′ can break the zero-knowledge property of (PrsZK , VrsZK),
which is a contradiction. Hence, Exp1,i and Exp1,i−1 are indistinguishable.
Let Exp2,0 be the same as Exp1,�, and for i = 1, . . . , �,
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 131
Exp2,i: Similar to Exp2,i−1 except that com(ri) in the first message m0 is
replaced by com(0). Consider the following reduction to the computational hiding
property of com: Acom sends ri and 0 to Scom; it passes the commitment from
Scom as the ith commitment in m0 of Exp2,i−1 (or Exp2,i); Acom can complete
the experiment as it does not need to know which message it commits using
SimrsZK ; Acom outputs the output of the experiment. The computational hiding
property implies that Exp2,i and Exp2,i−1 are indistinguishable.
Now we construct a cheating prover P ∗
CONC for Γ by running Exp2,� inter-
nally as follows: P ∗
CONC sends com(0) to P ∗
RES ; P ∗
c passes every messages from
P ∗
RES to VCONC ; P ∗
CONC passes every message from VCONC to P ∗
RES then runs
SimrsZK while P ∗
RES runs VrsZK . Thus, P ∗
CONC can prove a false theorem x /∈ L
with non-negligible probability, which contradicts the soundness of Γ . �
Theorem 6. Assuming one-way functions, there exists a compiler transforming
an �-round concurrent zero-knowledge argument to a O(�)-round resettable zero-
knowledge argument.
Proof. The resettable zero knowledge and soundness are proved in Lemmas 1
and 2, respectively. The completeness follows from the completeness of Γ by
inspection. For each round of Γ , P and V has to run additional O(1) rounds
for resettably-sound ZK protocol that V uses the committed random bits, and
1 extra round in the beginning. Thus, the round complexity is O(�). �
Corollary 1. Assuming the existence of families of collision-resistant hash
functions, one-way permutations, and indistinguishability obfuscators for
P/poly that are super-polynomially secure, there exists a constant-round reset-
table zero-knowledge argument for NP.
Proof. We instantiate Λ by letting Γ be the constant-round concurrent zero-
knowledge argument system of [11]. Perfectly binding com can be constructed
from one-way permutations. A constant-round resettably-sound ZK argument
can be constructed from one-way functions [12]. �
4 Concurrent ZK with Resettable Soundness
In this section, we construct a constant-round resettably-sound concurrent ZK
argument based on the constant-round cZK argument in [11]. We make use of
our constant-round rZK argument from the previous section (Corollary 1), the
technique used in [3] to add resettable soundness to a public-coin protocol, and
our new techniques to deal with non-public coin nature of the cZK protocol
in [11].
4.1 Construction
Let Γ be the constant-round concurrent ZK argument from [11] described in
Sect. 3. We construct a constant-round concurrent ZK argument with resettable
soundness Δ as follows:
132 W. Chongchitmate et al.
Let (PrZK , VrZK) be a constant-round resettable ZK argument with the sim-
ulator SimrZK . The verifier V chooses a random seed s for a pseudorandom
function fs : {0, 1}∗ → {0, 1}l(n), where l(n) is the upper bound on the size of
random bits V need in each round of Γ . Then P and V run Γ with the following
modifications. In Step 10, instead of running a ZK argument (PZK , VZK), V and
P run the resettable ZK argument (PrZK , VrZK). Additionally, for each message
m that V sends in Γ , V uses the output of fs applying to the transcript from
the protocol up to this point as random bits to compute m.
4.2 Proofs
Before we prove that the protocol above is a concurrent ZK argument with
resettable soundness, we consider another modification, Γ ′, of the protocol Γ
in [11]. First, P and V repeat Steps 7–9 for t times with V using the same
ρCRSGen for some t = poly(n). Let Steps 7j–9j denoted jth repeat of Steps 7–9.
Secondly, we remove the zero-knowledge proof in Step 10, and replace it with
“P chooses i ∈ [t] and sends i to V ”, and then P and V follows the rest of the
protocol ignoring Steps 7j–9j for j �= i.
Lemma 3. Γ ′ is a sound interactive argument.
Proof. We strictly follow the proof of soundness of Γ in [11] with a modification
necessary for the repetition of Steps 7–9. Assume for contradiction that there is a
non-uniform deterministic polynomial-time prover P ∗ and a positive polynomial
p such that for infinitely many n ∈ N, P ∗ can convince V to accept x /∈ L
with non-negligible probability 1/p(n). Let E be the global proof-of-knowledge
extractor of the WIUA (PUA, VUA), and E′ be the knowledge extractor of the
WISSP (PSS , VSS). We define the experiment Exp which runs 〈P ∗, V 〉(1n, x)
with the following addition:
– In Step 5, let P ∗
prefix1
be the residual WIUA prover who has received prefix1 =
(h, r) in Steps 1 and 3. Run w1 ← E
P ∗
prefix1
s1 , where s1 is uniform randomness.
If E fails, halt and output ⊥.
– In Step 7j, for j = 1, . . . , t, let P ∗
prefix2,j
be the residual WIUA prover who has
received prefix2,j consisting of h, r, WIUA messages, PP and ̂Πk in Steps 1,
3, 5, 6, 8k and 9k for k = 1, . . . , j − 1. Run w2,j ← E
P ∗
prefix2,j
s2,j , where s2,j is
uniform randomness. If E fails, halt and output ⊥.
– In Step 12, let P ∗
prefix3
be the residual WISSP prover who has received prefix3
consisting of h, r, WIUA messages, PP and ̂Πj in Steps 1, 3, 5, 6, 8j and 9j
for j = 1, . . . , t. Run w3 ← E
′P ∗
prefix3
s3 , where s3 is uniform randomness. If E′
fails, halt and output ⊥.
– In Step 13, let P ∗
prefix4
be the residual WISSP prover who has received prefix4
consisting of prefix3 and WISSP messages in Step 12. Run w4 ← E
′P ∗
prefix4
s4 ,
where s4 is uniform randomness. If E′ fails, halt and output ⊥.
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 133
– If V rejects, output ⊥. Otherwise,
• Parse w1 = (S, j, s, σ, ρ1, ρ2). If w1 does not have this form, output ⊥.
• Let q = (Emun, (S, (1n, j, s), σ), r). For j = 1, . . . , t, if w2,j �= (q, ρ2,j , ρ3,j)
for some ρ2,j , ρ3,j , output ⊥.
• Let d = PreGen(PP, q). If w3 �= (d, ρ3,i, ρ4) for some ρ4 where i ∈ [t] is
chosen by P ∗ in Step 10, output ⊥.
• Let CRS = (PP, ̂Π(d, ρ3,i)). If w4 �= (CRS, ρ4, π) for some π, output ⊥.
– output (S, q, r).
By the weak proof-of-knowledge property of WIUA and special soundness of
WISSP, when P ∗ convinces V to accept x /∈ L, the extractors E and E′ succeed
in extracting the witnesses described above (instead of the actual witness of the
theorem) with non-negligible probability 1/p′(n). By perfectly binding property
of com and collision-resistance of H, the consistency check in the last step will
pass except with negligible probability ν(n). In this case, except with negligible
probability, c3,j sent in Step 7j is com(d; ρ3,j) for the same d = PreGen(PP, q) for
all j = 1, . . . , t. Otherwise, we can construct a cheating WIUA prover that com-
mits to c′ = com(d′; ρ′) with d′ �= PreGen(PP, q) with non-negligible probability
by randomly pick j ∈ [t] and commit to c′ = c3,j . This breaks the soundness
of WIUA. So, the only output of ̂Πj is CRSGen(PP,K, d, ρCRSGen) = κ for all
j = 1, . . . ,m except with negligible probability ν′(n). Thus, the probability that
Exp does not output ⊥ and every ̂Πj output the same κ is 1/p′(n)−ν(n)−ν′(n)
which is non-negligible. We call this event Good.
Now consider a series of experiments Exp′
j for j ∈ [t] defined as follows:
Exp′
0 = Exp, and Exp′
j differs from Exp′
j−1 in Step 9j where we replace ̂Πj ←
iO(Πn,c3,j ,PP,K,ρCRSGen
) with ̂Π ′
j ← iO(Π ′
n,c3,j ,κ) where κ = CRSGen(PP,K, d;
ρCRSGen). When Good occurs, by perfectly binding property of com, Π ′
n,c3,j ,κ and
Πn,c3,j ,PP,K,ρCRSGen
are functionally equivalent except with negligible probability.
In this case, Exp′
j−1 and Exp′
j are indistinguishable by the reduction to iO as
follows: DiO runs Exp′
j−1 (or Exp′
j) up to Step 8j and outputs Π ′
n,c3,j ,κ and
Πn,c3,j ,PP,K,ρCRSGen
and the state of the experiment z; up to receiving obfuscated
program ̂Π and z, AiO sends ̂Π to P ∗, continues the experiment until the end,
and outputs the output of the experiment. Thus, Exp′
j−1 and Exp′
j are indistin-
guishable by the security of iO. Hence, by hybrid argument, the probability of
Good event is non-negligible in Exp′
j for j = 1, . . . , t. Let Exp′ = Exp′
t.
Now suppose that Good and q is false occurs with non-negligible proba-
bility. Then we construct P ∗
Pcert that breaks the strong soundness of the P-
certificate system as follows: P ∗
Pcert runs Exp′ up to Step 5 where it extracts q
from w1. Up on receiving CRS = (PP, κ) where (PP,K) ← SetUp(1n,D) and
κ ← CRSGen(PP,K,PreGen(PP, q)), it continues Exp′ using PP and κ and out-
put π extracted from w4. If Good occurs, by the soundness of WISSP, P ∗
Pcert
succeeds and Vcert(CRS, π) = 1 except with negligible probability. Thus, P ∗
Pcert
contradicts the strong soundness of the P-certificate system. Hence, Good and
q is true occurs with non-negligible probability. We call this event Good′. By
averaging argument, there exists h such that Good′|h occurs with non-negligible
probability.
134 W. Chongchitmate et al.
Finally, consider Exp′′ where Exp′ is run twice with this h but with the
second execution replacing r in Step 3 by an independent random string r′.
With non-negligible probability, both executions succeed and output (S, q, r) and
(S′, q′, r′). Since c1 must be the same in both executions, S = S′ except with neg-
ligible probability by perfectly binding property of com and collision-resistance
of H. Since q = (Emun, (S, (1n, j, s), σ), r) and q′ = (Emun, (S, (1n, j′, s′), σ′), r′)
are true, we have SOn
Vcert (1n, j, s) = r and SOn
Vcert (1n, j′, s′) = r′. We have that
|(1n, j, s)| < 3n < 4n = |r| and |(1n, j′, s′)| < |r′|. However, the deterministic
machine SOn
Vcert predicts independent r and r′ with non-negligible probability.
This is information theoretically impossible as there are at most 23n possible
outputs for SOn
Vcert . Thus, we reach a contradiction.
As in the proof of soundness of Γ in [11], the WIUA global proof-of-knowledge
extractor E runs in super-polynomial time as a part of the witness q is of
super-polynomial size. Thus, the collision-resistant hash functions H, the com-
mitment scheme com and indistinguishability obfuscators iO need to be super-
polynomially secure. �
Now we can prove the main theorem of this section.
Theorem 7. Δ is a concurrent ZK argument with resettable soundness.
Proof. Since the rZK argument (PrZK , VrZK) is also a ZK argument and we only
further modify an honest verifier V , the concurrent zero-knowledge of Δ follows
directly from the concurrent zero-knowledge property of Γ . Now we consider the
protocol ΔF where we replace a pseudorandom function fs by a truly random
function F : {0, 1}∗ → {0, 1}l(n). We argue that ΔF is indistinguishable from
Δ by the reduction to the security of pseudorandom function as follows. Fix
x /∈ L and P ∗
RES that convinces a resettable verifier VRES to accept x /∈ L with
probability ε through protocol ΔF . We construct an adversary APRF having
access to an oracle computing either fs or F such that APRF runs Δ (or ΔF )
with the following modification: for each message m sent by an honest VRES ,
APRF asks the oracle using the transcript of the protocol up to that point as
input; it then uses the oracle output as the random bits to compute m. APRF
outputs the output of V . Since APRF runs the honest VRES from the beginning
to the end, it has access to private parameter K that V generates in Step 6, and
thus is able to compute the obfuscated program and rZK messages in Steps 9
and 10. Thus, any non-uniform polynomial-size provers must behave in the same
way except with negligible probability. Hence, the completeness follows from the
completeness of Γ .
We now show the resettable soundness of the protocol. Assume for contra-
diction that there is a non-uniform polynomial-time resetting prover P ∗
RES that
convinces a resettable verifier VRES to accept x /∈ L with probability ε through
protocol ΔF . We construct a polynomial-time (standard) prover P ∗
S , emulating
P ∗
RES , that convinces a (standard) verifier VS to accept the same x /∈ L through
protocol Γ ′ repeating Steps 7–9 for t times, where t = poly(n) is the total
number of messages sent by P ∗
RES . Let c be the number of (prover) rounds in Δ.
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 135
The cheating prover P ∗
S proceeds as follows. First it uniformly selects
i1, . . . , ic ∈ {1, . . . , t}. It invokes P ∗
RES while emulating VRES . In the jth round
of ΔF , P ∗
S answers a message from P ∗
RES according to the following cases:
– If the prefix of the current session transcript is identical to a corresponding
prefix of a previous session, then P ∗
CONC answers by using the same answer
it has given in the previous session.
– Otherwise, P ∗
S either forwards the message to VS and then forwards the reply
it receives, or generates the reply itself according to the following conditions:
• If the message is c3 or WIUA in Steps 7j–8j, P ∗
S repeats its decision
whether to forward the message in Step 6. In other words, if P ∗
S forwards
the message in Step 6, it will forward this message. If it generates the reply
in Step 6 itself, it will generate the reply for this message as well. This is
because it can only generate an answer in Step 9i if it has generated the
answer in Step 6 of the same transcript (instead of passing to VS).
• If the message is i ∈ [t] in Step 10, P ∗
S does not forward the message, but
instead runs the simulator SimrZK with P ∗
RES corresponding to obfus-
cated program in Step 9i.
• If the index of the current message from P ∗
RES does not equal to ij selected
previously, P ∗
S generates a reply message using a uniformly selected ran-
dom bits.
• Otherwise, P ∗
S forwards the current message to VS and sends P ∗
RES a
reply it receives from VS .
In each case, P ∗
CONC records the messages from both sides for later use.
By the resettable zero-knowledge of (PrZK , VrZK), the probability of P ∗
RES
proving a false theorem x /∈ L only changes negligibly by running SimrZK instead
of PrZK . By the property of truly random function, the view of P ∗
RES is identical
to the distribution that P ∗
RES sees when interacting with an honest VRES . If
the chosen i1, . . . , ic equal the indices of the messages that correspond to the c
messages sent in a session in which P ∗
RES convinces VRES to accept x /∈ L, then
P ∗
S will also convince VS to accept x /∈ L by our construction of VRES . Thus,
the probability of VS accepting x /∈ L is at least ε/tc − ν(n) for some negligible
function ν. This probability is non-negligible. Therefore, it contradicts Lemma3.
�
Let Λ = (PrZK , VrZK) be the constant-round resettable ZK protocol
obtained in Corollary 1, we get the following corollary.
Corollary 2. Assuming the existence of families of collision-resistant hash
functions, one-way permutations, and indistinguishability obfuscators for P/poly
that are super-polynomially secure, there exists a constant-round resettably-sound
concurrent zero-knowledge argument for NP.
5 Simultaneous Resettable ZK
To obtain our main theorem, we apply a combination of the transformations in
Theorem 4 and 5 in Sect. 6, and Theorem 6 and 7 in Appendix C of [25] to our
protocol in Sect. 4 to obtain simultaneous resettability.
136 W. Chongchitmate et al.
More specifically, we combine three transformations in [25]:
– from resettably-sound (relaxed) concurrent zero-knowledge argument to
hybrid-sound hybrid-resettable zero-knowledge argument;
– from hybrid-sound zero-knowledge argument to resettably-sound zero-
knowledge argument while maintaining (hybrid) resettability;
– from hybrid-resettable zero-knowledge argument to resettable zero-knowledge
argument while maintaining (hybrid) resettable soundness.
We refer to Sect. 1 for an informal discussion and [25] for formal definitions of
relaxed concurrent zero-knowledge, hybrid resettability and hybrid soundness.
Theorem 8 (implied from [25]). Assuming the existence of ZAPs (i.e., 2-
round resettably-sound resettable witness-indistinguishable proof systems) and
family of pseudorandom functions, there exists a transformation from an �-round
resettably-sound concurrent zero-knowledge argument to a O(�)-round resettably-
sound resettable zero-knowledge argument.
Applying the transformations to the protocol Δ in Corollary 2 results in the
following theorem. Note that ZAPs can be constructed from iO and one-way
functions [6], which can then be transformed to have resettable soundness and
resettable witness indistinguishability. Furthermore, only the first transformation
is based on ZAPs while all of them assume pseudorandom functions.
Theorem 9. Assuming the existence of families of collision-resistant hash func-
tions, one-way permutations, and indistinguishability obfuscators for P/poly
that are super-polynomially secure, there exists a constant-round resettably-sound
resettable zero-knowledge argument for NP.
Acknowledgments. Research supported in part by “GNCS - INdAM”, EU COST
Action IC1306, NSF grants 1065276, 1118126, 1136174 and 1619348, DARPA, US-
Israel BSF grant 2008411 and 2012366, OKAWA Foundation Research Award, IBM
Faculty Research Award, Xerox Faculty Research Award, B. John Garrick Foundation
Award, Teradata Research Award, and Lockheed-Martin Corporation Research Award.
This material is based upon work supported in part by DARPA Safeware program. The
views expressed are those of the authors and do not reflect the official policy or position
of the Department of Defense or the U.S. Government. The work of the 3rd author has
been done in part while visiting UCLA.
References
1. Barak, B.: How to go beyond the black-box simulation barrier. In: FOCS 2001, pp.
106–115 (2001)
2. Barak, B., Goldreich, O.: Universal arguments and their applications. SIAM J.
Comput. 38(5), 1661–1694 (2008)
3. Barak, B., Goldreich, O., Goldwasser, S., Lindell, Y.: Resettably-sound zero-
knowledge and its applications. In: FOCS 2002, pp. 116–125 (2001)
4. Bitansky, N., Paneth, O.: On the impossibility of approximate obfuscation and
applications to resettable cryptography. In: STOC 2013 (2013)
Resettably-Sound Resettable Zero Knowledge in Constant Rounds 137
5. Bitansky, N., Paneth, O.: On non-black-box simulation and the impossibility of
approximate obfuscation. SIAM J. Comput. 44(5), 1325–1383 (2015)
6. Bitansky, N., Paneth, O.: ZAPs and non-interactive witness indistinguishability
from indistinguishability obfuscation. In: Dodis, Y., Nielsen, J.B. (eds.) TCC
2015. LNCS, vol. 9015, pp. 401–427. Springer, Heidelberg (2015). doi:10.1007/
978-3-662-46497-7 16
7. Brassard, G., Chaum, D., Crépeau, C.: Minimum disclosure proofs of knowledge.
J. Comput. Syst. Sci. 37(2), 156–189 (1988)
8. Canetti, R., Goldreich, O., Goldwasser, S., Micali, S.: Resettable zero-knowledge
(extended abstract). In: STOC 2000, pp. 235–244 (2000)
9. Cho, C., Ostrovsky, R., Scafuro, A., Visconti, I.: Simultaneously resettable argu-
ments of knowledge. In: Cramer, R. (ed.) TCC 2012. LNCS, vol. 7194, pp. 530–547.
Springer, Heidelberg (2012). doi:10.1007/978-3-642-28914-9 30
10. Chung, K.M., Lin, H., Pass, R.: Constant-round concurrent zero knowledge from
p-certificates. In: FOCS 2013, pp. 50–59. IEEE (2013)
11. Chung, K.-M., Lin, H., Pass, R.: Constant-round concurrent zero-knowledge from
indistinguishability obfuscation. In: Gennaro, R., Robshaw, M. (eds.) CRYPTO
2015. LNCS, vol. 9215, pp. 287–307. Springer, Heidelberg (2015). doi:10.1007/
978-3-662-47989-6 14
12. Chung, K.-M., Ostrovsky, R., Pass, R., Venkitasubramaniam, M., Visconti, I.: 4-
round resettably-sound zero knowledge. In: Lindell, Y. (ed.) TCC 2014. LNCS, vol.
8349, pp. 192–216. Springer, Heidelberg (2014). doi:10.1007/978-3-642-54242-8 9
13. Chung, K.M., Ostrovsky, R., Pass, R., Visconti, I.: Simultaneous resettability from
one-way functions. In: FOCS 2013, pp. 60–69. IEEE (2013)
14. Chung, K.M., Pass, R., Seth, K.: Non-black-box simulation from one-way functions
and applications to resettable security. In: STOC 2013. ACM (2013)
15. Deng, Y., Goyal, V., Sahai, A.: Resolving the simultaneous resettability conjecture
and a new non-black-box simulation strategy. In: FOCS 2009, pp. 251–260. IEEE
(2009)
16. Deng, Y., Lin, D.: Instance-dependent verifiable random functions and their
application to simultaneous resettability. In: Naor, M. (ed.) EUROCRYPT
2007. LNCS, vol. 4515, pp. 148–168. Springer, Heidelberg (2007). doi:10.1007/
978-3-540-72540-4 9
17. Di Crescenzo, G., Persiano, G., Visconti, I.: Constant-round resettable zero knowl-
edge with concurrent soundness in the bare public-key model. In: Franklin, M.
(ed.) CRYPTO 2004. LNCS, vol. 3152, pp. 237–253. Springer, Heidelberg (2004).
doi:10.1007/978-3-540-28628-8 15
18. Dwork, C., Naor, M.: Zaps and their applications. In: FOCS 2000, pp. 283–293.
IEEE (2000)
19. Dwork, C., Naor, M., Sahai, A.: Concurrent zero-knowledge. In: STOC 1998, pp.
409–418. ACM (1998)
20. Feige, U., Shamir, A.: Witness indistinguishable and witness hiding protocols. In:
STOC 1990, pp. 416–426 (1990)
21. Garg, S., Ostrovsky, R., Visconti, I., Wadia, A.: Resettable statistical zero knowl-
edge. In: Cramer, R. (ed.) TCC 2012. LNCS, vol. 7194, pp. 494–511. Springer,
Heidelberg (2012). doi:10.1007/978-3-642-28914-9 28
22. Goldreich, O.: Foundations of Cryptography - Basic Tools. Cambridge University
Press, Cambridge (2001)
23. Goldwasser, S., Micali, S.: Probabilistic encryption. J. Comput. Syst. Sci. 28(2),
270–299 (1984)
http://dx.doi.org/10.1007/978-3-662-46497-7_16
http://dx.doi.org/10.1007/978-3-662-46497-7_16
http://dx.doi.org/10.1007/978-3-642-28914-9_30
http://dx.doi.org/10.1007/978-3-662-47989-6_14
http://dx.doi.org/10.1007/978-3-662-47989-6_14
http://dx.doi.org/10.1007/978-3-642-54242-8_9
http://dx.doi.org/10.1007/978-3-540-72540-4_9
http://dx.doi.org/10.1007/978-3-540-72540-4_9
http://dx.doi.org/10.1007/978-3-540-28628-8_15
http://dx.doi.org/10.1007/978-3-642-28914-9_28
138 W. Chongchitmate et al.
24. Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive
proof-systems. In: STOC 1985, pp. 291–304. ACM (1985)
25. Goyal, V., Sahai, A.: Resolving the simultaneous resettability conjecture and a
new non-black-box simulation strategy. IACR Cryptology ePrint Archive 2008/545
(2008)
26. Goyal, V., Sahai, A.: Resettably secure computation. In: Joux, A. (ed.) EURO-
CRYPT 2009. LNCS, vol. 5479, pp. 54–71. Springer, Heidelberg (2009). doi:10.
1007/978-3-642-01001-9 3
27. Groth, J., Ostrovsky, R., Sahai, A.: Non-interactive zaps and new techniques for
NIZK. In: Dwork, C. (ed.) CRYPTO 2006. LNCS, vol. 4117, pp. 97–111. Springer,
Heidelberg (2006). doi:10.1007/11818175 6
28. H̊astad, J., Impagliazzo, R., Levin, L., Luby, M.: A pseudorandom generator from
any one-way function. SIAM J. Comput. 28, 12–24 (1999)
29. Kilian, J., Petrank, E.: Concurrent and resettable zero-knowledge in poly-
loalgorithm rounds. In: STOC 2001, pp. 560–569 (2001)
30. Lindell, Y.: Foundations of cryptography 89-856 (2010). http://u.cs.biu.ac.il/
lindell/89-856/complete-89-856.pdf
31. Micali, S., Reyzin, L.: Soundness in the public-key model. In: Kilian, J. (ed.)
CRYPTO 2001. LNCS, vol. 2139, pp. 542–565. Springer, Heidelberg (2001). doi:10.
1007/3-540-44647-8 32
32. Naor, M.: Bit commitment using pseudorandomness. J. Cryptol. 4(2), 151–158
(1991)
33. Ostrovsky, R., Visconti, I.: Simultaneous resettability from collision resistance.
In: Electronic Colloquium on Computational Complexity (ECCC), vol. 19, p. 164
(2012)
34. Scafuro, A., Visconti, I.: On round-optimal zero knowledge in the bare public-key
model. In: Pointcheval, D., Johansson, T. (eds.) EUROCRYPT 2012. LNCS, vol.
7237, pp. 153–171. Springer, Heidelberg (2012). doi:10.1007/978-3-642-29011-4 11
35. Yung, M., Zhao, Y.: Generic and practical resettable zero-knowledge in the bare
public-key model. In: Naor, M. (ed.) EUROCRYPT 2007. LNCS, vol. 4515, pp.
129–147. Springer, Heidelberg (2007). doi:10.1007/978-3-540-72540-4 8
http://dx.doi.org/10.1007/978-3-642-01001-9_3
http://dx.doi.org/10.1007/978-3-642-01001-9_3
http://dx.doi.org/10.1007/11818175_6
http://u.cs.biu.ac.il/lindell/89-856/complete-89-856.pdf
http://u.cs.biu.ac.il/lindell/89-856/complete-89-856.pdf
http://dx.doi.org/10.1007/3-540-44647-8_32
http://dx.doi.org/10.1007/3-540-44647-8_32
http://dx.doi.org/10.1007/978-3-642-29011-4_11
http://dx.doi.org/10.1007/978-3-540-72540-4_8
	Resettably-Sound Resettable Zero Knowledge in Constant Rounds
	1 Introduction
	1.1 Our Results
	1.2 Main Tools and Our New Techniques
	1.3 Our Approach
	1.4 Open Questions
	2 Definitions
	2.1 P-Certificate with Delegatable CRS Generation
	3 Constant-Round Resettable Zero Knowledge
	3.1 From Concurrent ZK to Resettable ZK
	3.2 Proofs
	4 Concurrent ZK with Resettable Soundness
	4.1 Construction
	4.2 Proofs
	5 Simultaneous Resettable ZK
	References