Public Key Timed-Release Searchable Encryption
Public Key Timed-Release Searchable Encryption
Ke Yuan, Zheli Liu, Chunfu Jia*, Jun Yang
College of Information Technical Science
Nankai University
Tianjin, China
Email: {yuanke hhhh, liuzheli1978}@163.com,
cfjia@nankai.edu.cn, yangjun19910112@yahoo.cn
Shuwang Lv
State Key Laboratory of Information Security
Chinese Academy of Sciences
Beijing, China
Email: swlu@ustc.edu.cn
Abstract—This paper introduces and explores a new concept
of timed-release searchable encryption (TRSE) which can be
used to solve the time-sensitive ciphertext retrieval problem.
In this paper, we preliminarily focus on the PKTRSE which
is a kind of public key TRSE. In our PKTRSE model, the
sender encrypts a message so that only the intended receiver
can search target ciphertext containing specified keywords after
a pre-set release time in the future. We begin by explaining
what is PKTRSE and introducing the application scenario of
PKTRSE. Then, we show the preconditions of timed-release
public key encryption combining other asymmetric crypto-
graphic mechanisms. Afterwards, we formalize the notion of
PKTRSE and its security game model. Finally, we give two
construction schemes of PKTRSE: A generic scheme and a
concrete scheme which are secure under the BDH assumption
in the random oracle model.
Keywords-timed-release; searchable encryption; time trap-
door; keyword trapdoor; provable security
I. INTRODUCTION
Time has always played an important role in time-
sensitive practical applications, as well as keyword has
always performed a critical role in information retrieval. The
goal of timed-release searchable encryption (TRSE) is to
send a message with keyword into the future. It has two
properties of time and keyword. The property of time here
means to encrypt a message such that the receiver cannot
decrypt the ciphertext until a specific time in the future.
This is called timed-release encryption which is abbreviated
as TRE [1]. Most of the TRE schemes adopt asymmetric
cryptographic mechanism, such TRE is called as TR-PKE
(timed-release public key encryption) [2]. The property of
keyword here means to enable the sender to send a trapdoor
TW to the server which will enable the server to locate all
messages containing the keyword W , but learn nothing else.
This is called searchable encryption which is abbreviated as
SE. SE includes symmetric SE (SSE) [3], [4], [5], [6], [7],
[8] and asymmetric SE (PEKS) [9], [10], [11], [12], [13],
[14], [15], [16], [17], [18], [19]. Public key timed-release
searchable encryption or public key timed-release encryption
with keyword search, which is abbreviated as PKTRSE, is
a combination of TR-PKE and PEKS.
PKTRSE is a kind of TRSE adopting asymmetric crypto-
graphic mechanism. Asymmetric cryptographic mechanism
has some good characteristics, especially the one which can
integrate different cryptographic mechanism conveniently.
Hence, we preliminarily focus on the PKTRSE in this paper
and we defer the scheme involving symmetric cryptographic
mechanism to the succession of this paper.
A. Our Contribution
The contribution of this paper is to solve the time-
dependent ciphertext retrieval problem by combining the
existing cryptographic mechanism TR-PKE and PEKS. We
show the preconditions of TR-PKE combining other asym-
metric cryptographic mechanisms and formalize the notion
of PKTRSE. Then we provide a generic scheme and a
provably secure concrete scheme for PKTRSE, which are
based on the BDH problem. We also prove the concrete
scheme semantically secure against a chosen plaintext attack
in the random oracle model.
Our primary technique is that we detail how to combine
TR-PKE with PEKS. There are two public/private key pairs
(tspub, tspriv) of the time server and (upkr, uskr) of the re-
ceiver in TR-PKE, encrypting plaintext uses tspub and upkr,
decrypting ciphertext uses the time trapdoor ST (generated
by using tspriv) and uskr. There are a public/private key pair
(upkr, uskr) of the receiver in PEKS, encrypting plaintext
and testing keyword trapdoor TW use the upkr, decrypting
ciphertext and generating TW use uskr. In PKTRSE, the
same keys as in TR-PKE are used, but the usage pattern
is different. The sender uses tspub to test ST , uses upkr
to test TW and encrypt plaintext; the receiver uses tspriv
to generate ST , uses uskr to generate TW and decrypt
ciphertext. Our method is very concise and efficient.
B. Applications of PKTRSE
PKTRSE would have many practical applications, for
example, timed-release email, timed-release electronic con-
fidential archives, electronic magazine, timed-release out-
sourcing compution, electronic bidding and so on.
Timed-release email is a typical one to one PKTRSE
application scene. Suppose Alice receive many emails, she
2013 Fourth International Conference on  Emerging Intelligent Data and Web Technologies
978-0-7695-5044-2/13 $26.00 © 2013 IEEE
DOI 10.1109/EIDWT.2013.47
241
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:44:35 UTC from IEEE Xplore.  Restrictions apply. 
wants to read some emails with some specific keywords
but doesn’t want the email server know any information
about the email and the keywords. Besides, suppose Bob
sends an email to Alice doesn’t permit Alice to read it until
the appointed time. To meet the above two requirements,
Bob encrypts his email using a standard public key system.
He then appends to the resulting ciphertext a TAG of
release time and each keyword. To send a message M with
keywords W1, ...,Wl Bob sends
[EApub
(M)||TAG(Apub, tspub,W1, T )||
· · · ||TAG(Apub, tspub,Wl, T )]
to the email server, where Apub is Alice’s public key, tspub
is the public key of the time server. The point of this
form of encryption is that Alice can give the email server
a certain keyword trapdoor TW and release time trapdoor
ST that enable the email server to test whether a time
associated with the message is equal to the release time
T and whether one of the keywords associated with the
message is equal to the word W of Alice’s choice. Given
TAG(Apub, tspub,W
′, T ′), TW and ST the email server
can test whether W = W ′, T = T ′. If W = W ′ and
T = T ′ the email server learns nothing more about W ′ and
T ′. Noting that Alice and Bob do not communicate in this
entire process, Bob generates the timed-release searchable
encryption for W ′ and T ′ just given the public key of Alice
and the time server.
Electronic magazine is a typical one to many PKTRSE
application scene. The publisher of the electronic magazine
send the ciphertext of the magazine appending a TAG
with keywords and release time. The authorized users can
catch their interest articles by search corresponding key-
words when the release time comes. we will give detailed
description of electronic magazine scene and propose its
solutions using the cryptographic technique of identity-based
broadcast encryption (IBBE [20]) in the succession of this
paper.
C. Related Work
We provide a brief overview of the TRE and the PEKS
as follows:
TRE allows a sender to encrypt a message so that no one
else except the intended receiver can read it only after a
pre-set time in the future. The problem of TRE was first
advocated by May [21] in 1993 and demonstrated in detail
by Rivest et al. [1] in 1996. And since then, extraordinary
progress has been made in its theory and practice, which
demonstrates its mighty application values. In theoretical
aspect, some new concepts of TRE was proposed in suc-
cession. The first attempt at scalable, server-passive, user-
anonymous TRE was due to Blake and Chan [22] and the
first try at TRE with pre-open capability (TRE-PC) was
due to Hwang et al. [23] in 2005. Afterwards, CHEON
et al. [2] formalized the concept of a secure timed-release
public key cryptosystem in 2008. More recently, Emura et
al. [24] firstly proposed timed-release proxy re-encryption
(TR-PRE) for solving the TRE problem of multiple receivers
with the same release time and Paterson et al. [25] firstly
proposed time-specific encryption (TSE) where an encryptor
can specify a suitable time interval such that the ciphertexts
may only be decrypted within this time interval in 2010.
In practical aspect, TRE has been utilized in AFPC [26],
OT [27], UWSNs [28].
PEKS enables a server to test whether a tag from a
sender and a keyword trapdoor from a receiver contain the
same keyword. The question of PEKS was first proposed
by Boneh et al. [9] in 2004. Since then, many revisions
and extensions have been given. Byun et al. [10] showed
that PEKS might be attacked by the off-line keyword-
guessing attacks in 2006. To solve this problem, Baek et
al. [11] proposed a new PEKS called SCF-PEKS in 2008.
In 2004, A new PEKS called PECKS for solving conjunctive
keyword search was proposed by Park et al. [12], further,
Zhang et al. [13] proposed PECSK which extend PECKS
to solve conjunctive with subset keywords search in 2011.
Li et al. [19] proposed a novel framework for outsourcing
and sharing searchable encrypted data on hybrid cloud in
2012. Some other extensions of PEKS such as PETKS [14],
mPECK [15], PERKS [16], PKEDS [17], PEMKS [18] were
also proposed.
D. Organization
We begin by explaining what is PKTRSE and introducing
the application scene of PKTRSE. In Section II we review
our security assumptions and show the preconditions of TR-
PKE combining other public key cryptographic mechanisms.
In Section III We formalize the notion of PKTRSE and
its security game model. In Section IV we provide two
construction schemes for PKTRSE. Finally, we conclude in
Section V .
II. PRELIMINARIES
Below, we briefly review the definitions of bilinear map
and discuss the complexity assumption on which the security
of our schemes are based. Then, we also give the precondi-
tions of TRE combining other cryptographic mechanisms.
A. Complexity Assumptions
1) Bilinear Diffie-Hellman (BDH) Problem: Let G1 and
G2 be two groups of order p for some large prime p. The
group G1 is a subgroup of the additive group of points of
an elliptic curve. The group G2 is a subgroup of the multi-
plicative group. A bilinear map is a map e : G1×G1 → G2
satisfies the following properties:
• Computable: There is an efficient algorithm to compute
e(P,Q) ∈ G2 for any P,Q ∈ G1.
242
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:44:35 UTC from IEEE Xplore.  Restrictions apply. 
• Bilinear: For any integers a, b ∈ Z∗p we have e(aP, bQ)
= e(P,Q)ab.
• Non-degenerate: If P is a generator of G1 then e(P, P )
is a generator of G2.
The BDH problem [29] in G1 is as follows: given a tuple
P, aP, bP, cP ∈ G1 as input, output e(P, P )abc ∈ G1. An
attacker A has advantage ε in solving BDH in G1 if
Pr[A(P, aP, bP, cP ) = e(P, P )abc] ≥ ε
where the probability is over the random choice of generator
P ∈ G∗1, the random choice of a, b, c ∈ Z∗p , and the random
bits used by A.
Definition 1: We say that (t, ε)-BDH assumption holds in
G1 if no t-time algorithm has advantage at least ε in solving
the BDH problem in G1.
B. Preconditions
Bilinear pairing has the following linear property: e(P +
Q,R) = e(P,R)e(Q,R), e(P,Q+R) = e(P,Q)e(P,R) for
any P,Q,R ∈ G1. Accordingly, we can deduce an equation:
e(aP, bQ) = e(abP,Q) = e(P, abQ) = e(bP, aQ) =
e(P,Q)ab for any a, b ∈ Z∗p , P,Q ∈ G1. This equation
shows bilinear property which the element coefficient can
move between the elements in bilinear pairing and we
mainly use of this feature for combining TR-PKE with other
cryptographic mechanisms. To use this feature, we require
the following preconditions:
Requirement 1: The private/public key pair of the time
server is in the form similar to (s, sP ) and the time
trapdoor is in the form similar to sH(T ) for any s ∈ Z∗p ,
P,H(T ) ∈ G1.
Requirement 2: The private/public key pair of the user
is in the form similar to (u, uP ) for any u ∈ Z∗p , P ∈ G1.
Many concrete schemes of TRE meet the Requirement 1
and many cryptographic mechanisms, such as IBE, PEKS,
IBBE, TBE meet the Requirement 2. Consequently, many
cryptographic mechanisms can combine TRE for solv-
ing more time-sensitive cryptographic problems. A generic
scheme and a concrete scheme of PEKS combining TR-
PKE, i.e.PKTRSE, based on the BDH problem are proposed
in section IV .
III. PKTRSE: DEFINITIONS
We start by precisely defining what is a secure PKTRSE
scheme. Suppose user Bob is about to send an encrypted
email to Alice with keywords W1,W2, ...,Wl and Alice can
read it only after a specified time. Bob sends the following
message:
[EApub
(M), TAG(Apub, tspub,W1, T ),
..., TAG(Apub, tspub,Wl, T )] (1)
Where Apub is Alice’s public key, M is the email body, T is
the release time, and TAG is an algorithm discussed below.
The TAG values do not reveal any information about the
message and the release time, but enable searching for target
ciphertext with specific keywords and release time. For the
rest of this paper, we use our sample application as a mail
server which stores all incoming email and a time server
that periodically output the trapdoor ST at every current
time instant.
Our goal is to enable Alice to send two trapdoors TW and
ST to the mail server that will enable the server to locate
all messages containing the keyword W and the release
time T without learning anything else. Alice generates the
trapdoor TW using her private key and gets the trapdoor ST
by downloading from the time server after the release time.
The server simply sends the relevant emails back to Alice.
We call such a system non-interactive Public Key Timed-
Release Searchable Encryption.
Definition 2: A non-interactive Public Key Timed-
Release Searchable Encryption scheme consists of the fol-
lowing polynomial time randomized algorithms:
KeyGen. Take a security parameter, and generate pub-
lic/private key pairs (upkr, uskr) and (tspub, tspriv).
TAG. For public key upkr, tspub, a word W and a release
time T , produce a TAG of W and T .
Trapdoor. Given the sender’s private key uskr and a word
W produce a keyword trapdoor TW ; given the time server’s
private key tspriv and a release time T , produce a time
trapdoor ST .
Test. Given trapdoors TW , ST and a timed-release search-
able encryption TAG(W ′, T ′), if W = W ′ and T = T ′,
output ‘yes’; otherwise, output ‘no’.
The PKTRSE system runs the KeyGen algorithm to
generate Alice’s and time server’s public/private key pairs.
Alice uses Trapdoor algorithm to get trapdoor ST for any
release time T and generates trapdoors TW for any keywords
W that she wants the mail server or mail gateway to search
for. The mail server uses the given trapdoors as input to the
Test algorithm to determine whether a given email contains
one of the keywords W and release time T specified by
Alice.
Next, we define security for a PKTRSE in the sense of
semantic-security. We need to ensure that an TAG algorithm
does not reveal any information about W and T unless TW
and ST are available. We define security against an active
attacker who is able to obtain trapdoors TW for any W and
ST for any T of his choice. Even under such attack the
attacker should not be able to distinguish an encryption of
W0, T0 from an encryption of W1, T1 for which he did not
obtain the trapdoors. Formally, we define security against
an active attacker using the simulation game between a
challenger B and the attacker A as follows:
1. B runs the KeyGen algorithm to generate public/private
key pairs. It gives public keys to the A.
2. A can adaptively ask the challenger for the trapdoor
TW for any keyword W ∈ {0, 1}∗ and ST for any release
243
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:44:35 UTC from IEEE Xplore.  Restrictions apply. 
time T ∈ {0, 1}∗ of his choice.
3. At some point, A sends B two words W0,W1 and two
release time T0, T1 on which it wishes to be challenged.
The only restriction is that A did not previously ask for
their trapdoors. B picks random x, y ∈ {0, 1} and gives the
attacker C = TAG(Wx, Ty). We refer to C as the challenge
TAG.
4. A can continue to ask for the trapdoor TW for any
keyword W and ST for any release time T of his choice as
long as W �= W0,W1 and T �= T0, T1.
5. Eventually,A outputs x′, y′ ∈ {0, 1} and wins the game
if x = x′ and y = y′.
In other words, the attacker A wins the game if he
can correctly guess whether he was given the TAG for
(W0, T0) or (W0, T1) or (W1, T0) or (W1, T1). We define
A’s advantage in breaking the PKTRSE as
AdvIND−CPA
PKTRSE,A = |Pr[x = x′, y = y′]− 1
4
|
Definition 3: We say that a PKTRSE is semantically
secure against an adaptive chosen plaintext attack if for any
polynomial time attacker A we have that AdvIND−CPA
PKTRSE,A is
a negligible function.
Chosen Ciphertext Security. We note that Definition 2
ensures that the construction given in Eq. (1) is semantically
secure whenever the public key encryption system EApub
is
semantically secure. However, as is, the construction is not
chosen ciphertext secure. Indeed, a chosen ciphertext attack-
er can break semantic security by reordering the keywords
and release time in Eq. (1) and submitting the resulting
ciphertext for decryption. A standard technique can make
this construction chosen ciphertext secure using the methods
of [30]. We defer this to the succession of the paper.
IV. PKTRSE: CONSTRUCTIONS
We give two construction schemes for PKTRSE: (1) a
generic construction based on the BDH problem and (2)
a concrete construction based on the BDH problem and is
provably secure in the random oracle.
A. A generic constuction of PKTRSE
In this subsection, we propose our generic PKTRSE
scheme and we firstly give an useful definition as follow:
Definition 4: By discarding partial characteristic of some
cryptographic schemes meeting the Requirement 2, we
abstract those schemes as such schemes which only contain
three stage of setup, encryption and decryption. We define
3-tuple algorithm εPKE = (Setup,Enc,Dec) as follows:
Setup: Generate public parameters and system us-
er’s private/public key (u, uP ) in the form meeting
Requirement 2.
Enc: Encrypt plaintext using uP and output ciphertext
CPKE = Enc(M,uP ).
Dec: Decrypt ciphertext using u and output plaintext M =
Dec(CPKE , u).
We construct a generic scheme of PKTRSE by us-
ing the definition above. PEKS is a 4-tuple algorith-
m εPEKS = (KeyGen, PEKS, Trapdoor, Test) [9],
KeyGen is viewed as Setup, PEKS is abstracted as Enc,
Trapdoor and Test is abstracted as Dec. In such way, we
abstract εPEKS as εPKE . Then, we introduce time corre-
lation parameters T, tspriv, tspub, ST , i.e., T, s, sP, sH(T )
into εPKE . At this point, we give 3-tuple algorithm
εPKTRSE−gen = (Setup,Enc,Dec) of the generic scheme
of PKTRSE as follows:
Setup: Generate public parameters and private/public key
of system user and time server in the form meeting the
Requirement 2.
Enc: Introduce the parameters of T and tspub into Enc
algorithm of εPKE , compute CPKTRSE−gen = CPKE ·
e(H(T ), f(·)tspub) = CPKE · e(H(T ), f(·)sP ), output
ciphertext C = (CPKTRSE−gen, f(·)P ), where f(·) is an
arbitrary function and its value is confidential.
Dec: Introduce the parameters of ST into Dec algorithm
of εPKE , and output plaintext M = Dec(CPKE , u) =
Dec(
CPKTRSE−gen
e(ST ,f(·)P ) , u).
The correctness proof of the Dec algorithm:
CPKTRSE−gen
e(ST ,f(·)P ) =
CPKTRSE−gen
e(sH(T ),f(·)P ) =
CPKTRSE−gen
e(H(T ),f(·)sP ) = CPKE ,
M = Dec(CPKE , u).
Our generic construction gives us a general method for
constructing concrete scheme. That is, when we want to
generate a concrete construction, what we need to do is
specifying the CPKE and f(·).
B. A concrete scheme of PKTRSE
In this subsection, we propose our concrete PKTRSE
scheme and we prove our scheme is secure under chosen
plaintext attack.
1) Description of the Scheme: We build a non-interactive
PKTRSE scheme from such a bilinear map defined above.
The construction is based on [9]. Our PETRSE scheme with
random oracle works as follows:
Setup: Given security parameter k ∈ Z+ and take the
following steps:
1. The algorithm takes k and generates a prime p, an
additive group G1 and a multiplicative group G2 of order p,
an admissible bilinear map e : G1×G1 → G2 and arbitrary
generator P ∈ G1.
2. The following cryptographic hash functions are chosen:
H1 : {0, 1}∗ → G1 and H2 : G2 → {0, 1}log p.
TRSetup: Choose s ∈R Z∗p as the private key tspriv and
set sP as the public key tspub of the time server.
KeyGen: Choose u ∈R Z∗p as the private key uskr and
set uP as the public key upkr of the receiver.
TAG: Compute t = (e(H1(W ), upkr)e(H1(T ), tspub))
r
∈ G2 for a r ∈R Z∗p . Output TAG = (rP,H2(t)) = (A,B).
Trapdoor: Output TW = uH1(W ) ∈ G1 and ST =
sH1(T ) ∈ G1.
244
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:44:35 UTC from IEEE Xplore.  Restrictions apply. 
Test: Test if H2(e(TW , A)e(ST , A)) = B. If so, output
‘yes’; if not, output ‘no’.
Indeed, for the valid trapdoor TW and ST , we have
H2(e(TW , A)e(ST , A))
= H2(e(uH1(W ), rP )e(sH1(T ), rP ))
= H2(e(H1(W ), ruP )e(H1(T ), rsP ))
= H2((e(H1(W ), uP )e(H1(T ), sP ))r)
= H2((e(H1(W ), upkr)e(H1(T ), tspub))
r)
= H2(t) = B
2) Security of the Scheme: We prove that this system
is a non-interactive PKTRSE scheme semantically secure
against a chosen plaintext attack in the random oracle model.
The proof of security relies on the difficulty of the BDH
problem [29].
Theorem 1: The non-interactive PKTRSE above is se-
mantically secure against a chosen plaintext attack in the
random oracle model assuming BDH is intractable.
Proof: Suppose A is an attack algorithm that has
advantage ε in breaking the PKTRSE. Suppose A makes
at most qH2
hash function queries to H2 and at most qT
trapdoor queries (we assume qT and qH2
are positive). We
construct an algorithm B that solves the BDH problem with
probability at least ε′ = ε/[3e2qH2(qT − 1)], where e is
the base of the natural logarithm. Algorithm B’s running
time is approximately the same as A’s. Hence, if the BDH
assumption holds in G1 then ε′ is a negligible function and
consequently ε must be a negligible function in the security
parameter.
Let P be a generator of G1. Algorithm B is given P ,
P1 = aP = uP + sP , P2 = bP , P3 = cP ∈ G1, a, b, c ∈
Z∗p . Its goal is to output v = e(P, P )abc ∈ G2. Algorithm
B simulates the challenger and interacts with forger A as
follows:
Algorithm B starts by giving A the public key upkr = uP
and tspub = sP .
H1,H2-queries. At any time algorithm A can query
the random oracles H1 or H2. To respond to H1 queries
algorithm B maintains a list of tuples < Wj , hj ,mj , nj >
and < Tj , h
′
j ,m
′
j , n
′
j > called the H1-list. The list is initially
empty. When A queries the random oracle H1 at a point
Wi ∈ {0, 1}∗, algorithm B responds as follows:
1. If the query Wi already appears on the H1-list in a
tuple < Wi, hi,mi, ni > then algorithm B responds with
H1(Wi) = hi ∈ G1.
2. Otherwise, B generates a random coin mi ∈ {0, 1} so
that Pr[ni = 0] = 1/(qT + 1).
3. Algorithm B picks a random mi ∈ Zp.
If ni = 0, B computes hi ← P2 +mi · P ∈ G1.
If ni = 1, B computes hi ← mi · P ∈ G1.
4. Algorithm B adds the tuple < Wi, hi,mi, ni > to the
H1-list and responds to A by setting H1(Wi) = hi. Note
that either way hi is uniform in G1 and is independent of
A’s current view as required.
When A queries the random oracle H1 at a point Ti ∈
{0, 1}∗, algorithm B responds similarly as above, just uses
Ti, h
′
i, m
′
i, n
′
i in place of Wi, hi, mi, ni respectively.
Similarly, at any time A can issue a query to H2.
Algorithm B responds to a query for H2(t) by picking a
new random value V ∈ {0, 1}log p for each new t and setting
H2(t) = V . In addition, B keeps track of all H2 queries by
adding the pair (t, V ) to an H2-list. The H2-list is initially
empty.
Trapdoor queries. When A issues a query for the trap-
door corresponding to the keyword Wi algorithm B responds
as follows:
1. Algorithm B runs the above algorithm for responding to
H1-queries to obtain an hi ∈ G1 such that H1(Wi) = hi ∈
G1. Let < Wi, hi,mi, ni > be the corresponding tuple on
the H1-list. If ni = 0 then B reports failure and terminates.
2. Otherwise, we know ni = 1 and hence hi = mi · P ∈
G1. Define TWi
= mi ·upkr. Observe that TWi
= uH1(Wi)
and therefore TWi is the correct trapdoor for the keyword
Wi under the public key upkr. Algorithm B gives TWi to
algorithm A.
When A issues a query for the trapdoor corresponding to
the release time Ti algorithm B responds similarly as above,
just uses Ti, h
′
i, m
′
i, n
′
i, STi
, tspub in place of Wi, hi, mi,ni,
TWi , upkr respectively.
Challenge. Eventually algorithm A produces a pair of
keywords (W0,W1) and release time (T0, T1) that it wishes
to be challenged on. Algorithm B generates the challenge
TAG as follows:
1. Algorithm B runs the above algorithm for responding
to H1-queries four times to obtain h0, h1, h
′
0, h
′
1 ∈ G1 such
that H1(W0) = h0, H1(W1) = h1, H1(T0) = h′0 and
H1(T1) = h′1. For i = 0, 1, let < Wi, hi,mi, ni > and
< Ti, h
′
i,m
′
i, n
′
i > be the corresponding tuples on the H1-
list. If n0 = n1 = n′0 = n′1 = 1 then B reports failure and
terminates.
2. We know that at least one of n0, n1 is equal to 0 and
one of n′0, n′1 is equal to 0. Algorithm B randomly picks
x, y ∈ {0, 1} such that nx = 0 (if only one nx is equal
to 0 then no randomness is needed since there is only one
choice).
3. Algorithm B responds with the challenge TAG C =
[P3, J ] for a random J ∈ {0, 1}log p. Note that this chal-
lenge implicitly defines H2(e(H1(Wx), c·upkr)e(H1(Ty), c·
tspub)) = J . In other words, J = H2(e(H1(Wx), c ·
upkr)e(H1(Ty), c · tspub)) = H2(e(P2+mxP, ucP )e(P2+
m′yP, scP )) = e(P, P )uc(b+md)e(P, P )sc(b+m′y). With this
definition, C is a valid TAG for Wx, Ty as required.
More trapdoor queries. A can continue to issue trap-
door queries for keywords Wi and release time Ti where
the only restriction is that Wi �= W0,W1, Ti �= T0, T1.
Algorithm B responds to these queries as before.
245
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:44:35 UTC from IEEE Xplore.  Restrictions apply. 
Output. Eventually, A outputs its guess x, y ∈ {0, 1}
indicating whether the challenge C is the result of TAG.
At this point, algorithm B picks a random pair (t, V ) from
the H2-list and outputs t/[e(upkr, P3)
mxe(tspub, P3)
m′y ] as
its guess for e(P, P )abc, where mx,m
′
y is the value used
in the challenge step. The reason this works is that, as
we will show, A must have issued a query for one of
H2(e(H1(W0), c ·upkr)e(H1(T0), c · tspub)), H2(e(H1(W0
), c · upkr)e(H1(T1), c · tspub)), H2(e(H1(W1), c · upkr)e(
H1(T0), c · tspub)), H2(e(H1(W1), c · upkr)e(H1(T1), c ·
tspub)). Thus, with probability 1/4 the H2-list contains a pair
whose left hand side is t = e(H1(Wx), c·upkr)e(H1(Ty), c·
tspub) = e(P, P )uc(b+mx)e(P, P )sc(b+m′y). If B picks this
pair (t, V ) from the H2-list then t/[e(upkr, P3)
mxe(tspub,
P3)
m′y ] = e(P, P )abc as required.
This completes the description of algorithm B. It remains
to show that B correctly outputs e(P, P )abc with probability
at least ε′. To do so, we first analyze the probability that B
does not abort during the simulation. We define two events:
E1: B does not abort as a result of any of A’s trapdoor
queries.
E2: B does not abort during the challenge phase.
We first argue as in [31] that both events E1 and E2 occur
with sufficiently high probability.
Claim 1: The probability that algorithm B does not abort
as a result of A’s trapdoor queries is at least 1/e2. Hence,
Pr[E1] ≥ 1/e2.
Proof: When A queries for the trapdoor of keywords,
without loss of generality we assume that A does not ask for
the trapdoor of the same keyword twice. The probability that
a trapdoor query causes B to abort is 1/(qT +1). To see this,
let Wi be A’s i’th trapdoor query and let < Wi, hi,mi, ni >
be the corresponding tuple on the H1-list. Prior to issuing
the query, the bit ni is independent of A’s view–the only
value that could be given to A that depends on ni is H(Wi),
but the distribution on H(Wi) is the same whether ni = 0
or ni = 1. Therefore, the probability that this query causes
B to abort is at most 1/(qT + 1). Since A makes at most
qT trapdoor queries the probability that B does not abort
as a result of trapdoor queries of keywords is at least (1−
1/(qT + 1))qT . Similarly, the probability that B does not
abort as a result of trapdoor queries of release time is at
least (1− 1/(qT +1))qT too. Therefore, the probability that
B does not abort as a result of all trapdoor queries is at least
(1−1/(qT +1))qT (1−1/(qT +1))qT ≥ (1/e)(1/e) = 1/e2.
Claim 2: The probability that algorithm B does not abort
during the challenge phase is at least 1/qT . Hence, Pr[E2] ≥
1/qT .
Proof: Algorithm B will abort during the challenge
phase if A is able to produce W0, W1, T0, T1 with the
following property: n0 = n1 = n′0 = n′1 = 1 where for
i = 0, 1 the tuple < Wi, hi,mi, ni > and < Ti, h
′
i,m
′
i, n
′
i >
are the tuples on the H1-list corresponding to Wi and Ti.
Since A has not queried for the trapdoor for W0, W1, T0, T1,
we have that n0, n1, n
′
0, n
′
1 are independent of A’s current
view. Therefore, since Pr[ni = 0]Pr[n
′
i = 0] = 1/(qT + 1)
for i = 0, 1, and the four values are independent of each
other, we have that Pr[n0 = n1 = n′0 = n′1 = 1] =
(1− 1/(qT +1))4 ≤ (1− 1/qT )
2 ≤ 1− 1/(qT − 1). Hence,
the probability that B does not abort is at least 1/(qT − 1).
Observe that since A can never issue a trapdoor query
for the challenge keywords W0,W1 and the release time
T0, T1, the two events E1 and E2 are independent. Therefore,
Pr[E1
∧ E2] ≥ 1/[e2(qT − 1)].
To complete the proof of Theorem 1 it remains to show
that B outputs the solution to the given BDH instance
with probability at least ε/qH2
. To do we show that during
the simulation A issues a query for H2(e(H1(Wx), c ·
upkr)e(H1(Ty), c · tspub)) with probability at least ε.
Claim 3: Suppose that in a real attack game A is given
the public key upkr,tspub and A asks to be challenged on
keywords W0,W1 and release time T0,T1. In response, A is
given a challenge C = [rP, J ]. Then, in the real attack game
A issues an H2 query for one of H2(e(H1(W0), c ·upkr)e(
H1(T0), c · tspub)), H2(e(H1(W0), c · upkr)e(H1(T1), c ·
tspub)), H2(e(H1(W1), c · upkr)e(H1(T0), c · tspub)), H2(
e(H1(W1), c ·upkr)e(H1(T1), c · tspub)) with probability at
least 2ε.
Proof: Let E3 be the event that in the real attack A does
not issue a query for any one of H2(e(H1(W0), c · upkr)e(
H1(T0), c · tspub)), H2(e(H1(W0), c · upkr)e(H1(T1), c ·
tspub)), H2(e(H1(W1), c · upkr)e(H1(T0), c · tspub)), H2(
e(H1(W1), c · upkr)e(H1(T1), c · tspub)). Then, when E3
occurs we know that the bits x, y ∈ {0, 1} indicating
whether C is a TAG of the exact keywords and release time is
independent of A’s view. Therefore, A’s output x′, y′ will
satisfy x = x′, y = y′ with probability at most 1/4. We
abbreviate the event of x = x′, y = y′ as E0. By definition
of A, we know that in the real attack |Pr[E0] − 1/4| ≥ ε.
We show that these two facts imply that Pr[¬E3] ≥ 4ε. To
do so, we first derive simple upper and lower bounds on
Pr[E0]:
Pr[E0] = Pr[E0|E3]Pr[E3] + Pr[E0|¬E3]Pr[¬E3]
≤ Pr[E0|E3]Pr[E3] + Pr[¬E3]
=
1
4
Pr[E3] + Pr[¬E3]
=
1
4
+
3
4
Pr[¬E3]
Pr[E0] ≥ Pr[E0|E3]Pr[E3]
=
1
4
Pr[E3]
=
1
4
− 1
4
Pr[¬E3]
≥ 1
4
− 3
4
Pr[¬E3]
246
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:44:35 UTC from IEEE Xplore.  Restrictions apply. 
It follows that ε ≤ |Pr[E0] − 1
4 | ≤ 3
4Pr[¬E3]. Therefore, in
the real attack, Pr[¬E3] ≥ 4
3ε as required.
Now, assuming B does not abort, we know that B simu-
lates a real attack game perfectly up to the moment when
A issues a query for one of H2(e(H1(W0), c · upkr)e(H1(
T0), c · tspub)), H2(e(H1(W0), c · upkr)e(H1(T1), c ·
tspub)), H2(e(H1(W1), c · upkr)e(H1(T0), c · tspub)),
H2(e(H1(W1), c · upkr)e(H1(T1), c · tspub)). Therefore, by
Claim 3, by the end of the simulation A will have issued a
query for one of H2(e(H1(W0), c ·upkr)e(H1(T0), c · tspub
)), H2(e(H1(W0), c · upkr)e(H1(T1), c · tspub)), H2(e(H1(
W1), c · upkr)e(H1(T0), c · tspub)), H2(e(H1(W1), c ·
upkr)e(H1(T1), c · tspub)) with probability at least 4/3ε.
It follows that A issues a query for H2(e(H1(Wx), c ·
upkr)e(H1(Ty), c · tspub)) with probability at least 1/3ε.
Consequently, the value e(H1(Wx), c · upkr)e(H1(Ty), c ·
tspub) = e(P, P )uc(b+mx)e(P, P )sc(b+m′y) will appear on
the left hand side of some pair in the H2-list. Algorithm
B will choose the correct pair with probability at least
1/qH2
and therefore, assuming B does not abort during
the simulation, it will produce the correct answer with
probability at least ε/(3qH2
). Since B does not abort with
probability at least 1/[e2(qT − 1)] we see that B’s success
probability overall is at least ε/[3e2qH2(qT −1)] as required.
V. CONCLUSION AND FUTURE WORK
We propose a new concept of TRSE which can be used
to solve the time-dependent ciphertext retrieval problem. In
our PKTRSE model, the sender chooses a release time to
search target ciphertext containing specified keywords on the
cloud server. In other words, the receiver cannot get target
ciphertext until the release time in the future. It seems that
this can strengthen the security of PKTRSE.
We formalize the notion of PKTRSE and its security
model. We show the preconditions of TR-PKE combining
other asymmetric cryptographic mechanisms and detail how
to combine TR-PKE with PEKS. We also propose two
constructions of PKTRSE and prove the security against
chosen plaintext attack of the concrete scheme. We will
discuss another concrete scheme which is secure under the
BDHI assumption without random oracles in the succession
of this paper.
PKTRSE would have many practical applications. In this
paper, we research the application scene of the one to one
PKTRSE, the one to many PKTRSE scene will be studied by
using the cryptographic technique of IBBE. TRSE adopting
symmetric cryptographic mechanism or hybrid mechanism
will be also explored in our future work.
ACKNOWLEDGMENT
This work was supported by the National Key Basic
Research Program of China (No. 2013CB834204), the Na-
tional Natural Science Foundation of China (Nos. 60973141
and 61272423) and the Specialized Research Fund for the
Doctoral Program of Higher Education of China (Nos.
20100031110030 and 20120031120036).
REFERENCES
[1] R. L. Rivest, A. Shamir, and D. A. Wagner, “Time-lock puz-
zles and timed-release crypto,” MIT LCS Tech, Cambridge,
MA, Tech. Rep. MIT/LCS/TR-684, 1996.
[2] J. H. Cheon, N. Hopper, Y. Kim, and I. Osipkov, “Provably
secure timed-release public key encryption,” ACM Transac-
tions on Information and System Security, vol. 11, no. 2, pp.
1–44, 2008.
[3] D. Song, D. Wagner, and A. Perrig, “Practical techniques for
searches on encrypted data,” in Security and Privacy, 2000.
S&P 2000. Proceedings. 2000 IEEE Symposium on. IEEE,
2000, pp. 44–55.
[4] R. Curtmola, J. Garay, S. Kamara, and R. Ostrovsky, “Search-
able symmetric encryption: improved definitions and efficient
constructions,” in Proceedings of the 13th ACM conference
on Computer and communications security. ACM, 2006,
pp. 79–88.
[5] J. Li, Q. Wang, C. Wang, N. Cao, K. Ren, and W. Lou, “Fuzzy
keyword search over encrypted data in cloud computing,” in
INFOCOM, 2010 Proceedings IEEE. IEEE, 2010, pp. 1–5.
[6] M. Islam, M. Kuzu, and M. Kantarcioglu, “Access pattern
disclosure on searchable encryption: Ramification, attack and
mitigation,” in Network and Distributed System Security Sym-
posium (NDSS12), 2012.
[7] S. Kamara, C. Papamanthou, and T. Roeder, “Dynamic
searchable symmetric encryption,” in Proceedings of the 2012
ACM conference on Computer and communications security.
ACM, 2012, pp. 965–976.
[8] J. Li, J. Li, X. Chen, C. Jia, and Z. Liu, “Efficient keyword
search over encrypted data with fine-grained access control
in hybrid cloud,” in Network and System Security. Springer,
2012, pp. 490–502.
[9] D. Boneh, G. D. Crescenzo, R. Ostrovsky, and G. Persiano,
“Public key encryption with keyword search,” in Advances in
Cryptology-EUROCRYPT 2004, ser. Lecture Notes in Com-
puter Science, vol. 3027. Springer, 2004, pp. 506–522.
[10] J. W. Byun, H. S. Rhee, H.-A. Park, and D. H. Lee, “Off-
line keyword guessing attacks on recent keyword search
schemes over encrypted data,” in Secure Data Management,
ser. Lecture Notes in Computer Science, vol. 4165. Springer,
2006, pp. 75–83.
[11] J. Baek, R. Safavi-Naini, and W. Susilo, “Public key en-
cryption with keyword search revisited,” in Computational
Science and Its Applications–ICCSA 2008, ser. Lecture Notes
in Computer Science, vol. 5072. Springer, 2008, pp. 1249–
1259.
[12] D. J. Park, K. Kim, and P. J. Lee, “Public key encryption with
conjunctive field keyword search,” in Information Security
Applications, ser. Lecture Notes in Computer Science, vol.
3325. Springer, 2005, pp. 73–86.
247
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:44:35 UTC from IEEE Xplore.  Restrictions apply. 
[13] B. Zhang and F. Zhang, “An efficient public key encryption
with conjunctive-subset keywords search,” Journal of Net-
work and Computer Applications, vol. 34, no. 1, pp. 262–267,
2011.
[14] M. Abdalla, M. Bellare, D. Catalano, E. Kiltz, T. Kohno,
T. Lange, J. Malone-Lee, G. Neven, P. Paillier, and H. Shi,
“Searchable encryption revisited: Consistency properties, re-
lation to anonymous ibe, and extensions,” in Advances in
Cryptology–CRYPTO 2005, ser. Lecture Notes in Computer
Science, vol. 3621. Springer, 2005, pp. 205–222.
[15] Y. H. Hwang and P. J. Lee, “Public key encryption with
conjunctive keyword search and its extension to a multi-user
system,” in Pairing-Based Cryptography–Pairing 2007, ser.
Lecture Notes in Computer Science, vol. 4575. Springer,
2007, pp. 2–22.
[16] Q. Tang and L. Chen, “Public-key encryption with registered
keyword search,” in Public Key Infrastructures, Services and
Applications, ser. Lecture Notes in Computer Science, vol.
6391. Springer, 2010, pp. 163–178.
[17] L. Ibraimi, S. Nikova, P. Hartel, and W. Jonker, “Public-key
encryption with delegated search,” in Applied Cryptography
and Network Security, ser. Lecture Notes in Computer Sci-
ence, vol. 6715. Springer, 2011, pp. 532–549.
[18] C. Hu, P. He, and P. Liu, “Public key encryption with multi-
keyword search,” in Network Computing and Information
Security, ser. Communications in Computer and Information
Science, vol. 345. Springer, 2012, pp. 568–576.
[19] J. Li, C. Jia, J. Li, and Z. Liu, “A novel framework for
outsourcing and sharing searchable encrypted data on hybrid
cloud,” in Intelligent Networking and Collaborative Systems
(INCoS), 2012 4th International Conference on. IEEE, 2012,
pp. 1–7.
[20] C. Delerablée, “Identity-based broadcast encryption with
constant size ciphertexts and private keys,” in Advances in
Cryptology–ASIACRYPT 2007, ser. Lecture Notes in Com-
puter Science, vol. 4833. Springer, 2007, pp. 200–215.
[21] T. May, “Timed-release crypto,” Unpublished manuscript,
1993.
[22] A.-F. Chan and I. F. Blake, “Scalable, server-passive, user-
anonymous timed release cryptography,” in Distributed Com-
puting Systems, 2005. ICDCS 2005. Proceedings. 25th IEEE
International Conference on. IEEE, 2005, pp. 504–513.
[23] Y. H. Hwang, D. H. Yum, and P. J. Lee, “Timed-release
encryption with pre-open capability and its application to
certified e-mail system,” in Information Security, ser. Lecture
Notes in Computer Science, vol. 3650. Springer, 2005, pp.
344–358.
[24] K. Emura, A. Miyaji, and K. Omote, “A timed-release proxy
re-encryption scheme and its application to fairly-opened
multicast communication,” in Provable Security, ser. Lecture
Notes in Computer Science, vol. 6402. Springer, 2010, pp.
200–213.
[25] K. G. Paterson and E. A. Quaglia, “Time-specific encryption,”
in Security and Cryptography for Networks, ser. Lecture
Notes in Computer Science, vol. 6280. Springer, 2010, pp.
1–16.
[26] K. Haramura, M. Yoshida, and T. Fujiwara, “Anonymous
fingerprinting for predelivery of contents,” in Information
Security and Cryptology–ICISC 2008, ser. Lecture Notes in
Computer Science, vol. 5461. Springer, 2009, pp. 134–151.
[27] X. Ma, L. Xu, and F. Zhang, “Oblivious transfer with timed-
release receivers privacy,” Journal of Systems and Software,
vol. 84, no. 3, pp. 460–464, 2011.
[28] A. A. Yavuz and P. Ning, “Self-sustaining, efficient and
forward-secure cryptographic constructions for unattended
wireless sensor networks,” Ad Hoc Networks, 2012.
[29] D. Boneh and M. Franklin, “Identity-based encryption from
the weil pairing,” in Advances in Cryptology-CRYPTO 2001,
ser. Lecture Notes in Computer Science, vol. 2139. Springer,
2001, pp. 213–229.
[30] D. Dolevy, C. Dworkz, and M. Naorx, “Non-malleable cryp-
tography,” In SIAM Journal on Computing, vol. 30, no. 2, pp.
391–437, 2000.
[31] J.-S. Coron, “On the exact security of full domain hash,” in
Advances in Cryptology-CRYPTO 2000, ser. Lecture Notes in
Computer Science, vol. 1880. Springer, 2000, pp. 229–235.
248
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 06:44:35 UTC from IEEE Xplore.  Restrictions apply.