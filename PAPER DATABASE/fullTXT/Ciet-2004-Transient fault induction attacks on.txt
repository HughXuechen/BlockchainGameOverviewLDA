LNCS 3269 - Transient Fault Induction Attacks on XTR
Transient Fault Induction Attacks on XTR
Mathieu Ciet1 and Christophe Giraud2
1 Innova Card,
Avenue Coriandre, 13 600 La Ciotat, France
mathieu.ciet@innova-card.com
2 Oberthur Card Systems,
25, rue Auguste Blanche, 92 800 Puteaux, France
c.giraud@oberthurcs.com
Abstract. At Crypto 2000, the public-key system XTR was introduced
by Lenstra and Verheul. This system uses an efficient and compact
method to represent subgroup elements. Application of XTR in cryp-
tographic protocols, such as Diffie-Hellman key agreement, El Gamal
encryption or DSA signature, greatly reduces the computational cost
without compromising security. XTR in the presence of a fault, i.e. when
processing under unexpected conditions, has never been studied. This pa-
per presents four different fault analyses and shows how an error during
the XTR exponentiation can be exploited by a malicious adversary to
recover a part or the totality of the secret parameter. Countermeasures
are also presented to counteract fault attacks. They are very simple to
implement and induce a negligible performance penalty in terms of both
memory and time.
Keywords: Differential fault analysis, public-key system XTR, counter-
measures, smart cards.
1 Introduction
XTR has been introduced for the first time in [18] as an extension of the LUC
cryptosystem [23]. Whereas LUC uses elements in GF(p2)∗ with order p + 1
represented by their trace over GF(p), XTR represents elements of a subgroup
of GF(p6)∗ of order dividing p2 − p + 1 by their trace over GF(p2), see [16–
19, 24, 25]. In [9], Gong and Harn used a similar idea with a subgroup of order
p2 + p + 1 of GF(p3)∗. Compared to the usual representation, Gong and Harn
achieved a factor 1.5 size reduction, LUC a factor 2 and XTR a factor 3. The
main advantage of the compact representation of XTR is that it speeds up the
computations. Finally, to conclude this brief history, Rubin and Silverberg have
recently presented an alternative compression method of such cryptosystems
in [21], see also [11].
Physical constraints must be taken into account when implementing crypto-
algorithms on tamper-proof devices [2,3]. In [13,14], Kocher et al. show the im-
portance for an implementation of being resistant against computation leakages
by introducing the notion of side-channel analysis. In [7,8,12,26], the necessity of
J. López, S. Qing, and E. Okamoto (Eds.): ICICS 2004, LNCS 3269, pp. 440–451, 2004.
c© Springer-Verlag Berlin Heidelberg 2004
Transient Fault Induction Attacks on XTR 441
taking into account fault induction during computation was underlined. Indeed,
if an error occurs during an execution of a crypto-algorithm, the faulty result can
be used to obtain information on the secret parameter. Fault attacks are very
powerful; for example with an RSA implementation using the CRT, the secret
key can be recovered by using only one faulty result of a known input [8,15]. The
AES secret key can also be revealed by using only two faulty ciphertexts [20].
These examples illustrate the necessity to ensure that an algorithm does not
operate under unexpected conditions.
The rest of this paper is organized as follows. In the next section we briefly
describe XTR and its main operation: the XTR exponentiation. Then we present
in Section 3 several observations about this exponentiation which are used in
Section 4. In the latter, the behaviour of XTR in the presence of a transient
fault is analyzed. Four different fault attacks are thus presented. The first one is
a random bit-fault attack on a random part of the computation, the second one
is a random fault attack on a chosen part of the computation, the third one is an
erasing fault analysis on a coordinate at a random moment and the last one is a
random bit-fault attack on the exponent. Section 5 deals with practical aspects of
fault attacks against XTR and more precisely, with synchronization techniques
which can be used to choose the part of the computation to disturb. In Section 6,
two efficient countermeasures to counteract fault attacks are presented. It is
worth noticing that these countermeasures are extremely simple to implement
with a very small amount of extra computation.
2 Generalities About XTR
XTR operations are performed over the field GF(p2) where p is chosen as a prime
number such that p2 − p + 1 has a sufficiently large prime factor q.
Let p be a prime equal to 2 modulo 3. The polynomial X2 + X + 1 is thus
irreducible over GF(p2) and the roots α and αp of this polynomial form an
optimal normal basis for GF(p2) over GF(p). Moreover, since p ≡ 2 mod 3,
αi = αi mod 3. It follows that:
GF(p2) ∼= {x1α + x2α
2 : α2 + α + 1 = 0 and x1, x2 ∈ GF(p)} (1)
Each element of GF(p2) can thus be represented as a couple (x1, x2) where
x1, x2 ∈ GF(p). This representation allows very efficient arithmetic over GF(p2)
as shown in [16, Lemma2.2.1] To perform operations over GF(p2) instead over
GF(p6), XTR uses the trace over GF(p2) to represent elements of a subgroup
〈g〉 of GF(p6)∗ with order dividing p2 − p + 1, i.e. elements of this subgroup do
not belong to GF(p), GF(p2) and GF(p3). XTR provides the GF(p6) security
with calculations in GF(p2).
The trace over GF(p2) of an element g ∈ GF(p6) is defined by the sum of
the conjugates of g over GF(p2), Tr(g)g + gp2
+ gp4
. Corollary1 leads to a fast
algorithm to compute Tr(gn) from Tr(g). For the sake of simplicity, we denote
in the rest of this paper Tr(g) by c and Tr(gk) by ck.
442 Mathieu Ciet and Christophe Giraud
Corollary 1. [16, Corollary2.3.3] Let c, cn−1, cn and cn+1 be given.
i. Computing c2n = c2
n − 2cp
n takes two multiplications in GF(p);
ii. Computing cn+2 = c·cn+1−cp ·cn+cn−1 takes four multiplications in GF(p);
iii. Computing c2n−1 = cn−1 · cn − cp · cp
n + cp
n+1 takes four multiplications in
GF(p);
iv. Computing c2n+1 = cn+1 · cn − c · cp
n + cp
n−1 takes four multiplications in
GF(p).
The XTR exponentiation, i.e. computing Tr(gn) from Tr(g) given an integer
n, is done by using Algorithm2.3.5 of [16]. Let n =
∑r
j=0 nj2j be the secret
exponent, we denote by Sk(c) the triplet (ck−1, ck, ck+1) and by Sk(c) the
triplet (c2k, c2k+1, c2k+2). Algorithm 2.1 gives the way to compute Sn(c) for
any c in GF(p2).
Algorithm 2.1 Computation of Sn(c) given n and c, from [16, Algorithm 2.3.5]
Input: n and c
Output: Sn(c)
if n < 0 then apply this algorithm to −n and c, and apply Lem. 2.3.2.ii of [16] to
the output.
if n = 0 then S0(c) = (cp, 3, c).
if n = 1 then S1(c) = (3, c, c2 − 2cp).
if n = 2 then use Cor. 1.ii and S1(c) to compute c3.
else define Si(c) = S2i+1(c) and let m = n.
if m is even then m← m− 1.
m← m− 1
2
, k = 1,
Sk(c)← S3(c) (use Cor. 1.i and S2(c) to compute c4).
m =
∑r
j=0 mj2
j with mj ∈ {0, 1} and mr = 1.
for j from r − 1 to 0 do
if mj = 0 then compute S2k(c) from Sk(c)
(using Cor. 1.i for c4k and c4k+2 and Cor. 1.iii for c4k+1).
if mj = 1 then compute S2k+1(c) from Sk(c)
(using Cor. 1.i for c4k+2 and c4k+4 and Cor. 1.iv for c4k+3).
k ← 2k + mj
if n is even then use Sm(c) to compute Sm+1(c) (using Cor. 1.ii) and m← m+1.
return Sn(c) = Sm(c)
3 Some Useful Remarks
3.1 Computing Sk(c) from S2k(c) or S2k+1(c)
From S2k(c), c2k and c2k+1 can be obtained by using the following corollary. Once
these two values are determined, the last third of Sk(c) is linearly obtained by
using Corollary 1.iii: cp
2k+2c4k+1 − c2k · c2k+1 − cp · cp
2k+1. Recovering Sk(c) from
S2k+1(c) can be done in a similar manner.
Transient Fault Induction Attacks on XTR 443
Corollary 2. Computing ck = (x1, x2) from c2k = (y1, y2) can easily be done
by computing S2−1 mod q(c2k).
Proof. By definition, ∀i ∈ Z, ci ∈ GF(p2). So ∀j ∈ Z, we can compute:
Sj(ci) = (Tr((gi)j−1), Tr((gi)j), Tr((gi)j+1) = (ci∗(j−1), ci∗j , ci∗(j+1))
Then, as g is of prime order q,
S2−1 mod q(c2k) = (c−k, ck, c3k) (2)
�
3.2 An Observation About the Exponentiation
Considering the formulas used to perform the XTR exponentiation, we remark
that the ci’s used during computations inside the main loop are dependent of
the corresponding value of the bit of n (cf. Fig. 1):
– If nj = 0 then, the first element of S2k(c) is only computed from c2k, the
second one from all the three elements of Sk(c) and the third one only from
c2k+1.
– If nj = 1 then, the first element of S2k+1(c) is only computed from c2k+1,
the second one from all the three elements of Sk(c) and the third one only
from c2k+2.
c2k c2k+1 c2k+2
↓ ↘ ↓ ↘↙
c4k c4k+1 c4k+2
c2k c2k+1 c2k+2
↘↙ ↓ ↙ ↓
c4k+2 c4k+3 c4k+4
(a) Computation of S2k(c). (b) Computation of S2k+1(c).
Fig. 1. Algorithms to compute S2k(c) and S2k+1(c).
4 Fault Analysis
Following the previous remarks, this section deals with fault analysis against
XTR. We show how an attacker can retrieve the secret key when the crypto-
algorithm XTR proceeds under unexpected conditions. Two types of induced
faults can mainly be distinguished: the one induced on a temporary result
(Sections 4.1, 4.2 and 4.3) and the (more classical) one induced on the secret
scalar (Section 4.4). The current size of the security parameter q (resp. p) is of
160 bits (resp. 170 bits).
444 Mathieu Ciet and Christophe Giraud
S0(c) −→ Sk(c) −→ Sn(c)
�
S̃k(c) −→ S̃n(c)
S̃n(c) −→ S̃�n/2r0�(c)
↓
Ŝn(c) ←− Ŝ�n/2r0�(c)
=?
Sn(c)
(a) Random bit-fault on a random Sk(c). (b) Fault analysis skeleton.
Fig. 2. Bit-fault model.
4.1 Random Bit-Faults on a Random Sk(c)
This first attack stems from the fault attacks on the elliptic curve scalar multi-
plication described by Biehl et al. in [6].
If one bit of a temporary result Sk(c) is disturbed during the computation
of Sn(c) = (cn−1, cn, cn+1), then a faulty result denoted S̃n(c) = (c̃n−1, c̃n, c̃n+1)
is computed instead of the correct one Sn(c).
The attacker knows Sn(c) and S̃n(c) but she does not know which Sk(c) has
been disturbed neither the bit of Sk(c) which has been flipped.
At the beginning, the step r0 when the fault is induced is guessed. An hy-
pothesis on the first r0 bits of n is also made. By using these guesses and formulas
from Section 3.1, S̃�n/2r0�(c) can be obtained from S̃n(c). For each possible value
of the induced fault (6 ∗ 170 possibilities), Ŝ�n/2r0�(c) is computed. Then, Ŝn(c)
is evaluated by using the guess on the first r0 bits of n. If Sn(c) = Ŝn(c) then
the hypothesis on the first r0 bits of the secret value n is correct, or else another
guess is done on the first r0 bits of n. If the equality Sn(c) = Ŝn(c) never occurs
for any of the possible values for the first r0 bits of n, this implies that the guess
on the position r0, where the fault has been induced, has to be changed.
To estimate the cost of this attack, we can suppose from a practical point
of view that step r0 is known with approximately one or two positions (the
pertinence of this supposition is justified in Section 6). If we suppose that an
error occurs at the rth
0 step, this attack then requires at most 2 ∗ 6 ∗ 170 ∗ 2r0−1
computations of S̃2−1 mod q(ci) and of Ŝn(c). For example, if an error occurs at
step 20, the previous attack allows one to recover 20 bits by computing less than
230 S̃2−1 mod q(ci) and 230 Ŝn(c).
More importantly, if we suppose that a first faulty result is obtained with
a fault induced at step r0 and a second faulty result is obtained with a fault
induced at step r1 with r1 > r0 > 1 then, r1 bits of the secret exponent can be
found in less than 2040 ∗ (2r0−1 + 2r1−r0) computations of S̃2−1 mod q(ci) and
of Ŝn(c). This is much less than 2040 ∗ 2r1−1. Finally, applying this principle to
several induced faults r with ri > rj for any i > j allows one to find the secret
exponent with a very small complexity.
4.2 Random Faults on a Chosen ci
Let us suppose that the result Sn(c) of the correct exponentiation is known. Let
us also suppose the first bits of n are known such as we could recover the value of
Transient Fault Induction Attacks on XTR 445
a temporary result Sm(c) by iterating the method described in Section 3.1. By
observing Algorithm 2.1, we can consider that Sm(c) is computed from a triplet
Sk(c) = (c2k, c2k+1, c2k+2).
If an unknown error is induced on a chosen element of this Sk(c), a faulty
result S̃n(c) is obtained. From this result, the temporary result S̃m(c) can be
recovered by using the same method as the one used to compute Sm(c). By
using Sm(c), S̃m(c) and the observation described in Section 3.2, the following
cases can be distinguished:
1. The fault has disturbed c2k:
– The first and the second elements of S̃m(c) are different from the same
elements of Sm(c), this implies nj = 0.
– Only the second element of S̃m(c) is different from the second element of
Sm(c), this implies nj = 1.
2. The fault has disturbed c2k+1:
– The second and the third elements of S̃m(c) are different from the same
elements of Sm(c), this implies nj = 0.
– The first and the second elements of S̃m(c) are different from the same
elements of Sm(c), this implies nj = 1.
3. The fault has disturbed c2k+2:
– Only the second element of S̃m(c) is different from the second element of
Sm(c), this implies nj = 0.
– The second and the third elements of S̃m(c) are different from the same
elements of Sm(c), this implies nj = 1.
Thus, by knowing the first j bits of n and by knowing which element of Sk(c)
has been disturbed, one can recover the value of the jth bit of n.
Finally, by iterating this attack, the whole value of the secret exponent can
be recovered by using 160 faulty results obtained from unknown errors.
4.3 Erasing Faults on a Coordinate of c2k+1 of a Random Sk(c)
As aforementioned in Section 3.2, the main loop of the XTR exponentiation
depends on the value of the corresponding bit of the exponent n (nj = 0 or 1).
In both cases, it can be seen that c4k+2 is only computed from c2k+1.
If a perturbation is induced on one of the coordinates of c2k+1 and if this
perturbation sets the coordinate to zero1, one of the coordinates of c4k+2 is
the result of the computation: 0 ∗ (0 − 2 ∗ x) − 2 ∗ 0 (cf. Corollary 1.i and
Lemma 2.2.1, i, ii of [16]) and is also equal to zero.
From a practical point of view, such a computation is easily observable by
looking at information leakages, as for example the power consumption of the
device under which the crypto-algorithm proceeds. Akishita and Takagi, and
1 Such a perturbation is not easy to induce in practice (22 bytes must be set to zero),
but due to improvements of fault attacks, such a fault model has to be considered,
see for example [22].
446 Mathieu Ciet and Christophe Giraud
Goubin use such a method to achieve their attacks on elliptic curve cryptosys-
tems [1, 10]. For more information about the detection of a zero value by using
power consumption analysis, the reader can refer to [1, § 4.6].
If the observation is made during the computation of the first part of the
triplet (ci, ci+1, ci+2) with i = 4k+nj, it can be deduced that nj = 0 else, if this
computation is observed during the computation of the last part of the triplet,
it implies that nj = 1. Therefore, one bit can be recovered by this process of
observation and by combining a fault attack and a power consumption analysis.
By iterating this principle on every bit of n, the whole value of the secret
exponent is recovered. As q is a 160-bit prime and n < q, only 160 faulty com-
putations are needed to recover n.
Remark 1. If we succeed in inducing such a fault at the jth step of the exponen-
tiation and if the flipped bit nj is followed by a set on k complementary bits, the
value of these k + 1 bits can be deduced by observing the power consumption
of the card: if nj = 0 (resp. nj = 1), one of the coordinates of the last part
(resp. the first part) of the following k triplets (ci, ci+1, ci+2) is still zero (cf.
Example 1). Moreover, we can also deduce the value of the bit nj+k+1 which is
equal to nj . The probability of such a sequence is 2−k. Thus, small sequences
exist with a non-negligible probability, optimizing the attack.
Example 1.
(x1, x2) (x3, 0) (x5, x6)
↓ ↘ ↓ ↘↙ nj = 0
(y1, y2) (y3, y4) (0, x2
3)
↘↙ ↓ ↙ ↓ nj+1 = 1
(z1, z2) (z3, z4) (x4
3, 0)
↘↙ ↓ ↙ ↓ nj+2 = 1
(w1, w2) (w3, w4) (0, x8
3)
↓ ↘ ↓ ↘↙ nj+3 = 0
(v1, v2) (v3, v4) (v5, v6)
This attack can be extended by using a clever remark made in Bévan’s thesis [5]
in which several chosen-ciphertext power analysis attacks on the XTR exponen-
tiation are described. For one of them, Bévan shows that if the input c of the
exponentiation is of the form either (x, 0) or (0, x), there is a finite state machine
for the Si(c)’s, 3 ≤ i ≤ n (cf. Algorithm 2.1; see Figure 3).
Therefore, if one of the input’s coordinates c is set to zero, the secret key
can be recovered by analysing the power consumption of only one faulty XTR
exponentiation.
4.4 Random Bit-Faults on the Secret Exponent
In previous sections, various faults on various parts of the computation have
been considered. Let us suppose now that an attacker is able to flip one bit of
the secret exponent during the exponentiation [4]. A faulty result is obtained
denoted cñ instead of the correct one cn. If an attacker succeeds in flipping the
ith bit of n, a faulty result cñ is obtained with ñ = n + (−1)ni2i where ni is the
Transient Fault Induction Attacks on XTR 447
1S
2S
3S
n=0
j
n=0
j
n=1
j
n=1
j
n=0
j
n=1
j
where
S1 = ((x1, x2), (x3, 0), (0, x6))
S2 = ((0, y2), (y3, y4), (y5, 0))
S3 = ((z1, 0), (0, z4), (z5, z6))
S1 = ((x1, x2), (0, x4), (x5, 0))
S2 = ((y1, 0), (y3, y4), (0, y6))
S3 = ((0, z2), (z3, 0), (z5, z6))
(a) if c is of the form (x, 0). (b) if c is of the form (0, x).
Fig. 3. State machine of the XTR exponentiation with an input of the form (x, 0) or
(0, x).
ith bit of n. By testing if cñ = cn+2i or cn = cñ+2i she obtains the value of the
ith bit of n. Moreover cj+2i can be computed from cj by using Corollary1.ii.
This is achieved with 4 ∗ 2i multiplications in GF(p).
So if the ith bit of n has been flipped, an attacker needs to perform
∑i
k=0 2 ∗
4 ∗ 2k = 2i+4 − 23 multiplications in GF(p) to recover the value of the ith bit of
n. If we suppose that it is feasible to perform 232 multiplications in GF(p), the
attacker can thus exploit a faulty result if the fault has been induced on one of
the first 30 bits of n. Once discovered the first k bits of n, the attacker can use
the method described in Section 3.1 to compute the corresponding temporary
result and then continue with the attack on the next 30 bits of n.
5 Practical Aspects: Synchronizing the Attacks
One of the main problem when mounting a fault analysis on a cryptosystem is
to respect hypotheses on fault area localization and on fault induction time. By
analyzing the power consumption of the device where the algorithm is processed,
we can observe the timing where each loop of the XTR exponentiation is per-
formed (see Fig. 4 where a part of the power trace is given). This information is
very useful to synchronize fault induction with the beginning of each loop.
Synchronizing an attack to succeed in disturbing the computation of a chosen
ci is slightly more difficult. Computations of the three elements c2i, c2i+1 and
c2i+2 of Si(c) are more often done in ascending order: firstly c2i, then c2i+1 and
finally c2i+2. As aforementioned, the attacker can use an SPA analysis to detect
when the different loops of the exponentiation are performed. The attacker can
roughly divide the time required to perform a loop into three (non-equal) periods.
As c2i requires 2 multiplications in GF(p), c2i+1 requires 4 multiplications and
c2i+2 4 multiplications, we can consider that ci is computed during the first fifth
of the loop, c2i+2 is computed during the last two fifth of the loop and c2i+1
is computed between these two periods of time. Of course the knowledge of the
implementation design is a plus when mounting fault analysis and here when
defining the subperiods of the loop, i.e. order and duration of each cj .
448 Mathieu Ciet and Christophe Giraud
Fig. 4. Power consumption of the XTR exponentiation during the first three loops.
6 Countermeasures
Two kinds of countermeasures can mainly be applied according to the fault that
occurs. The first one is to avoid a fault against the secret exponent. The most
simple and classical countermeasure is to add a crc to the exponent at the end
of the computation. This crc is compared with the crc of the exponent stored
in non-volatile memory before outputting the result. This countermeasure is very
efficient and simple to implement.
The second countermeasure avoids fault attacks against a temporary result.
It uses the fact that we must have three consecutive ci at the end of each loop. If
an error is induced on one of these ci, the coherence between the three elements
is lost. To prevent fault attacks on a temporary ci, a check of consistency can
be added at the end of each loop. It proceeds as follows:
– If nj = 0:
– Compute c4k+3 from Corollary1 iv. It uses c2k, c2k+1 and c2k+2.
– Check if c4k+3 = c · c4k+2 − cp · c4k+1 + c4k.
– If nj = 1:
– Compute c4k+1 from Corollary1 iii. It uses c2k, c2k+1 and c2k+2.
– Check if c4k+4 = c · c4k+3 − cp · c4k+2 + c4k+1.
This countermeasure induces a performance penalty of roughly 50% if done on
each round, i.e. for each bit of n. However, this countermeasure only needs to be
applied at the end of the last round since if coherence is broken at anytime of the
computation, this incoherence remains until the end and can be detected at this
time. The penalty compared with the whole exponentiation is negligible: only 8
multiplications in GF(p), that means 0.6% of penalty. An algorithm including
both countermeasures is depicted in Appendix A.
Transient Fault Induction Attacks on XTR 449
Unfortunately, the previous countermeasure is useless against the second at-
tack described in Section 4.3. Hopefully, by observing that for each possible
state there are exactly two computations which result into a zero, this attack
can be counteract by randomizing the computation of the three parts of Si(c), i.e.
computing the three parts in a random order for each loop of the XTR exponen-
tiation. The attacker could thus not be able to distinguish the different states.
7 Concluding Remarks
In this paper, several fault attacks on the public-key system XTR are described.
By using a bit-fault model, the secret key can be revealed by using 160 faulty
results, if the faults are induced either on a temporary result or on the secret
exponent. Moreover, if one coordinate of the input of the XTR exponentiation
can be set to zero, the secret key is obtained in only one shot.
We also describe efficient countermeasures to resist fault attacks, the cost
of these countermeasures is very low in terms of both memory space and speed
execution. The low cost allows an implementer to efficiently counteract fault
analysis with negligible penalty of performance and memory requirements.
Acknowledgements
We are very grateful to Martijn Stam for his careful reading of the preliminary
version of this paper and for his very useful comments. We would also like to
thank Francesco Sica and Erik Knudsen for answering some mathematical ques-
tions and Régis Bévan for helping us when measuring the power consumption of
the XTR exponentiation.
References
1. T. Akishita and T. Takagi. Zero-value Point Attacks on Elliptic Curve Cryptosys-
tem. In Information Security – ISC 2003, vol. 2851 of LNCS, pages 218–233.
Springer, 2003.
2. R. Anderson and M. Kuhn. Tamper Resistance - a Cautionary Note. In Proceedings
of the 2nd USENIX Workshop on Electronic Commerce, pages 1–11, 1996.
3. R. Anderson and M. Kuhn. Low cost attacks on tamper resistant devices. In 5th
Security Protocols Workshop, vol. 1361 of LNCS, pages 125–136. Springer, 1997.
4. F. Bao, R. Deng, Y. Han, A. Jeng, A. D. Narasimhalu, and T.-H. Ngair. Break-
ing Public Key Cryptosystems an Tamper Resistance Devices in the Presence of
Transient Fault. In 5th Security Protocols WorkShop, vol. 1361 of LNCS, pages
115–124. Springer, 1997.
5. R. Bévan. Estimation statistique et sécurité des cartes à puce – Evaluation
d’attaques DPA évoluées. PhD thesis, Supelec, June 2004.
6. I. Biehl, B. Meyer, and V. Müller. Differential Fault Analysis on Elliptic Curve
Cryptosystems. In Advances in Cryptology – CRYPTO 2000, vol. 1880 of LNCS,
pages 131–146. Springer, 2000.
7. E. Biham and A. Shamir. Differential Fault Analysis of Secret Key Cryptosystem.
In Advances in Cryptology – CRYPTO ’97, vol. 1294 of LNCS, pages 513–525.
Springer, 1997.
450 Mathieu Ciet and Christophe Giraud
8. D. Boneh, R.A. DeMillo, and R.J. Lipton. On the Importance of Checking Cryp-
tographic Protocols for Faults. In Advances in Cryptology – EUROCRYPT ’97,
vol. 1233 of LNCS, pages 37–51. Springer, 1997.
9. G. Gong and L. Harn. Public key cryptosystems based on cubic finite field exten-
sions. In IEEE Transaction on Information Theory, LNCS. Springer, November
1999.
10. L. Goubin. A Refined Power-Analysis Attack on Elliptic Curve Cryptosystem. In
Public Key Cryptography – PKC 2003, vol. 2567 of LNCS, pages 199–210. Springer,
2003.
11. R. Granger, D. Page, and M. Stam. A Comparison of CEILIDH and XTR. In
Algorithmic Number Theory: 6th International Symposium, ANTS-VI, vol. 3076 of
LNCS. Springer, 2004.
12. M. Joye, A.K. Lenstra, and J.-J. Quisquater. Chinese Remaindering Based Cryp-
tosystems in the Presence of Faults. Journal of Cryptology, 12(4):241–246, 1999.
13. P. Kocher. Timing attacks on implementations of Diffie-Hellman, RSA, DSS, and
other systems. In Advances in Cryptology – CRYPTO ’96, vol. 1109 of LNCS,
pages 104–113. Springer, 1996.
14. P. Kocher, J. Jaffe, and B. Jun. Differential Power Analysis. In Advances in
Cryptology – CRYPTO ’99, vol. 1666 of LNCS, pages 388–397. Springer, 1999.
15. A.K. Lenstra. Memo on RSA Signature Generation in the Presence of Faults.
Manuscript, 1996. Available from the author at akl@Lucent.com.
16. A.K. Lenstra and E.R. Verheul. An overview of the XTR public key system. In
Public Key Cryptography and Computational Number Theory Conference, 2000.
17. A.K. Lenstra and E.R. Verheul. Key improvements to XTR. In Advances in
Cryptology – ASIACRYPT 2000, vol. 1976 of LNCS, pages 220–233. Springer,
2000.
18. A.K. Lenstra and E.R. Verheul. The XTR public key system. In Advances in
Cryptology – CRYPTO 2000, vol. 1880 of LNCS, pages 1–19. Springer, 2000.
19. A.K. Lenstra and E.R. Verheul. Fast irreductibility and subgroup membership
testing in XTR. In Public Key Cryptography – PKC 2001, vol. 1992 of LNCS,
pages 73–86. Springer, 2001.
20. G. Piret and J.-J. Quisquater. A Differential Fault Attack Technique Against SPN
Structures, with Application to the AES and Khazad. In Cryptographic Hardware
and Embedded Systems – CHES 2003, vol. 2779 of LNCS, pages 77–88. Springer,
2003.
21. K. Rubin and A. Silverberg. Torus-based cryptography. In Advances in Cryptology
– CRYPTO 2003, vol. 2729 of LNCS, pages 349–365. Springer, 2003.
22. S. Skorobogatov and R. Anderson. Optical Fault Induction Attack. In Crypto-
graphic Hardware and Embedded Systems – CHES 2002, vol. 2523 of LNCS, pages
2–12. Springer, 2002.
23. P. Smith and C. Skinner. A public-key cryptosystem and a digital signature sys-
tem based on the Lucas function analogue to discret logarithms. In Advances in
Cryptology – ASIACRYPT 1994, vol. 917 of LNCS, pages 357–364. Springer, 1994.
24. M. Stam and A.K. Lenstra. Speeding up XTR. In Advances in Cryptology –
ASIACRYPT 2001, vol. 2248 of LNCS, pages 125–143. Springer, 2001.
25. E.R. Verheul. Evidence that XTR Is More Secure then Supersingular Elliptic
Curve Cryptosystems. In Advances in Cryptology – EUROCRYPT 2001, vol. 2045
of LNCS, pages 195–210. Springer, 2001.
26. S.-M. Yen and M. Joye. Checking before output may not be enough against fault-
based cryptanalysis. IEEE Transactions on Computers, 49(9):967–970, 2000.
Transient Fault Induction Attacks on XTR 451
A A SPA/DFA-Resistant XTR Exponentiation
Algorithm A.1 Secure computation of Sn(c) given n and c, from Algorithm 2.1
Input: n and c
Output: Sn(c)
if n < 0 then apply this algorithm to −n and c, and apply [16, Lem. 2.3.2.ii] to the
output.
if n = 0 then S0(c) = (cp, 3, c).
if n = 1 then S1(c) = (3, c, c2 − 2cp).
if n = 2 then use Cor. 1.ii and S1(c) to compute c3.
else define Si(c) = S2i+1(c) and let m = n.
if m is even then m← m− 1.
m← m− 1
2
, k = 1,
Sk(c)← S3(c) (use Cor. 1.i and S2(c) to compute c4).
m =
∑r
j=0 mj2
j with mj ∈ {0, 1} and mr = 1.
for j from r − 1 to 0 do
c4k+2mj ← c2
2k+mj
− 2cp
2k+mj
c4k+1+2mj ← c2k+2mj .c2k+1 − cp(1−mj )+mj cp
2k+1 + cp
2k+2(1−mj )
c4k+2+2mj ← c2
2k+1+mj
− 2cp
2k+1+mj
k ← 2k + mj
c4k+3−2mj ← c2k+2(1−mj ).c2k+1 − cp.mj+1−mj .cp
2k+1 + cp
2k+2mj
if c4k+3+mj �= c.c4k+2+mj − cp.c4k+1+mj + c4k+mj then
return (“A fault attack on a temporary result has been detected”)
if n is even then use Sm(c) to compute Sm+1(c) (using Cor. 1.ii) and m← m+1.
if ComputeCRC(n) �= ComputeCRC(nEEPROM) then
return (Sm(c))
else
return (“A fault attack on the exponent has been detected”)
	1 Introduction
	2 Generalities About XTR
	3 Some Useful Remarks
	3.1 Computing $\bar S_{k}(c)$ from $\bar S_{2k}(c)$ or $\bar S_{2k+1}(c)$
	3.2 An Observation About the Exponentiation
	4 Fault Analysis
	4.1 Random Bit-Faults on a Random $\bar S_{k}(c)$
	4.2 Random Faults on a Chosen $c_i$
	4.3 Erasing Faults on a Coordinate of $c_{2k+1}$ of a Random $\bar S_{k}(c)$
	4.4 Random Bit-Faults on the Secret Exponent
	5 Practical Aspects: Synchronizing the Attacks
	6 Countermeasures
	7 Concluding Remarks
	References
	A A SPA/DFA-Resistant XTR Exponentiation