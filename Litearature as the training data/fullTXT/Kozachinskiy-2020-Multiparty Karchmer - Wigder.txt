Multiparty Karchmer – Wigderson Games and Threshold Circuits
Multiparty Karchmer – Wigderson Games and
Threshold Circuits
Alexander Kozachinskiy
Department of Computer Science, University of Warwick, Coventry, UK
Alexander.Kozachinskiy@warwick.ac.uk
Vladimir Podolskii
Steklov Mathematical Institute, Russian Academy of Sciences, Moscow, Russia
podolskii@mi-ras.ru
Abstract
We suggest a generalization of Karchmer – Wigderson communication games to the multiparty
setting. Our generalization turns out to be tightly connected to circuits consisting of threshold
gates. This allows us to obtain new explicit constructions of such circuits for several functions. In
particular, we provide an explicit (polynomial-time computable) log-depth monotone formula for
Majority function, consisting only of 3-bit majority gates and variables. This resolves a conjecture
of Cohen et al. (CRYPTO 2013).
2012 ACM Subject Classification Theory of computation → Circuit complexity
Keywords and phrases Karchmer-Wigderson Games, Threshold Circuits, threshold gates, majority
function
Digital Object Identifier 10.4230/LIPIcs.CCC.2020.24
Funding Alexander Kozachinskiy: Supported by the EPSRC grant EP/P020992/1 (Solving Parity
Games in Theory and Practice).
Vladimir Podolskii: The work of V.V. Podolskii was performed at the Steklov International Math-
ematical Center and supported by the Ministry of Science and Higher Education of the Russian
Federation (agreement no. 075-15-2019-1614).
Acknowledgements The authors are grateful to Alexander Shen for suggesting to generalize our
initial results.
1 Introduction
Karchmer and Wigderson established tight connection between circuit depth and communic-
ation complexity [11] (see also [12, Chapter 9]). Namely, they showed that for each Boolean
function f one can define a communication game which communication complexity exactly
equals the depth of f in the standard De Morgan basis. This discovery turned out to be
very influential in Complexity Theory. A lot of circuit depth lower bounds as well as formula
size lower bounds rely on this discovery [10, 13, 5, 7, 4]. Karchmer – Wigderson games have
been used also in adjacent areas like Proof Complexity (see, e.g., [14]).
Karchmer – Wigderson games represent a deep connection of two-party communication
protocols with De Morgan circuits. Loosely speaking, in this connection one party is
responsible for ∧ gates and the other party is responsible for ∨ gates. In this paper we
address the question of what would be a natural generalization of Karchmer – Wigderson
games to the multiparty setting. Is it possible to obtain in this way a connection with other
types of circuits?
We answer positively to this question: we suggest such a generalization and show its
connection to circuits consisting of threshold gates. To motivate our results we first present
applications we get from this new connection.
© Alexander Kozachinskiy and Vladimir Podolskii;
licensed under Creative Commons License CC-BY
35th Computational Complexity Conference (CCC 2020).
Editor: Shubhangi Saraf; Article No. 24; pp. 24:1–24:23
Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany
https://orcid.org/0000-0002-9956-9023
mailto:Alexander.Kozachinskiy@warwick.ac.uk
https://orcid.org/0000-0001-7154-138X
mailto:podolskii@mi-ras.ru
https://doi.org/10.4230/LIPIcs.CCC.2020.24
https://creativecommons.org/licenses/by/3.0/
https://www.dagstuhl.de/lipics/
https://www.dagstuhl.de
24:2 Multiparty Karchmer – Wigderson Games and Threshold Circuits
1.1 Applications to circuits
There are two classical constructions of O(logn)-depth monotone formulas for the Majority
function, MAJ2n+1. The one was given by Valiant [15]. Valiant used probabilistic method
which does not give an explicit construction. The other construction is the AKS sorting
network [1]. This construction actually gives polynomial-time computable O(logn)-depth
O(n logn)-size monotone circuit for MAJn.
Several authors (see, e.g., [6, 3]) noticed that the Valiant’s probabilistic argument actually
gives a O(logn)-depth formula for MAJn, consisting only of MAJ3 gates and variables. Is it
possible to construct a O(logn)-depth circuit for MAJ2n+1, consisting only of MAJ3 gates
and variables, deterministically in polynomial time?1
This question was stated as a conjecture by Cohen et al. in [3]. First, they showed that
the answer is positive under some cryptographic assumptions. Secondly, they constructed
(unconditionally) a polynomial-time computable O(logn)-depth circuit, consisting only of
MAJ3 gates and variables, which coincides with MAJn for all inputs in which the fraction of
ones is bounded away from 1/2 by 2−Θ(
√
log n).
We show that the conjecture of Cohen et al. is true (unconditionally).
I Theorem 1. There exists polynomial-time computable O(logn)-depth formula for MAJ2n+1,
consisting only of MAJ3 gates and variables.
In the proof we use the AKS sorting network. In fact, one can use any polynomial-time
computable construction of O(logn)-depth monotone circuit for MAJ2n+1. We also obtain
the following general result:
I Theorem 2. If there is a monotone formula (i.e., formula, consisting of ∧,∨ gates and
variables) for MAJ2n+1 of size s, then there is a formula for MAJ2n+1 of size O(s ·nlog2(3)) =
O(s · n1.58...), consisting only of MAJ3 gates and variables.
Transformation from the last theorem, however, is not efficient. We can make this transform-
ation polynomial-time computable, provided log2(3) is replaced by 1/(1− log3(2)) ≈ 2.71. In
turn, we view Theorem 2 as a potential approach to obtain super-quadratic lower bounds on
monotone formula size for MAJ2n+1. However, this approach requires better than n2+log2(3)
lower bound on formula size of MAJ2n+1 in the {MAJ3} basis. Arguably, this basis may be
easier to analyze than the standard monotone basis. The best known size upper bounds
in the {∧,∨} basis and the {MAJ3} basis are, respectively, O(n5.3) and O(n4.29) [8]. Both
bounds are due to Valiant’s method (see [8] also for the limitations of Valiant’s method).
We also study a generalization of the conjecture of Cohen et al. to threshold functions.
By THRb
a we denote the following Boolean function:
THRb
a : {0, 1}b → {0, 1}, THRb
a(x) =
{
1 x contains at least a ones,
0 otherwise.
For some reasons (to be discussed below) a natural generalization would be a question of
whether THRkn+1
n+1 can by computed by a O(logn)-depth circuit, consisting only of THRk+1
2
gates and variables (initial conjecture can be obtained by setting k = 2). This question was
also addressed by Cohen et al. in [3]. First, they observed that there is a construction of depth
O(n) (and exponential size). Secondly, they gave an explicit construction of depth O(logn),
which coincides with THRkn+1
n+1 for all inputs in which the fraction of ones is bounded away
from 1/k by Θ(1/
√
logn).
1 Note that AKS sorting network does not provide a solution because it consists of ∧ and ∨ gates.
A. Kozachinskiy and V. Podolskii 24:3
However, no exact (even non-explicit) construction with sub-linear depth or sub-exponen-
tial size was known. In particular, Valiant’s probabilistic construction does not work for k ≥ 3.
Nevertheless, in this paper we improve depth O(n) to O(log2 n) and size from exp{O(n)} to
nO(1) for this problem:
I Theorem 3. For any constant k ≥ 3 there exists polynomial-time computable O(log2 n)-
depth polynomial-size circuit for THRkn+1
n+1 , consisting only of THRk+1
2 gates and variables.
1.2 Applications to Multiparty Secure Computations
The conjecture stated in [3] was motivated by applications to Secure Multiparty Computations.
The paper [3] establishes an approach to construct efficient multiparty protocols based on
protocols for a small number of players. More specifically, in their framework one starts
with a protocol for a small number of players and a formula F computing a certain boolean
function. Then one combines a protocol for a small number of players with itself recursively,
where the recursion mimics the formula F .
It is shown in [3] that from our result it follows that for any n there is an explicit
polynomial size protocol for n players secure against a passive adversary that controls any
t < n
2 players. It is also implicit in [3] that from Theorem 3 for k = 3 it follows that for any
n there is a protocol of size 2O(log2 n) for n players secure against an active adversary that
controls any t < n
3 players. An improvement of the depth of the formula in Theorem 3 to
O(logn) would result in a polynomial size protocol. We refer to [3] for more details on the
secure multiparty computations.
1.3 Multiparty Karchmer – Wigderson games
We now reveal a bigger picture to which the above results belong to. Namely, they can be
put into framework of multiparty Karchmer – Wigderson games.
Before specifying how we define these games let us give an instructive example. Consider
ordinary monotone Karchmer – Wigderson game for MAJ2n+1. In this game Alice receives
a string x ∈ MAJ−1
2n+1(0) and Bob receives a string y ∈ MAJ−1
2n+1(1). In other words, the
number of ones in x is at most n and the number of ones in y is at least n+ 1. The goal of
Alice and Bob is to find some coordinate i such that xi = 0 and yi = 1. Next, imagine that
Bob flips each of his input bits. After that parties have two vectors in both of which the
number of ones is at most n. Now Alice and Bob have to find any coordinate in which both
vectors are 0.
In this form this problem can be naturally generalized to the multiparty setting. Namely,
assume that there are k parties, and each receives a Boolean vector of length kn+ 1 with at
most n ones. Let the task of parties be to find a coordinate in which all k input vectors are
0. How many bits of communication are needed for that?
For k = 2 the answer is O(logn), because there exists a O(logn)-depth monotone circuit
for MAJ2n+1 and hence the monotone Karchmer – Wigderson game for MAJ2n+1 can
be solved in O(logn) bits of communication. For k ≥ 3 we are only aware of a simple
O(log2 n)-bit solution based on the binary search.
Now, let us look at the case k ≥ 3 from another perspective and introduce multiparty
Karchmer – Wigderson games. Note that each party receives a vector on which THRkn+1
n+1
equals 0. The goal is to find a common zero. Note that we can consider a similar problem for
any function f satisfying so-called Qk-property: any k vectors from f−1(0) have a common
zero. In the next definition we define Qk-property formally and also introduce related
Rk-property.
CCC 2020
24:4 Multiparty Karchmer – Wigderson Games and Threshold Circuits
I Definition 4. Let Qk be the set of all Boolean functions f satisfying the following property:
for all x1, x2, . . . , xk ∈ f−1(0) there is a coordinate i such that x1
i = x2
i = . . . = xk
i = 0.
Further, let Rk be the set of all Boolean functions f satisfying the following property: for
all x1, x2, . . . , xk ∈ f−1(0) there is a coordinate i such that x1
i = x2
i = . . . = xk
i .
For f ∈ Qk let Qk-communication game for f be the following communication problem.
In this problem there are k parties. The jth party receives a Boolean vector xj ∈ f−1(0).
The goal of players is to find any coordinate i such that x1
i = x2
i = . . . = xk
i = 0.
Similarly we can define Rk-communication games for functions from Rk. In the Rk-
communication games the objective of parties is slightly different: their goal is to find any
coordinate i and a bit b such that x1
i = x2
i = . . . = xk
i = b.
Self-dual functions belong to R2 and monotone self-dual functions belong to Q2. It is
easy to see that R2-communication games are equivalent to Karchmer – Wigderson games for
self-dual functions (one party should flip all the input bits). Moreover, Q2-communication
games are equivalent to monotone Karchmer – Widgerson games for monotone self-dual
functions.
In this paper we consider Rk-communication games as a multiparty generalization of
Karchmer – Wigderson games. In turn, Qk-communication games are considered as a
generalization of monotone Karchmer – Wigderson games. To justify this choice one should
relate them to some type of circuit complexity.
1.4 Connection to threshold gates and the main result
Every function from Qk can be lower bounded by a circuit, consisting only of THRk+1
2 gates
and variables. More precisely, let us write C ≤ f for a Boolean circuit C and a Boolean
function f if for all x ∈ f−1(0) we have C(x) = 0. Then the following proposition holds:
I Proposition 5 ([3]). The set Qk is equal to the set of all Boolean functions f for which
there exists a circuit C ≤ f , consisting only of THRk+1
2 gates and variables.
There is a similar characterization of the set Rk.
I Proposition 6. The set Rk is equal to the set of all Boolean functions f for which there
exists a circuit C ≤ f , consisting only of THRk+1
2 gates and literals2.
The proof from [3] of Proposition 5 with obvious modifications also works for Proposition 6.
Given f ∈ Qk, what is the minimal depth of a circuit C ≤ f , consisting only of THRk+1
2
gates and variables? We show that this quantity is equal (up to constant factors) the
communication complexity of Qk-communication game for f .
I Theorem 7. Let k ≥ 2 be any constant. Then for any f ∈ Qk the following two quantities
are equal up to constant factors:
the communication complexity of Qk-communication game for f ;
minimal d for which there exists a d-depth circuit C ≤ f , consisting only of THRk+1
2
gates and variables.
Similar result can be obtained for Rk-communication games.
2 We stress that negations can only be applied to variables but not to THRk+1
2 gates.
A. Kozachinskiy and V. Podolskii 24:5
I Theorem 8. Let k ≥ 2 be any constant. Then for any f ∈ Rk the following two quantities
are equal up to constant factors:
the communication complexity of Rk-communication game for f ;
minimal d for which there exists a d-depth circuit C ≤ f , consisting only of THRk+1
2
gates and literals.
Proofs of both theorems are divided into two parts:
(a) transformation of a d-depth circuit C ≤ f , consisting only of THRk+1
2 gates and variables
(literals), into a O(d)-bit protocol computing Qk(Rk)-communication game for f ;
(b) transformation of a d-bit protocol computing Qk(Rk)-communication game for f into a
d-depth circuit C ≤ f , consisting only of THRk+1
2 gates and variables (literals).
The first part is simple and the main challenge is the second part. Later in this paper
(Section 6) we also formulate refined versions of Theorems 7 and 8. Namely, we refine these
theorems in the following two directions. Firstly, we take into account circuit size and for
this we consider dag-like communication protocols. Secondly, we show that transformations
(a-b) can be done in polynomial time (under some mild assumptions).
We derive our upper bounds on the depth of MAJ2n+1 and THRkn+1
n+1 (Theorems 1
and 3) from Theorem 7. We first solve the corresponding Qk-communication games with
small number of bits of communication. Namely, for the case of MAJ2n+1 we use AKS
sorting network to solve the corresponding Q2-communication game with O(logn) bits
of communication. For the case of THRkn+1
n+1 with k ≥ 3 we solve the corresponding Qk-
communication game by a simple binary search protocol with O(log2 n) bits of communication.
This is where we get depth O(logn) for Theorem 1 and depth O(log2 n) for Theorem 3.
Again, some special measures should be taken to make the resulting circuits polynomial-time
computable and to control their size3.
1.5 Our techniques: Qk(Rk)-hypotheses games
As we already mentioned, the hard part of our main result is to transform a protocol into a
circuit.
For this we develop a new language to describe circuits, consisting of threshold gates.
Namely, for every f in Qk (Rk) we introduce the corresponding Qk(Rk)-hypotheses game
for f . We show that strategies in these games exactly capture depth and size of circuits,
consisting only of THRk+1
2 gates and variables (literals). It turns out that strategies are more
convenient than circuits to simulate protocols, since they operate in the same top-bottom
manner.
Once we establish the equivalence of circuits and hypotheses games, it remains for us
to transform a communication protocol into a strategy in a hypotheses games. This is an
elaborate construction that is presented in Propositions 20 and 24. Below in this section we
introduce hypotheses games and as an illustration sketch the construction of a strategy in a
hypothesis game that is used in the proof of Theorem 1.
Here is how we define these games. Fix f : {0, 1}n → {0, 1}. There are two players,
Nature and Learner. Before the game starts, Nature privately chooses z ∈ f−1(0), which then
can not be changed. The goal of Learner is to find some i ∈ [n] such that zi = 0. The game
proceeds in rounds. At each round Learner specifies k + 1 families H0,H1, . . . ,Hk ⊂ f−1(0)
to Nature. We understand this as if Learner makes the following k + 1 hypotheses about z:
3 We should only care about the size in case of Theorem 3, because depth O(log n) immediately gives
polynomial size.
CCC 2020
24:6 Multiparty Karchmer – Wigderson Games and Threshold Circuits
“z ∈ H0”,
“z ∈ H1”,
...
“z ∈ Hk”.
Learner loses immediately if less than k hypotheses are true, i.e., if the number of j ∈
{0, 1, . . . , k} satisfying z ∈ Hj is less than k. Otherwise Nature points out to some hypothesis
which is true. In other words, Nature specifies to Learner some j ∈ {0, 1, . . . , k} such that
z ∈ Hj . The game then proceeds in the same manner for some finite number of rounds. At
the end Learner outputs an integer i ∈ [n]. We say that Learner wins if zi = 0.
It is not hard to show that Learner has a winning strategy in Qk-hypotheses game for f
if and only if f ∈ Qk. Since we will use similar arguments in the paper, let us go through
the “if” part: if f ∈ Qk, then Learner has a winning strategy. Denote by Z be the set of
all z’s which are compatible with Nature’s answers so far. At the beginning Z = f−1(0).
If |Z| ≥ k + 1, Learner takes any distinct z1, z2, . . . , zk+1 ∈ Z and makes the following
hypotheses:
“z 6= z1”,
“z 6= z2”,
...
“z 6= zk+1”.
At least k hypotheses are true, and the Nature’s response strictly reduces the size of Z.
When the size of Z becomes k, Learner is ready to give an answer due to Qk-property of f .
This strategy requires exponential in n number of rounds. This can be easily improved
to O(n) rounds. Indeed, instead of choosing k + 1 distinct elements of Z split Z into k + 1
disjoint almost equal parts. Then let the ith hypotheses be “z is not in the ith part”. Nature’s
response to this reduces the size of Z by a constant factor, until the size of Z is k.
For f ∈ Qk we can now ask what is the minimal number of rounds on in a Learner’s
winning strategy. The following proposition gives an exact answer:
I Proposition 9. For any f ∈ Qk the following holds. Learner has a d-round winning
strategy in Qk-hypotheses game for f if and only if there exists a d-depth circuit C ≤ f ,
consisting only of THRk+1
2 gates and variables.
Proposition 9 is the core result for our applications. For instance, we prove Theorem 1
by giving an explicit O(logn)-round winning strategy of Learner in Q2-hypotheses game for
MAJ2n+1. Let us now sketch our argument (the complete proof can be found in Section 4).
Assume that Nature’s input vector is z. We notice that in O(logn) rounds one can easily
find two integers i, j ∈ [2n+ 1] such that either zi = 0 or zj = 0. However, we need to know
for sure. For that we take any polynomial time computable O(logn)-depth monotone formula
F for MAJ2n+1 (for instance one that can be obtained from the AKS sorting network). We
start to descend from the output gate of F to one of F ’s inputs. Throughout this descending
we maintain the following invariant. If g is the current gate, then either g(z) = 0 ∧ zi = 0 or
g(¬z) = 1 ∧ zj = 0 (here ¬ denotes bit-wise negation). It can be shown that in one round
one can either exclude i or j (which will already give us an answer) or replace g by some
gate which is fed to g. If we reach an input to F , we output the index of the corresponding
variable.
A. Kozachinskiy and V. Podolskii 24:7
Similarly one can define Rk-hypotheses game for any f : {0, 1}n → {0, 1}. In Rk-
hypotheses game Nature and Learner play in the same way except that now Learner’s
objective is to find some pair (i, b) ∈ [n]× {0, 1} such that zi = b. The following analog of
Proposition 9 holds:
I Proposition 10. For any f ∈ Rk the following holds. Learner has a d-round winning
strategy in Rk-hypotheses game for f if and only if there exists a d-depth circuit C ≤ f ,
consisting only of THRk+1
2 gates and literals.
1.6 Organization of the paper
In Section 2 we give Preliminaries. In Section 3 we define Qk(Rk)-hypotheses games formally
and derive Proposition 9 and 10. In Section 4 we obtain our results for Majority function
(Theorems 1 and 2) using simpler arguments than in our general results. Then in Section 5
we prove these general results (Theorems 7 and 8). In Section 6 we refine Theorems 7 and 8
in order to take into account the circuit size and computational aspects (Theorems 27 and 30
below). In Section 7 we derive Theorem 3 and provide another proof for Theorem 1. Finally,
in Section 8 we formulate some open problems.
2 Preliminaries
Let [n] denote the set {1, 2, . . . , n} for n ∈ N. For a set W we denote the set of all subsets
of W by 2W . For two sets A and B by AB we mean the set of all functions of the form
f : B → A.
We usually use subscripts to denote coordinates of vectors. In turn, we usually use
superscripts to numerate vectors.
We use standard terminology for Boolean formulas and circuits [9]. We denote the size of
a circuit C by size(C) and the depth by depth(C). By De Morgan formulas/circuits we mean
formulas/circuits consisting of ∧,∨ gates of fan-in 2 and literals (i.e., we assume that negations
are applied only to variables). By monotone formulas/circuits we mean formulas/circuits
consisting of ∧,∨ gates of fan-in 2 and variables. We also consider formulas/circuits consisting
only of THRk+1
2 gates and variables (literals). We stress that in such circuits we do not use
constants. Allowing literals as inputs we allow to apply negations only to variables. We also
assume that negations in literals do not contribute to the depth of a circuit.
We use the notion of deterministic communication protocols in the multiparty number-in-
hand model. However, to capture the circuit size in our results we consider not only standard
tree-like protocols, but also dag-like protocols. This notion was considered by Sokolov in [14].
We use slightly different variant of this notion, arguably more intuitive one. In the next
subsection we provide all necessary definitions. To obtain a definition of a standard protocol
one should replace dags by binary trees.
2.1 Dags and dag-like communication protocols
We use the following terminology for directed acyclic graphs (dags). Firstly, we allow more
than one directed edge from one node to another. A terminal node of a dag G is a node with
no out-going edges. Given a dag G, let
V (G) denote the set of nodes of G;
T (G) denote the set of terminal nodes of G.
For v ∈ V (G) let OutG(v) be the set of all edges of G that start at v. A dag G is called
t-ary if every non-terminal node v of G we have |OutG(v)| = t. An ordered t-ary dag is a
t-ary dag G equipped with a mapping from the set of edges of G to {0, 1, . . . , t− 1}. This
CCC 2020
24:8 Multiparty Karchmer – Wigderson Games and Threshold Circuits
mapping restricted to OutG(v) should be injective for every v ∈ V (G) \ T (G). The value
of this mapping on an edge e will be called the label of e. In terms of labels we require for
ordered t-ary dags that any t edges, starting at the same node, have different labels.
By a path in G we mean a sequence of edges 〈e1, e2, . . . , em〉 such that for every j ∈ [m−1]
edge ei ends in the same node in which ej+1 starts. Note that there may be two distinct
paths visiting same nodes (for instance, there may be two parallel edges from one node to
another).
We say that a node w is a descendant of a node v if there is a path from v to w. We call
w a successor of v if there is an edge from v to w. A node s is called starting node if any
other node is a descendant of s. Note that any dag has at most one starting node.
If a dag G has the starting node s, then by depth of v ∈ V (G) we mean the maximal
length of a path from s to v. The depth of G then is the maximal depth of its nodes.
Assume that X1,X2, . . . ,Xk,Y are some finite sets.
I Definition 11. A k-party dag-like communication protocol π with inputs from X1 ×X2 ×
. . .Xk and with outputs from Y is a tuple 〈G,P1, P2, . . . , Pk, φ1, φ2, . . . , φk, l〉, where
G is an ordered 2-ary dag with the starting node s;
P1, P2, . . . , Pk is a partition of V (G) \ T (G) into k disjoint subsets;
φi is a function from Pi ×Xi to {0, 1};
l is a function from T (G) to Y.
The depth of π (denoted by depth(π)) is the depth of G. The size of π (denoted by
size(π)) is |V (G)|.
The underlying mechanics of the protocol is as follows. Parties descend from s to one
of the terminals of G. If the current node v is not a terminal and v ∈ Pi, then at v the ith
party communicates a bit to all the other parties. Namely, the ith party communicates the
bit b = φi(v, x), where x ∈ Xi is the input of the ith party. Among the two edges, starting
at v, parties choose one labeled by b and descend to one of the successors of v along this
edge. Finally, when parties reach a terminal t, they output l(t).
We say that x ∈ Xi is i-compatible with an edge e from v to w if one of the following two
condition holds:
v /∈ Pi;
v ∈ Pi and e is labeled by φi(v, x).
We say that x ∈ Xi is i-compatible with a path p = (e1, e2, . . . , em) of G if for every j ∈ [m]
it holds that x is i-compatible with ej . Finally, we say that x ∈ Xi is i-compatible with a
node v ∈ V (G) if there is a path p from s to v such that x is i-compatible with v.
We say that an input (x1, x2, . . . , xk) ∈ X1 ×X2 × . . .Xk visits a node v ∈ V (G) if there
is a path p from s to v such that for every i ∈ [k] it holds that xi is i-compatible with p.
Note that there is unique t ∈ T (G) such that (x1, x2, . . . , xk) visits t.
To formulate an effective version of Theorems 7 and Theorem 8 we need the following
definition.
I Definition 12. The light form of a k-party dag-like communication protocol π =
〈G,P1, P2, . . . , Pk, φ1, φ2, . . . , φk, l〉 is a tuple 〈G,P1, P2, . . . , Pk, l〉.
I.e., to obtain the light form of π we just forget about φ1, φ2, . . . , φk. In other words, the
light form only contains the underlying graph of π, the partition of non-terminal nodes
between parties and the labels of terminals. On the other hand, in the light form there is no
information at all how parties communicate at the non-terminal nodes.
Protocol π computes a relation S ⊂ X1×X2× . . .×Xk×Y if the following holds. For every
(x1, x2, . . . , xk) ∈ X1 ×X2 × . . .×Xk there exist y ∈ Y and t ∈ T (G) such that (x1, . . . , xk)
visits t, l(t) = y and (x1, x2, . . . , xk, y) ∈ S.
A. Kozachinskiy and V. Podolskii 24:9
Using language of relations, we can formally define Qk- and Rk-communication games.
Namely, given f : {0, 1}n → {0, 1}, f ∈ Qk, we define Qk-communication game for f as the
following relation:
S ⊂ f−1(0)× . . .× f−1(0)︸ ︷︷ ︸
k
×[n],
S =
{
(x1, . . . , xk, j) | x1
j = . . . = xk
j = 0
}
.
Similarly, given f : {0, 1}n → {0, 1}, f ∈ Rk, we define Rk-communication game for f as the
following relation:
S ⊂ f−1(0)× . . .× f−1(0)︸ ︷︷ ︸
k
×([n]× {0, 1}),
S =
{
(x1, . . . , xk, (j, b)) | x1
j = . . . = xk
j = b
}
.
It is easy to see that a dag-like protocol for S can be transformed into a tree-like protocol
of the same depth, but this transformation can drastically increase the size.
3 Formal treatment of Qk(Rk)-hypotheses games
Fix f ∈ Qk, f : {0, 1}n → {0, 1}. Here we define Learner’s strategies in Qk-hypotheses game
for f formally. We consider not only tree-like strategies but also dag-like. To specify a
Learner’s strategy S in Qk-hypotheses game we have to specify:
An ordered (k + 1)-ary dag G with the starting node s;
a subset Hj(p) for every j ∈ {0, 1, . . . , k} and for every path p in G from s to some node
in V (G) \ T (G);
a number it ∈ [n] for every terminal t.
The underlying mechanics of the game is as follows. Let Nature’s vector be z ∈ f−1(0).
Learner and Nature descend from s to one of the terminals of G. More precisely, a position
in the game is determined by a path p, starting at s. If the endpoint of p is not a terminal,
then Learner specifies some sets H0(p),H1(p), . . . ,Hk(p) as his hypotheses. If less than k of
these sets contain z, then Nature wins. Otherwise Nature specifies some j ∈ {0, 1, . . . , k}
such that z ∈ Hj(p). Among k + 1 edges that start at the endpoint of p players choose one
which is labeled by j. After that they extend p by this edge. At some point parties reach
some terminal t (i.e., the endpoint of p becomes equal t). Then the game ends and Learner
output it.
We stress that Learner’s output depends only on t but not on a path to t (unlike Learner’s
hypotheses). This property will be crucial in establishing connection of Qk-hypotheses games
to circuits.
We now proceed to a formal definition of what does it mean that S is winning for Learner.
We say that z ∈ f−1(0) is compatible with a path p = 〈e1, . . . , em〉, starting in s, if the
following holds. If p is of length 0, then every z ∈ f−1(0) is compatible with p. Otherwise
for every i ∈ {1, . . . , em} it should hold that z ∈ Hj(〈e1, . . . , ei−1〉), where j is the label of
edge ei. Informally this means that Nature, having z on input, can reach a position in the
game which corresponds to a path p.
We say that strategy S is winning for Learner in Qk-hypotheses game for f if for every
path p, starting at s, and for every z ∈ f−1(0), compatible with p, the following holds:
if the endpoint of p is not a terminal, then the number of j ∈ {0, 1, . . . , k} such that
z ∈ Hj(p) is at least k;
if the endpoint of p is t ∈ T (G), then zit = 0.
CCC 2020
24:10 Multiparty Karchmer – Wigderson Games and Threshold Circuits
We will formulate a stronger version of Proposition 9. For that we need the notion of the
light form of the strategy S. Namely, the light form of S is its underlying dag G equipped
with a mapping which to every t ∈ T (G) assigns it. In other words, the light form contains
a “skeleton” of S and Learner’s outputs in terminals (and no information about Learner’s
hypotheses).
We can identify the light form of any strategy S with a circuit, consisting only of THRk+1
2
gates and variables. Namely, place THRk+1
2 gate in every v ∈ V (G) \ T (G) and for every
t ∈ T (G) place a variable xit in t. Set s to be the output gate.
I Proposition 13. For all f ∈ Qk, f : {0, 1}n → {0, 1} the following holds:
(a) if S is a Learner’s winning strategy in Qk-hypotheses game for f , then its light form,
considered as a circuit C consisting only of THRk+1
2 gates and variables, satisfies C ≤ f .
(b) Assume that C ≤ f is a circuit, consisting only of THRk+1
2 gates and variables. Then
there exists a Learner’s winning strategy S in Qk-hypotheses game for f such that the
light form of S coincides with C.
We omit the proof of (b) as in the paper we only use (a).
Proof of (a) of Proposition 13. For a node v ∈ V (G) let fv : {0, 1}n → {0, 1} be the
function, computed by the circuit C at the gate, corresponding to v.
We shall prove the following statement. For any path p, starting in s, and for any z which
is compatible with p it holds that fv(z) = 0, where v is the endpoint of p. To see why this
implies C ≤ f take any z ∈ f−1(0) and note that z is compatible with the path of length 0.
The endpoint of such path is s and hence 0 = fs(z) = C(z).
We will prove the above statement by the backward induction on the length of p. The
longest path p ends in some t ∈ T (G). By definition ft = xit
. On the other hand, since S is
winning, zit
= 0 for any z compatible with p. In other words, ft(z) = 0 for any z compatible
with p. The base is proved.
Induction step is the same if p ends in some other terminal. Now assume that p ends in
v ∈ V (G)\T (G). Take any z ∈ f−1(0) compatible with p. Let pj be the extension of p by the
edge which starts at v and is labeled by j ∈ {0, 1, . . . , k}. Next, let vj be the endpoint of pj
(nodes v0, v1, . . . , vk are successors of v). Since S is winning, the number of j ∈ {0, 1, . . . , k}
such that z ∈ Hj(p) is at least k. Hence by definition the number of j ∈ {0, 1, . . . , k} such
that z is compatible with pj is at least k. Finally, by the induction hypothesis this means
that the number of j ∈ {0, 1, . . . , k} such that fvj
(z) = 0 is at least k. On the other hand:
fv = THRk+1
2 (fv0 , fv1 , . . . , fvk
).
Therefore fv(z) = 0, as required. J
One can formally define analogues notions for Rk-hypotheses games. We skip this as
modifications are straightforwards and only formulate an analog of Proposition 13.
I Proposition 14. For all f ∈ Rk, f : {0, 1}n → {0, 1} the following holds:
(a) if S is a Learner’s winning strategy in Rk-hypotheses game for f , then its light form,
considered as a circuit C consisting only of THRk+1
2 gates and literals, satisfies C ≤ f .
(b) Assume that C ≤ f is a circuit, consisting only of THRk+1
2 gates and literals. Then
there exists a Learner’s winning strategy S in Rk-hypotheses game for f such that the
light form of S coincides with C.
I Remark 15. It might be unclear why we prefer to construct strategies instead of constructing
circuits directly, because beside the circuit itself we should also specify Learner’s hypotheses.
The reason is that strategies can be seen as proofs that the circuit we construct is correct.
A. Kozachinskiy and V. Podolskii 24:11
4 Results for Majority
Proof of Theorem 1. There exists an algorithm which in nO(1)-time produces a monotone
formula F of depth d = O(logn) computing MAJ2n+1. Below we will define a strategy SF in
the Q2-hypotheses game for MAJ2n+1. Strategy SF will be winning for Learner. Moreover,
its depth will be d + O(logn). In the end of the proof we will refer to Proposition 13 to
show that SF yields a O(logn)-depth polynomial-time computable formula for MAJ2n+1,
consisting only of MAJ3 gates and variables.
Strategy SF has two phases. The first phase does not uses F at all, only the second
phase does. The objective of the first phase is to find some distinct i, j ∈ [2n+ 1] such that
either zi = 0 ∧ zj = 1 or zi = 1 ∧ zj = 0, where z is the Nature’s vector. This can be done as
follows.
I Lemma 16. One can compute in polynomial time a 3-ary tree T of depth O(logn) with
the set of nodes v(T ) and a mapping w : v(T )→ 2[2n+1] such that the following holds:
if r is the root of T , then w(r) = [2n+ 1];
if v is not a leaf of T and v1, v2, v3 are 3 children of v, then every element of w(v) is
covered at least twice by w(v1), w(v2), w(v3);
if l is a leaf of T , then w(r) is of size 2.
Proof. We start with a trivial tree, consisting only of the root, to which we assign [2n+ 1].
Then at each iteration we do the following. We have a 3-ary tree in which nodes are assigned
to some subsets of [2n+1]. If every leaf is assigned to a set of size 2, we terminate. Otherwise
we pick any leaf l of the current tree which is assigned to a subset A ⊂ [2n+1] of size at least 3.
We split A into 3 disjoint subsets A1, A2, A3 of sizes b|A|/3c, b|A|/3c and |A| − 2b|A|/3c. We
add 3 children to l (which become new leafs) and assign A1 ∪A2, A1 ∪A3, A2 ∪A3 to them.
It is easy to verify that the sizes of A1 ∪A2, A1 ∪A3, A2 ∪A3 are at least 2 and at most
4
5 · |A|. Hence the size of the set assigned to a node of depth h is at most
( 4
5
)h · (2n + 1).
This means that the depth of the tree is at any moment at most log5/4(2n+ 1) = O(logn).
Therefore we terminate in 3O(log n) = nO(1) iterations, as at each iteration we add 3 new
nodes. Each iteration obviously takes polynomial time. J
We use T to find two i, j ∈ [2n+ 1] such that either zi = 0 or zj = 0. Namely, we descend
from the root of T to one of its leafs. Learner maintains an invariant that the leftmost
0-coordinate of z is in w(v), where v is the current node of T . Let v1, v2, v3 be 3 children
of v. Learner for every i ∈ [3] makes a hypothesis that the leftmost 0-coordinate of z is in
w(vi). Due to the properties of w at least two hypotheses are true. Nature indicates some vi
for which this is true, and Learner descends to vi. When Learner reaches a leaf, he knows a
set of size two containing the leftmost 0-coordinate of z. Let this set be {i, j}.
We know that either zi or zj is 0. Thus zizj ∈ {00, 01, 10}. At the cost of one round
we can ask Nature to identify an element of {00, 01, 10} which differs from zizj . If 10 is
identified, then zizj ∈ {00, 01}, and hence zi = 0, i.e., we can already output i. Similar thing
happens when 01 is identified. Finally, if 00 is identified, then the objective of the first phase
is fulfilled and we can proceed to the second phase.
The second phase takes at most d rounds. In this phase Learner produces a sequence
g0, g1, . . . , gd′ , d′ ≤ d of gates of F , where the depth of gi is i, the last gate gd′ is an input
variable (i.e., a leaf of F ) and each g ∈ {g0, g1, . . . , gd′} satisfies:
(g(z) = 0 ∧ zizj = 01) ∨ (g(¬z) = 1 ∧ zizj = 10) . (1)
Here ¬z denotes the bit-wise negation of z.
CCC 2020
24:12 Multiparty Karchmer – Wigderson Games and Threshold Circuits
At the beginning Learner sets g0 = gout to be the output gate of F . Let us explain why
(1) holds for gout. Nature’s vector is an element of MAJ−1
2n+1(0). I.e., the number of ones in
z is at most n. In turn, in ¬z there are at least n+ 1 ones. Since gout computes MAJ2n+1,
we have that gout(z) = 0 and gout(¬z) = 1. In turn, by the first phase it is guarantied that
zizj = 01 ∨ zizj = 10.
Assume now that the second phase is finished, i.e., Learner has produced some gd′ = xk
satisfying (1). Then by (1) either gd′(z) = zk = 0 or gd′(¬z) = (¬z)k = 1. In both cases
zk = 0, i.e., Learner can output k.
It remains to explain how to fulfill the second phase. It is enough to show the following.
Assume that Learner knows a gate gl of F of depth l satisfying (1) and that gl is not an
input variable. Then in one round he can either find a gate gl+1 of depth l + 1 satisfying (1)
or give a correct answer to the game.
The gate gl+1 will be one of the two gates which are fed to gl. Assume first that gl is an
∧-gate and gl = u ∧ v. From (1) we conclude that from the following 3 statements exactly 1
is true for z:
u(z) = 0 and zizj = 01, (2)
u(z) = 1, v(z) = 0 and zizj = 01, (3)
u(¬z) = v(¬z) = 1 and zizj = 10. (4)
At the cost of one round Learner can ask Nature to indicate one statement which is false for
x. If Nature says that (2) is false for z, then (1) holds for gl+1 = v. Next, if Nature says
that (3) is false for z, then (1) holds for gl+1 = u. Finally, if Nature says that (4) is false for
z, then we know that zizj = 01, i.e., Learner can already output i.
In the same way we can deal with the case when gl is an ∨-gate and gl = u ∨ v. By (1)
exactly 1 of the following 3 statements is true for z:
u(z) = v(z) = 0 and zizj = 01, (5)
u(¬z) = 1 and zizj = 10, (6)
u(¬z) = 0, v(¬z) = 1 and zizj = 10. (7)
Similarly, Learner asks Nature to indicate one statement which is false for z. If Nature says
that (5) is false for z, then zizj = 10, i.e., Learner can output j. Next, if Nature says that
(6) is false for z, then (1) holds for gl+1 = v. Finally, if Nature says that (7) is false for z,
then (1) holds for gl+1 = u.
Thus SF is a O(logn)-depth winning strategy of Learner. Apply Proposition 13 to SF .
We get a O(logn)-depth formula F ′ ≤ MAJ2n+1, consisting only of MAJ3 gates and variables.
In fact, F ′ computes MAJ2n+1. Indeed, F ′ ≤ MAJ2n+1 means that F ′ outputs 0 on every
input with at most n ones. On the other hand, F ′ consists of MAJ3 gates and hence F ′
computes a self-dual function. Therefore F ′ outputs 1 on every input with at least n + 1
ones.
It remains to explain how to compute F ′ in polynomial time. To do so we have to
compute in polynomial time the light form of SF , i.e., the underlying tree of SF and the
outputs of Learner in the leafs. It is easy to see that one can do this as follows.
First, compute F and compute T from Lemma 16. For each leaf l of T do the following.
Let w(l) = {i, j}. Add 3 children to l. Two of them will be leafs of SF , in one Learner
outputs i and in the other Learner outputs j. Attach a tree of F to the third child. Then
add to each non-leaf node of F one more child so that now the tree of F is 3-ary. Each added
child is a leaf of SF . If a child was added to an ∧-gate, then Learner outputs i in this child.
A. Kozachinskiy and V. Podolskii 24:13
In turn, if a child was added to an ∨ gate, then Learner outputs j in it. Finally, there are
leafs that were in F initially, each labeled by some input variable. In these nodes Learner
outputs the index of the corresponding input variable. J
Proof of Theorem 2. How many rounds takes the first phase of the strategy SF from the
previous proof? Initially the left-most 0-coordinate of z takes O(n) values. At the cost of
one round we can shrink the number of possible values almost by a factor of 3/2. Thus the
first phase corresponds to a ternary tree of depth log3/2(n) + O(1). The size of that tree
is hence 3log3/2(n)+O(1) = O(n1/(1−log3(2))) = O(n2.70951...). To some of its leafs we attach a
tree of the same size as the initial formula F . As a result we obtain a formula F ′ of size
O(n2.70951... · s) for MAJ2n+1, consisting of MAJ3 gates and variables (here s is the size of
the initial formula F ).
Let us show that we can perform the first phase in log2(n) + O(1) rounds. This will
improve the size of the previous construction to O(3log2(n)+O(1) ·s) = O(nlog2(3) ·s). However,
the construction with log2(n) + O(1) rounds will not be explicit. We need the following
Lemma:
I Lemma 17. There exists a formula D with the following properties:
formula D is a complete ternary tree of depth dlog2(n)e+ 10;
every non-leaf node of D contains a MAJ3 gate and every leaf of D contains a conjunction
of 2 variables;
D(x) = 0 for every x ∈ {0, 1}2n+1 with at most n ones.
Let us at first explain how to use formula D from Lemma 17 to fulfill the first phase. Recall
that our goal is to find two indices i, j ∈ [2n+ 1] such that either zi = 0 or zj = 0. To do so
Learner descends from the output gate of D to some of its leafs. He maintains an invariant
that for his current gate g of D it holds that g(z) = 0. For the output gate the invariant
is true because by Lemma 17 D is 0 on all Nature’s possible vectors. If we reached a leaf
so that g is a conjuction of two variables zi and zj , then the first phase is fulfilled (by the
invariant zi ∧ zj = 0). Finally, if g is a non-leaf node of D, i.e., a MAJ3 gate, then we can
descend to one of the children of g at the cost of one round without violating the invariant.
Indeed, as g(z) = 0, then the same is true for at least 2 children of g. For each child gi of g
Learner makes a hypotheses that gi(z) = 0. Any Nature’s response allows us to replace g by
some gi.
Proof of Lemma 17. We will show existence of such D via probabilistic method. Namely,
independently for each leaf l of D choose (i, j) ∈ [2n+ 1]2 uniformly at random and put the
conjuction zi ∧ zj into l. It is enough to demonstrate that for any x ∈ {0, 1}2n+1 with at
most n ones it holds that Pr[D(x) = 1] < 2−2n−1.
To do so we use the modification of the standard Valiant’s argument. For any fixed x let
p be the probability that a leaf l of D equals 1 on x. This probability is the same for all
the leafs and is at most 1/4. Now, Pr[D(x) = 1] can be expressed exactly in terms of p as
follows:
Pr[D(x) = 1] = f(f(f(. . . f︸ ︷︷ ︸
dlog2(n)e+ 10
(p))) . . .),
where f(t) = t3 + 3t2(1− t) = 3t2 − 2t3. Observe that 3f(t) ≤ (3t)2. Hence
3 Pr[D(x) = 1] ≤ (3p)2dlog2(n)e+10
≤ (3/4)1000n < (1/2)−2n−1. J
J
CCC 2020
24:14 Multiparty Karchmer – Wigderson Games and Threshold Circuits
5 Proof of the main theorem
Theorem 7 follows from Proposition 18 (Subsection 5.1) and Proposition 20 (Subsection 5.2).
In turn, Theorem 8 follows from Proposition 19 (Subsection 5.1) and Proposition 24 (Subsec-
tion 5.2).
5.1 From circuits to protocols
I Proposition 18. For any constant k ≥ 2 the following holds. Assume that f ∈ Qk and
C ≤ f is a circuit, consisting only of THRk+1
2 gates and variables. Then there is a protocol
π, computing Qk-communication game for f , such that depth(π) = O(depth(C)).
Proof. Let the inputs to parties be z1, . . . , zk ∈ f−1(0). Parties descend from the output
gate of C to one of the inputs. They maintain the invariant that for the current gate g
of C it holds that g(z1) = g(z2) = . . . = g(zk) = 0. If g is not yet an input, then g is a
THRk+1
2 gate and g = THRk+1
2 (g1, . . . , gk+1) for some gates g1, . . . , gk+1. For each zi we
have g(zi) = THRk+1
2 (g1(zi), . . . , gk+1(zi)) = 0. Hence for each zi there is at most one gate
out of g1, . . . , gk+1 satisfying gj(zi) = 1. This means that in O(1) bits of communication
parties can agree on the index j ∈ [k + 1] satisfying gj(z1) = gj(z2) = . . . gj(zk) = 0.
Thus in O(depth(π)) bits of communication they reach some input of C. If this input
contains the variable xl, then by the invariant z1
l = z2
l = . . . = zk
l = 0, as required. J
Exactly the same argument can be applied to the following proposition.
I Proposition 19. For any constant k ≥ 2 the following holds. Assume that f ∈ Rk and
C ≤ f is a circuit, consisting only of THRk+1
2 gates and literals. Then there is a protocol π,
computing Rk-communication game for f , such that depth(π) = O(depth(C)).
5.2 From protocols to circuits
I Proposition 20. For every constant k ≥ 2 the following holds. Let f ∈ Qk. Assume that
π is a communication protocol computing Qk-communication game for f . Then there is a
circuit C ≤ f , consisting of THRk+1
2 gates and variables, such that depth(C) = O(depth(π)).
Proof. In the proof we will use the following terminology for strategies in Qk-hypotheses
game. Fix some strategy S. A current play is a finite sequence r1, r2, r3, . . . rj of integers
from 0 to k. By ri we mean Nature’s response in the ith round. Given a current play, let
Hi
0, . . . ,Hi
k ⊂ f−1(0) be k + 1 hypotheses Learner makes in the ith round according to S if
Nature’s responses in the first i− 1 rounds were r1, . . . , ri−1. If after that Nature’s response
is ri, then Nature’s input vector z satisfies z ∈ Hi
ri
. We say that z ∈ f−1(0) is compatible
with the current play r1, . . . , rj if z ∈ H1
r1
, . . . , z ∈ Hj
rj
. Informally, this means that Nature,
having z on input, can produce responses r1, . . . , rj by playing against strategy S.
Set d = depth(π). By Proposition 13 it is enough to give a O(d)-round winning strategy
of Learner in the Qk-hypotheses game for f . Strategy proceeds in d iterations, each iteration
takes O(1) rounds.
As the game goes on, a sequence of Nature’s responses r1, r2, r3 . . . is produced. Assume
that r1, . . . , rh′ are Nature’s responses in the first h iteration (here h′ is the number of rounds
in the first h iterations). Given any r1, r2, r3 . . ., by Zh we denote the set of all z ∈ f−1(0)
which are compatible with r1, . . . rh′ , . We also say that elements of Zh are compatible with
the current play after h iterations.
A. Kozachinskiy and V. Podolskii 24:15
Let V be the set of all nodes of the protocol π and let T be the set of all terminals of the
protocol π.
Consider a set Z ⊂ f−1(0), a set of nodes U ⊂ V and a function g : Z → C, where
|C| = k. A g-profile of a tuple (z1, . . . , zk) ∈ Z is a vector (g(z1), . . . , g(zk)) ∈ Ck.
We say that g : Z → C is complete for Z with respect to the set of nodes U if the following
holds. For every vector c̄ ∈ Ck there exists a node v ∈ U such that all tuples from Zk with
g-profile c̄ visit v in the protocol π.
We say that a set of nodes U ⊂ T is complete for Z if there exists g : Z → C, |C| = k
which is complete for Z with respect to U .
Note that we can consider only complete sets of size at most kk. Formally, if U is complete
for Z, then there is a subset U ′ ⊂ U of size at most kk which is also complete for Z. Indeed,
there are kk possible g-profiles and for each we need only one node in U .
I Lemma 21. Assume that U ⊂ T is complete for Z ⊂ f−1(0). Then there exists i ∈ [n]
such that zi = 0 for every z ∈ Z.
Proof. If Z is empty, then there is nothing to prove. Otherwise let g : Z → C, |C| = k
be complete for Z with respect to U . Take any vector c̄ = (c1, . . . , ck) ∈ Ck such that
{ci | i ∈ [k]} = g(Z). There exists a node v ∈ U such that any tuple from Zk with g-profile c̄
visits v. Note that v is a terminal of π and let i be the output of π in v. Let us show that for
any z ∈ Z it holds that zi = 0. Indeed, note that there exists a tuple z̄ ∈ Zk which includes
z and which has g-profile c̄. This tuple visits v. Since π computes Qk-communication game
for f , every element of the tuple z̄ should have 0 at the ith coordinate. In particular, this
holds for z. J
After d iterations Learner should be able to produce an output. For that there should exist
i ∈ [n] such that for any z ∈ Zd it holds that zi = 0. We will use Lemma 21 to ensure that.
Namely, we will ensure that there exists U ⊂ T which is complete for Zd. Learner achieves
this by maintaining the following invariant.
Let us say that a set of nodes U is h-low if every element of U is either a terminal or a
node of depth at least h.
I Invariant 22. There is a h-low set U which is complete for Zh.
This invariant implies that Learner wins in the end, as any d-low set consists only of terminals.
A 0-low set which is complete for Z0 = f−1(0) is a set consisting only of the starting
node of π.
Assume that Invariant 22 holds after h iterations. Let us show how to perform the next
iteration to maintain the invariant. For that we need a notion of communication profile.
A communication profile of z ∈ f−1(0) with respect to a set of nodes U ⊂ V is a function
pz : U → {0, 1}. For v ∈ U the value of pz(v) is defined as follows. If v is a terminal, set
pz(v) = 0. Otherwise let i ∈ [k] be the index of the party communicating at v. Set pz(v) to
be the bit transmitted by the ith party at v on input z. I.e., pz for every v ∈ U contains
information where the protocol goes from the node v if the party, communicating at v, has z
on input.
We also define a communication profile of the tuple (z1, . . . , zk) ∈ (f−1(0))k as
(pz1 , . . . , pzk ).
I Lemma 23. Let (z1, . . . , zk), (y1, . . . , yk) ∈ (f−1(0))k be two inputs visiting the same node
v ∈ V \ T . Assume that their communication profiles with respect to {v} coincide. Then
these two inputs visit the same successor of v.
CCC 2020
24:16 Multiparty Karchmer – Wigderson Games and Threshold Circuits
Proof. Let their common communication profile with respect to {v} be (p1, . . . , pk). Next,
assume that i is the index of the party communicating at v. Then the information where
these inputs descend from v is contained in pi. J
Here is what Learner does during the (h+ 1)st iteration. He takes any h-low U of size at
most kk which is complete for Zh. Then he takes any g : Zh → C, |C| = k which is complete
for Zh with respect to U . He now devises a new function g′ taking elements of the set Zh on
input. The value of g′(z) is a pair (pz, g(z)), where pz is a communication profile of z with
respect to U . There are at most 2|U | ≤ 2kk different communication profiles with respect to
U . Hence g′(z) takes at most 2kk · k = O(1) values.
At each round of the (h+ 1)st iteration Learner asks Nature to identify some pair (p, c),
where p : U → {0, 1} and c ∈ C, such that g′(z) 6= (p, c) for the Nature’s vector z. Namely,
we take any k + 1 values of g′ which are not yet rejected by Nature and ask Nature to reject
one of them. We do so until there are only k possible values (p1, c1), . . . (pk, ck) left. This
takes O(1) rounds and the (h+ 1)st iteration is finished. Any z ∈ f−1(0) which is compatible
with the responses Nature’ gave during the (h+ 1)st iteration in the current play satisfies
g′(z) ∈ C ′ = {(p1, c1), . . . (pk, ck)}. In particular, any z ∈ Zh+1 satisfies g′(z) ∈ C ′. I.e.,
the restriction of g′ to Zh+1 is a function of the form g′ : Zh+1 → C ′. Let us show that
g′ : Zh+1 → C ′ is complete for Zh+1 with respect to some (h+ 1)-low set U ′. This will ensure
that Invariant 22 is maintained after h+ 1 iterations.
We define U ′ is follows. Take any vector c̄ ∈ (C ′)k. It is enough to show that all the
inputs from (Zh+1)k with g′-profile c̄ visit the same node v′ which is either a terminal or
of depth at least h+ 1. Then we just set U ′ to be the union of all such v′ over all possible
g′-profiles.
All the tuples from (Zh+1)k with the same g′-profile visit the same node v ∈ U . This is
because g′-profile of a tuple determines its g-profile (the value of g′ determines the value of
g) , and hence we can use Invariant 22 for Zh−1 here. If v is a terminal, there is nothing
left to prove. Otherwise, note that g′-profile of a tuple also determines its communication
profile with respect to U and hence with respect to {v} ⊂ U . Therefore all the tuples with
the same g′-profile by Lemma 23 visit the same successor of v. J
With straightforward modifications one can obtain a proof of the following:
I Proposition 24. For every constant k ≥ 2 the following holds. Let f ∈ Rk. Assume that
π is a dag-like protocol computing Rk-communication game for f . Then there is a circuit
C ≤ f , consisting of THRk+1
2 gates and literals, satisfying depth(C) = O(depth(π)).
I Corollary 25 (Weak version of Theorem 3). For any constant k ≥ 2 there exists O(log2 n)-
depth formula for THRkn+1
n+1 , consisting only of THRk+1
2 gates and variables.
Proof. We will show that there exists O(log2 n)-depth protocol π computing Qk-communica-
tion game for THRkn+1
n+1 . By Proposition 20 this means that there is a O(log2 n)-depth
formula F ≤ THRkn+1
n+1 , consisting only of THRk+1
2 gates and variables. It is easy to see that
F actually coincides with THRkn+1
n+1 . Indeed, assume that F (x) = 0 for some x with at least
n+ 1 ones. Then it is easy to construct x2, . . . , xk, each with n ones, such that there is no
common 0-coordinate for x, x2, . . . , xk. On all of these vectors F takes value 0. However, the
function computed by F should belong to Qk (Proposition 5).
Let π be the following protocol. Assume that the inputs to parties are x1, x2, . . . , xk ∈
{0, 1}kn+1, without loss of generality we can assume that in each xr there are exactly n ones.
For x ∈ {0, 1}kn+1 define supp(x) = {i ∈ [kn+ 1] | xi = 1}. Let T be a binary rooted tree of
A. Kozachinskiy and V. Podolskii 24:17
depth d = log2(n) +O(1) with kn+ 1 leafs. Identify leafs of T with elements of [kn+ 1]. For
a node v of T let Tv be the set of all leafs of T which are descendants of v. Once again, we
view Tv as a subset of [kn+ 1].
The protocol proceeds in at most d iterations. After i iterations, i = 0, 1, 2, . . . , d, parties
agree on a node v of T of depth i, satisfying the following invariant:
k∑
r=1
|supp(xr) ∩ Tv| < |Tv|. (8)
At the beginning Invariant (8) holds just because v is the root, Tv = [kn + 1] and each
supp(xr) is of size n.
After d iterations v = l is a leaf of T . Parties output l. This is correct because by (8) we
have |Tl| = 1 =⇒ |supp(xr) ∩ Tl| = 0 =⇒ xl = 0 for every r ∈ [k].
Let us now explain what parties do at each iteration. If the current v is not a leaf, let
v0, v1 be two children of v. Each party sends |supp(xr) ∩ Tv0 | and |supp(xr) ∩ Tv1 |, using
O(logn) bits. Since Tv0 and Tv1 is a partition of Tv, we have:
1∑
b=0
k∑
r=1
|supp(xr) ∩ Tvb
| =
k∑
r=1
|supp(xr) ∩ Tv| < |Tv| =
1∑
b=0
|Tvb
|.
Thus the inequality:
k∑
r=1
|supp(xr) ∩ Tvb
| < |Tvb
| (9)
is true either for b = 0 or for b = 1. Let b∗ be the smallest b ∈ {0, 1} for which (9) is true.
Parties proceed to the next iteration with v being replaced by vb∗ .
There are d = O(logn) iterations, at each parties communicate O(logn) bits. Hence π is
O(log2 n)-depth, as required. J
I Remark 26. Strategy from the proof of Proposition 20 is efficient only in terms of the
number of rounds. In the next section we give another version of this strategy. This version
will ensure that circuits we obtain from protocols for Qk-communication games are not only
low-depth, but also polynomial-size and explicit. For that, however, we require a bit more
from the protocol π.
6 Effective version
Fix f ∈ Qk. We say that a dag-like communication protocol π strongly computes Qk-
communication game for f if for every terminal t of π, for every x ∈ f−1(0) and for every
i ∈ [k] the following holds. If x is i-compatible with t, then xj = 0, where j = l(t) is the
label of terminal t in the protocol π.
Similarly, fix f ∈ Rk. We say that a dag-like communication protocol π strongly computes
Rk-communication game for f if for every terminal t of π, for every x ∈ f−1(0) and for every
i ∈ [k] the following holds. If x is i-compatible with t, then xj = b, where (j, b) = l(t) is the
label of terminal t in the protocol π.
Strong computability is close to the notion of computability that Sokolov gave in [14] for
general relations. Strong computability implies more intuitive notion of computability that
we gave in the Preliminaries. The opposite direction is false in general.
Next we prove an effective version of Proposition 20.
CCC 2020
24:18 Multiparty Karchmer – Wigderson Games and Threshold Circuits
I Theorem 27. For every constant k ≥ 2 there exists a polynomial-time algorithm A such
that the following holds. Assume that f ∈ Qk and π is a dag-like protocol which strongly
computes Qk-communication game for f . Then, given the light form of π, the algorithm
A outputs a circuit C ≤ f , consisting only of THRk+1
2 gates and variables, such that
depth(C) = O(depth(π)), size(C) = O
(
size(π)O(1)).
Proof. We will again give a O(d)-round winning strategy of Learner in the Qk-hypotheses
game for f . Now, however, we should ensure that the light form of our strategy is of size
O
(
size(π)O(1)) and can be computed in time O
(
size(π)O(1)) from the light form of π. Instead
of specifying the light form of our strategy directly we will use the following trick. Assume
that Learner has a working tape consisting of O(log size(π)) cells, where each cell can store
one bit. Learner memorizes all the Nature’s responses so that he knows the current position
of the game. But he does not store the sequence of Nature’s responses on the working tape
(there is no space for it). Instead, he first makes his hypotheses which depend on the current
position. Then he receives a Nature’s response r ∈ {0, 1, . . . , k}. And then he modifies
the working tape, but the result should depend only on the current content of the working
tape and on r (and not on the current position in a game). Moreover, we will ensure that
modifying the working tape takes O
(
size(π)O(1)) time, given the light form of π.
The main purpose of the working tape manifests itself in the end. Namely, at some point
Learner decides to stop making hypotheses. This should be indicated on the working tape.
More importantly, Learner’s output should depend only on the content of working tape in
the end (and not on the whole sequence of Nature’s responses). Moreover, this should take
O
(
size(π)O(1)) time to compute that output, given the light form of π.
If a strategy satisfies these restrictions, then its light form is computable in O
(
size(π)O(1))
time given the light form of π. Indeed, the underlying dag will consist of all possible
configurations of the working tape. There are O
(
size(π)O(1)) of them, as working tape uses
O(log size(π)) bits. For all non-terminal configurations c we go through all r ∈ {0, 1, . . . , k}.
We compute what would be a configuration cr of the working tape if the current configuration
is c and Nature’s response is r. After that we connect c to c0, c1, . . . , ck. Finally, in all
terminal configurations we compute the outputs of Learner. This gives a light form of our
strategy in O
(
size(π)O(1)) time.
Let V be the set of nodes of π and T be the set of terminals of π. Strategy proceeds in d
iterations, each taking O(1) rounds. We define sets Zh exactly as in the proof of Proposition
20. We also use the same notion of communication profile. However, we define completeness
in a different way. First of all, instead of working with sets of nodes with no additional
structure we will work with multidimensional arrays of nodes. Namely, we will consider
k-dimensional arrays in which every dimension is indexed by integers from [k]. Formally,
such arrays are functions of the form M : [k]k → V . We will use notation M [c1, . . . , ck] for
the value of M on (c1, . . . , ck) ∈ [k]k.
Consider any Z ⊂ f−1(0). We say that g : Z → [k] is complete for Z with respect to a
multidimensional array M : [k]k → V if for every (c1, . . . , ck) ∈ [k]k, for every i ∈ [k] and for
every z ∈ Z the following holds. If ci = g(z), then z is i-compatible with M [c1, . . . , ck].
We say that a multidimensional array M : [k]k → V is complete for Z if there exists
g : Z → [k] which is complete with respect to M .
To digest the notion of completeness it is instructive to consider the case k = 2. In this
case M is a 2× 2 table containing four nodes of π. The function g : Z → [2] is complete for
Z with respect to M if the following holds. First, for every z ∈ Z two nodes in the g(z)th
row of M should be 1-compatible with z. Second, for every z ∈ Z two nodes in the g(z)th
column of M should be 2-compatible with z.
A. Kozachinskiy and V. Podolskii 24:19
Let us now establish an analog of Lemma 21.
I Lemma 28. Assume that M : [k]k → T is complete for Z ⊂ f−1(0). Let l be the output of
π in the terminal M [1, 2, . . . , k]. Then zl = 0 for every Z.
Proof. Since π strongly computes Qk-communication game for f , it is enough to show that
every z ∈ Z is i-compatible withM [1, 2, . . . , k] for some i. Take g : Z → [k] which is complete
for Z with respect to M . By definition z is g(z)-compatible with M [1, 2, . . . , k]. J
We now proceed to the description of the Learner’s strategy. The working tape of Learner
consists of:
an integer iter;
a multidimensional array M : [k]k → V ;
O(1) additional bits of memory.
Integer iter will be at most d ≤ size(π) so to store all this information we need O(log(size(π)))
bits, as required. Integer iter always equals the number of iterations performed so far (at the
beginning iter = 0). The array M changes only at the moments when iter is incremented by
1. So let Mh denote the content of the array M when iter = h.
We call an array of nodes h-low if every node in it is either terminal or of depth at least
h. Learner maintains the following invariant.
I Invariant 29. Mh is h-low and Mh is complete for Zh.
At the beginning Learner sets every element of M0 to be the starting node of π so that
Invariant 29 trivially holds.
Note that every node in Md is a terminal of π. After d iterations Learner outputs the
label of terminal Md[1, 2, . . . , k] in the protocol π. As Md is complete for Zd due to Invariant
29, this by Lemma 28 will be a correct output in the Qk-hypotheses game for f . Obviously
producing the output takes polynomial time given the light form of π and the content of
Learner’s working tape in the end.
Now we need to perform an iteration. Assume that h iterations passed and Invariant 29
still holds. Let Uh be the set of all nodes appearing in Mh. Take any function g : Zh → [k]
which is complete for Zh with respect to Mh.
For any z ∈ f−1(0) we denote by pz a communication profile of z with respect to Uh.
Recall that pz is an element of {0, 1}Uh , i.e., a function from Uh to {0, 1}. At each round of
the (h+ 1)st iteration Learner asks Nature to specify some pair (p, c) ∈ {0, 1}Uh × [k] such
that (pz, g(z)) 6= (p, c), where z is the Nature’s vector. Learner stores each (p, c) using his
O(1) additional bits on the working tape. Learner can do this until there are only k pairs
from (p1, c1), . . . , (pk, ck) ∈ {0, 1}Uh × [k] left which are not rejected by Nature. When this
moment is reached, the (h+ 1)st iteration is finished. The iteration takes 2|Uh| · k− k = O(1)
rounds, as required. For any z compatible with the current play after h+ 1 iterations we
know that (pz, g(z)) is among (p1, c1), . . . , (pk, ck), i.e,
(pz, g(z)) ∈ {(p1, c1), . . . , (pk, ck)} for all z ∈ Zh+1. (10)
Learner writes (p1, c1), . . . , (pk, ck) on the working tape (all the pairs that were excluded
are on the working tape and hence he can compute the remaining ones). Learner then
computes a (h+ 1)-low array Mh+1 which will be complete for Zh+1. To compute Mh+1 he
will only need to know Mh, (p1, c1), . . . , (pk, ck) (this information is on the working tape)
and the light form of π.
CCC 2020
24:20 Multiparty Karchmer – Wigderson Games and Threshold Circuits
Namely, Learner determines Mh+1[d1, . . . , dk] for (d1, . . . , dk) ∈ [k]k as follows. Consider
the node v = Mh[cd1 , . . . , cdk
]. If v is a terminal, then set Mh+1[d1, . . . , dk] = v. Otherwise
let i ∈ [k] be the index of the party communicating at v. Look at pdi
, which can be considered
as a function of the form pdi : Uh → {0, 1}. Define r = pdi(v). Among two edges, starting at
v, choose one which is labeled by r. Descend along this edge from v and let the resulting
successor of v be Mh+1[d1, . . . , dk].
Obviously, computing Mh+1 takes O
(
size(π)O(1)). To show that Invariant 29 is main-
tained we have to show that (a) Mh+1 is (h+ 1)-low and (b) Mh+1 is complete for Zh+1.
The first part, (a), holds because eachMh+1[d1, . . . , dk] is either a terminal or a successor
of a node of depth at least h. For (b) we define the following function:
g′ : Zh+1 → [k], g′(z) = i, where i is such that (pz, g(z)) = (pi, ci).
By (10) this definition is correct. We will show that g′ is complete for Zh+1 with respect to
Mh+1.
For that take any (d1, . . . , dk) ∈ [k]k, z ∈ Zh+1 and i ∈ [k] such that di = g′(z). We shall
show that z is i-compatible with a node Mh+1[d1, . . . , dk]. By definition of g′ we have that
g(z) = cdi
. As by Invariant 29 function g is complete for Zh with respect to Mh, this means
that z is i-compatible with v = M [cd1 , . . . , cdk
]. If v is a terminal, then Mh+1[d1, . . . , dk] = v
and there is nothing left to prove.
Otherwise v ∈ V \ T . Let j be the index of the party communicating at v. By definition
Mh+1[d1, . . . , dk] is a successor of v. If j 6= i, i.e., not the ith party communicates at v, then
any successor of v is i-compatible with z. Finally, assume that j = i. Node Mh+1[d1, . . . , dk]
is obtained from v by descending along the edge which is labeled by r = pdi(v). Hence to
show that z is i-compatible with Mh+1[d1, . . . , dk] we should verify that at v on input z
the ith party transmits the bit r. For that again recall that g′(z) = di, which means by
definition of g′ that pz = pdi
. I.e., pdi
is the communication profile of z with respect to Uh.
In particular, the value r = pdi(v) is the bit transmitted by the ith party on input z at v, as
required. J
In the same way one can obtain an analog of the previous theorem for the Rk-case.
I Theorem 30. For every constant k ≥ 2 there exists a polynomial-time algorithm A
such that the following holds. Assume that f ∈ Rk and π is a dag-like protocol which
strongly computes Rk-communication game for f . Then, given the light form of π, the
algorithm A outputs a circuit C ≤ f , consisting only of THRk+1
2 gates and literals, such that
depth(C) = O(depth(π)), size(C) = O
(
size(π)O(1)).
7 Derivation of Theorems 1 and 3
In this section we obtain Theorems 1 and 3 by devising protocols strongly computing the
corresponding Qk-communication games. Unfortunately, establishing strong computability
requires diving into straightforward but tedious technical details, even for simple protocols.
Alternative proof of Theorem 1. We will show that there exists O(logn)-depth protocol π
with polynomial-time computable light form, strongly computing Q2-communication game
for MAJ2n+1. By Theorem 27 this means that there is a polynomial-time computable
O(logn)-depth formula F ≤ MAJ2n+1, consisting only of MAJ3 gates and variables. From
self-duality of MAJ2n+1 and MAJ3 it follows that F computes MAJ2n+1.
A. Kozachinskiy and V. Podolskii 24:21
Take a polynomial-time computable O(logn)-depth monotone formula F ′ for MAJ2n+1.
Consider the following communication protocol π. The tree of π coincides with the tree of
F ′. Inputs to F ′ will be leafs of π. In a leaf containing input variable xi the output of the
protocol π is i. Remaining nodes of π are ∧ and ∨ gates. In the ∧ gates communicates the
first party, while in the ∨ gates communicates the second party.
Fix an ∧ gate g (which belongs to the first party). Let g0, g1 be gates which are fed to g,
i.e., g = g0 ∧ g1. There are two edges, starting at g, one leads to g0 (and is labeled by 0) and
the other leads to g1 (and is labeled by 1). Take an input a ∈ MAJ−1
2n+1(0) to the first party.
On input a at the gate g the first party transmits the bit r = min{c ∈ {0, 1} | gc(a) = 0}. If
the minimum is over the empty set, then we set r = 0.
Take now an ∨ gate h belonging to the second party. Similarly, there are two edges,
starting at h, one leads to h0 (and is labeled by 0) and the other leads to h1 (and is labeled
by 1). Here h0, h1 are two gates which are fed to h, i.e., h = h0 ∨ h1. Take an input
b ∈ MAJ−1
2n+1(0) to the second party. On input b at the gate h the second party transmits
the bit r = min{c ∈ {0, 1} | hc(¬b) = 1}. If the minimum is over the empty set, then we set
r = 0. Here ¬ denotes the bit-wise negation. Description of the protocol π is finished.
Clearly, the protocol π is of depth O(logn) and its light form is polynomial-time com-
putable. It remains to argue that the protocol strongly computes Q2-communication game
for MAJ2n+1. Nodes of the protocol may be identified with the gates of F ′. Consider any
path p = 〈e1, . . . , em〉 in the protocol π. Assume that ej is an edge from gj−1 to gj and g0 is
the output gate of F ′. We shall show that the following: if a ∈ MAJ−1
2n+1(0) is 1-compatible
with p, then g0(a) = g1(a) = . . . = gm(a) = 0. Indeed, g0(a) = 0 holds because F ′ computes
MAJ2n+1. Now, assume that gj(a) = 0 is already proved. If gj is an ∨ gate, then gj+1(a) = 0
just because gj+1 feds to gj . Otherwise gj is an ∧ gate which therefore belongs to the first
party. Let r ∈ {0, 1} is the label of the edge ej+1. Note that gj+1 = gj
r , where g
j
0, g
j
1 are two
gates which are fed to gj . . Since a is 1-compatible with p, it holds that r coincides with
the bit that the first party transmits at gj on input a, i.e., with min{c ∈ {0, 1} | gj
c(a) = 0}.
The set over which the minimum is taken is non-empty because gj(a) = 0. In particular r
belongs to this set, which means that gj+1(a) = gj
r(a) = 0, as required.
Similarly one can verify that if b ∈ MAJ−1
2n+1(0) is 2-compatible with p, then g0(¬b) =
g1(¬b) = . . . = gm(¬b) = 0. Hence we get that if a leaf l is 1-compatible (2-compatible)
with a (b) and l contains a variable xi, then ai = 0 (¬bi = 1). Hence the protocol strongly
computes the Q2-communication game for MAJ2n+1. J
Proof of Theorem 3. We will realize the protocol from the proof of Corollary 25 in such a
way that it will give us O(log2 n)-depth polynomial-size dag-like protocol with polynomial-
time computable light form, strongly computing Qk-communication game for THRkn+1
n+1 .
By Theorem 27 this means that there is a polynomial-time computable O(log2 n)-depth
polynomial-size circuit C ≤ THRkn+1
n+1 , consisting only of THRk+1
2 gates and variables. With
the same argument as in Corollary 25 one can show that C coincides with THRkn+1
n+1 .
We will use the same tree T as in the proof of Corollary 25. Let us specify the underlying
dag G of our protocol π. For a node v of T let Sv be the set of all tuples (s1, s2, . . . , sk) ∈
{0, 1, . . . , kn+ 1}k such that s1 + s2 + . . .+ sk < |Tv|. For every node v of T and for every
(s1, s2, . . . , sk) ∈ Sv the dag G will contain a node identified with a tuple (v, s1, s2, . . . , sk).
These nodes of G will be called the main nodes (there will be some other nodes too). The
starting node of G will be (r, n, . . . , n), where r is the root of T . Note that if l is a leaf of
T , then |Tl| = 1. Hence the only main node having l as the first coordinate is (l, 0, . . . , 0).
The set of terminals of π will coincide with the set of all main nodes of the form (l, 0, . . . , 0),
where l is a leaf of T . The output of π in (l, 0, . . . , 0) is l.
CCC 2020
24:22 Multiparty Karchmer – Wigderson Games and Threshold Circuits
For an integer s ≤ kn + 1 let W (s) be a binary tree of depth O(logn) with
|{(a, b) | a, b ∈ {0, 1, . . . , s}, a+ b = s}| leaves. We assume that leaves of W (s) are identified
with elements of {(a, b) | a, b ∈ {0, 1, . . . , s}, a + b = s}. We use W (s) in the construction
of G. Namely, take any main node (v, s1, s2, . . . , sk) with a non-leaf v. Attach W (s1) to it.
Then attach to every leaf of W (s1) a copy of W (s2). Next, to every leaf of the resulting
tree attach a copy of W (s3) and so on. In this way we obtain a binary tree W (v, s1, . . . , sk)
of depth O(logn) growing at (v, s1, . . . , sk). Its leaves can be identified with tuples of
integers (a1, b1, . . . , ak, bk) satisfying a1, b1, . . . , ak, bk ≥ 0, a1 + b1 = s1, . . . , ak + bk = sk.
We will merge every leaf of W (v, s1, . . . , sk) with some main node. Namely, take a leaf
(a1, b1, . . . , ak, bk). If a1 + . . .+ ak < |Tv0 |, then we merge (a1, b1, . . . , ak, bk) with the main
node (v0, a1, . . . , ak). Otherwise it should hold that b1 + . . . + bk < |Tv1 |. In this case we
merge (a1, b1, . . . , ak, bk) with the main node (v1, b1, . . . , bk).
Description of the dag of π is finished. Since k is constant, there are nO(1) main nodes and
to each we attach a tree of depth O(logn). Hence π is O(log2 n)-depth and nO(1)-size. Let
us define a partition of non-terminal nodes between parties. Take a main node (v, s1, . . . , sk),
where v is not a leaf of T . The tree W (v, s1, . . . , sk), growing from (v, s1, . . . , sk) consists of
copies of W (s1), . . . ,W (sk). We simply say that the ith party communicates in copies of
W (si). After that we conclude that the light form of π is polynomial-time computable.
Now let us specify how the ith party communicates inside W (si). Assume that x ∈
{0, 1}kn+1 is the input to the ith party. If |Tv∩supp(x)| 6= si, then the ith party communicates
arbitrarily. Now, assume that |Tv ∩ supp(x)| = si. Then the ith party communicates in such
a way that the resulting path descends from the root of W (si) to the leaf identified with a
pair of integers (|Tv0 ∩ supp(x)|, |Tv1 ∩ supp(x)|).
From this we immediately get the following observation. Let p be a path from the
root of W (v, s1, . . . , sk) to a leaf identified with a tuple (a1, b1, . . . , ak, bk). Further, assume
that x ∈ (THRkn+1
n+1 )−1(0), satisfying |Tv ∩ supp(x)| = si, is i-compatible with p. Then
ai = |Tv0 ∩ supp(x)| and bi = |Tv1 ∩ supp(x)|. Indeed, any such p passes though a copy W (si)
and leaves W (si) in a leaf identified with (|Tv0 ∩ supp(x)|, |Tv1 ∩ supp(x)|).
From this observation one can easily deduce that if x ∈ (THRkn+1
n+1 )−1(0) is i-compatible
with a main node (v, s1, . . . , sk), then |Tv ∩ supp(x)| = si. Indeed, we can obtain this by
induction on the depth of v. Induction step easily follows from the previous paragraph. As
for induction base we notice that |Tr ∩ supp(x)| = n for the root r of T (as in the proof of
Corollary 25 we assume that |supp(x)| = n as party can always add missing 1’s).
In particular, this means that π strongly computes Qk-communication game for THRkn+1
n+1 .
Indeed, any terminal of π is of the form (l, 0, . . . , 0), where l is a leaf of T . If x ∈
(THRkn+1
n+1 )−1(0) is i-compatible with (l, 0, . . . , 0), then, as shown in the previous para-
graph, |Tl ∩ supp(x)| = |{l} ∩ supp(x)| = 0. This means that xl = 0 and hence the output of
the protocol is correct. J
8 Open problems
Can Qk-communication game for THRkn+1
n+1 be solved in O(logn) bits of communication
for k ≥ 3? Equivalently, can THRkn+1
n+1 be computed by O(logn)-depth circuit, consisting
only of THRk+1
2 and variables? Can a deeper look into the construction of AKS sorting
network help here (note that we only use this sorting network as a black-box)?
Can at least Rk-communication game for THRkn+1
n+1 be solved in O(logn) bits of commu-
nication for k ≥ 3? Again, this is equivalent to asking whether THRkn+1
n+1 can be computed
by O(logn)-depth circuit, consisting only of THRk+1
2 and literals. Note that if we allow
A. Kozachinskiy and V. Podolskii 24:23
literals (along with ∧ and ∨ gates), then there are much simpler constructions of a
O(logn)-depth formula for MAJn and, in fact, for every symmetric Boolean function [16].
Moreover, this can be done in terms of communication complexity [2]. A natural approach
would be to apply ideas of [2] to Rk-communication games.
Are there any other interesting functions in Qk and Rk which can be analyzed with our
technique?
References
1 Miklós Ajtai, János Komlós, and Endre Szemerédi. An 0 (n log n) sorting network. In
Proceedings of the fifteenth annual ACM symposium on Theory of computing, pages 1–9, 1983.
doi:10.1145/800061.808726.
2 Gerth Stølting Brodal and Thore Husfeldt. A communication complexity proof that symmetric
functions have logarithmic depth. BRICS, Department of Computer Science, Univ., 1996.
3 Gil Cohen, Ivan Bjerre Damgård, Yuval Ishai, Jonas Kölker, Peter Bro Miltersen, Ran Raz, and
Ron D Rothblum. Efficient multiparty protocols via log-depth threshold formulae. In Annual
Cryptology Conference, pages 185–202. Springer, 2013. doi:10.1007/978-3-642-40084-1_11.
4 Irit Dinur and Or Meir. Toward the KRW composition conjecture: Cubic formula lower
bounds via communication complexity. computational complexity, 27(3):375–462, 2018. doi:
10.1007/s00037-017-0159-x.
5 Dmitry Gavinsky, Or Meir, Omri Weinstein, and Avi Wigderson. Toward better formula
lower bounds: an information complexity approach to the KRW composition conjecture. In
Proceedings of the forty-sixth annual ACM symposium on Theory of computing, pages 213–222,
2014. doi:10.1145/2591796.2591856.
6 Oded Goldreich. Valiant’s polynomial-size monotone formula for majority, 2011. URL:
http://www.wisdom.weizmann.ac.il/~oded/PDF/mono-maj.pdf.
7 Mika Göös and Toniann Pitassi. Communication lower bounds via critical block sensitivity. In
Proceedings of the forty-sixth annual ACM symposium on Theory of computing, pages 847–856,
2014. doi:10.1145/2591796.2591838.
8 Arvind Gupta and Sanjeev Mahajan. Using amplification to compute majority with small
majority gates. Computational Complexity, 6(1):46–63, 1996. doi:10.1007/BF01202041.
9 Stasys Jukna. Boolean function complexity: advances and frontiers, volume 27. Springer
Science & Business Media, 2012. doi:10.1007/978-3-642-24508-4.
10 Mauricio Karchmer, Ran Raz, and Avi Wigderson. Super-logarithmic depth lower bounds
via the direct sum in communication complexity. Computational Complexity, 5(3-4):191–204,
1995. doi:10.1007/BF01206317.
11 Mauricio Karchmer and Avi Wigderson. Monotone circuits for connectivity require super-
logarithmic depth. SIAM Journal on Discrete Mathematics, 3(2):255–265, 1990. doi:10.1137/
0403021.
12 Anup Rao and Amir Yehudayoff. Communication Complexity: and Applications. Cambridge
University Press, 2020. doi:10.1017/9781108671644.
13 Ran Raz and Pierre McKenzie. Separation of the monotone NC hierarchy. In Proceedings
38th Annual Symposium on Foundations of Computer Science, pages 234–243. IEEE, 1997.
doi:10.1109/SFCS.1997.646112.
14 Dmitry Sokolov. Dag-like communication and its applications. In International Computer Sci-
ence Symposium in Russia, pages 294–307. Springer, 2017. doi:10.1007/978-3-319-58747-9_
26.
15 Leslie G. Valiant. Short monotone formulae for the majority function. Journal of Algorithms,
5(3):363–366, 1984. doi:10.1016/0196-6774(84)90016-6.
16 Ingo Wegener. The complexity of Boolean functions. BG Teubner, 1987.
CCC 2020
https://doi.org/10.1145/800061.808726
https://doi.org/10.1007/978-3-642-40084-1_11
https://doi.org/10.1007/s00037-017-0159-x
https://doi.org/10.1007/s00037-017-0159-x
https://doi.org/10.1145/2591796.2591856
http://www.wisdom.weizmann.ac.il/~oded/PDF/mono-maj.pdf
https://doi.org/10.1145/2591796.2591838
https://doi.org/10.1007/BF01202041
https://doi.org/10.1007/978-3-642-24508-4
https://doi.org/10.1007/BF01206317
https://doi.org/10.1137/0403021
https://doi.org/10.1137/0403021
https://doi.org/10.1017/9781108671644
https://doi.org/10.1109/SFCS.1997.646112
https://doi.org/10.1007/978-3-319-58747-9_26
https://doi.org/10.1007/978-3-319-58747-9_26
https://doi.org/10.1016/0196-6774(84)90016-6
	Introduction
	Applications to circuits
	Applications to Multiparty Secure Computations
	Multiparty Karchmer – Wigderson games
	Connection to threshold gates and the main result
	Our techniques: Q_k(R_k)-hypotheses games
	Organization of the paper
	Preliminaries
	Dags and dag-like communication protocols
	Formal treatment of Q_k(R_k)-hypotheses games
	Results for Majority
	Proof of the main theorem
	From circuits to protocols
	From protocols to circuits
	Effective version
	Derivation of Theorems 1 and 3
	Open problems