New Bounds for Keyed Sponges
with Extendable Output: Independence Between
Capacity and Message Length
Yusuke Naito1(B) and Kan Yasuda2
1 Mitsubishi Electric Corporation, Kanagawa, Japan
naito.yusuke@ce.mitsubishielectric.co.jp
2 NTT Secure Platform Laboratories, Tokyo, Japan
yasuda.kan@lab.ntt.co.jp
Abstract. We provide new bounds for the pseudo-random function
security of keyed sponge constructions. For the case c ≤ b/2 (c the capac-
ity and b the permutation size), our result improves over all previously-
known bounds. A remarkable aspect of our bound is that dependence
between capacity and message length is removed, partially solving the
open problem posed by Gaži et al. at CRYPTO 2015. Our bound is essen-
tially tight, matching the two types of attacks pointed out by Gaži et al.
For the case c > b/2, Gaži et al.’s bound remains the best for the case of
single-block output, but for keyed sponges with extendable outputs, our
result partly (when query complexity is relatively large) provides better
security than Mennink et al.’s bound presented at ASIACRYPT 2015.
Keywords: PRF · XOF · Game playing · Coefficient H technique ·
Lazy sampling · Multi-collision · Stirling’s approximation
1 Introduction
The sponge construction today, though being originally introduced as a mode
for keyless hash functions [7], is drawing more and more attention in the secret-
key setting. The primary reason seems to lie in the flexibility: the keyed sponge
construction has been modified in a variety of ways such as duplexing [6], par-
allelism [3] and full-state (i.e. the rate being equal to the permutation size)
absorption [9,19]. However, one of the reasons why the sponge construction was
so attractive in the first place was that it inherently possessed the capability of
extendable output.
FIPS 202 [17] standardizes two sorts of extendable output functions (XOFs):
SHAKE128 and SHAKE256, which have a permutation size of b = 1600 bits and
capacity values of c = 256, 512 bits, respectively. FIPS 202 states:
XOFs are a powerful new kind of cryptographic primitive that offers the
flexibility to produce outputs with any desired length. ... In practice, the
use of an XOF as a key derivation function (KDF ) could preclude the
c© International Association for Cryptologic Research 2016
T. Peyrin (Ed.): FSE 2016, LNCS 9783, pp. 3–22, 2016.
DOI: 10.1007/978-3-662-52993-5 1
4 Y. Naito and K. Yasuda
possibility of related outputs, by incorporating the length and/or type of the
derived key into the message input to the KDF. In that case, a disagreement
or misunderstanding between two users of the KDF about the type or length
of the key they are deriving would almost certainly not lead to related
outputs.
To confirm the above statement in a more formal way, we need to investigate
the security of the KDF as a pseudo-random function (PRF).
Previous PRF Bounds. Several different types of PRF bounds are known for
keyed sponges. Security parameters of keyed sponges include the permutation
size b, the capacity c, the rate r := b − c, and the key length k. The main focus
remains on the capacity value c, because usually it is this parameter that defines
a dominant term in a bound. Nevertheless, none of the previous bounds has been
shown to be strictly tight in relation to parameter c, as explained below.
The PRF security of keyed sponges can be derived from the indifferentiability
of the sponge construction. The indifferentiability of the sponge construction [7]
crucially depends on the capacity c, and hence so does the derived PRF bound.
Roughly, the indifferentiability-based PRF bound has a dominant term of the
form (�q + Q)2/2c, where parameter � is the maximum length of an adversarial
query, parameter q the maximum number of construction (online) queries to the
keyed sponge C, and parameter Q the maximum number of primitive (offline)
queries to the underlying permutation P .
Note that we are working in the ideal model [1,13,16] where the underlying
permutation P is regarded as a random permutation. In practice, P is a fixed
permutation; hence Q corresponds to the time complexity of the adversary, mea-
suring how many times the adversary could perform offline computation of P .
The above indifferentiability-based PRF bound is rather loose, and the
actual PRF security of keyed sponges should be much higher, as first noticed
by Bertoni et al. [8]. Later, Andreeva et al. [1] successfully removed the term
Q2/2c and obtained a bound which was basically
(
(�q)2 + μQ
)
/2c. Here, μ is an
adversarial parameter called “multiplicity” and lies somewhere between 2�q/2r
and 2�q.
Concurrently, Gaži et al. [13] provided a “nearly tight” bound [16] which was
roughly of the form (q2 + �q + qQ)/2c. Gaži et al. also pointed out two attacks
matching q2/2c and qQ/2c, respectively. They observed that their bound “only
mildly depends on the length” when � is sufficiently small [13] but left it open
whether their bound was tight for all cases, especially when � is large. It should
be noted that Gaži et al. [13] only treated the case of single-block output, and
their method did not seem to be easily extendable to the case of multiple-block
output [16].
For the case of extendable output, recently Mennink et al. [16] has provided
another bound which is essentially (�q2 + μQ)/2c. While definitely improving
Andreeva et al.’s
(
(�q)2 + μQ
)
/2c, Mennink et al.’s bound does not come close
to Gaži et al.’s (q2 + �q + qQ)/2c, at least for the case of single-block output.
New Bounds for Keyed Sponges with Extendable Output 5
Table 1. Comparison of target keyed sponge constructions
Key Extendable
Inner Outer output
Bertoni et al. [8] — � �
Chang et al. [11] � � �
Andreeva et al. [1] � � �
Gaži et al. [13]a — � —
Mennink et al. [16]b � — �
This paper � � �
aGaži et al. [13] treat the case where the
rate values are different between absorbing
and squeezing phases. Only the rate r for the
squeezing phase appears in the bound; the rate
for absorbing phase does not affect security in
their analysis.
bMennink et al. [16] study the case of full-state
absorption, i.e. the rate for absorbing phase is
equal to the permutation size except for the first
call of the underlying permutation.
Consequently, it seems that there is still room for improvement. It might be
possible to come up with a tighter PRF bound for keyed sponges, especially for
the case of extendable output.
Inner- and Outer-Keying. There are two ways of keying the sponge con-
struction. The difference between the two methods is analogous to the one
between NMAC and HMAC [4]. The first method, which is like NMAC, is
called the inner-keyed sponge [1]. This replaces (part of) the inner IV with a
secret key K ∈ {0, 1}k, so that k ≤ c. The inner-keyed sponge was proposed by
Chang et al. [11] who showed that it has a certain advantage in the standard-
model security.
The second method, which is like HMAC, is called the outer-keyed sponge [1].
This is nothing but the sponge construction itself that processes the input K‖M
(i.e. a message prefixed by a secret key K) and hence does not have a limita-
tion on the key size k. A first analysis of the outer-keyed sponge was given by
Bertoni et al. [8]. The obvious advantage of this method, besides key length, is
that we can make use of existing sponge constructions that have been already
implemented as hash functions.
Our Contributions. We provide new PRF bounds for keyed sponges with
extendable output, under the condition that the rate and capacity remain the
same for absorbing and squeezing phases. We treat both inner- and outer-keyed
sponges (cf. Table 1). Previous PRF bounds and our results are summarized in
Table 2.
6 Y. Naito and K. Yasuda
– Case c ≤ b/2. This case includes SHAKE128 and SHAKE256. In this case,
our bound improves over all previously-known PRF bounds. For the inner-
keyed sponge, our bound is qualitatively better than the previous two bounds
by Andreeva et al. [1] and by Mennink et al. [16]. For example, if k = c (which
is the case that provides the highest security for the inner-keyed sponge), then
the previous bounds contained (�q2+μQ)/2c, whereas our bound only contains
(�q+q2+qQ)/2c. On the other hand, for the outer-keyed sponge, observe that
the term related to capacity in our bound becomes roughly (q2+qQ)/2c, which
is dominant in many scenarios. Note the absence of �q here; we remove the
dependence between capacity c and message length �, partially answering the
open question posed by Gaži et al. [13]. Together with the two attacks pointed
out by Gaži et al. [13] whose complexities were roughly q2/2c and qQ/2c, we see
that our bound is strictly tight in terms of parameters q and Q. Furthermore,
for the outer-keyed sponge, the remaining parameter � is restricted only by the
term �2q2/2b, whereas previous bounds contained �q/2c or �2q2/2c. Hence, our
bound has a qualitatively weaker restriction on �, under the condition c ≤ b/2.
– Case c > b/2. This is the case for lightweight hash functions, such as
Quark [2], SPONGENT [10] and PHOTON [14]. In this case, our contribution is
more subtle. For single-block output, Gaži et al.’s bound [13] remains the best,
beating our bound as well as Mennink et al.’s [16]. However, for multiple-block
output, our result improves over Mennink et al.’s [16] which has been the best
known bound for extendable output. The two bounds are incomparable due to
the parameter μ, but roughly speaking, we see that our bound becomes better
when query complexity is relatively large. For simplicity, assume k = c and
put μ = 2�q. Then Mennink et al.’s bound becomes roughly (�q2 + �qQ)/2c,
whereas our bound has a dominant term of
(
(�q2 + �qQ)/2b
)1/2. By compari-
son, our bound becomes smaller when �q2 + �qQ > 2c−r.
For our proofs we take an approach different from previous work. We first
make use of the game-playing technique, introducing just one intermediate game
between the real and ideal worlds. Our transition between the games heavily
relies on the coefficient H technique of Patarin [18]. To evaluate probabilities of
“bad” events, we make extensive use of lazy sampling. As pointed out by Bellare
and Rogaway [5], the lazy sampling of random functions with many constraints
can be tricky. We show how to carefully lazy-sample input/output points for
underlying permutations with certain restrictions. Lastly, we adopt techniques
developed by Jovanovic et al. [15] for bounding the size of multi-collisions and
for finally optimizing the bound (or “balancing” the terms).
2 Preliminaries
Notation. Let {0, 1}∗ be the set of all bit strings, and for an integer d ≥ 0,
let {0, 1}d be a set of d-bit strings. Let 0d denotes the bit string of d-bit zeroes.
For a bit string x ∈ {0, 1}d, let x[i, j] be the substring of x from i-th bit to j-th
bit, where 1 ≤ i ≤ j ≤ d. For a finite set X, x
$←− X means that an element is
New Bounds for Keyed Sponges with Extendable Output 7
Table 2. Comparison of PRF bounds for keyed sponges. In the bounds, parameter κ is
key length in blocks, i.e. κ := k/r; parameter μ is the multiplicity, i.e. 2�q/2r ≤ μ ≤ 2�q;
parameter t ≥ 1 can be arbitrary; the number e is Napier’s constant 2.71828 · · · ; the
function λ is defined as λ(x) := x/2k if κ = 1 and λ(x) := min{ε1, ε2} if κ ≥ 2, where
ε1 := (x2/2c+1) + (x/2k) and ε2 := (1/2b) + x(12b/2r)κ/2.
Inner-keyed (k ≤ c)
Andreeva et al. [1]
(�q)2
2c
+
μQ
2k
Mennink et al. [16]
2�q2
2c
+
μQ
2k
+
2(�q)2
2b
This paper (c ≤ b/2)
3q2 + qQ + 2r(q + Q)
2c
+
�q + Q
2k
+
(3 + 32e2r−2)�2q2
2b
This paper (c > b/2)
(
18e�q(q + Q)
2b
)1/2
+
3q2 + qQ + 2r(q + Q)
2c
+
�q + Q
2k
+
3�2q2
2b
Outer-keyed
Indifferentiability [7]
2(κ + �q + Q)2
2c
+
Q
2k
Andreeva et al. [1]
(�q)2 + 2μQ
2c
+
2κQ
2b
+ λ(Q)
Gaži et al. [13]
6bq2 + 8�q + qQ
2c
+
(6t + 17)�q2 + 7�qQ + 2q
2b
+
136�4q2
22b
+
2(�q)t+1
2bt
+ λ(�q + Q)
This paper (c ≤ b/2)
3q2 + 2qQ + 2r(q + Q)
2c
+
(3.5 + 32e2r−2)�2q2 + 2qQ + 2κQ
2b
+ λ(Q)
This paper (c > b/2)
(
18e�q(q + Q)
2b
)1/2
+
3q2 + 2qQ + 2r(q + Q)
2c
+
3.5�2q2 + 2qQ + 2κQ
2b
+ λ(Q)
randomly drawn from X and is set to x. For a set X, Perm(X) is the set of all
permutations on X. For sets X and Y , Func(X,Y ) is the set of all functions:
X → Y . We denote by ∅ an empty set. For sets X and Y , X ← Y means that
set Y is assigned to set X, and X
∪←− Y means X ← X ∪ Y .
PRF-Security. Through this paper, a distinguisher D is a computationally
unbounded probabilistic algorithm. It is given query access to one or more oracles
O, denoted DO. Its complexity is solely measured by the number of queries made
to its oracles. For integers k > 0 and τ > 0, let FK : {0, 1}∗ → {0, 1}τ be a keyed
hash function based on a permutation having keys K ∈ {0, 1}k. The security
proof will be done in the ideal model, regarding the underlying permutation as
a random permutation P $←− Perm({0, 1}b) for an integer b > 0. We denote by
P−1 its inverse.
8 Y. Naito and K. Yasuda
0b
-k
m1 m2 z
P
mn
P P P
s1t1 tn sn tn+1 sn+1 tn+ -1 n+ -1ss0
K
Fig. 1. IKSponge Construction
The PRF-security of FK is defined in terms of indistinguishability between
the real world and the ideal world. In the real world, D has query access to FK , P,
and P−1 for a key K
$←− {0, 1}k and P $←− Perm({0, 1}b). In the ideal world, it has
query access to a random function R, P, and P−1, for R $←− Func({0, 1}∗, {0, 1}τ )
and P $←− Perm({0, 1}b). After D’s interaction, it outputs y ∈ {0, 1}. The event
is denoted by D ⇒ y. Then the advantage function is defined as
Advprf
F (D) = Pr[DFK ,P,P−1 ⇒ 1] − Pr[DR,P,P−1 ⇒ 1].
We call queries to FK/R “online queries” and queries to (P,P−1) “offline
queries.” Though this paper, without loss of generality, assume that D is deter-
ministic and makes no repeated query.
3 Inner Keyed Sponge and the PRF-Security
3.1 Inner Keyed Sponge Construction
The inner keyed sponge construction uses the sponge function as the underlying
function. By IKSponge we denote the construction.
First we explain the sponge function. The sponge function is a permutation-
based one. For an integer b > 0, let P ∈ Perm({0, 1}b) be the underlying permu-
tation. By SpongeP , we denote the sponge function using P . For integers r > 0
and c ≥ 0 with r + c = b, r is a bit length so-called rate and c is a bit length
so-called capacity. For an input m ∈ {0, 1}∗, the output SpongeP (m) = z is
calculated as follows. Firstly, a bit string pad(|m|) is appended to the suffix of
m such that the bit length of m‖pad(|m|) becomes a multiple of r and the last
r-bit block is not 0r. The example of the padded string is m‖pad(|m|) = m‖1‖0∗,
which means that 1 and the minimum number of zeroes so that the bit length
becomes a multiple of r. Secondly, the padded bit string is partitioned into r-bit
blocks m1, . . . ,ml, where ml �= 0r. Thirdly, b-bit internal state s is updated by
the following procedure.
s ← 0b; for i = 1, . . . l do s ← P (mi‖0c ⊕ s)
Finally, the �out × r-bit string z is produced by the following procedure.
z ← s[1, r]; for i = 1, . . . �out − 1 do s ← P (s); z ← z‖s[1, r]
New Bounds for Keyed Sponges with Extendable Output 9
Next we explain the IKSponge construction. For an integer k with 0 < k ≤ c,
let K ∈ {0, 1}k be a secret key. By IKSpongeP
K , we denote IKSponge with P
having K. IKSponge equals Sponge with the initial value 0b−k‖K. Concretely,
for a message m, the response IKSpongeP
K(m) = z is denoted as follows, and the
Fig. 1 shows the procedure.
1. Partition m‖pad(|m|) into r-bit blocks m1, . . . ,mn
2. s0 ← 0b−k‖K
3. For i = 1, . . . , n do ti ← mi‖0c ⊕ si−1; si ← P (ti)
4. z ← sn[1, r]
5. For i = 1, . . . , �out − 1 do tn+i ← sn+i−1; sn+i ← P (tn+i); z ← z‖sn+i[1, r]
6. Return z
3.2 PRF-Security of the IKSponge Construction
We show the PRF-security of IKSponge in the ideal permutation model.
Theorem 1. Let D be a distinguisher which makes q online queries of r-bit
block length at most �in and Q offline queries. Then, for any parameter ρ, we
have Advprf
IKSponge(D) ≤ �q+Q
2k + 3q2+qQ+2ρ(q+Q)
2c + 3�2q2
2b + 2r+1 ×
(
2e�q
ρ2r
)ρ
, where
� = �in + �out − 1 and e = 2.71828 · · · is Napier’s constant.
Corollary 1. We assume c ≤ b/2. Then, we put ρ = r, and without loss of
generality, assume r ≥ 2 (otherwise r = c = 1 and b=2). Since r ≥ b/2, we have
Advprf
IKSponge(D) ≤ 3q2+qQ+2r(q+Q)
2c + (3+32e2r−2)�2q2
2b + �q+Q
2k .
We assume c > b/2, and put ρ = max
{
r,
(
2e×�q
2r−c(q+Q)
)1/2
}
. Then we have
Advprf
IKSponge(D) ≤
(
32e�q(q+Q)
2b
)1/2
+ 3q2+qQ+2r(q+Q)
2c + 3�2q2
2b + �q+Q
2k .
4 Proof of Theorem 1
We prove the PRF-security of IKSpongeP
K via three games. We denote these
games by Game 1, Game 2, and Game 3. For i ∈ {1, 2, 3}, we let Gi :=
(Li,P,P−1) to which D has query access in Game i. Note that in each game,
P is independently drawn as P $←− Perm({0, 1}b). We let L1 := IKSpongeP
K and
L3 := R. Hence we have
Advprf
IKSponge(D) =
2∑
i=1
(
Pr[DGi ⇒ 1] − Pr[DGi+1 ⇒ 1]
)
. (1)
Hereafter, we upper-bound Pr[DGi ⇒ 1] − Pr[DGi+1 ⇒ 1] for i ∈ {1, 2}. Note
that we define L2 before Pr[DG1 ⇒ 1] − Pr[DG2 ⇒ 1] is evaluated.
In the following proof, for α ∈ {1, . . . , Q}, we denote an α-th offline query by
xα or yα, and the response by yα or xα, where yα = P(xα) or xα = P−1(yα).
For α ∈ {1, . . . , q}, we denote an α-th online query by mα and the response
by zα. We also use superscripts for other values defined by online queries, e.g.,
n1, t11, s
1
1, n
2, t21, s
2
1, etc.
10 Y. Naito and K. Yasuda
4.1 Upper-Bound of Pr[DG1 ⇒ 1] − Pr[DG2 ⇒ 1]
We start by defining L2. Let G1,G2, . . . ,G�
$←− Func({0, 1}b, {0, 1}b) be random
functions. Let K
$←− {0, 1}k be a secret key. For an online query m ∈ {0, 1}∗, the
response L2(m) = z is defined as follows.
1. Partition m‖pad(|m|) into r-bit blocks m1, . . . ,mn
2. s0 ← 0b−k‖K
3. For i = 1, . . . , n do ti ← mi‖0c ⊕ si−1; si ← Gi(ti)
4. z ← sn[1, r]
5. For i = 1, . . . , �out −1 do tn+i ← sn+i−1; sn+i ← Gn+i(tn+i); z ← z‖sn+i[1, r]
6. Return z
Transcript. Let τL = {(m1, z1), . . . , (mq, zq)} be the set of query-response pairs
defined by online queries and τP = {(x1, y1), . . . , (xQ, yQ)} be the set of query-
response pairs defined by offline queries. Additionally, we define sets τ1, . . . , τ�.
For i ∈ {1, . . . , �}, let τi =
⋃q
α=1{(tαi , sα
i )} be the set of all input-output pairs
at the i-th block defined by online queries. Note that for α ∈ {1, . . . , q}, i ∈
{1, . . . , �} if (tαi , sα
i ) is not defined then {(tαi , sα
i )} is an empty set.
This proof permits D to obtain these sets and a secret key K after D’s
interaction but before it outputs a result. We let τ1..� =
⋃�
i=1 τi. Then D’s
transcript is summarized as τ = {τL, τP , τ1..�,K}.
Let T1 be the transcript in Game 1 obtained by sampling K
$←− {0, 1}k and
P $←− Perm({0, 1}b). Let T2 be the transcript in Game 2 obtained by sampling
K
$←− {0, 1}k, P $←− Perm({0, 1}b), G1,G2, . . . ,G�
$←− Func({0, 1}b, {0, 1}b). We call
τ valid if an interaction with their oracles could render this transcript, namely,
Pr[Ti = τ ] > 0 for i ∈ {1, 2}. Then Pr[DG1 ⇒ 1] − Pr[DG2 ⇒ 1] is upper-
bounded by the statistical distance of transcripts, i.e.,
Pr[DG1 ⇒ 1] − Pr[DG2 ⇒ 1] ≤ SD(T1,T2) =
1
2
∑
τ
|Pr[T1 = τ ] − Pr[T2 = τ ]| ,
where the sum is over all valid transcripts.
Coefficient H Technique. We upper-bound the statistical distance by using the
coefficient H technique [12,18]. In this technique, firstly, we need to partition
valid transcripts into good transcripts Tgood and bad transcripts Tbad. Then we
can upper-bound the statistical distance SD(T1,T2) by the following lemma.
Lemma 1 (Coefficient H Technique). Let 0 ≤ ε ≤ 1 be such that for all
τ ∈ Tgood,
Pr[T1=τ ]
Pr[T2=τ ] ≥ 1 − ε. Then, SD(T1,T2) ≤ ε + Pr[T2 ∈ Tbad].
The proof of the lemma is given in [12]. Hence, we can upper-bound Pr[DG1 ⇒
1] − Pr[DG2 ⇒ 1] by defining good and bad transcripts and by evaluating ε and
Pr[T2 ∈ Tbad].
New Bounds for Keyed Sponges with Extendable Output 11
Good and Bad Transcripts. We define Tbad that satisfies one of the following
conditions.
– hittx,sy ⇔ ∃(t, s) ∈ τ1..�, (x, y) ∈ τP s.t. t = x ∨ s = y
– hittt ⇔ ∃i, j ∈ {1, . . . , �} with i �= j s.t. ∃(ti, si) ∈ τi, (tj , sj) ∈ τj s.t. ti = tj
– hitss ⇔ ∃(t, s), (t′, s′) ∈ τ1..� s.t. t �= t′ ∧ s = s′
Tgood is defined such that the above conditions are not satisfied.
Upper-Bound of Pr[T2 ∈ T bad]. We start by defining additional conditions
mcollT , mcollS , and colltt. Firstly, we define mcollT and mcollS which are
(q + ρ)- and ρ-multi-collision conditions for sets T and S, respectively. Here,
T keeps all inputs to G2, . . . ,G�, and S keeps all outputs of G1, . . . ,G�, where
T :=
⋃q
α=1
⋃nα+�out−1
i=2 {tαi } and S :=
⋃q
α=1
⋃nα+�out−1
i=1 {sα
i }. Note that sets T
and S do not keep duplex elements, and T does not keep inputs to G1. Then the
conditions are defined as
mcollT ⇔ ∃t(1), t(2), . . . , t(q+ρ) ∈ T s.t. t(1)[1, r] = t(2)[1, r] = · · · = t(q+ρ)[1, r]
mcollS ⇔ ∃s(1), s(2), . . . , s(ρ) ∈ S s.t. s(1)[1, r] = s(2)[1, r] = · · · = s(ρ)[1, r]
where ρ is a free parameter which was described in Theorem 1. We let mcoll :=
mcollT ∨mcollS . Secondly, we define colltt which is a collision condition for inputs
to a random function in L2. The condition is defined as follows.
colltt ⇔∃α, β ∈ {1, . . . , q} with α �= β, i ∈ {2, . . . ,min{nα, nβ} + �out − 1}
s.t. tαi−1 �= tβi−1 ∧ tαi = tβi .
Then we have
Pr[T2 ∈ Tbad] ≤ Pr[hittx,sy ∨ hittt ∨ hitss]
≤ Pr[hitss] + Pr[colltt] + Pr[mcollS ] + Pr[mcollT |¬colltt]
+ Pr[hittx,sy|¬mcoll] + Pr[hittt ∧ ¬(colltt ∨ mcoll)] . (2)
�We upper-bound Pr[hitss]. Note that |τ1..�| ≤ �q holds, and for all (t, s) ∈ τ1..�
s is randomly drawn from {0, 1}b. Hence we have Pr[hitss] ≤
(
�q
2
)
× 1
2b = 0.5�2q2
2b .
� We upper-bound Pr[hittx,sy|¬mcoll]. Note that hittx,sy implies that
∃α ∈ {1, . . . , q}, i ∈ {1, . . . , nα + �out − 1}, β ∈ {1, . . . , Q} s.t. tα
i = xβ ∨ sα
i = yβ .
We then consider the following cases.
Case 1⇔ hittx,sy ∧ tαi = xβ ∧ i = 1:
Note that tα1 has the form tα1 = mα
1 ‖0c⊕0b−k‖K. Since K is randomly drawn
from {0, 1}k, the probability that Case 1 holds is at most Q
2k .
12 Y. Naito and K. Yasuda
t
=/
mγ
t1 t
1 nγ
nγ
m1 m
t1 tnγ
α α
γ γ
αα
= =
α
γ mγ
t tnγ+1
γ
j*−1
γ tj*
γ
mnγ+1
α
nγ
tnγ+1
α
=
mγ
1 nγmγ
mα
j*−1=0r
tj*−1
α
=
j*
α
m =0rα
j* /=0r
T1
0b
-k
K
s0
0b
-k
K
s0
Fig. 2. Procedures for set T1 and prefix=mα
Case 2⇔ hittx,sy ∧ tαi = xβ ∧ i �= 1:
By ¬mcollT , the number of elements in T whose first r bits are equal to
xβ [1, r] is at most q + ρ. We note that for some r-bit block Mα, tαi has
the form tαi = Mα‖0c ⊕ sα
i−1, where Mα is 0r or a message block. Since
sα
i−1[r + 1, b] is randomly drawn from {0, 1}c, the probability that Case 2
holds is at most (q+ρ)Q
2c .
Case 3⇔ hittx,sy ∧ sα
i = yβ :
By ¬mcollS , the number of elements in S whose first r bits are equal to
yβ [1, r] is at most ρ. Since sα
i [r + 1, b] is randomly drawn from {0, 1}c, the
probability that Case 3 holds is at most ρQ
2c .
Hence we have Pr[hittx,sy|¬(hitux,wy ∨ mcoll)] ≤ Q
2k + (q+2ρ)Q
2c .
� We upper-bound Pr[mcollS ]. Fix s ∈ {0, 1}r and s(1), s(2), . . . , s(ρ) ∈ S. Since
they are randomly drawn from {0, 1}b, the probability that s(1)[1, r] = s(2)[1, r] =
· · · = s(ρ)[1, r] = s holds is at most
(
1
2r
)ρ. By s ∈ {0, 1}r and |S| ≤ �q, we have
Pr[mcollS ] ≤ 2r ×
(
�q
ρ
)
×
(
1
2r
)ρ ≤ 2r ×
(
e�q
ρ × 1
2r
)ρ
, using Stirling’s approximation
(x! ≥ (x/e)x for any x).
� We upper-bound Pr[mcollT |¬colltt]. First we partition set T into two sets
T1 and T2. Roughly speaking, T1 keeps all inputs to random functions whose
first r bits can be controlled by message blocks. The Fig. 2 (with the boxed
statement) depicts the procedure of L2 corresponding with T1, which considers
γ-th and α-th online queries with γ < α and nγ < nα (nγ and nα are the query
lengths in blocks at the γ-th and α-th online queries, respectively) such that
these message blocks satisfy the condition: ∃j∗ ∈ {nγ + 1, . . . , nγ + �out − 1} s.t.
mα
1 = mγ
1 ,mα
2 = mγ
1 , . . . ,mα
nγ = mγ
nγ ,mα
nγ = 0r, . . . ,mα
j∗−1 = 0r,mα
j∗ �= 0r. We
call the condition between the α-th and γ-th online queries “prefix condition.”
In this case, tαj∗ becomes an element of T1. Since sα
j∗−1 = sγ
j∗−1 holds and
before the α-th online query a distinguisher can find sγ
j∗−1[1, r] which is the part
New Bounds for Keyed Sponges with Extendable Output 13
m1 m2 mn
β β β
β zβ
s0
Fig. 3. Lazy sampling random functions in Case 2, where black boxes represent out-
puts defined at the β-th query and gray boxes represent outputs defined after D’s
interaction.
of output blocks at the γ-th online query, he can assign any value to tαj∗ [1, r] by
using the message block mα
j∗ . We call the input tαj∗ “controllable input,” and T1
keeps all controllable inputs. The definitions of these sets are given as follows.
T1 :=
{
tαj∗ ∈ T : (α ∈ {2, . . . , q}) ∧
(
∃γ ∈ {1, . . . , α − 1} s.t.
(
nγ < nα
)
∧
(
∀j ∈ {1, . . . , nγ} : mα
j = mγ
j
)
∧
(
∃j∗ ∈ {nγ + 1, . . . , nγ + �out − 1} s.t.
(∀j ∈ {nγ + 1, . . . , j∗ − 1} : mα
j = 0r) ∧ (mα
j∗ �= 0r)
))}
,
and T2 := T\T1. Note that for any α1, α2, . . . , αi ∈ {1, . . . , q} with α1 < α2 <
· · · < αi and with the prefix relations, the number of controllable inputs is
at most i − 1, because set T1 does not keep duplex elements. Hence, we have
|T1| ≤ q − 1, and thereby Pr[mcollT |¬colltt] is upper-bounded by the proba-
bility that a ρ-multi-collision occurs in T2 under the condition ¬colltt, that is,
∃t(1), t(2), . . . , t(ρ) ∈ T2 s.t. t(1)[1, r] = t(2)[1, r] = · · · = t(ρ)[1, r]. Hereafter, we
upper-bound the ρ-multi-collision probability under the condition ¬colltt.
Fix t ∈ {0, 1}r and tαi ∈ T2 with α ∈ {1, . . . , q} and i ∈ {2, . . . , nα +�out−1}.
We upper-bound the probability that tαi [1, r] = t holds under the condition
¬colltt. We consider the following cases.
Case 1⇔ (tαi [1, r] = t) ∧ (nα + 1 ≤ i):
By nα + 1 ≤ i, tαi = sα
i−1 holds, where sα
i−1 = Gi−1(tαi−1). By ¬colltt, sα
i−1
is randomly drawn from at least 2b − q values. Thus, the probability that
Case 1 holds is at most 2c
2b−q
.
Case 2⇔ (tαi [1, r] = t) ∧ (2 ≤ i ≤ nα):
In the evaluation, we lazy sample random functions G1, . . . ,G� that is con-
sistent with the condition ¬colltt. The procedure is shown bellow.
− At the β-th online query with β ∈ {1, . . . , q}, the following procedure is
performed.
• For j ∈ {nβ , . . . , nβ +�out−1}, sβ
j [1, r] is randomly drawn from {0, 1}r.
− After D’s interaction, the following procedure is performed.
• For all β ∈ {1, . . . , q} and j ∈ {1, . . . , nβ −1}, if tβj is a new input to Gj
then sβ
j is randomly drawn from {0, 1}b, keeping the condition ¬colltt.
• For all β ∈ {1, . . . , q} and j ∈ {nβ , . . . , nβ + �out − 1}, sβ
j [r + 1, b] is
randomly drawn from {0, 1}c, keeping the condition ¬colltt.
14 Y. Naito and K. Yasuda
The Fig. 3 depicts the above procedure. Without loss of generality, assume that
q < 2c (If q ≥ 2c then the advantage of Theorem 1 becomes 1 or more). Note
that for each random function, there are at most q inputs, and for a ∈ {0, 1}r,
there are 2c elements in {0, 1}b whose first r bits are equal to a. Thus, for all
β ∈ {1, . . . , q} and j ∈ {nβ , . . . , nβ + �out − 1}, sβ
j [r + 1, b] can be defined such
that it is consistent with the condition ¬colltt. Thus, the above procedure realizes
random functions G1, . . . ,G� that are consistent with the condition ¬colltt.
For 2 ≤ i ≤ nα, tαi has the form tαi = mα
i ‖0c ⊕ sα
i−1. By the above procedure,
sα
i−1 is randomly drawn from at least 2b − q values after D’s interaction (i.e.,
after mα
i is determined). Hence, the probability that tαi [1, r] = t holds is at most
2c
2b−q
.
We next fix t(1), t(2), . . . , t(ρ) ∈ T2 and t ∈ {0, 1}r. By the above evalua-
tions, the probability that t(1)[1, r] = t(2)[1, r] = · · · = t(ρ)[1, r] = t holds is at
most
(
2c
2b−q
)ρ
≤
(
2
2r
)ρ, assuming q ≤ 2b−1. By t ∈ {0, 1}r and |T2| ≤ �q, we
have Pr[mcollT |¬colltt] ≤ 2r ×
(
�q
ρ
)
×
(
2
2r
)ρ ≤ 2r ×
(
e�q
ρ × 2
2r
)ρ
, using Stirling’s
approximation (x! ≥ (x/e)x for any x).
� We upper-bound Pr[colltt]. We denote by collαtt the condition where at the α-th
online query colltt holds. Then we have
Pr[colltt] ≤
∑q
α=2 Pr[collαtt ∧ ¬collα−1
tt ] ≤
∑q
α=2 Pr[collαtt|¬collα−1
tt ].
Next we fix α ∈ {2, . . . , q}, and upper-bound Pr[collαtt|¬collα−1
tt ], which is the
probability that colltt holds at the α-th online query when it does not hold up to
the (α−1)-th online query. In order to upper-bound the probability, we consider
two cases with respect to the following condition.
prefix=mα ⇔∃γ ∈ {1, . . . , α − 1} s.t.
(
nγ < nα
)
∧
(
∀j ∈ {1, . . . , nγ} : mγ
j = mα
j
)
∧
(
∃j∗ ∈ {nγ + 1, . . . , nγ + �out − 1} s.t.
mα
nγ+1 = 0r, . . . ,mα
j∗−1 = 0r,mα
j∗ �= 0r
)
.
We call such γ-th online query “prefix online query” of the α-th query, and
such j∗ “distinct point.” The Fig. 2 (without the boxed statement) depicts the
procedures of L2 corresponding with the condition. In this evaluation, similar
to Case 2 of Pr[mcollT |¬colltt], we lazy sample random functions G1, . . . ,G� that
are consistent with the condition ¬collα−1
tt . The procedure is shown bellow.
– At the β-th online query with β ∈ {1, . . . , α − 1}, the following procedure is
performed.
• For all j ∈ {nβ , . . . , nβ +�out−1}, sβ
j [1, r] is randomly drawn from {0, 1}r.
– At the α-th online query, the following procedure is performed.
• For all β ∈ {1, . . . , α − 1},
* for all j ∈ {1, . . . , nβ −1}, if tβj is a new input to Gj then the response
sβ
j is randomly drawn from {0, 1}b, keeping the condition ¬collα−1
tt ,
* for all j ∈ {nβ , . . . , nβ + �out −1}, sβ
j [r +1, b] is randomly drawn from
{0, 1}c, keeping the condition ¬collα−1
tt .
New Bounds for Keyed Sponges with Extendable Output 15
wκ
β β <α m1 m2 mn
β β β
β
α
wκ
m1 m2 mn
α αα
zβ
zαα
wκ
β
β = γ, β <α
m1 m2 mn
β β β
β
wκ
m1 m2 mn
γ γγγ
α
wκ
m1 m2 mn
α αα mj
α
zβ
== = = = =/
zγ
0r 0r
=
∗
γ
γ
m1 mn
γ γ γ=m1
α =mnγα
mj +1
α
∗
(j*-1)-th block j*-th block
mα
=
mα
=
Fig. 4. Lazy sampling random functions in the evaluation of Pr[collαtt|¬collα−1
tt ], where
black boxes represent outputs defined up to the (α − 1)-th query and gray boxes
represent outputs defined at the α-th query.
• For j ∈ {1, . . . , nα + �out −1}, if tαj is a new input to Gj then the response
sα
j is randomly drawn from {0, 1}b.
The top (resp., the bottom) of the Fig. 4 depicts the above procedure under
the condition prefix=mα (resp., ¬prefix=mα). Then we evaluate the probability
Pr[collαtt|¬collα−1
tt ] as follows.
Case 1⇔ collαtt under the condition ¬collα−1
tt ∧ ¬prefix=mα :
For i ∈ {2, . . . , nα + �out − 1}, let collα,i
tt be the condition where collαtt holds
at the i-th block of the α-th online query, and let coll≤α,i−1
tt := collα,2
tt ∨
collα,3
tt ∨ · · · ∨ collα,i−1
tt . Note that for i ∈ {2, . . . , nα + �out − 1}, collα,i
tt ∧
¬coll≤α,i−1
tt is the condition where collαtt holds at the i-th block of the α-th
online query for the first time. (i.e., collαtt does not hold up to the (i − 1)-
th block), and thus collαtt ⇔
∨nα+�out−1
i=2 (collα,i
tt ∧ ¬coll≤α,i−1
tt ), where collα,2
tt ∧
¬coll≤α,1
tt := collα,2
tt . In the following, for i ∈ {2, . . . , nα +�out−1}, we assume
that coll≤α,i−1
tt does not hold, and thus upper-bound the probability that
collα,i
tt holds under the condition ¬collα−1
tt ∧ ¬coll≤α,i−1
tt ∧ ¬prefix=mα . By p1,i,
we denote the probability. Note that for some r-bit string Mα tαi has the form
tαi = Mα‖0c ⊕ sα
i−1, where Mα is a message block or 0r. By the condition
¬coll≤α,i−1
tt , tαi−1 is a new input to Gi−1, and thereby sα
i−1 is randomly drawn
from {0, 1}b after Mα is determined. Hence, we have p1,i ≤ (α−1)× 1
2b , and
thereby Pr[Case 1] ≤ � × (α − 1) × 1
2b .
16 Y. Naito and K. Yasuda
Case 2⇔ collαtt under the condition ¬collα−1
tt ∧ prefix=mα :
In this analysis, we use the conditions collα,i
tt and coll≤α,i−1
tt defined above.
For i ∈ {2, . . . , nα + �out − 1}, we assume that coll≤α,i−1
tt does not hold,
and thus upper-bound the probability that collα,i
tt holds under the condition
¬collα−1
tt ∧ ¬coll≤α,i−1
tt ∧ prefix=mα . By p2,i, we denote the probability. We
assume that the γ-th online query (γ ∈ {1, . . . , α − 1}) is the prefix online
query of the α-th online query, and j∗ is the distinct point. If there are two
or more prefix online queries of the α-th online query then we consider the
prefix online query such that the distinct point is maximum.
− Firstly, we consider the case of i ∈ {2, . . . , j∗ − 1}. By prefix=mα , tαi = tγi
holds. By the condition ¬collα−1
tt ∧ ¬coll≤α,i−1
tt , we have p2,i = 0.
− Secondly, we consider the case of i = j∗. Note that tαj∗ [r+1, b] = sα
j∗−1[r+
1, b] holds, and by the lazy sampled random functions, sα
j∗−1 is randomly
drawn from at least 2b − q values. Thus we have p2,i ≤ (α − 1) × 2r
2b−q
.
− Finally, we consider the case of i ∈ {j∗ +1, . . . , nα +�out −1}. In this case,
for some r-bit string Mα, tαi has the form tαi = Mα‖0c ⊕ sα
i−1, where
Mα is a message block or 0r. Since j∗ is maximum and by the condition
¬coll≤α,i−1
tt tαi−1 is a new input to Gi−1, sα
i−1 is randomly drawn from
{0, 1}b after Mα is determined. Hence, we have p2,i ≤ (α − 1) × 1
2b .
Hence, we have Pr[Case 2] ≤ (α − 1) ×
(
2r
2b−q
+ �out
2b
)
.
Finally, we assume that q ≤ 2b−1. We then have
Pr[colltt] ≤
∑q
α=2(α − 1) × max
{
�
2b ,
(
2r
2b−q
+ �out
2b
)}
≤ q2
2c + 0.5�q2
2b .
� We upper-bound Pr[hittt ∧¬(colltt ∨mcoll)]. We start by defining the following
condition.
hitK ⇔ ∃α ∈ {1, . . . , q}, i ∈ {2, . . . , nα + �out − 1} s.t. tαi [r + 1, b] = 0c−k‖K
Then we have
Pr[hittt ∧ ¬(colltt ∨ mcoll)] ≤ Pr[hitK ] + Pr[hittt ∧ ¬(colltt ∨ mcoll) ∧ ¬hitK ] .
Since K is randomly drawn from {0, 1}k, we have Pr[hitK ] ≤ �q
2k .
Next, we upper-bound Pr[hittt ∧ ¬(colltt ∨ mcoll) ∧ ¬hitK ]. Note that hittt
implies that
∃α, β ∈ {1, . . . , q}, i ∈ {1, . . . , nα + �out − 1}, j ∈ {1, . . . , nβ + �out − 1}
s.t. i �= j ∧ tαi = tβj .
For α ∈ {1, . . . , q}, we define a condition where hittt holds up to the α-th online
query. The concrete definition is given bellow.
hitαtt ⇔∃β, γ ∈ {1, . . . , α}, i ∈ {1, . . . , nβ + �out − 1}, j ∈ {1, . . . , nγ + �out − 1}
s.t. i �= j ∧ tβi = tγj .
New Bounds for Keyed Sponges with Extendable Output 17
Then the following inequation holds.
Pr[hittt ∧ ¬(colltt ∨ mcoll) ∧ hitK ]
≤
q∑
α=1
Pr[hitαtt ∧ ¬hitα−1
tt ∧ ¬(mcoll ∨ colltt) ∧ ¬hitK ]
≤
q∑
α=1
Pr[hitαtt ∧ ¬hitα−1
tt ∧ ¬mcoll ∧ ¬hitK |¬colltt] .
First fix α ∈ {1, . . . , q}, and upper-bound the probability Pr[hitαtt ∧¬hitα−1
tt ∧
¬mcoll ∧ ¬hitK |¬colltt]. In this evaluation, we lazy sample random functions
G1, . . . ,G� by the similar way to the evaluation of Pr[colltt]. The procedure is
shown bellow, and the Fig. 4 depicts the procedure.
– At the β-th online query with β ∈ {1, . . . , α − 1}, the following procedure is
performed.
• For all j ∈ {nβ , . . . , nβ +�out−1}, sβ
j [1, r] is randomly drawn from {0, 1}r.
– At the α-th online query, the following procedure is performed.
• For all β ∈ {1, . . . , α − 1},
* for all j ∈ {1, . . . , nβ −1}, if tβj is a new input to Gj then the response
sβ
j is randomly drawn from {0, 1}b, keeping the condition ¬colltt,
* for all j ∈ {nβ , . . . , nβ + �out −1}, sβ
j [r +1, b] is randomly drawn from
{0, 1}c, keeping the condition ¬colltt.
• For j ∈ {1, . . . , nα + �out −1}, if tαj is a new input to Gj then the response
sα
j is randomly drawn from {0, 1}b, keeping the condition ¬colltt.
In this evaluation, we consider two cases with respect to the condition prefix=mα
which was defined in the analysis of Pr[colltt]. In addition, the following analyses
use the terms “prefix online query” and “distinct point.”
Case 1⇔ hitαtt∧¬hitα−1
tt ∧¬mcoll∧¬hitK under the condition ¬colltt∧¬prefix=mα :
For i ∈ {1, . . . , nα + �out − 1}, let hitα,i
tt be the condition where hitαtt holds at
the i-th block of the α-th online query, that is,
hitα,i
tt ⇔(∃β ∈ {1, . . . , α − 1}, j ∈ {1, . . . , nβ + �out − 1} s.t. i �= j ∧ tαi = tβj )
∧ (∃j ∈ {1, . . . , i − 1} s.t. tαi = tαj ).
Then hitαtt ⇒
∨nα+�out−1
i=1 hitα,i
tt . In the following, for i ∈ {1, . . . , nα+�out−1},
we upper-bound the probability that hitα,i
tt ∧ ¬hitα−1
tt ∧ ¬mcoll∧ ¬hitK holds
under the condition ¬colltt ∧ ¬prefix=mα . By p1,i, we denote the probability.
− Firstly, we consider the case of i = 1. In addition to the condition
¬colltt ∧ ¬prefix=mα , we assume that hitK does not hold, and don’t
consider the condition ¬hitα−1
tt ∧ ¬mcoll. Since tα1 has the form tα1 =
(mα
1 ‖0c) ⊕ (0b−k‖K), the probability that hitα,1
tt holds under the condi-
tion ¬colltt ∧ ¬prefix=mα ∧ ¬hitK is 0 and thus we have p1,1 = 0.
18 Y. Naito and K. Yasuda
− Secondly, we consider the case of i ≥ 2. In this case, we don’t consider the
condition ¬hitα−1
tt ∧¬mcoll∧¬hitK . Note that for an r-bit string Mα, tαi
has the form tαi = Mα‖0c⊕sα
i−1, where Mα is a message block or 0r. Since
sα
i−1 is randomly drawn from at least 2b − q values after Mα is defined,
the probability that hitα,i
tt holds under the condition ¬colltt ∧ ¬prefix=mα
is at most (�−1)(α−1)+(i−1)
2b−q
≤ (�−1)α
2b−q
, and thus we have p1,i ≤ (�−1)α
2b−q
.
Hence, we have Pr[Case 1] ≤ (� − 1) × (�−1)α
2b−q
.
Case 2⇔ hitαtt ∧¬hitα−1
tt ∧¬mcoll∧¬hitK under the condition ¬colltt ∧prefix=mα :
In this analysis, we use the condition hitα,i
tt for i ∈ {1, . . . , nα + �out − 1},
defined in Case 1. We let hit≤α,i−1
tt := hitα−1
tt ∨ hitα,1
tt ∨ · · · ∨ hitα,i−1
tt ,
where hitα,0
tt := hitα−1
tt . Then the following holds: hitαtt ∧ ¬hitα−1
tt ⇒
∨nα+�out−1
i=1 (hitα,i
tt ∧ ¬hit≤α,i−1
tt ). In this evaluation, we don’t consider the
condition ¬hitK , and thus for i ∈ {1, . . . , nα + �out − 1}, upper-bound
the probability that hitα,i
tt ∧ ¬hit≤α,i−1
tt ∧ ¬mcoll holds under the condition
¬colltt ∧ prefix=mα . By p2,i, we denote the probability. We assume that the
γ-th online query (γ ∈ {1, . . . , α − 1}) is the prefix online query of the α-th
online query, and j∗ is the distinct point. If there are two or more prefix
online queries of the α-th online query then we consider the prefix online
query such that the distinct point is maximum.
− Firstly, we consider the case of i < j∗. In this case, we don’t consider the
condition ¬mcoll, and assume that hit≤α,i−1
tt does not hold in addition
to the condition ¬colltt ∧ prefix=mα . By prefix=mα , tαi = tγi holds, and by
¬hit≤α,i−1
tt , hitγtt does not hold. Hence, hitα,i
tt does not hold under the
condition ¬colltt ∧ prefix=mα ∧ hit≤α,i−1
tt , and thus we have p2,i = 0.
− Secondly, we consider the case of i = j∗. In this analysis, we don’t consider
the condition ¬hit≤α,i−1
tt , and assume that mcoll does not hold in addition
to the condition ¬colltt ∧ prefix=mα . Note that since j∗ is the maximum
distinct point, tαj∗ is a new input to Gj∗ . By ¬mcollT , the number of
inputs to random functions whose first r bits are equal to tαj∗ [1, r] is at
most (q + ρ). Note that tαj∗ [r + 1, b] = sα
j∗−1[r + 1, b], and sα
j∗−1[r + 1, b]
is randomly drawn from at least 2c − q values. Hence, the probability
that hitα,i
tt holds under the condition ¬colltt ∧prefix=mα ∧¬mcoll is at most
q+ρ
2c−q , and thus we have p2,i ≤ q+ρ
2c−q .
− Finally, we consider the case of i > j∗. In this analysis, we don’t consider
the conditions ¬hit≤α,i−1
tt and ¬mcollT . Note that for an r-bit string Mα,
tαi has the form tαi = Mα‖0c ⊕ sα
i−1, where Mα is a message block or 0r.
By ¬colltt, sα
i−1 is randomly drawn from at least 2b − q values after Mα
is defined. We thus have p2,i ≤ (�−2)α
2b−q
.
Hence, we have Pr[Case 2] ≤ q+ρ
2c−q + (� − 2) × (�−2)α
2b−q
.
New Bounds for Keyed Sponges with Extendable Output 19
Hence, we have
Pr[hittt ∧ ¬(colltt ∨ mcoll) ∧ ¬hitK ] ≤
q∑
α=1
max
{
(� − 1)2α
2b − q
,
q + ρ
2c − q
+
(� − 2)2α
2b − q
}
≤ 2(q + ρ)q
2c
+
�2q2
2b
, assuming q ≤ 2c−1.
Finally, we have Pr[hittt ∧ ¬(colltt ∨ mcoll)] ≤ �q
2k + 2(q+ρ)q
2c + �2q2
2b .
� We put the above bounds to the inequation (2). Then we have
Pr[T2 ∈ Tbad] ≤ �q + Q
2k
+
2q2 + qQ + 2ρ(q + Q)
2c
+
2�2q2
2b
+ 2r+1 ×
(
2e�q
ρ2r
)ρ
.
Upper-Bound of ε. Let τ ∈ Tgood. Let alli be the set of all oracles in Game i for
i = 1, 2. Let compi(τ) be the set of oracles compatible with τ in Game i for
i = 1, 2. Then Pr[T1 = τ ] = |comp1(τ)|
|all1| and Pr[T2 = τ ] = |comp2(τ)|
|all2| .
Firstly, we evaluate |all1|. Since K ∈ {0, 1}k and P ∈ Perm({0, 1}b), we have
|all1| = 2k · 2b!.
Secondly, we evaluate |all2|. Since K ∈ {0, 1}k, P ∈ Perm({0, 1}b), and
G1,G2, . . . ,G� ∈ Func({0, 1}b, {0, 1}b), we have |all2| = 2k · (2b!) ·
(
(2b)2
b
)�
.
Thirdly, we evaluate |comp1(τ)|. For i ∈ {1, . . . , �}, let γi be the number of
pairs in τi. Let γP be the numbers of pairs in τP . Let γ = γP +
∑�
i=1 γi. Since
τ1, . . . , τ� and τP are defined so that they do not overlap each other, we have
|comp1(τ)| = (2b − γ)!.
Fourthly, we evaluate |comp2(τ)|. Here, γ1, . . . γ�, and γP are analogously
defined. Then we have |comp2(τ)| = (2b − γP)! ·
∏�
i=1(2
b)2
b−γi = (2b − γP)! ·
(2b)�2b−γ+γP .
Finally, we have
Pr[T1 = τ ]
Pr[T2 = τ ]
=
|comp1(τ)|
|all1|
× |all2|
|comp2(τ)| =
(2b − γ)!
2k · (2b!)
× 2k · (2b!) · (2b)�2b
(2b − γP)! · (2b)�2b−γ+γP
=
(2b)γ · (2b − γ)!
(2b)γP · (2b − γP)!
≥ 1 ,
and thus ε = 0.
Upper-Bound of Pr[DG1 ⇒ 1] − Pr[DG2 ⇒ 1]. Finally, by Lemma 1, the
upper-bound of Pr[T2 ∈ Tbad] and ε yield the following bound.
Pr[DG1 ⇒ 1] − Pr[DG2 ⇒ 1]
≤ �q + Q
2k
+
2q2 + qQ + 2ρ(q + Q)
2c
+
2�2q2
2b
+ 2r+1 ×
(
2e�q
ρ2r
)ρ
. (3)
20 Y. Naito and K. Yasuda
4.2 Upper-Bound of Pr[DG2 ⇒ 1] − Pr[DG3 ⇒ 1]
Firstly, we prove the following lemma.
Lemma 2. G2 and G3 are indistinguishable unless the following condition holds
in Game 2.1
coll ⇔∃α, β ∈ {1, . . . , q}, i ∈ {max{nα, nβ}, . . . ,min{nα, nβ} + �out − 1}
s.t. α �= β ∧ tαi = tβi .
Proof. If coll does not hold then all blocks in outputs of L2 are independently
drawn by random functions. Hence the above lemma holds. ��
By the above lemma, Pr[DG2 ⇒ 1|¬coll] = Pr[DG3 ⇒ 1] holds. Then we have
Pr[DG2 ⇒ 1] − Pr[DG3 ⇒ 1] ≤ Pr[coll] .
Hereafter, we upper-bound Pr[coll]. In this evaluation, we use the condition
colltt given in Subsect. 4.1. Then we have Pr[coll] ≤ Pr[colltt] + Pr[coll|¬colltt]
where the upper-bound of Pr[colltt] is given in Subsect. 4.1: Pr[colltt] ≤ q2
2c + 0.5�q2
2b .
We thus upper-bound Pr[coll|¬colltt]. First fix α, β ∈ {1, . . . , q} with α �= β,
and upper-bound the probability that by the α-th and β-th online queries, coll
holds. We consider the following cases.
Case 1⇔ nα = nβ : Since mα �= mβ , there exists j∗ ∈ {1, . . . , nα} such that
tαj∗ �= tβj∗ . By ¬colltt, for all j ∈ {j∗ +1, . . . , nα +�−1}, tαj �= tβj holds. Hence,
in this case, coll does not hold.
Case 2⇔ nα �= nβ : Without loss of generality, assume that nα > nβ . By
mα
nα �= 0r and mα �= mβ , there exists j∗ ∈ {1, . . . , nβ} such that tαj∗ �= tβj∗
holds. By ¬colltt, for all j ∈ {j∗ + 1, . . . , nα + � − 1}, tαj �= tβj holds. Hence,
in this case, coll does not hold.
By the above evaluations, we have Pr[coll|¬colltt] = 0.
Finally, we have
Pr[DG2 ⇒ 1] − Pr[DG3 ⇒ 1] ≤ Pr[coll] ≤ q2
2c
+
0.5�q2
2b
. (4)
4.3 Upper-Bound of the Advantage
We put the upper-bounds (3) and (4) into the inequation (1). Then we have
Advprf
IKSponge(D) ≤ �q + Q
2k
+
3q2 + qQ + 2ρ(q + Q)
2c
+
3�2q2
2b
+ 2r+1 ×
(
2e�q
ρ2r
)ρ
.
1 Note that in this condition we consider a collision at the same position for two online
queries, where in the position the outputs of the queries are produced. Hence, the
first point of i is max{nα, nβ} and the last point is min{nα, nβ} + �out − 1.
New Bounds for Keyed Sponges with Extendable Output 21
5 Outer Keyed Sponge and the PRF-Security
By OKSponge we denote the outer keyed sponge construction, and by OKSpongeP
K ,
denote OKSponge with P having K. For a message m ∈ {0, 1}∗, the response is
defined as OKSpongeP
K(m) := SpongeP (K∗‖m), where K∗ is defined by append-
ing some bit string to the suffix of K such that the bit length is a multiple
of r, e.g., a zero string is appended. So the difference between OKSponge and
IKSponge is the procedure to define the value s0. In OKSpongeP
K , s0 is defined
as follows, where κ := |K∗|/r.
1. Partition K∗ into r-bit blocks K1, . . . ,Kκ;
Partition m‖pad(|K∗‖m|) into r-bit blocks m1, . . . ,mn
2. w0 ← 0b; For i = 1, . . . , κ do ui ← Ki‖0c ⊕ wi−1; wi ← P (ui)
3. s0 ← wκ
Basically, we can prove the PRF-security of OKSponge by the similar proof but
need to consider the structural difference: s0 = 0b−k‖K in IKSponge and s0 = wκ
in OKSponge. If D does not know wκ, that is, D does not make an offline query
P(uκ) and P−1(wκ) then wκ becomes a secret random value of b bits. Therefore,
the upper-bound of the PRF-security of OKSponge can be obtained from that of
IKSponge, where the probability for K, �q+Q
2k , is replaced with the probability
for the “bad” event where D knows wκ. The probability for the bad event was
considered in [1,13], and we use their bound. The concrete upper-bound is given
as follows, where the probability for the bad event is λ(Q) + 2κQ
2b .
Theorem 2. Let D be a distinguisher which makes q online queries of r-
bit block length at most �in and Q offline queries. Then for any ρ, we have
Advprf
OKSponge(D) ≤ λ(Q)+ 2κQ
2b + 2qQ+3.5�2q2
2b + 3q2+2qQ+2ρ(q+Q)
2c +2r+1×
(
2e�q
ρ2r
)ρ
,
where � = �in + �out − 1, e = 2.71828 · · · is Napier’s constant, and λ(Q) = Q
2k if
k ≤ r, and λ(Q) = min
{
Q2
2c+1 + Q
2k , 1
2b + Q
2
(
1
2 − log2(3b)
2r
− 1
r
)
k
}
otherwise.
Corollary 2. We assume c ≤ b/2. Then, we put ρ = r, and without loss of
generality, assume r ≥ 2 (otherwise r = c = 1 and b=2). Since r ≥ b/2, we have
Advprf
OKSponge(D) ≤ 3q2+2qQ+2r(q+Q)
2c + (3.5+32e2r−2)�2q2+2qQ+2κQ
2b + λ(Q).
We assume c > b/2 and put ρ = max
{
r,
(
2e×�q
2r−c(q+Q)
)1/2
}
. Then we have
Advprf
OKSponge(D) ≤
(
18e�q(q+Q)
2b
)1/2
+ 3q2+2qQ+2r(q+Q)
2c + 3.5�2q2+2qQ+2κQ
2b +λ(Q).
References
1. Andreeva, E., Daemen, J., Mennink, B., Van Assche, G.: Security of keyed sponge
constructions using a modular proof approach. In: Leander, G. (ed.) FSE 2015.
LNCS, vol. 9054, pp. 364–384. Springer, Heidelberg (2015)
22 Y. Naito and K. Yasuda
2. Aumasson, J.-P., Henzen, L., Meier, W., Naya-Plasencia, M.: Quark: a lightweight
hash. In: Mangard, S., Standaert, F.-X. (eds.) CHES 2010. LNCS, vol. 6225, pp.
1–15. Springer, Heidelberg (2010)
3. Aumasson, J.-P., Jovanovic, P., Neves, S.: NORX: parallel and scalable AEAD. In:
Kuty�lowski, M., Vaidya, J. (eds.) ICAIS 2014, Part II. LNCS, vol. 8713, pp. 19–36.
Springer, Heidelberg (2014)
4. Bellare, M., Canetti, R., Krawczyk, H.: Keying hash functions for message authen-
tication. In: Koblitz, N. (ed.) CRYPTO 1996. LNCS, vol. 1109, pp. 1–15. Springer,
Heidelberg (1996)
5. Bellare, M., Rogaway, P.: The security of triple encryption and a framework for
code-based game-playing proofs. In: Vaudenay, S. (ed.) EUROCRYPT 2006. LNCS,
vol. 4004, pp. 409–426. Springer, Heidelberg (2006)
6. Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: Duplexing the sponge: single-
pass authenticated encryption and other applications. In: Miri, A., Vaudenay, S.
(eds.) SAC 2011. LNCS, vol. 7118, pp. 320–337. Springer, Heidelberg (2012)
7. Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: On the indifferentiability
of the sponge construction. In: Smart, N.P. (ed.) EUROCRYPT 2008. LNCS, vol.
4965, pp. 181–197. Springer, Heidelberg (2008)
8. Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: On the security of the keyed
sponge construction. In: SKEW 2011 (2011)
9. Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: Permutation-based encryp-
tion, authentication and authenticated encryption. In: DIAC 2012 (2012)
10. Bogdanov, A., Knežević, M., Leander, G., Toz, D., Varıcı, K., Verbauwhede, I.:
spongent: a lightweight hash function. In: Preneel, B., Takagi, T. (eds.) CHES
2011. LNCS, vol. 6917, pp. 312–325. Springer, Heidelberg (2011)
11. Chang, D., Dworkin, M., Hong, S., Kelsey, J., Nandi, M.: A keyed sponge construc-
tion with pseudorandomness in the standard model. In: Third SHA-3 Candidate
Conference (2012)
12. Chen, S., Steinberger, J.: Tight security bounds for key-alternating ciphers. In:
Nguyen, P.Q., Oswald, E. (eds.) EUROCRYPT 2014. LNCS, vol. 8441, pp. 327–
350. Springer, Heidelberg (2014)
13. Gaži, P., Pietrzak, K., Tessaro, S.: The exact PRF security of truncation: tight
bounds for keyed sponges and truncated CBC. In: Gennaro, R., Robshaw, M.
(eds.) CRYPTO 2015. LNCS, vol. 9215, pp. 368–387. Springer, Heidelberg (2015)
14. Guo, J., Peyrin, T., Poschmann, A.: The PHOTON family of lightweight hash
functions. In: Rogaway, P. (ed.) CRYPTO 2011. LNCS, vol. 6841, pp. 222–239.
Springer, Heidelberg (2011)
15. Jovanovic, P., Luykx, A., Mennink, B.: Beyond 2c/2 security in sponge-based
authenticated encryption modes. In: Sarkar, P., Iwata, T. (eds.) ASIACRYPT 2014.
LNCS, vol. 8873, pp. 85–104. Springer, Heidelberg (2014)
16. Mennink, B., Reyhanitabar, R., Vizár, D.: Security of full-state keyed sponge and
duplex: applications to authenticated encryption. In: Iwata, T., et al. (eds.) ASI-
ACRYPT 2015. LNCS, vol. 9453, pp. 465–489. Springer, Heidelberg (2015)
17. NIST: SHA-3 standard: permutation-based hash and extendable-output functions.
In: FIPS PUB 202 (2015)
18. Patarin, J.: The “Coefficients H” technique. In: Avanzi, R.M., Keliher, L., Sica, F.
(eds.) SAC 2008. LNCS, vol. 5381, pp. 328–345. Springer, Heidelberg (2009)
19. Sasaki, Y., Yasuda, K.: How to incorporate associated data in sponge-based authen-
ticated encryption. In: Nyberg, K. (ed.) CT-RSA 2015. LNCS, vol. 9048, pp. 353–
370. Springer, Heidelberg (2015)
	New Bounds for Keyed Sponges with Extendable Output: Independence Between Capacity and Message Length
	1 Introduction
	2 Preliminaries
	3 Inner Keyed Sponge and the PRF-Security
	3.1 Inner Keyed Sponge Construction
	3.2 PRF-Security of the IKSponge Construction
	4 Proof of Theorem 1
	4.1 Upper-Bound of Pr[DG1 1] - Pr[DG2 1]
	4.2 Upper-Bound of Pr[DG2 1] - Pr[DG3 1]
	4.3 Upper-Bound of the Advantage
	5 Outer Keyed Sponge and the PRF-Security
	References