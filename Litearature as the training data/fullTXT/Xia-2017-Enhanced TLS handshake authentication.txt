Enhanced TLS Handshake Authentication with Blockchain and Smart Contract (Short Paper)
Enhanced TLS Handshake Authentication
with Blockchain and Smart Contract
(Short Paper)
Bingqing Xia1,2, Dongyao Ji1,2(B), and Gang Yao1,2
1 State Key Lab of Information Security,
Institute of Information Engineering of Chinese Academy of Sciences, Beijing, China
jidongyao@iie.ac.cn
2 School of Cyber Security, University of Chinese Academy of Sciences,
Beijing, China
Abstract. Transport Layer Security (TLS) is the main standard
designed for secure connections over the Internet. Security of TLS con-
nections against active Man-in-the-Middle attacks relies on correctly
validating public-key certificates during TLS handshake authentica-
tion. Although Certificate Transparency (CT) and further improved CT
system—IKP mitigated the certificate authentication issues from the per-
spective of monitoring CA misbehavior, less attentions have been paid
to consider the misbehavior of domain in using certificates during TLS
handshake authentication. One misusing case is that domains refuse to
use the certificates in Certificate Transparency Log for their own prof-
its, the other is that a malicious domain impersonates the real one to
deceive clients. In order to defend against domain’s misbehaviors in using
certificates, we propose ETDA system based on IKP and CT aiming to
enhance the security of TLS protocol from a novel perspective. ETDA
is a blockchain-based system enforcing the automatic punishments in
response to domain misbehavior and compensations to the client during
TLS handshake authentication. The decentralized nature and incentives
mechanism of ETDA provide an effective approach to prevent domains
from sending invalid certificates to clients. We implement this system
through Ethereum platform and Game Theory, which proved to be both
technically and economically feasible.
Keywords: TLS Handshake Protocol · Certificate transparency ·
Ethereum blockchain · Smart contract · Game Theory
1 Introduction
Transport Layer Security (TLS) are protocols designed to provide confidential-
ity, authenticity, and integrity over the Internet [1]. TLS clients receive digital
This work was supported by the National Key Research and Development Program
of China, No. 2016YFB0800503.
c© Springer International Publishing AG 2017
S. Obana and K. Chida (Eds.): IWSEC 2017, LNCS 10418, pp. 56–66, 2017.
DOI: 10.1007/978-3-319-64200-0 4
Enhanced TLS Handshake Authentication with Blockchain 57
certificates when they request to establish secure connections to domains. They
verify them using the embedded public keys of CAs in their browsers or operating
system certificate trust stores. Specifically, with a rogue certificate, the adversary
may be able to conduct a TLS man-in-the-middle (MITM) attack between the
end user and a fake website. Since the rogue certificate is technically valid and
trusted, there will not be automated detection or security warnings generated
for such an attack. In order to immediately identify a rogue certificate (including
bogus or self-signed certificate), Certificate Transparency (CT) was proposed to
provide a publicly logged and audited certificates facility for checking the validity
of certificates [2]. A supplementary system Revocation Transparency [3] was also
proposed. And a further improved CT system—IKP [4] infrastructure initially
improved the log-based PKI based on blockchain and smart contract by offer-
ing automatic responses to CA misbehaviors and incentives for those who help
detect misbehaviors. Unfortunately, despite these benefits, TLS handshake still
suffers from several problems. First, responding to domain misbehavior takes
time and requires manual effort in CT. Second, IKP fails to consider the mis-
behavior of domain in using certificates during TLS handshake authentication.
Finally, there is no way to overcome denial of service attack [5].
In this paper, we try to solve these problems by applying blockchain and
smart contract based on CT and IKP. Smart contracts are agreements between
mutually distrusting participants, which are automatically enforced by the con-
sensus mechanism of the blockchain without relying on a trusted authority [6].
The security of TLS protocol largely depends on whether the client has authen-
ticated the received certificates, thus surveillance over domain’s certificates sent
to clients during the TLS handshake is also significant. In this paper, we present
an enhanced TLS handshake domain authentication framework ETDA, a sup-
plement to IKP. ETDA system relies on a decentralized entity that handles the
definition and evaluation of domain misbehavior in certificates during the TLS
handshake authentication and automatically executes pre-defined reactions to
this misbehavior, which enhances the security of TLS handshake protocol and
provides a new application scenario for blockchain research.
In summary, we make the following contributions:
1. We design and propose an enhanced TLS handshake domain authentication
framework ETDA, including Client Check Policies and Domain Reactions
Polices.
2. We demonstrate through a game theoretic analysis that ETDA system pun-
ishes domain misbehavior and compensates client, which proved to be feasible
economically.
3. We implement this system through Ethereum platform, which proved to be
feasible technically.
2 Background
In this section, we provide the background required to understand ETDA includ-
ing TLS handshake authentication and smart contract on blockchain.
58 B. Xia et al.
TLS handshake authentication: The full TLS handshake protocol allows
domain and client to authenticate each other. In this paper, we only consider
the widely used version where clients authenticate domains(a.com)which mainly
depends on the certificate provided by domains. Whether the certificate is valid
or not is the key component during TLS handshake authentication [7].
Smart Contract on Blockchain: Blockchain is basically an append-only
data structure maintained by the nodes of a peer-to-peer network. It was ini-
tially introduced for Bitcoin payments [8]. Implementing smart contracts on
blockchains is also a prominent topics. Smart contracts are user-defined programs
that are automatically executed and enforced by the consensus protocol of the
blockchain [9]. A smart contract is identified by an address (a 160-bit identifier),
which allows users to create and invoke a smart contract by posting a transac-
tion including payments (in Ether) and input data to the contract address. Since
resided on blockchain, The program code of a smart contract can not be tam-
pered once the contract is created to avoid the interference of malicious behavior
to normal execution of contract. In this paper, we apply Ethereum Blockchain
as the smart contract platform which supports stateful contracts where values
can persist on the blockchain to be used in various invocations. For detailed
information, please refer to [10,11].
3 ETDA Framework
In this section, we first propose the framework of ETDA system in Fig. 1. In
general, ETDA system extends the traditional TLS ecosystem where domains
interact with clients by carrying out TLS handshake with Ethereum blockchain.
Then we illustrate the main components and functions of ETDA as well as explicit
description of Client Check Policy and Domain Reaction Policy respectively.
Fig. 1. Framework of ETDA
Enhanced TLS Handshake Authentication with Blockchain 59
3.1 Components and Functions
We illustrate the following four main components in ETDA and functions:
Domains. Domains send certificates to clients during TLS handshake and issue
Domain Reaction Policies (DRPs), which take effect if a domain sends an invalid
certificate to clients, acting as a sort of payments insurance policy against
domains misbehaviors. To participate in ETDA, domains should register identity
information and DRPs in Ethereum blockchain.
Clients. Clients receive certificates from domains in TLS handshake protocol
and issue Client Check Policies (CCPs), which publicize criterion to determine
whether the certificates are valid. Clients also purchase DRPs from domains
to obtain incentives for compensations if the certificate proved invalid. To join
ETDA, clients should register identity and CCPs in Ethereum blockchain.
ETDA Contract. ETDA Contract provides different functions related to the
operations of each entity in ETDA and contains the logic to execute the opera-
tions. It owns a contract fund account which maintains its own balance to escrow
funds and provide rewards. Since based on blockchain, the contract is shared for
all entities joining the blockchain once the contract is publicized.
Ethereum Blockchain. It is a decentralized platform providing incentive
nature and a transaction framework to participants. We design smart contracts
to realize incentives mechanism of punishing the misbehaving domains and com-
pensating the clients automatically based on Ethereum Blockchain.
3.2 Client Check Policies (CCPs)
A CCP is issued by a client to check the validity of a domain’s certificate. We
design the contents of CCPs including: (1) Client Name, to identify client for
which CCP is active. (2) Payment Address, to authenticate client’s identities
and receive payments. (3) Valid From, to denote start date of CCP’s validity.
(4) Valid To, to denote the expire date of CCP’s validity. (5) Version Number, to
denote version of CCP. (6) Check Contract, specified as a smart contract address
to determine certificate validity.
Specifically, Check Contract is an Ethereum account on blockchain that pro-
vides a function check which takes in serialized bytes of a public-key certificate
and returns a Boolean value representing certificate validity. We leverage Cer-
tificate Transparency (CT) Certificate Logs [2] as the checking criterion to check
invalid certificates. The check policy can be interpreted as:
If the certificate hasn’t been logged in the Certificate Transparency Logs
and the domain is the one who sends the certificate,
then the domain is deemed to have misbehaved.
60 B. Xia et al.
3.3 Domain Reaction Polices (DRPs)
A DRP is issued by a domain in response to its misbehavior in certificates.
Similar to CCP, we design the contents of DRPs including: (1) Domain Name,
to identify who sends certificates to clients during TLS handshake, (2) Issuer,
the primary domain who issued the DRP. In particular, the primary domain is
responsible for the certificate misbehaviors for all of its subdomains, for example
a.com is responsible for the certificate errors for c.a.com et. (3) Payment address,
to authenticate domain’s identity and send payments, (4) Valid From, to denote
start date of DRPs validity, (5) Valid To, to denote expiration date of DRP’s
validity. (6) Version Number, to denote version of CCP corresponding to DRP.
(7) Reaction contract, smart contract in response to domain’s misbehaviors.
Reactions Contract is also a contract account on Ethereum which provides a
method trigger in response to domain’s misbehaviors in using certificates. The
DRP itself also contains two methods including terminate and expire through
the ETDA contract. The terminate method can be called by a client if the
domain misbehaves in certificate and executes after trigger method. The expire
method can be called by the domain once the DRP has expired. In general, a
DRP contains a domain’s commitment denoting that:
If a domain (for example a.com) sends an invalid certificate to a client,
then it will pay X Ether and the client who detects it will get Y Ether.
4 ETDA Operations
We take an in-depth look at the main operations of ETDA in this section and
specify three entities involved in operations: (1) the client, who we denote as C,
(2) the domain, which we denote as D, (3) the contract fund account, which we
denote as CF. We use these abbreviations in the following sections as well.
4.1 Registrations
Each domain interacting with clients in TLS protocol should register its identity
and a DRP in ETDA contract. When registering identity information, D sends
a transaction which contains the D’s certificate and corresponding certificate
link containing the trusted root as well as signature information signed with
private key which corresponds to the public key in certificate to ETDA contract.
Therefore, the ETDA contract can determine domain’s identity. In this way, an
account for a registering domain D is created. D generates a pair of public key
and private key (PKD−account, SKD−account) to control this account.
During TLS handshake, D sends a certificate appending with the signature
information signed with the private key for manipulating its account. We denote
the signature information as SIGSKD−account
(Cert,D, sid), which binds the cer-
tificate Cert with the D’s identity information D and a session number sid to
ensure that when D misuses the certificate, it fails to deny the misbehavior. Simi-
larly, C should register its identity in ETDA contract. We denote the registration
fees of D and C as rD and rC respectively.
Enhanced TLS Handshake Authentication with Blockchain 61
4.2 Purchasing DRPs
If C choose to check a certificate from D, then C should purchase a DRP issued
by D. We denote the fee for purchasing the DRP as p which is transferred from
C to D who issued the DRP. Besides, gD and gC are denoted as gas fees [10]
paid to the contract fund account (CF). These gas fees restrict the execution
steps of transactions to prevent from denial-of-service attacks where adversaries
try to overwhelm the network with over-consumption of resources.
4.3 Certificates Checking
C can check D’s certificate by executing the certificate check contract. If the
certificate hasn’t been logged in the CT Logs and D is the one who sends the
certificate, then the certificate is deemed to be invalid. We present this checking
algorithm written in smart contract in Solidity as a check method, where the
output is true that denotes the certificate invalid and triggers the DRP’s reaction
contract. The detection algorithm is as follows:
Algorithm 1. Check Method in Certificate Check Contract
1: procedure Certificate−checking check()
2: Input: certificate Cert , SIGSKD−account()
3: List ← get CT−Logs
4: look up Cert in List
5: if (Cert not in List) and (Verify(SIGSKD−account())=true) then
6: output: true
7: end if
8: end procedure
4.4 Misbehaviors Reactions
Once a CCP determines a D’s certificate to be invalid, the reaction contract of
DRP is triggered to execute a series of payments automatically. We realize this
incentives mechanism through a Game Theoretic model whose core idea is Nash
Equilibrium [12]. We specify the following three kinds of payments:
Misbehavior payment, m: is the fund paid to C from D who sends an invalid
certificate. It aims at compensating C for security risks it will suffer in TLS pro-
tocol. The amount of m depends on the severity of the misbehavior. We assume
two kinds of misbehavior payments: (1) internal misbehavior payment, mi, which
is caused by a registered domain in Ethereum, (2) external misbehavior payment,
me, which is caused by an un-registered domain.
Termination Payment, t: is the fund split between C and D if C terminates
the DRP before Valid To date of DRP. It compensates C for lost trust in D due to
the misbehavior of D and the cost of purchasing a new DRP. To guarantee that
C can receive some minimum amount of funds, we set a parameter δ. And the
split amount of the termination payout is proportional to the amount of time left
in the DRP’s validity. We denote the total amount of termination payment is t,
62 B. Xia et al.
which is split for C as tC , and D as tD (t = tC + tD) and the proportion of the
termination as θ (0 ≤ θ ≤ 1). Then we observe:
tC = δ + θ(t − δ) (1)
tD = (1 − θ)(t − δ) (2)
And we remark:
δ ≤ tC ≤ t (3)
0 ≤ tD ≤ t − δ (4)
Contract Fund Payment, f: is the fund paid to contract fund account aiming
to replenish the contract fund to ensure that it owns enough funds to continue its
operation. Therefore, we design contract fund payments to compensate for any
losses that the contract fund may suffer which will occur with high probability.
We denote the total amount as S (S = m+t+f) and a proportion α (0 < α < 1)
of the total amount (αI) is escrowed in the contract to ensure the availability of
these funds. The algorithm of trigger method is as follows:
Algorithm 2. Trigger Method in Domain Reaction Contract
1: procedure Misbehavior−reaction trigger()
2: Input: Certificate−checking check()=true
3: Client ← Domain m Ether
4: Contract−Fund ← Domain f Ether
5: end procedure
In particular, ETDA contract maintains a mapping between C and a list of
their corresponding active DRPs. When C purchase a new DRP, ETDA contract
adds the new DRP to C’s current DRP list. This scheme ensures the DRP to
every single instance of D’s misbehavior is unambiguous. In summary, we com-
bine the two operations of the certificate checking and the misbehavior reaction,
and present Algorithm 3 which handles an invalid certificate.
Algorithm 3. ETDA contract handling an invalid certificate
1: procedure ETDA−contract
2: Input: certificate Cert, Client address C
3: D← get certificate−owner name from Cert
4: SIGSKD−account() ← get D’s signature information from D
5: CCP← get CCP from C
6: Check−contract ← get check contract address from CCP
7: if Check−contract.check(Cert, SIGSKD−account()) then
8: DRP−list ← look up DRP list for D
9: DRP ← get reaction contract address from DRP−list[0]
10: DRP.trigger(check−contract.check())
11: delete DRP from DRP−list
12: terminate()
13: end if
14: end procedure
Enhanced TLS Handshake Authentication with Blockchain 63
5 Payments Analysis
In this section, we analyze the payments between different entities in different
scenarios. First, we provide a general analysis of a list of payments in response
to each action in ETDA. Then we provide explicit analysis for different sce-
narios to determine what constraints to set to guarantee that entities benefit
from behaving correctly and get punished for misbehaving with Game Theory
approach.
5.1 General Analysis
We summarize the different payment flows between different entities for the main
operations in Table 1 and classify the domains misbehaviors into two categories:
(1) DRP-issuer scenario. D is the issuer of the DRP. If D misbehaves, we call
it internal misbehavior as illustrated in Sect. 4. (2) non-DRP-issuer scenario.
omain is not the issuer of the DRP and we denote the issuer as R. We note that
an external misbehavior can only occur in non-DRP-issuer scenario.
We propose the following principles for payment designs: (1) Domains who
internally misbehave lose money. (2) Domains who externally misbehave cannot
profit. (3) Clients profit from internal misbehaviors. In particular, The domain
may purposely misbehave in order to trigger DRP and then collude with the
entities who receive positive funds to gain profits after summing their rewards.
Therefore we must guarantee that no possible collusion attacks can result in the
profits for the misbehaving domain.
5.2 DRP-issuer Scenario
For DRP-issuer scenario, we assume C has purchased a DRP and appropriate
fees has been sent. Table 2 presents how payments transfer between different
entities in response to scenarios of whether D misbehaves or not.
We observe that if D misbehaves, D should pay additional mi + tC + f
as punishment than it would otherwise and C will be rewarded mi + tC as
compensation. To guarantee C to profit, we set mi + tC > p. By Eq. 3 which is
δ ≤ tC , we set the constraint p < mi + δ and to guarantee D to lose money for
its misbehavior, we set p < mi + δ + f . However, this constraint is subsumed by
the previous constraint p < mi + δ, which sets a tighter bound on p. To avoid
collusion attacks, we observe that C profits If D misbehaves. The total rewards
of D and C is -f. Thus D cannot profit from colluding with C. To sum up, the
constraint based on Game Theory is: p < mi + δ.
5.3 non-DRP-issuer Scenario
In this scenario, we consider whether or not D registers in ETDA contract respec-
tively as Tables 3 and 4 present.
non-DRP-issuer scenario where D registers. From Table 3, we observe
that C has the same rewards as in the DRP-issuer scenario. Therefore we set
64 B. Xia et al.
Table 1. Payments for various events
Event From To Amount
Register Domain D CF rD
Register Client C CF rC
Issue (purchase) DRP D CF αS + gD
C CF p + gC
CF D p
Detect internal misbehavior (DRP-issuer) CF C mi + tC
CF D αS − tC − f
Detect internal misbehavior (non-DRP-issuer) CF C mi + tC
CF R αS − tC
D CF mi + f
Detect external misbehavior (non-DRP-issuer) CF C me + tC
CF R αS − tC
Terminate DRP CF C tC
CF D αS − tC
Expire DRP CF D αS
Table 2. Rewards in the DRP-issuer scenario
Entities Events
C D CF
Behave −p p 0
Misbehave −p + mi + tC p − mi − tC − f f
the same constraint as p < mi + δ. For R who is the issuer of DRP and has
not misbehaved, it should still profit for the DRP purchase fee. Therefore we set
p > tC . And by Eq. 3 which is tC ≤ t, we set the tighter constraint p > t. For
D, it should pay additional fee rD for the registration. If D misbehaves, while D
still faces penalty as in the DRP-issuer scenario, it receives p + rD less rewards
than it behaves. Similarly, considering collusion attacks, we add the rewards of
C, R and D. The sum −f − rD still ends up with a negative rewards to avoid
collusion attack. To sum up, the constraints are: t < p < mi + δ.
non-DRP-issuer scenario where D does not register. From Table 4, we
observe that R has the same rewards as in the non-DRP-issuer scenario where D
registers. Since D has not registered in ETDA, it does not need to pay anything
and fails to have sufficient funds to pay C, then ETDA contract’s CF replenish
D’s absence funds and pay the appropriate rewards to C. Since that D does not
need to pay anything, colluding with any entity with positive reward results in
profits. Colluding with R will definitely bring D profits but the profits is less than
Enhanced TLS Handshake Authentication with Blockchain 65
Table 3. Rewards in the domain-registered non-DRP-issuer scenario
Entities Events
C R D CF
Behave −p p −rD rD
Misbehave −p + mi + tc p − tc −rD − mi − f f + rD
the collusion rewards if D behaves. According to Game Theory, misbehaving is
not the better strategy, which enforces D to choose the better choice, namely is to
behave. If D colludes with C, the total sum of D and C is −p+me+tC , therefore,
we must set the constraint p ≥ me + tC to ensure this reward is non-positive.
Combining Eq. 3, we set a tighter constraint p ≥ me + t. Under this constraint,
we observe that C will have to lose money which seems unreasonable. However,
C still obtains a higher reward than the case that D behaves. Therefore, checking
D’s misbehavior is the better strategy for C. To sum up, the constraint set based
on Game Theory is: p ≥ me + t.
Table 4. Rewards in the domain-unregistered non-DRP-issuer scenario
Entities Events
C R D CF
Behave −p p 0 0
Misbehave −p + me + tC p − tC 0 −me
6 Conclusion
On the basis of CT and IKP, we proposed ETDA: a system for detecting
and automatically responding to Domain misbehavior with smart contracts on
Ethereum Blockchain. This provides a novel way for enhancing the security of
TLS handshake authentication protocols. One merit of our method is that it
can provide the power to restrict the error behavior of the domain. Besides, our
experience suggests that reward and punishment mechanism based on Game
Theory may be more suitable to repel the concrete attack scenarios.
References
1. Rescorla, E.: The Transport Layer Security (TLS) Protocol Version 1.3-draft-ietf-
tls-tls13-20, April 2017. https://tools.ietf.org/html/draft-ietf-tls-tls13-20
2. Laurie, B., Langley, A., Kasper, E. Certificate Transparency, June 2013. http://
tools.ietf.org/pdf/rfc6962.pdf, IETF RFC 6962
3. Laurie, B., Kasper, E.: Revocation Transparency (2012). http://sump2.links.org/
RevocationTransparency.pdf
https://tools.ietf.org/html/draft-ietf-tls-tls13-20
http://tools.ietf.org/pdf/rfc6962.pdf
http://tools.ietf.org/pdf/rfc6962.pdf
http://sump2.links.org/RevocationTransparency.pdf
http://sump2.links.org/RevocationTransparency.pdf
66 B. Xia et al.
4. Matsumoto, S., Reischuk, R.: IKP: Turning a PKI Around with Blockchains. Cryp-
tology ePrint Archive: Report 2016/1018
5. Aura, T., Nikander, P., Leiwo, J.: DOS-resistant authentication with client puzzles.
In: Christianson, B., Malcolm, J.A., Crispo, B., Roe, M. (eds.) Security Protocols
2000. LNCS, vol. 2133, pp. 170–177. Springer, Heidelberg (2001). doi:10.1007/
3-540-44810-1 22
6. Luu, L., Chu, D., Olickel, H., Saxena, P., Hober, A.: Making smart contracts
smarter. In: Proceedings of the 2016 ACM SIGSAC Conference on Computer and
Communications Security, pp. 254–269, October 2016
7. Bhargavan, K., Lavaud, A., Fournet, C., Pironti, A., Strub, P.: Triple handshakes
and cookie cutters: breaking and fixing authentication over TLS. In: IEEE Sym-
posium on Security and Privacy (SP), pp. 98–113 (2014)
8. Nakamoto, S.: Bitcoin: A pee-to-peer electronic cash system (2008)
9. Delmolino, K., Arnett, M., Kosba, A., Miller, A., Shi, E.: Step by step towards
creating a safe smart contract: lessons and insights from a cryptocurrency lab.
In: Clark, J., Meiklejohn, S., Ryan, P.Y.A., Wallach, D., Brenner, M., Rohloff, K.
(eds.) FC 2016. LNCS, vol. 9604, pp. 79–94. Springer, Heidelberg (2016). doi:10.
1007/978-3-662-53357-4 6
10. Ethereum Foundation. Ethereum’s white paper (2014). https://github.com/
ethereum/wiki/White-Paper
11. Bonneau, J.: EthIKS: using ethereum to audit a CONIKS key transparency log.
In: Clark, J., Meiklejohn, S., Ryan, P.Y.A., Wallach, D., Brenner, M., Rohloff, K.
(eds.) FC 2016. LNCS, vol. 9604, pp. 95–105. Springer, Heidelberg (2016). doi:10.
1007/978-3-662-53357-4 7
12. Weibull, J.: Evolutionary Game Theory. MIT Press, Cambridge (1995)
http://dx.doi.org/10.1007/3-540-44810-1_22
http://dx.doi.org/10.1007/3-540-44810-1_22
http://dx.doi.org/10.1007/978-3-662-53357-4_6
http://dx.doi.org/10.1007/978-3-662-53357-4_6
https://github.com/ethereum/wiki/White-Paper
https://github.com/ethereum/wiki/White-Paper
http://dx.doi.org/10.1007/978-3-662-53357-4_7
http://dx.doi.org/10.1007/978-3-662-53357-4_7
	Enhanced TLS Handshake Authentication with Blockchain and Smart Contract (Short Paper)
	1 Introduction
	2 Background
	3 ETDA Framework
	3.1 Components and Functions
	3.2 Client Check Policies (CCPs)
	3.3 Domain Reaction Polices (DRPs)
	4 ETDA Operations
	4.1 Registrations
	4.2 Purchasing DRPs
	4.3 Certificates Checking
	4.4 Misbehaviors Reactions
	5 Payments Analysis
	5.1  General Analysis
	5.2 DRP-issuer Scenario
	5.3 non-DRP-issuer Scenario
	6 Conclusion
	References