wChain: A Fast Fault-Tolerant Blockchain Protocol for Multihop Wireless Networks
IEEE TRANSACTIONS ON WIRELESS COMMUNICATIONS, VOL. 20, NO. 10, OCTOBER 2021 6915
wChain: A Fast Fault-Tolerant Blockchain Protocol
for Multihop Wireless Networks
Minghui Xu , Member, IEEE, Chunchi Liu, Yifei Zou , Member, IEEE, Feng Zhao , Member, IEEE,
Jiguo Yu , Senior Member, IEEE, and Xiuzhen Cheng , Fellow, IEEE
Abstract— This paper presents wChain , a blockchain protocol
specifically designed for multihop wireless networks that deeply
integrates wireless communication properties and blockchain
technologies under the realistic SINR model. We adopt a hier-
archical spanner as the communication backbone to address
medium contention and achieve fast data aggregation within
O(log N log Γ) slots where N is the network size and Γ
refers to the ratio of the maximum distance to the minimum
distance between any two nodes. Besides, wChain employs
data aggregation and reaggregation as well as node recovery
mechanisms to ensure efficiency, fault tolerance, persistence, and
liveness. The worst-case runtime of wChain is upper bounded
by O(f log N log Γ), where f = � N
2
� is the upper bound of
the number of faulty nodes. To validate our design, we conduct
both theoretical analysis and simulation studies. The results not
only demonstrate the nice properties of wChain , but also point
to a large new space for the exploration of blockchain protocols
in wireless networks.
Index Terms— Blockchain, fault-tolerance, multihop wireless
networks, SINR model.
I. INTRODUCTION
IN RECENT years, the popularity of 5G and IoT has arisen
more security and privacy issues relevant to identity man-
agement, data sharing, and distributed computing in wireless
Manuscript received January 3, 2021; revised March 16, 2021; accepted
April 25, 2021. Date of publication June 3, 2021; date of current version Octo-
ber 11, 2021. This work was supported in part by the National Key Research
and Development Program of China under Grant 2019YFB2102600; in part
by the National Natural Science Foundation of China under Grant 61771289,
Grant 61871466, Grant 61832012, and Grant 61672321; in part by the Key
Science and Technology Project of Guangxi under Grant AB19110044; and
in part by the Blockchain Core Technology Strategic Research Program of
Ministry of Education of China under Grant 2020KJ010301. The associate
editor coordinating the review of this article and approving it for publication
was H. Zhu. (Corresponding author: Feng Zhao.)
Minghui Xu and Xiuzhen Cheng are with the School of Computer Sci-
ence and Technology, Shandong University, Qingdao 266510, China, and
also with the Department of Computer Science, The George Washing-
ton University, Washington, DC 20052 USA (e-mail: mhxu@sdu.edu.cn;
xzcheng@sdu.edu.cn).
Chunchi Liu and Yifei Zou are with the School of Computer Science
and Technology, Shandong University, Qingdao 266510, China (e-mail:
liuchunchi@sdu.edu.cn; yfzou@sdu.edu.cn).
Feng Zhao is with the Guangxi Colleges and Universities Key Laboratory
of Complex System Optimization and Big Data Processing, Yulin Normal
University, Yulin 537000, China (e-mail: zhaofeng@guet.edu.cn).
Jiguo Yu is with the School of Computer Science and Technology, Qilu Uni-
versity of Technology (Shandong Academy of Sciences), Jinan 250014, China,
also with the Shandong Computer Science Center (National Supercomputer
Center in Jinan), Jinan 250014, China, and also with the Shandong Laboratory
of Computer Networks, Jinan 250014, China (e-mail: jiguoyu@sina.com).
Color versions of one or more figures in this article are available at
https://doi.org/10.1109/TWC.2021.3078639.
Digital Object Identifier 10.1109/TWC.2021.3078639
networks. With the inception of Bitcoin, blockchain has been
envisioned as a promising technology that can be utilized
to support various applications such as online payments and
supply chain due to its salient properties of decentralization,
immutability, and traceability. Correspondingly, effort has been
put on protecting wireless applications using the blockchain
technology, e.g., mobile edge computing (MEC) [1], intelligent
5G [2], vehicular networking [3], and wireless sensor network-
ing (WSN) [4]. The common idea of applying blockchain in
wireless networks is to introduce trustlessness with blockchain
so that functions such as identity management and data sharing
become more efficient and secure.
However, previous studies on blockchain-enabled wireless
applications mostly focus on developing practical applications
or proposing architectures based on existing blockchain
protocols, which were originally designed for wired network
applications and thus are not suitable for wireless scenarios.
To defend this point of view, let’s consider the state-of-the-art
blockchain protocols. The concept of proof of physical
resources has been widely adopted, e.g., Proof-of-Work
(PoW), Proof-of-Space, Proof-of-Elapsed Time, Proof-
of-Space Time. The noteworthy drawback of these protocols is
that they require high electricity, storage, or specific hardware
(e.g., Intel SGX), which wireless devices cannot provide.
On the other hand, protocols based on virtual resources such as
stake, reputation, or credibility, i.e., Proof-of-Stake, Delegated
Proof-of-Stake, Proof-of-Authority, Proof-of-Reputation, etc.,
always have a complicated design in order to avoid the cen-
tralization of wealth or power, which justifies why there is still
no such a protocol particularly designed for wireless networks.
Another line of blockchain protocols, such as Ripple, Algo-
rand, Tendermint, and Hotstuff, rely on message passing.
They provide blockchain systems with safety and liveness in
confronting faulty nodes or even Byzantine failures. However,
when implemented in wireless networks, the following two
major problems need to be addressed:
• Traditional protocols commonly used on the Internet are
not efficient enough in wireless networks. For example,
PBFT [5] and Tendermint [6] can reach a consensus
within O(N2) successful transmissions where N is the
network size, while Hotstuff [7] reduces complexity to
O(N) but increases additional overhead due to the intro-
duction of the cryptographic tools.
• Transforming fault-tolerant or Byzantine fault-tolerant
protocols used in wired networks to wireless environ-
ments remains a tricky and challenging problem. A recent
1536-1276 © 2021 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See https://www.ieee.org/publications/rights/index.html for more information.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
https://orcid.org/0000-0003-3675-3461
https://orcid.org/0000-0003-4579-5380
https://orcid.org/0000-0002-5730-2208
https://orcid.org/0000-0001-6451-1158
https://orcid.org/0000-0001-5912-4647
6916 IEEE TRANSACTIONS ON WIRELESS COMMUNICATIONS, VOL. 20, NO. 10, OCTOBER 2021
work by Poirot et al. presented a fault-tolerant wireless
Paxos for low-power wireless networks [8]. However,
their results indicate that traditional consensus algorithms
require many message exchanges and high bandwidths,
which may not be available in wireless networks.
In this paper, we consider designing a message-
passing-based blockchain protocol for wireless networks.
To achieve this goal, we primarily need to overcome the
challenge of properly implementing the medium access con-
trol (MAC) layer for blockchain. A promissing idea is to
adopt the abstract MAC layer service (absMAC) proposed by
Kuhn et al. [9], which provides low-level network functions
to help design distributed algorithms in wireless networks.
The most efficient implementation of absMAC was presented
in [10], which achieves the optimal bound for a success-
ful transmission in O(Δ + log N) slots via carrier sensing,
where Δ is the maximum number of neighbors a node may
have. Obviously, with this efficient implementation and a
fault-tolerant consensus algorithm that requires an optimal
O(N) successful transmissions (e.g., Hotstuff), the best we
can obtain is a protocol with a communication complexity of
O(N(Δ + log N)) slots.
Nevertheless, this is far less than satisfactory. One needs
a blockchain protocol that can take into consideration the
unique features of wireless networking by deeply integrat-
ing wireless communications with blockchain to achieve the
necessary properties of efficiency, fault-tolerance, persistence,
and liveness. Since the most basic primitives heavily used in
wireless consensus algorithms are broadcasts and data aggre-
gations, which are respectively responsible for disseminating
and collecting opinions or votes from peers, we use a spanner
structure to accelerate the consensus process. A spanner is a
hierarchical communication backbone that can organize nodes
carefully to speed up data aggregation and dissemination
processes. It introduces a sparse topology in which only
a small number of links need to be maintained such that
efficiency and simplicity can be well-balanced. Due to the
need for decentralization and practicality, our spanner is con-
structed in a distributed manner and works under the realistic
Interference-plus-Noise-Ratio (SINR) model. Facilitated with
the spanner structure, we develop the two primitives of data
aggregation and reaggregation to directly handle interference
with an adaptive power scheme. These two primitives are
adopted by our fault-tolerant wChain protocol to address
faulty behaviors caused by fail-stop errors or dynamic topolo-
gies such that the properties of resource conservation, fault-
tolerance, efficiency, persistence, and liveness can be achieved.
The main contributions of this paper are summarized as
follows.
1) To the best of our knowledge, wChain is the first
blockchain protocol that is particularly designed for
multihop wireless networks under a realistic SINR
model to deeply integrate wireless communications and
blockchain technologies.
2) The wChain protocol ensures high performance by
employing a spanner as the communication back-
bone. The runtime upper bound of the protocol
is O(log N log Γ) when crash failures happen in a
low frequency, and the worst-case upper bound is
O(f log N log Γ) where f = �N
2 � is the maximum
number of faulty nodes that wChain can tolerate.
3) Our wChain protocol simultaneously achieves proper-
ties of resource conservation, fault-tolerance, efficiency,
persistence, and liveness, which are proved by theoreti-
cal analysis and verified by simulation studies.
The rest of the paper is organized as follows. Section II
introduces the most related work on the state-of-the-art
blockchain protocols and consensus algorithms in wireless
networks. Section III describes our model and preliminary
knowledge. In Section IV, building blocks including utilities
and data aggregation and reaggregation subroutines are pre-
sented, followed by the details of the three-phase wChain
protocol. Our wChain protocol is theoretically analyzed in
Section V in terms of efficiency, persistence, and liveness.
We report the results of our simulation studies in Section VI
and conclude this paper in Section VII.
II. RELATED WORK
A. Blockchain Protocols for Wireless Networks
Blockchain technology has been studied for wireless appli-
cations such as mobile edge computing (MEC) [1], intelligent
5G [2], vehicular networking [3], secure localization [4], and
Wireless D2D Transcoding [11]. Feng et al. [1] considered
the joint optimization of blockchain and MEC through a
radio and computational resource allocation framework.
Dai et al. [2] proposed a secure and intelligent architecture
for next-generation wireless networks by integrating
blockchain and AI technologies. In vehicular ad hoc
networks, Malik et al. [3] utilized blockchain for secure key
management. A blockchain-based trust management model
was proposed to ensure secure localization in wireless sensor
networks [4]. A blockchain-enabled Device-to-Device (D2D)
transcoding system was developed to provide trustworthy
wireless transcoding services in [11]. Onireti et al. [12]
provided an analytic modeling framework to obtain a viable
area for wireless PBFT-based blockchain networks. In [13],
a trustless mechanism with PoW-based blockchain was estab-
lished to incentivize nodes to store data. Liu et al. [14] realized
computation offloading and content caching with mobile edge
nodes in wireless blockchain networks. Sun et al. [15]
proposed an analytic framework to explore how the
performance and security of wireless blockchain systems are
affected by wireless communication features such as SINR.
Despite these extensive studies on applying blockchain to
wireless networks, we are still in dire need of blockchain
protocols that are specifically designed for wireless networks,
which drives us to investigate and summarize existing dis-
tributed leader election and consensus algorithms for wireless
networks in the sequel.
B. Consensus and Leader Election Algorithms for Wireless
Networks
Consensus and leader election have also been extensively
explored in various wireless contexts, and the corresponding
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
XU et al.: wCHAIN: FAST FAULT-TOLERANT BLOCKCHAIN PROTOCOL FOR MULTIHOP WIRELESS NETWORKS 6917
solutions can guide us to design wireless blockchains in a
proper way. Most existing studies on consensus and leader
election for wireless networks assume a high-level wireless
network abstraction [16]–[21] or a realistic model grappling
with issues in physical and link layers [22]–[26].
Moniz et al. [16] proposed a BFT consensus protocol with
runtime bounded by O(N2) among k > �N
2 � nodes in wireless
ad hoc networks. They hid physical layer information but
let nodes directly use high-level communication primitives.
Leveraging the elegance of absMAC, Newport provided upper
and lower bounds for distributed consensus in wireless net-
works [17]. Subsequently, Newport and Robinson proposed
a fault-tolerant consensus algorithm that terminates within
O(N3 log N) with unknown network size [18]. A fully dis-
tributed leader election scheme was proposed to make election
value unforgeable and be resistant to jamming attacks in
wireless sensor networks. A secure extrema finding algorithm
was proposed as a lock-step leader election algorithm that can
be transformed to a secure preference-based leader election
algorithm with a utility function depicting nodes’ preference
in wireless ad hoc networks [20]. A top k-leader election
algorithm with faulty nodes was presented in [21].
Chockler et al. [22] investigated the relationship between
collision detection and fault-tolerant consensus under a
graph-based model. Assuming a graph model with message
delays, Scutari and Sergio [23] proposed a consensus
algorithm in wireless sensor networks with multipath fading.
Aysal et al. [24] studied the average consensus problem
with probabilistic broadcasts under a graph-based model.
Richa et al. [25] focused on self-stabilization of leader
election for single-hop wireless networks to mitigate jamming
attacks by adaptively adjusting the transmission probability at
the MAC layer. Gołȩbiewski and Klonowski [26] proposed a
fair leader election scheme in ad-hoc single-hop radio sensor
networks, enabling resistance to adversaries who can transmit
continuously to block channels or try to forge identities.
In contrast, we observe that designing a blockchain proto-
col is more challenging than consensus and leader election
in wireless networks. On one hand, blockchain introduces
new data structures such as a chain of blocks, and thus
the corresponding computation, communication, and storage
overheads should be carefully addressed. On the other hand,
it is harder to balance performance and security in blockchain
since consensus and leader election offer more straightforward
services without requiring a strong security guarantee. More
importantly, blockchain requires extra design elements (e.g.,
randomness, transaction and block verification, blockchain
update) to guarantee strict persistence and liveness properties.
III. MODELS AND PRELIMINARIES
A. Blockchain Basics
Each node v maintains a blockchain locally, denoted by
BCv , which is a hash-chain of blocks. Bi
v refers to the ith
block in BCv . We also denote BCi+
v (BCi−
v ) as the partial
blockchain of BCv before (after) Bi
v. Each block contains
multiple transactions, and txj
i stands for the jth transaction
in Bi
v . Assume the latest block of BCv is Bk
v ; then v’ view
is defined as a tuple {seq, hash}v, where seq and hash are
respectively the sequence number and block hash of Bk
v . The
unspent transaction output (UTXO) model is adopted due to
its remarkable properties such as strong security and large
scalability [27]. We further assume that nodes are supported
by a public key infrastructure, and the cryptographic primitives
such as digital signature and hash function leveraged in our
design are secure so that no malicious entity can spoof the
involved messages. Except for the digital signature and hash
function, wChain is free from other complicated cryptography
primitives; therefore it can be implemented in any wireless
network that has elementary cryptography support. However,
wChain might not be applicable in certain wireless sensor
networks (WSNs) with prohibitively strict resource constraints
even though there do exist lightweight cryptography for
WSNs.
B. Network Model
We consider a multihop wireless ad hoc network with a set
V of N nodes deployed in a 2-dimensional geographic plane.
Let d(u, v) denote the Euclidean distance between nodes u and
v, DR(v) denote the disk centered at v with a radius R, and
NR(v) denote the set of nodes excluding v within DR(v). For
simplicity, we normalize the minimum distance between any
two nodes to be 1, and denote by Γ the ratio of the maximum
distance to the minimum distance between any two nodes.
Each node has a unique id and knows no advanced information
other than the network size N . The transmission power of each
node can be controlled for interference mitigation. Assume
nodes can crash at any time, which means that each node
is either functioning normally or completely stop working.
A node is regarded as faulty if it crashes in the current epoch or
does not have the latest view due to crash failures in previous
epochs. Without loss of generality, we assume N is odd. Our
protocol can tolerate at most f faulty nodes where f = �N
2 �.
C. Interference and SINR Model
We adopt the Signal-to-Interference-plus-Noise-Ratio
(SINR) model, which captures the wireless network
interference in a more realistic and precise way than a
graph-based one. A standard SINR model can be formulated
as follows, which states that a message sent by u is correctly
received by v if and only if
SINR(u, v) =
Pu · d(u, v)−α
N +
∑
w∈S\{u} Pw · d(w, v)−α
≥ β (1)
holds, where α ∈ (2, 6] is the path-loss exponent, threshold
β > 1 is determined by hardware, Pu·d(u, v)−α is the received
signal power of node v from u, N is the ambient noise, Pw ·
d(w, v)−α is the received signal power of node v from w,
S ⊆ V denotes the set of nodes transmitting simultaneously
with u. Besides, we assume that nodes can perform physical
carrier sensing.
D. Maximal Independent Set (MIS)
A set S ⊆ V is an independent set of V with respect to
distance r if for any pair of nodes u and v in S, d(u, v) > r;
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
6918 IEEE TRANSACTIONS ON WIRELESS COMMUNICATIONS, VOL. 20, NO. 10, OCTOBER 2021
Fig. 1. Spanner visualization.
and S is referred to as a maximal independent set if for any
node w /∈ S, there is a node x ∈ S such that d(w, x) ≤ r. MIS
has been widely researched in recent years, and there exist a
number of methods computing an MIS in a distributed manner.
In this paper, we adopt the approach presented in [28], which
computes a distributed MIS in optimal time O(log N) if the
nodes’ density is a constant.
E. Spanner Construction
A spanner is a network backbone possessing the following
properties: it only needs to maintain a small number of links,
and can balance well between efficiency and simplicity com-
pared to other topologies. Taking advantages of these features
we employ a spanner to facilitate the deployment of our data
aggregation algorithm in wChain . More specifically, we adopt
the distributed spanner construction algorithm presented in
[28], which can construct a sparse spanner, denoted as H ,
with a bounded maximum degree, in O(log N log Γ) slots with
a high probability. As illustrated in Fig. 1, the construction
process of H contains log Γ rounds; and in the ith round,
where i = 1, 2, · · · , log Γ, Vi contains the nodes in a maximal
independent set elected from Vi−1 by running a distributed
MIS algorithm with respect to ri = 2i; thereby Vlog Γ ⊆ · · · ⊆
V1 ⊆ V0 = V . One can see that the constructed H holds the
following properties:
• nodes in Vi constitute an MIS of Vi−1 with respect to ri;
• each node v ∈ Vi−1 \ Vi has a parent node u ∈ Vi and
d(v, u) ≤ ri;
• Vlog Γ contains only one node, i.e., the root.
For ease of explanation, nodes in V0 \ Vlog Γ and Vlog Γ
are referred to as followers and collector, respectively. In this
paper, we say that an event E occurs with high probability
(w.h.p.) if for any c ≥ 1, E occurs with probability at least
1 − 1/N c. A summary of all critical notations and their
meanings is presented in Table I.
IV. THE PROTOCOL
In this section, we first present the design objectives,
an overview on wChain and the involved utilities; then
TABLE I
SUMMARY OF NOTATIONS
we detail the data aggregation and reaggregation algorithms,
the two subroutines of our blockchain protocol; finally, we pro-
pose the three-phase fast fault-tolerant wChain protocol.
A. Design Objectives
The primary design objectives of wChain include full
decentralization, high efficiency, fault-tolerance, persistence
and liveness.
1) Full decentralization: wChain should be a distributed
protocol that does not rely on a centralized authority.
This also indicates that the protocol should be free from
any single point of failure.
2) High Efficiency: wChain has low communication com-
plexity, providing low latency and high throughput.
3) Fault-Tolerance: wChain should be robust enough to
counter against f = �N
2 � faulty nodes according to
the network model. Particularly, we should address the
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
XU et al.: wCHAIN: FAST FAULT-TOLERANT BLOCKCHAIN PROTOCOL FOR MULTIHOP WIRELESS NETWORKS 6919
tricky and challenging problem when nodes become
faulty within an epoch.
4) Persistence and Liveness: As a blockchain protocol,
wChain should satisfy persistence and liveness, which
are defined in the protocol analysis section.
B. Technical Overview and Utilities
1) Technical Overview: The wChain protocol is executed
in disjoint and consecutive time intervals called epochs, and
at each epoch, no more than one block can be generated.
Non-faulty nodes should append the new block to their local
blockchain so that they can jointly maintain a consistent global
view. Within each epoch, a spanner is first established as a
communication backbone, and the collector of the spanner
is appointed as the leader to take charge of wChain for the
entire epoch. However, if a crash failure occurs, a new spanner
should be constructed in a reaggregation procedure within the
same epoch. Under this circumstance, the collector might be
changed, but the leader holds the line. Data can be aggre-
gated from followers to the new collector who subsequently
sends the aggregated data to the leader to complete the data
aggregation process of the current epoch. wChain proceeds
by three phases, namely PREPARE, COMMIT, and DECIDE.
In the PREPARE phase, an incumbent leader aggregates view
messages from all followers to learn about the latest view.
If more than f followers respond with the same view as
that of the leader, the leader can aggregate transactions in
the COMMIT phase. Otherwise, the leader sends a message
to the followers to abandon the current epoch. The threshold
(f + 1) (including f followers plus one leader) is specifically
designated to satisfy the quorum intersection property which
implies that among the (f + 1) nodes, at least one node is
non-faulty and has the correct information. In the DECIDE
phase, the leader verifies the collected transactions, organizes
them into a new block, and then sends the new block together
with the view update information to the entire network,
by which the nodes can update their local blockchain to obtain
the latest view.
2) Utilities: Before delving into details of the wChain
protocol, we explain its commonly used utilities. First of all,
MSG(datav) is used the most often in wChain to generate
a single message m embodying a variable data field, which
might be a string, a transaction, or a block. For example,
the parameter datav can be viewv (view information), or txv
(transaction); it also indicates that the input data is signed by
v. Other than the data field, m also includes the timestamp,
kindred, and role fields for verification purpose. The
kindred is a tuple consisting of v’s identity idv and the
identity idp
v of v’s parent. The role field clarifies the role
(i.e., follower, collector, or leader) and the specific level
information such as V0 \ V1. A receiver recognizes m as
valid if m includes correct identity and role information.
Moreover, Mv is a message queue to hold multiple messages.
Duplicate messages in Mv, which can be identified based on
the timestamp information, should be discarded. A node v
can perform an add(Mv, Mu) operation to append Mu to its
local Mv. For block formation, we provide pack(Mv) to read
Algorithm 1 Utilities for node v
1 Function MSG(datav)
2 m.data← datav
3 m.timestamp← time
4 m.kindred← {idv, id
p
v}
5 m.role← {rolev, levelv}
6 return m
7 Function add(Mv, Mu)
8 return Mv ←Mv ∪Mu
9 Function pack(Mv)
10 for m ∈Mv do
11 if m.data is a valid transaction then
12 organize m.data into Bv
13 return Bv
14 Function append(BCv, Bu)
15 if Bu contains the hash of the Bk
v then
16 return BCv ← BCv + Bu
17 Function extract(BCv , Mview
v )
18 i← the (f + s)th highest seq searched in Mview
v
19 return BCi+
v
20 Function update(BCv, BCi+
u )
21 for j = 1 to |BCi+
u | do
22 if Bj
u /∈ BCv then
23 append(BCv, B
j
u)
24 return BCv
all messages from Mv and organize valid transactions into
a block. Besides, append(BCv, Bu) can append a block Bu
from node u to BCv only if Bu contains the hash of the
last block of BCv . In addition, extract(BCv , Mview
v ) intends
to extract a partial blockchain BCi+
v from BCv where i is
determined by the (f + s)th highest seq searched in Mview
v
and s is an adjustable constant to be determined later. For
node recovery, the update(BCv, BCi+
u ) function is designed
to help a node v update BCv by complementing missed blocks
from the received BCi+
u .
C. Data Aggregation and Reaggregation
In this subsection, we present two critical algorithms to
realize data aggregation and reaggregation. The objective of
data aggregation is to rapidly collect data from all followers to
the leader in O(log N log Γ) w.h.p. However, messages might
be lost due to crash failures. Therefore, we propose the data
reaggregation subroutine to remedy such a situation and ensure
that the leader can completely aggregate the data from all
non-faulty nodes within an epoch.
1) Broadcast-Oriented Communications: When block-
chains are to be implemented in a wireless network,
unicast and multicast are generally not needed. Instead,
we should exploit the broadcast nature of the wireless
medium. Decomposing a typical consensus process one can
see that there exist three major communication patterns,
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
6920 IEEE TRANSACTIONS ON WIRELESS COMMUNICATIONS, VOL. 20, NO. 10, OCTOBER 2021
Algorithm 2 DataAggregation(datav) Subroutine
1 Function DataAggregation(datav)
2 Initially, mv ← MSG(datav), Mv = {mv}
3 � In Ri(i = 1, 2, · · · , log Γ):
4 if v ∈ Vi−1 \ Vi then
5 for μ · log N slots do
6 send Mv with probability p = 1
σλ� and power
Pi = 2Nβrα
i
7 else
8 if v ∈ Vi then
9 for μ · log N slots do
10 listen on the channel
11 if receive a valid Mu then
12 Mv ← add(Mv, Mu)
namely one-to-many, many-to-one, and many-to-many,
that heavily employ broadcast and data aggregation,
the two communication primitives. Broadcast can improve
blockchain’s efficiency since a one-to-many communication
only costs a one-time broadcast to disseminate a node’s
message to all its peers within the communication range. For
many-to-many, the communication complexity is O(N2) for
a network of size N if using unicast and multicast. With
broadcast, the complexity can be reduced to O(N).
However, to reach a consensus, medium contention and
packet collision need to be carefully addressed in wireless net-
works. For this purpose we restrict the transmission probability
to be p and transmission power to be Pi, which are formally
described in Section IV-C (also see line 6 in Algorithm. 2).
2) Data Aggregation: Leveraging a spanner, we propose
the DataAggregation(datav) subroutine to aggregate the data
level by level. As shown in Algorithm 2, a node v executing
DataAggregation(datav) takes datav as input, generates a
message mv by MSG(data), and initializes Mv = {mv}. Then
data aggregation proceeds by log Γ rounds. We denote by Ri
the ith round. Recall that for i = 1, 2, · · · , log Γ, a node
v ∈ Vi−1 \ Vi has a parent node u ∈ Vi and d(v, u) ≤ ri.
As a consequence, Ri is responsible for aggregating the data
from Vi−1 \ Vi to Vi, and Rlog Γ is the final round when the
collector receives the data from Vlog Γ−1 \ Vlog Γ.
In a specific round Ri, the nodes in Vi−1 \ Vi constantly
send Mv for μ · log N slots with probability p = 1
σλ� , where
λ� = 25 (determined in Section V-A), μ and σ are sufficiently
large constants whose lower bounds are given in Section V-A.
Note that μ · log N is the optimal number of slots to ensure
that without crash failures, the data from all child nodes can be
completely aggregated to their parent w.h.p. The transmission
power is set to be Pi = 2Nβrα
i so that the transmission range
of each node is 21/αri, where ri = 2i. This transmission
range is slightly larger than ri such that for any child v, its
parent is within the unit disk centered at v with a radius ri.
This power control strategy improves child nodes’ ability to
resist interference outside the unit disk, thus contributing to
the success of the transmissions. Moreover, a node v ∈ Vi as
Algorithm 3 Reaggregation(datav) Subroutine
1 � as a leader
2 while true do
3 � slot one
4 broadcast Mdata
�
5 � slot two
6 listen on the channel
7 � slot three
8 if sense noise > N in slot two then
9 broadcast m� ← MSG(reaggregation�)
10 else
11 broadcast m� ← MSG(stop�) and break
12 � data reaggregation
13 wait for aggregated data from a collector
14 � as a follower
15 while true do
16 � slot one
17 listen on the channel
18 � slot two
19 if receive Mdata
� in slot one and datav /∈Mdata
� then
20 broadcast mv ← MSG(missv)
21 � slot three
22 listen on the channel
23 � data reaggregation
24 if receive reaggregation message in slot three then
25 run SpannerConstruction
26 run DataAggregation(datav)
27 else
28 break
a parent in Ri listens on the channel for μ · log N slots to
receive messages from its children. If v receives a Mu from
a child u, it appends Mu to Mv. The entire data aggregation
process can be finished in μ log N log Γ slots, and the data
from all non-faulty nodes can be aggregated w.h.p., which is
proved in Section V-A.
3) Reaggragation: The reaggregation subroutine has two
stages: a three-slot integrity check stage (lines 3-11, lines
16-22) and a data reaggregation stage (lines 12-13, lines
23-28). We define a broadcast operation (used in lines
4/9/11/20) as transmitting a message with P̂ = 2Nβrα
log Γ so
that a node listening on the channel can either receive a mes-
sage from the sender or sense noise exceeding N . Concretely,
the integrity check stage intends to examine whether the leader
loses any message from non-faulty nodes using physical carrier
sensing. In slot one, the leader l broadcasts its current Mdata
�
to the entire network, where Mdata
� is the message queue
embodying the messages whose type is data (e.g., Mview
�
is the message queue of the view messages). Upon receiving
Mdata
� , each node v examines if its datav is included in
Mdata
� . If not, v broadcasts mv ← MSG(missv) so that in slot
two the leader can get the notice saying that some messages
are missed by sensing noise greater than N , and broadcast
m� ← MSG(reaggregation�) in slot three to start the second
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
XU et al.: wCHAIN: FAST FAULT-TOLERANT BLOCKCHAIN PROTOCOL FOR MULTIHOP WIRELESS NETWORKS 6921
Algorithm 4 Fast Fault-Tolerant Blockchain Protocol
1 � PREPARE
2 � as a leader
3 broadcast m� ← MSG(view�)
4 listen on the channel for μ log N log Γ slots
5 execute Reaggregation(view�)
6 � as a follower
7 if receive viewu from a leader then
8 run DataAggregation(viewv)
9 else
10 abandon the current epoch
11 execute Reaggregation(viewv)
12 � COMMIT
13 � as a leader
14 if |{m ∈Mview
� |m.data = view�}| ≥ f + 1 then
15 broadcast m� ← MSG(correct�)
16 listen on the channel for μ log N log Γ slots
17 execute Reaggregation(txv)
18 � as a follower
19 if receive correct� from a leader then
20 run DataAggregation(txv)
21 else
22 abandon the current epoch
23 execute Reaggregation(txv)
24 � DECIDE
25 � as a leader
26 B� ← pack(M tx
� ), and BC� ← append(BC�, B�)
27 broadcast BCi+
� ← extract(BC�, M
view
� )
28 � as a follower
29 if receive BCi+
� from the leader then
30 update(BCv, BCi+
� )
31 else
32 abandon the current epoch
stage. In the data reaggregation stage, all nodes except the
leader run SpannerConstrcution to reconstruct a spanner free
from faulty nodes. The SpannerConstrcution procedure is the
same as the one we illustrate in Section III. The new spanner
does not include the leader and it elects a new collector who
is responsible for sending the aggregated data to the leader.
Afterwards, the nodes whose messages are missed in Mdata
�
run DataAggregation(datav). Only when no messages
from non-faulty nodes are missed can the leader broadcast
m� ← MSG(stop�) to end the reaggregation process.
D. Fast Fault-Tolerant Blockchain Protocol
wChain is a three-phase protocol that can achieve
consensus on the sequence of blocks and handle failures
caused by wireless node crashes. Concretely, wChain
leverages broadcast communications, data aggregation and
reaggregation, which are all specifically designed for wireless
networks. At each epoch, wChain proceeds by three phases,
namely PREPARE, COMMIT, and DECIDE. In the following,
we depict each phase to demonstrate how fast fault-tolerance
can be achieved in wChain .
Prepare. The PREPARE phase intends to help a leader
obtain a global view. Recall that when a spanner is constructed
for the first time, wChain appoints the collector as the
leader to take charge of the current epoch. As a leader, �
broadcasts m� ← MSG(view�) to the entire network. Each
follower v runs DataAggregation(viewv) upon receiving
the view information from � in the previous slot. Otherwise,
the follower abandons the current epoch. Note that all nodes
should execute the reaggregation subroutine to ensure that the
data from all non-faulty nodes are completely aggregated.
Commit. Denote by Mview
� the message queue of �
embodying its view information. The requirement of |{m ∈
Mview
� |m.data = view�}| ≥ f + 1 means that the leader
should successfully receive no less than f view messages that
have identical views as itself. That is also to say, at least
f + 1 nodes (f followers and one leader) have an identical
view. If such a requirement is satisfied, the leader can broad-
cast a correct message and listen on the channel to receive
transactions while the followers receiving a correct signal start
transaction aggregation. The reaggregation subroutine is still
executed to ensure the full aggregation of transactions.
Decide. When the leader � receives all transactions from
non-faulty nodes, it packs the transactions into a block B�, and
appends the B� to its local BC�. Then the leader � executes
extract(BC�, M
view
� ) to formulate a BCi+
� , which is used to
help recover at least s nodes that have crashed in previous
epochs and need to update their blockchains to become non-
faulty. Each non-faulty follower v updates BCv by running
update(BCv, BCi+
� ).
V. PROTOCOL ANALYSIS
In this section, we analyze the protocol in terms of effi-
ciency, persistence, and liveness.
A. Efficiency of Data Aggregation and Reaggregation
Theorem 1: The runtime of the data aggregation subroutine
is upper bounded by O(log N log Γ) slots w.h.p., and the
runtime of the reaggregation subroutine is upper bounded by
O(f log N log Γ) slots w.h.p.
Proof: We first present Lemma 1, which focuses on
one slot in a given round Ri.
Lemma 1: For a given slot in round Ri, if v ∈ Vi is a parent
node of some node in Vi−1, for any node u ∈ Vi−1 ∩Nri(v),
if u transmits, v can receive the message with a constant
probability.
Proof: For a given slot in round Ri, we denote
the aggregated transmission probability of Vi−1 ∩ Nri(v) by
Pi(v) =
∑
w∈Vi−1∩Nri
(v) pw. Let’s first prove that Pi(v) can
be bounded by 1
σ , where σ is a sufficiently large constant. Due
to the property of the maximum independent set, the disks
of radius ri/2 centered at any node w ∈ Vi−1 ∩ Nri(v)
are disjoint. We define density λ as the number of nodes in
Vi−1 ∩Nri(v), then the upper bound of density is
λ ≤ π[r1 + r0/2]2
π(r0/2)2
= 25, (2)
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
6922 IEEE TRANSACTIONS ON WIRELESS COMMUNICATIONS, VOL. 20, NO. 10, OCTOBER 2021
where λ = 25 when i = 1. Since for each w ∈ Vi−1∩Nri(v),
pw = 1
σλ� , we have Pi(v) = λ · 1
σλ� ≤ 1
σ , where λ� = 25.
Then we partition the whole space outside Dri(v) into rings
Rj for j ≥ 1, where Rj is the ring with a distance in the
range [jri, (j + 1)ri] from v. Denote by Sj the set of nodes
in Vi−1 that also fall into Rj . Considering the property of
maximum independent set, one can see that the disks of radius
ri/2 centered at the nodes in Rj are disjoint. Then we have
|Sj | ≤ π[(j + 1)ri + ri/2]2 − π[jri − ri/2]2
π(ri/2)2
≤ 24j. (3)
Let I(v, w) be the interference at v caused by w. Denote
by Iout the interference caused by the nodes outside Dri(v).
Then one can calculate Iout as follows:
Iout =
∞∑
j=1
∑
w∈Sj
I(v, w) =
∞∑
j=1
∑
w∈Sj
Pi
d(v, w)α
· p
≤
∞∑
j=1
|Sj | 1
σ
· 2Nβrα
i
(jri)α
≤ 24β(α− 1)
σ(α − 2)
·N ≤ N/2, (4)
where the last inequality holds when σ > 48β(α−1)
(α−2) . Consid-
ering the case when u is the only node that transmits in the
current slot, since u ∈ Vi−1 ∩Nri(v), d(v, u) ≤ ri, we have
SINR(v, u) =
Pi
d(v,u)α
N + Iout
≥
2Nβrα
i
rα
i
N + N/2
≥ β, (5)
which indicates that if u is the only node who transmits, v can
receive the message. Then we bound the probability that u is
the only transmitting node. Since Pi(v) ≤ 1
σ , the probability
that only u transmits at each slot is
pu
∏
w∈Vi∩Nri
(v)\u
(1− pw) ≥ pu
∏
w∈Vi∩Nri
(v)
(1− pw)
≥ pu
∏
w∈Vi∩Nri
(v)
e
−pw
1−p
= pe
−Pi(v)
1−p
≥ (σλ�)−1e
−λ�
σλ�−1
∈ Ω(1). (6)
This implies that with a constant probability, v can receive
u’s message. �
In Algorithm 2, each round consists of a fixed number of
μ · log N slots. At each slot, a child u ∈ Vi−1 \ Vi transmits
constantly with probability p = 1
σλ� . Lemma 1 indicates that
at each slot, u can succeed in sending a message to its parent v
with a constant probability denoted by p̂. Thus, by applying the
Chernoff bound (see Lemma. 2 in Sec. VIII-A), the probability
that u succeeds in sending a message to its parent after μ·log N
slots is 1 − (1 − p̂)μ log N ≥ 1 − e−p̂μ log N ≥ 1 − N−2 if
μ ≥ 2/p̂. Since the density of the active nodes is bounded by
λ� = 25, the probability that all children succeed is (1−N2)λ�
.
Next, assume that the nodes have synchronized clocks. Then
at each round Ri, the nodes in different independent sets
can send messages to their parents at the same time. The
probability that the data has been aggregated to all parent
nodes in Ri is at least (1 − N2)λ�Vi+1 ≥ (1 − N−1) since
λ�Vi+1 < N . Thus, the one-round data aggregation succeeds
in O(log N) w.h.p. Considering the (log Γ)-round aggregation
process, one can immediately derive that data aggregation
succeeds in O(log N log Γ) w.h.p.
Unlike a normal data aggregation, Algorithm 3 terminates
when the messages from all non-faulty nodes are received by
the collector without any loss. A message can be lost when
crash failure happens. The number of faulty nodes is bounded
by f , thus during the data reaggregation process, there are at
most f times of the execution of the spanner construction and
data aggregation, which gives the upper bound of the runtime
as O(f log N log Γ). �
B. Persistence and Liveness
In this subsection, we demonstrate how our protocol ensures
persistence and liveness properties whose definitions are
adapted from the rigorous ones proposed by Garay et al. [29].
Theorem 2: Persistence. If a non-faulty node v proclaims
a transaction txv in the position txj
i , other nodes, if queried,
should report the same result.
Proof: To prove the persistence property, we need to
show that for any two blockchains BCv and BCu of nodes v
and u, respectively, one cannot find two different transactions
txv ∈ BCv and txu ∈ BCu that are in the same position txj
i .
To prove by contradiction, we assume that such txv and txu
do exist, and there are two cases when the assumption can
hold.
C1: txv and txu are respectively appended to blockchains
BCv and BCu at the same epoch. This indicates that a leader
broadcasts two different blocks in the same epoch, which is
not permissible in wChain , thus contradicting our assumption.
C2: txv and txu are appended to their corresponding
blockchains BCv and BCu in two different epochs em and
en. Let txj
i also denote the transaction generated for the first
time in position txj
i and appended to the blockchains of at
least f + 1 nodes in ei. Since a leader cannot broadcast two
different blocks in the same epoch, the nodes who append txj
i
to their local blockchain in ei should have an identical view
of txj
i . Without loss of generality, assume i < m < n. Using
contradiction, we assume txv �= txj
i . Since i < m, v should
crash before em and recover in em so that txv is appended
to BCv when v updates its blockchain by applying update().
The leader who sends the update information in em has an
identical view with at least f nodes, which means that at least
f + 1 nodes have the same view on txj
i in em. Since there
are also at least f + s nodes who agree on txj
i in ei and the
network size N = 2f +1, we have a contradiction saying that
N > 2f + 1 + s > N . That is, one can only have txj
i = txv .
By applying the same proof, we can obtain txj
i = txu. Hence
txj
i = txv = txu, which contradicts the assumption that txv
and txu are different.
In a nutshell, all the nodes queried for a transaction in a
specific position should report the same result or report error
messages. �
Theorem 3: Liveness. If a non-faulty node generates a
transaction and contends to send it, wChain can add it
to the blockchains within T slots w.h.p., where the upper
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
XU et al.: wCHAIN: FAST FAULT-TOLERANT BLOCKCHAIN PROTOCOL FOR MULTIHOP WIRELESS NETWORKS 6923
Fig. 2. The performance of wChain vs. the network size N and Γ (under uniform, normal, and exponential distributions).
bound of T is O(log N log Γ) when crash failures happen
in a low frequency, and the worst-case upper bound of T is
O(f log N log Γ).
Proof: In a specific epoch, the best case for
wChain occurs when no crash failures happen for all
nodes throughout the epoch so that the leader executing
the Reaggregation(data�) subroutine can broadcast m� ←
MSG(stop�) without the need of waiting for the aggregated
data from a new collector. By Theorem 1, the view mes-
sages and the transactions can be fully aggregated within
O(log N log Γ) w.h.p. Besides, the DECIDE phase takes O(1)
slots. Hence the upper bound of T is O(log N log Γ). In a
normal case, failures happen in a low frequency ∈ O(1) so
that data aggregation can be executed in O(1) time during the
data reaggregation process, and the PREPARE and COMMIT
phases take O(log N log Γ) slots in total. Therefore, the upper
bound of T is still O(log N log Γ).
From the worst-case perspective, we assume that before
epoch ei, nodes are all non-faulty, and f nodes crash during
ei. If a leader crashes, the worst-case runtime of the current
epoch is still O(log N log Γ) when it crashes in the DECIDE
phase. If a follower v crashes, some data from v’s children
cannot be collected to the leader such that the leader must exe-
cute SpannerConstruction and DataAggregation(datav),
which take O(log N log Γ) slots. Thus the extra runtime
brought by a one-time crash failure is O(log N log Γ). If f
nodes crash, the total time spent on waiting for a successful
DECIDE phase is bounded by O(f log N log Γ). This gives the
normal and worst-case upper bound of T as O(log N log Γ)
and O(f log N log Γ), respectively. �
VI. SIMULATION RESULTS
In this section, we conduct simulation experiments to val-
idate the performance of wChain . The impacts of various
parameters are investigated, including the SINR model para-
meters, network size N , and Γ, the ratio of the maximum
distance to the minimum distance between nodes. If not stated
otherwise, we adopt the following parameter settings: α = 3,
β = 3, s = 100, λ� = 25,N = 1, Pi = 2Nβ2iα. The
frequency of node crashes is set to be 1%×N nodes per second
which corresponds to a moderate crash rate in real-world
settings. To evaluate the performance, we adopt two metrics,
namely epoch length and throughput. Epoch length specifies
the number of slots within an epoch; given that the unit slot
time for IEEE 802.11 is set to be 50μs, one can calculate
throughput as
Throughput =
The number of transactions
Epoch length× 50μs
, (7)
hence the unit of throughput is transactions per second (TPS).
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
6924 IEEE TRANSACTIONS ON WIRELESS COMMUNICATIONS, VOL. 20, NO. 10, OCTOBER 2021
Fig. 3. The performance of wChain with various α and β (under a uniform distribution).
The simulation program is written in C and all the exper-
iments are performed under a CentOS 7 operating system
running on a machine with an Intel Xeon 3.4 GHz CPU,
120 GB RAM, and 1 TB SATA Hard Drive. Over 20 runs
are carried out to get the average for each result.
A. Impacts of Network Size and Γ
Since liveness is mainly determined by N and Γ, we first
study the impacts of N and Γ on the performance of wChain .
We consider three types of distributions, namely uniform,
normal, and exponential. To investigate the impact of N ,
we adopt parameters α = 3, β = 3 for the SINR model, and
the plane is of size 150×150. The results are reported in Fig. 2.
One can observe from Fig. 2(a) that the epoch length
increases with N . With a uniform distribution and N = 5000,
it is 49364 slots (about 2.47s). Under normal and exponential
distributions, the nodes have larger epoch lengths since they
are denser in the center or the corner. They may suffer
from heavier contention and spend more time transmitting a
message. This result is consistent with our model assumption
which states that the network density should be limited.
Fig. 2(b) indicates that under uniform distributions wChain
has the highest throughput, which only increases with N .
When N = 5000, the throughput with uniform distributions
reaches 2546 TPS and is about 28% higher than that for normal
distributions. Under normal distributions, the throughput can
reach 1986 TPS when N = 5000. Note that that the throughput
under normal or exponential distributions has a small decrease
from N = 3000. This is because the density is so high in
some areas with a large number of nodes that contend heavily,
negatively affecting throughput.
Then we investigate the impact of Γ and set N = 2000.
In Fig. 2(c), with an increasing Γ, the epoch length increases
since the spanner has more levels. In Fig. 2(d), the epoch
lengths under normal and exponential distributions are still
larger than the one under uniform distributions, which is
caused by the same reason as that for the case in Fig. 2(a).
Concerning that the throughput is a function of Γ, our
protocol running under uniform distributions yields the largest
throughput. However, the throughput decreases with a larger Γ
because a larger Γ indicates that the spanner has more levels,
and the data aggregation process takes a longer time.
B. Impacts of the SINR Model Parameters
We perform four experiments to explore how the SINR
model parameters, namely α and β, impact the performance
of wChain . Assume that nodes are uniformly distributed in
the plane. We choose the combinations of α = 3, 4, 5 and
β = 2, 3, which are tested with different N and Γ in our
experiments. Such combinations are chosen due to the fact
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
XU et al.: wCHAIN: FAST FAULT-TOLERANT BLOCKCHAIN PROTOCOL FOR MULTIHOP WIRELESS NETWORKS 6925
that α = 3, 4, 5 can cover various environments, which was
demonstrated by Akpaida et al. [30]. In addition, simulations
with β = 2, 3 can cover a wide range of hardware since
common hardware is sensitive enough to have β close to 1
(the more sensitive the hardware, the smaller the β).
As shown in Fig. 3(a), the epoch lengths scale from about
1 × 104 to 4 × 104 slots with N under different settings
of α and β but they differ very little for different α and β
and the same N . In 3(b), even though we observe a small
throughput decrease when α = 3 and β = 3, the epoch
length and throughput are independent of the values of α and
β with different N . In Fig. 3(c) and 3(d), the epoch length
and throughput slightly change with different α and β. This is
because α, as the path-loss exponent, works closely with the
distance between nodes as well as Γ. The impacts of α and β
on throughput are in an allowable range so that one can claim
that the performance of wChain is insensitive to them.
VII. CONCLUSION AND FUTURE RESEARCH
In this paper, we propose a fast fault-tolerant blockchain
protocol, namely wChain , which can ensure a fast data aggre-
gation leveraging a spanner as the communication backbone.
The runtime upper bound of our protocol is O(log N log Γ)
when crash failures happen in a low frequency, and the
worst-case upper bound of wChain is O(f log N log Γ).
Besides, wChain tolerates at most f = �N
2 � faulty nodes
and is capable of handling node recovery while satisfying
persistence and liveness, the two crucial properties for a
blockchain protocol to function properly. Both theoretical
analysis and simulation studies are conducted to validate our
design. On the last point, one can see that we only grapple
with crash failures in this paper. Nevertheless, it would be
interesting to consider Byzantine fault-tolerance in wireless
networks; it is also worthy of investigating the impact of
mobility in ad hoc wireless networks.
VIII. APPENDIX
A. Chernoff Bound
Lemma 2: (Chernoff Bound). Given a set of independent
binary random variables X1, X2, · · · , Xn, let X =
∑n
1 Xi
and μ =
∑n
1 pi, where Xi = 1 with probability pi.
If E
[∏
i∈S Xi ≤
∏
i∈S qi
]
, where S ⊆ {0, 1, · · · , n}, then it
holds for any δ > 0 that
Pr[X ≥ (1 + δ)μ] ≤ e−
δ2μ
2(1+δ/3b) .
If E
[∏
i∈S Xi ≥
∏
i∈S qi
]
, where S ⊆ {0, 1, · · · , n}, then for
any δ ∈ (0, 1], we have
Pr[X ≤ (1− δ)μ] ≤ e−
δ2μ
2 .
REFERENCES
[1] J. Feng, F. R. Yu, Q. Pei, J. Du, and L. Zhu, “Joint optimization of radio
and computational resources allocation in blockchain-enabled mobile
edge computing systems,” IEEE Trans. Wireless Commun., vol. 19, no. 6,
pp. 4321–4334, Jun. 2020.
[2] Y. Dai, D. Xu, S. Maharjan, Z. Chen, Q. He, and Y. Zhang,
“Blockchain and deep reinforcement learning empowered intelligent
5G beyond,” IEEE Netw., vol. 33, no. 3, pp. 10–17, May 2019, doi:
10.1109/MNET.2019.1800376.
[3] N. Malik, P. Nanda, X. He, and R. P. Liu, “Vehicular networks with
security and trust management solutions: Proposed secured message
exchange via blockchain technology,” Wireless Netw., vol. 26, no. 6,
pp. 4207–4226, Aug. 2020, doi: 10.1007/s11276-020-02325-z.
[4] T.-H. Kim et al., “A novel trust evaluation process for secure localization
using a decentralized blockchain in wireless sensor networks,” IEEE
Access, vol. 7, pp. 184133–184144, 2019.
[5] M. Castro and B. Liskov, “Practical Byzantine fault tolerance,” in Proc.
OSDI, vol. 99. 1999, pp. 173–186.
[6] J. Kwon, Tendermint: Consensus Without Mining, document Draft V.
0.6, Fall, vol. 1, p. 11, 2014.
[7] M. Yin, D. Malkhi, M. K. Reiter, G. G. Gueta, and I. Abraham,
“HotStuff: BFT consensus with linearity and responsiveness,” in Proc.
ACM Symp. Princ. Distrib. Comput., Jul. 2019, pp. 347–356.
[8] V. Poirot, B. Al Nahas, and O. Landsiedel, “Paxos made wireless:
Consensus in the air,” in Proc. EWSN, 2019, pp. 1–12.
[9] F. Kuhn, N. Lynch, and C. Newport, “The abstract mac layer,” in
Proc. Int. Symp. Distrib. Comput. Cham, Switzerland: Springer, 2009,
pp. 48–62.
[10] D. Yu, Y. Zhang, Y. Huang, H. Jin, J. Yu, and Q.-S. Hua, “Exact imple-
mentation of abstract MAC layer via carrier sensing,” in Proc. IEEE
Conf. Comput. Commun. (IEEE INFOCOM), Apr. 2018, pp. 1196–1204.
[11] M. Liu, Y. Teng, F. R. Yu, V. C. M. Leung, and M. Song,
“A deep reinforcement learning-based transcoder selection framework
for blockchain-enabled wireless D2D transcoding,” IEEE Trans. Com-
mun., vol. 68, no. 6, pp. 3426–3439, Jun. 2020.
[12] O. Onireti, L. Zhang, and M. A. Imran, “On the viable area of wireless
practical Byzantine fault tolerance (PBFT) blockchain networks,” in
Proc. IEEE Global Commun. Conf. (GLOBECOM), Dec. 2019, pp. 1–6.
[13] Y. Ren, Y. Liu, S. Ji, A. K. Sangaiah, and J. Wang, “Incentive mechanism
of data storage based on blockchain for wireless sensor networks,”
Mobile Inf. Syst., vol. 2018, pp. 1–10, Aug. 2018.
[14] M. Liu, F. R. Yu, Y. Teng, V. C. M. Leung, and M. Song, “Joint computa-
tion offloading and content caching for wireless blockchain networks,” in
Proc. IEEE Conf. Comput. Commun. Workshops (INFOCOM WKSHPS),
Apr. 2018, pp. 517–522.
[15] Y. Sun, L. Zhang, G. Feng, B. Yang, B. Cao, and M. A. Imran,
“Blockchain-enabled wireless Internet of Things: Performance analysis
and optimal communication node deployment,” IEEE Internet Things J.,
vol. 6, no. 3, pp. 5791–5802, Jun. 2019.
[16] H. Moniz, N. F. Neves, and M. Correia, “Byzantine fault-tolerant
consensus in wireless ad hoc networks,” IEEE Trans. Mobile Comput.,
vol. 12, no. 12, pp. 2441–2454, Dec. 2013.
[17] C. Newport, “Consensus with an abstract MAC layer,” in Proc. ACM
Symp. Princ. Distrib. Comput. (PODC), 2014, pp. 66–75.
[18] C. Newport and P. Robinson, “Fault-tolerant consensus with an
abstract MAC layer,” 2018, arXiv:1810.02848. [Online]. Available:
http://arxiv.org/abs/1810.02848
[19] Q. Dong and D. Liu, “Resilient cluster leader election for wireless sensor
networks,” in Proc. 6th Annu. IEEE Commun. Soc. Conf. Sensor, Mesh
Ad Hoc Commun. Netw., Jun. 2009, pp. 1–9.
[20] S. Vasudevan, B. DeCleene, N. Immerman, J. Kurose, and D. Towsley,
“Leader election algorithms for wireless ad hoc networks,” in Proc.
DARPA Inf. Survivability Conf. Expo., vol. 1, 2003, pp. 261–272.
[21] V. Raychoudhury, J. Cao, and W. Wu, “Top K-leader election in wireless
ad hoc networks,” in Proc. 17th Int. Conf. Comput. Commun. Netw.,
Aug. 2008, pp. 1–6.
[22] G. Chockler, M. Demirbas, S. Gilbert, C. Newport, and T. Nolte,
“Consensus and collision detectors in wireless ad hoc networks,” in
Proc. 24th Annu. ACM SIGACT-SIGOPS Symp. Princ. Distrib. Comput.
(PODC), 2005, pp. 197–206.
[23] G. Scutari and S. Barbarossa, “Distributed consensus over wireless
sensor networks affected by multipath fading,” IEEE Trans. Signal
Process., vol. 56, no. 8, pp. 4100–4106, Aug. 2008.
[24] T. C. Aysal, A. D. Sarwate, and A. G. Dimakis, “Reaching consen-
sus in wireless networks with probabilistic broadcast,” in Proc. 47th
Annu. Allerton Conf. Commun., Control, Comput. (Allerton), Sep. 2009,
pp. 732–739.
[25] A. Richa, C. Scheideler, S. Schmid, and J. Zhang, “Self-stabilizing leader
election for single-hop wireless networks despite jamming,” in Proc.
12th ACM Int. Symp. Mobile Ad Hoc Netw. Comput. (MobiHoc), 2011,
pp. 1–10.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
http://dx.doi.org/10.1109/MNET.2019.1800376
http://dx.doi.org/10.1007/s11276-020-02325-z
6926 IEEE TRANSACTIONS ON WIRELESS COMMUNICATIONS, VOL. 20, NO. 10, OCTOBER 2021
[26] Z. Gołȩbiewski, M. Klonowski, M. Koza, and M. Kutyłowski, “Towards
fair leader election in wireless networks,” in Proc. Int. Conf. Ad-Hoc
Netw. Wireless. Cham, Switzerland: Springer, 2009, pp. 166–179.
[27] K. R. Özyılmaz, H. Patel, and A. Malik, “Split-scale: Scaling bitcoin
by partitioning the UTXO space,” 2018, arXiv:1809.08473. [Online].
Available: http://arxiv.org/abs/1809.08473
[28] D. Yu, L. Ning, Y. Zou, J. Yu, X. Cheng, and F. C. M. Lau, “Distributed
spanner construction with physical interference: Constant stretch and lin-
ear sparseness,” IEEE/ACM Trans. Netw., vol. 25, no. 4, pp. 2138–2151,
Aug. 2017.
[29] J. Garay, A. Kiayias, and N. Leonardos, “The bitcoin backbone protocol:
Analysis and applications,” in Proc. Annu. Int. Conf. Theory Appl.
Cryptograph. Techn. Cham, Switzerland: Springer, 2015, pp. 281–310.
[30] V. O. A. Akpaida, F. I. Anyasi, S. I. Uzairue, and A. I. Idim, “Determina-
tion of an outdoor path loss model and signal penetration level in some
selected modern residential and office apartments in Ogbomosho, Oyo
State, Nigeria,” J. Eng. Res. Rep., vol. 1, no. 2, pp. 1–25, May 2018.
Minghui Xu (Member, IEEE) received the B.S.
degree in physics and minored in computer science
from Beijing Normal University, Beijing, China,
in 2018, and the Ph.D. degree in computer science
from The George Washington University, Washing-
ton, DC, USA, in 2021. His current research focuses
on blockchain, distributed computing, and quantum
computing.
Chunchi Liu received the B.S. degree (Hons.) in
computer science from Beijing Normal University,
Beijing, China, in 2017, and the Ph.D. degree in
computer science from The George Washington
University, Washington, DC, USA, in 2020. His
current research focuses on blockchain, the Internet
of Things, security, and applied cryptography.
Yifei Zou (Member, IEEE) received the B.E. degree
from the Computer School, Wuhan University,
in 2016, and the Ph.D. degree from the Department
of Computer Science, The University of Hong Kong,
in 2020. He is currently an Assistant Professor
with the School of Computer Science and Tech-
nology, Shandong University. His research interests
include wireless networking, ad hoc networking, and
distributed computing.
Feng Zhao (Member, IEEE) received the B.S.
degree from the Guilin University of Electronic
Technology, Guilin, China, in 1997, and the Ph.D.
degree in communications and information systems
from Shandong University, Jinan, China, in 2007.
He is currently a Professor with the Guangxi Col-
leges and Universities Key Laboratory of Complex
System Optimization and Big Data Processing, Yulin
Normal University, Yulin, China. His research inter-
ests include cognitive radio networks, MIMO wire-
less communications, cooperative communications,
and smart antenna techniques.
Jiguo Yu (Senior Member, IEEE) received the
Ph.D. degree from the School of Mathematics, Shan-
dong University, in 2004. He became a Full Pro-
fessor with the School of Computer Science, Qufu
Normal University, Shandong, China, in 2007. He is
currently a Full Professor with the Qilu University of
Technology (Shandong Academy of Sciences). His
main research interests include privacy-aware com-
puting, wireless networking, distributed algorithms,
blockchain, and graph theory.
Xiuzhen Cheng (Fellow, IEEE) received the
M.S. and Ph.D. degrees in computer science from
University of Minnesota, Twin Cities, in 2000 and
2002, respectively. From 2002 to 2020, she was a
Faculty Member with the Department of Computer
Science, The George Washington University. She
is currently a Professor of computer science with
Shandong University, Qingdao, China. Her research
focuses on blockchain computing, security and pri-
vacy, and the Internet of Things.
Authorized licensed use limited to: CITY UNIV OF HONG KONG. Downloaded on April 15,2023 at 08:08:28 UTC from IEEE Xplore.  Restrictions apply. 
<<
  /ASCII85EncodePages false
  /AllowTransparency false
  /AutoPositionEPSFiles true
  /AutoRotatePages /None
  /Binding /Left
  /CalGrayProfile (Black & White)
  /CalRGBProfile (sRGB IEC61966-2.1)
  /CalCMYKProfile (U.S. Web Coated \050SWOP\051 v2)
  /sRGBProfile (sRGB IEC61966-2.1)
  /CannotEmbedFontPolicy /Warning
  /CompatibilityLevel 1.4
  /CompressObjects /Tags
  /CompressPages true
  /ConvertImagesToIndexed true
  /PassThroughJPEGImages true
  /CreateJobTicket false
  /DefaultRenderingIntent /Default
  /DetectBlends true
  /DetectCurves 0.0000
  /ColorConversionStrategy /LeaveColorUnchanged
  /DoThumbnails true
  /EmbedAllFonts true
  /EmbedOpenType false
  /ParseICCProfilesInComments true
  /EmbedJobOptions true
  /DSCReportingLevel 0
  /EmitDSCWarnings false
  /EndPage -1
  /ImageMemory 524288
  /LockDistillerParams true
  /MaxSubsetPct 100
  /Optimize true
  /OPM 0
  /ParseDSCComments false
  /ParseDSCCommentsForDocInfo true
  /PreserveCopyPage true
  /PreserveDICMYKValues true
  /PreserveEPSInfo true
  /PreserveFlatness true
  /PreserveHalftoneInfo true
  /PreserveOPIComments true
  /PreserveOverprintSettings true
  /StartPage 1
  /SubsetFonts true
  /TransferFunctionInfo /Remove
  /UCRandBGInfo /Preserve
  /UsePrologue false
  /ColorSettingsFile ()
  /AlwaysEmbed [ true
    /AdobeArabic-Bold
    /AdobeArabic-BoldItalic
    /AdobeArabic-Italic
    /AdobeArabic-Regular
    /AdobeHebrew-Bold
    /AdobeHebrew-BoldItalic
    /AdobeHebrew-Italic
    /AdobeHebrew-Regular
    /AdobeHeitiStd-Regular
    /AdobeMingStd-Light
    /AdobeMyungjoStd-Medium
    /AdobePiStd
    /AdobeSansMM
    /AdobeSerifMM
    /AdobeSongStd-Light
    /AdobeThai-Bold
    /AdobeThai-BoldItalic
    /AdobeThai-Italic
    /AdobeThai-Regular
    /ArborText
    /Arial-Black
    /Arial-BoldItalicMT
    /Arial-BoldMT
    /Arial-ItalicMT
    /ArialMT
    /BellGothicStd-Black
    /BellGothicStd-Bold
    /BellGothicStd-Light
    /ComicSansMS
    /ComicSansMS-Bold
    /Courier
    /Courier-Bold
    /Courier-BoldOblique
    /CourierNewPS-BoldItalicMT
    /CourierNewPS-BoldMT
    /CourierNewPS-ItalicMT
    /CourierNewPSMT
    /Courier-Oblique
    /CourierStd
    /CourierStd-Bold
    /CourierStd-BoldOblique
    /CourierStd-Oblique
    /EstrangeloEdessa
    /EuroSig
    /FranklinGothic-Medium
    /FranklinGothic-MediumItalic
    /Gautami
    /Georgia
    /Georgia-Bold
    /Georgia-BoldItalic
    /Georgia-Italic
    /Helvetica
    /Helvetica-Bold
    /Helvetica-BoldOblique
    /Helvetica-Oblique
    /Impact
    /KozGoPr6N-Medium
    /KozGoProVI-Medium
    /KozMinPr6N-Regular
    /KozMinProVI-Regular
    /Latha
    /LetterGothicStd
    /LetterGothicStd-Bold
    /LetterGothicStd-BoldSlanted
    /LetterGothicStd-Slanted
    /LucidaConsole
    /LucidaSans-Typewriter
    /LucidaSans-TypewriterBold
    /LucidaSansUnicode
    /Mangal-Regular
    /MicrosoftSansSerif
    /MinionPro-Bold
    /MinionPro-BoldIt
    /MinionPro-It
    /MinionPro-Regular
    /MinionPro-Semibold
    /MinionPro-SemiboldIt
    /MVBoli
    /MyriadPro-Black
    /MyriadPro-BlackIt
    /MyriadPro-Bold
    /MyriadPro-BoldIt
    /MyriadPro-It
    /MyriadPro-Light
    /MyriadPro-LightIt
    /MyriadPro-Regular
    /MyriadPro-Semibold
    /MyriadPro-SemiboldIt
    /PalatinoLinotype-Bold
    /PalatinoLinotype-BoldItalic
    /PalatinoLinotype-Italic
    /PalatinoLinotype-Roman
    /Raavi
    /Shruti
    /Sylfaen
    /Symbol
    /SymbolMT
    /Tahoma
    /Tahoma-Bold
    /Times-Bold
    /Times-BoldItalic
    /Times-Italic
    /TimesNewRomanPS-BoldItalicMT
    /TimesNewRomanPS-BoldMT
    /TimesNewRomanPS-ItalicMT
    /TimesNewRomanPSMT
    /Times-Roman
    /Trebuchet-BoldItalic
    /TrebuchetMS
    /TrebuchetMS-Bold
    /TrebuchetMS-Italic
    /Tunga-Regular
    /Verdana
    /Verdana-Bold
    /Verdana-BoldItalic
    /Verdana-Italic
    /Webdings
    /Wingdings-Regular
    /ZapfDingbats
    /ZWAdobeF
  ]
  /NeverEmbed [ true
  ]
  /AntiAliasColorImages false
  /CropColorImages true
  /ColorImageMinResolution 150
  /ColorImageMinResolutionPolicy /OK
  /DownsampleColorImages true
  /ColorImageDownsampleType /Bicubic
  /ColorImageResolution 600
  /ColorImageDepth -1
  /ColorImageMinDownsampleDepth 1
  /ColorImageDownsampleThreshold 1.50000
  /EncodeColorImages true
  /ColorImageFilter /DCTEncode
  /AutoFilterColorImages true
  /ColorImageAutoFilterStrategy /JPEG
  /ColorACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /ColorImageDict <<
    /QFactor 0.15
    /HSamples [1 1 1 1] /VSamples [1 1 1 1]
  >>
  /JPEG2000ColorACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000ColorImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasGrayImages false
  /CropGrayImages true
  /GrayImageMinResolution 150
  /GrayImageMinResolutionPolicy /OK
  /DownsampleGrayImages true
  /GrayImageDownsampleType /Bicubic
  /GrayImageResolution 600
  /GrayImageDepth -1
  /GrayImageMinDownsampleDepth 2
  /GrayImageDownsampleThreshold 1.50000
  /EncodeGrayImages true
  /GrayImageFilter /DCTEncode
  /AutoFilterGrayImages true
  /GrayImageAutoFilterStrategy /JPEG
  /GrayACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /GrayImageDict <<
    /QFactor 0.15
    /HSamples [1 1 1 1] /VSamples [1 1 1 1]
  >>
  /JPEG2000GrayACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000GrayImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasMonoImages false
  /CropMonoImages true
  /MonoImageMinResolution 300
  /MonoImageMinResolutionPolicy /OK
  /DownsampleMonoImages true
  /MonoImageDownsampleType /Bicubic
  /MonoImageResolution 900
  /MonoImageDepth -1
  /MonoImageDownsampleThreshold 1.33333
  /EncodeMonoImages true
  /MonoImageFilter /CCITTFaxEncode
  /MonoImageDict <<
    /K -1
  >>
  /AllowPSXObjects false
  /CheckCompliance [
    /None
  ]
  /PDFX1aCheck false
  /PDFX3Check false
  /PDFXCompliantPDFOnly false
  /PDFXNoTrimBoxError true
  /PDFXTrimBoxToMediaBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXSetBleedBoxToMediaBox true
  /PDFXBleedBoxToTrimBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXOutputIntentProfile (None)
  /PDFXOutputConditionIdentifier ()
  /PDFXOutputCondition ()
  /PDFXRegistryName ()
  /PDFXTrapped /Unknown
  /CreateJDFFile false
  /Description <<
    /ENU ()
  >>
>> setdistillerparams
<<
  /HWResolution [600 600]
  /PageSize [612.000 792.000]
>> setpagedevice