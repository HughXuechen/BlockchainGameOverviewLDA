Group Activity Matching with Blockchain Backed Credible Commitment
Group Activity Matching with Blockchain Backed Credible
Commitment
Tianyi Wu
School of Computer Science, Fudan
University
Shanghai, China
Shanghai Key Laboratory of Data
Science, Fudan University
Shanghai, China
Liwe Shen
School of Computer Science, Fudan
University
Shanghai, China
Shanghai Key Laboratory of Data
Science, Fudan University
Shanghai, China
Xin Peng
School of Computer Science, Fudan
University
Shanghai, China
Shanghai Key Laboratory of Data
Science, Fudan University
Shanghai, China
Biao Shen
School of Computer Science, Fudan
University
Shanghai, China
Shanghai Key Laboratory of Data
Science, Fudan University
Shanghai, China
Zhengjie Li
School of Computer Science, Fudan
University
Shanghai, China
Shanghai Key Laboratory of Data
Science, Fudan University
Shanghai, China
ABSTRACT
Humans are social creatures which enjoy participating in group
activities. Existing platforms such as event-based social networks
and social-matching applications empower people to organize and
participate in different kinds of interest-based activities. However,
credibility issues are inevitable since the participants’ commitment
to participate in activities on time can hardly be guaranteed. As
a result, many activities are canceled due to lack of participation,
which impairs people’s will for attending activities and increases
the difficulty of coalescing activity groups.
In this work, we propose an approach, called BC-GAM, formatch-
ing group activities with blockchain backed credible commitment.
Based on a formalization of the matching problem, BC-GAM works
as follows. During user requesting (for certain type of activity), the
user is required to pay a variable deposit which reflects his/her level
of commitment for participating in the activity. Our matching algo-
rithm then automatically coalesces the users according to the user
requests and availability of facilities. Our algorithm is designed to
maximally allow the enrolled users to participate in activities based
on their commitment. Furthermore, BC-GAM utilizes blockchain
techniques and smart contracts so that the user requesting, commit-
ment and participation are automatically executed in a distributed
and trusted way. We implemented BC-GAM on a hyperledger and
developed a user interface for requesting and inquiry of the activi-
ties. Based on the blockchain platform, we performed experiments
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
Internetware’20, May 12–14, 2021, Singapore, Singapore
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-8819-1/20/11. . . $15.00
https://doi.org/10.1145/3457913.3457923
with not only simulated data but also actual user studies. The ex-
periment results show that the matching algorithm is effective and
efficient, and BC-GAM can be potentially applied in practice.
CCS CONCEPTS
•Human-centered computing→ Ubiquitous and mobile comput-
ing systems and tools.
KEYWORDS
group activity matching, blockchain, credible commitment, smart
contract
ACM Reference Format:
Tianyi Wu, Liwe Shen, Xin Peng, Biao Shen, and Zhengjie Li. 2020. Group
Activity Matching with Blockchain Backed Credible Commitment. In 12th
Asia-Pacific Symposium on Internetware (Internetware’20), May 12–14, 2021,
Singapore, Singapore. ACM, New York, NY, USA, 10 pages. https://doi.org/
10.1145/3457913.3457923
1 INTRODUCTION
Humans live in a social society, and it is essential for humans to
interact with each other by participating in group activities. Interest-
based activity groups bring together individuals with shared inter-
ests. Such activities help the increasing of social vitality as well as
the growth of social capital [7, 28].
In recent years, platforms such as event-based social networks
(EBSNs [22]) and social-matching systems [24, 32] empower people
to organize and participate in different kinds of interest-based activ-
ities. Social-matching systems allow people to meet online [24, 32].
People-nearby applications, e.g., the special social matching mobile
app reported in [33], facilitate users to meet offline [19]. Further-
more, EBSNs such asMeetup1, Eventbrite2 and Douban3 gradually
become popular among people who are willing to be enrolled in
1
Meetup. https://meetup.com/
2
Eventbrite. https://www.eventbrite.com/
3
Douban. https://www.douban.com/location/world/
81
https://doi.org/10.1145/3457913.3457923
https://doi.org/10.1145/3457913.3457923
https://doi.org/10.1145/3457913.3457923
https://meetup.com/
https://www.eventbrite.com/
https://www.douban.com/location/world/
http://crossmark.crossref.org/dialog/?doi=10.1145%2F3457913.3457923&domain=pdf&date_stamp=2021-07-21
Internetware’20, May 12–14, 2021, Singapore, Singapore Tianyi and Liwei, et al.
activities. In general, EBSNs require an organizer to start a group,
plan an activity, and wait for participants to join. Interested users
communicate on the platform and agree on the time and place for
the activity. However, a likely scenario which may happen on the
day of the activity is as follows.
"Where are you, Danny?We are waiting for you. We cannot
start the game without you."
"I’m really sorry. I was delayed by other things, so I can’t
come."
"But you signed up for this activity and you promised you
will come. You screwed up this activity."
Such conversations happen frequently. As a result, the activity
often has to be carried out with fewer than expected participants
or even completely canceled. The problem reflects the credibility
issues that are inevitable in existing platforms for promoting group
activities. The fundamental issue is that there is hardly any guaran-
tee that the participants will commit to participate in activities on
time. Furthermore, the lack of credible commitment influences peo-
ple’s enthusiasm for attending future activities, and consequently
increases the difficulty of coalescing activity groups. Several empir-
ical studies have shown that users often hesitate to be group orga-
nizers due to the unknown returns on the effort to initiate groups,
i.e., uncertainty about the critical mass of people [27] interested in
the activities and whether they will attend in the end [29, 30, 36].
To address the problem, we propose an approach, called BC-
GAM, for matching group activities with blockchain backed cred-
ible commitment. Our approach aims to be the matchmaker for
users’ requests for group activities. Based on a formalization of
the matching problem, BC-GAM works as follows. First, a user
makes a request which indicates the user’s intention to participate
in a certain type of activity. During the requesting phase, a user
is required to put in a deposit as commitment. The amount of the
deposit reflects the user’s level of commitment for the activity, i.e.,
a higher deposit may constraint the user to prioritize participation
in the activity over other potential arrangement. The deposit can be
refunded if the user fulfills the commitment of participation. Given
a set of user requests and facilities, BC-GAM tries to synthesize a
set of events which aim to satisfy more committed users, i.e., to
maximize the probability that the users will eventually participate
in the events. In order to improve the computation efficiency, a
‘greedy’ matching algorithm is proposed to synthesize the events
which serve the user requests by their constraints on locations,
time and commitment. BC-GAM further introduces blockchain as
a credible infrastructure to record the commitment of users and to
achieve the credible execution of the events by applying smart con-
tracts. We implemented BC-GAM on a hyperledger and developed a
user interface for requesting and inquiry of the activities. Based on
the blockchain backed platform, we performed experiments on user
requests from simulated data and from actual user intentions. The
experiment results verify the acceptable effectiveness and efficiency
of the matching algorithm, and the potential application value of
the platform in practice.
The rest of the paper is organized as follows. Section 2 presents
the conceptmodel and the formalization. Section 3 details thematch-
ing algorithm. Section 4 describes the blockchain-based platform
including its architecture and the prototype. Section 5 evaluates BC-
GAM by conducting a series of empirical studies. Section 6 presents
the related work. Section 7 concludes the paper and discusses the
future work.
2 CONCEPT MODEL AND FORMALIZATION
In this section, we outline the concept model for group activity
matching, and then formalize the problem definition in the match-
ing scenario.
2.1 Concept Model
Figure 1 illustrates the model covering concepts involved in a group
activity matching scenario. For the sake of simplicity, we focus on
the matching towards a single activity type such as soccer, basket-
ball or hiking. User requests for different activity types are treated
separately and equally.
Figure 1: Concept Model of the Group Activity Matching
In the model, a user request represents the intention of a user
to participate in a specific activity. A user needs to specify in the
request the location of the desired activity and the time range (i.e.,
the start time and the end time) she can spend on the activity.
Besides, commitment is a key element assigned by a user. It is
used to quantify user’s confidence to attend the activity. In our
setting, the commitment which is concretized by deposit will be
refunded to the user if she actually participates in the activity,
otherwise it will be confiscated if the promise is violated. In our
setting, half of the the confiscated deposit is used as activity fund
to compensate for the people who actually attended the events.
The other half of the deposit is withdrawn by the matchmaking
platform as compensation for platform services.
A f acility provides venues and resources for a specific activ-
ity type, for example a soccer field or a basketball court. Facility
providers can specify the number range of participants who can
use a facility for performing an activity. Due to the diversity in size,
different facilities can stipulate different minimum and maximum
number of participants, e.g., 10 to 14 people for a small soccer field,
and 20 to 30 people for a regular filed. Furthermore, a facility has
the available time bucket (start time and end time for use), and can
be adjusted depending on the time schedule every day.
An event is introduced as an instance of an activity type. It serves
a set of user requests to satisfy their intention of participating in
an activity by utilizing a corresponding facility. In a group activity
82
Group Activity Matching with Blockchain Backed Credible Commitment Internetware’20, May 12–14, 2021, Singapore, Singapore
matching scenario including a set of user requests and a set of
facilities, a set of events are to be synthesized as the solution each
serves a subset of user requests by a specific facility.
By the concept model, we propose a special structure avoiding
the dependence between the two counterparts of user requests and
facilities. Different from the conventional group coalescing, the
users do not need to know what facilities are available to support
the activity, and the facilities do not need to be provided by con-
sidering the existing requests. This acts a fair and simple trading
market for both the supply and demand sides. Users only need
to express their intentions of participating in activities, while the
facility providers only need to offer facilities according to their
timetable. The decision whether an event can be performed and
whether a user request can be satisfied depends on the matching
which takes into account the time, location and users’ commitment.
2.2 Formalization
Let Act be a set of activity types, each of which is denoted as typea .
Let Facilities be a set of facilities (e.g., soccer fields and basketball
courts). Each facility is a tuple
f = (typef , locationf , startTimef , endTimef ,minf ,maxf )
where startTimef and endTimef are the available time range of
the facility, andminf andmaxf are the minimum and maximum
number of users anticipated for activities using the facility. A user
request is a tuple
r = (typer ,userr , locationr , startTimer , endTimer , commitmentr )
where 0 ≤ commitmentr ≤ 100 is the level of user’s commitment.
An event is a tuple
e = (typee , locatione , startTimee , endTimee ,mine ,maxe , serveListe )
which instantiates an activity with a specific time and a specific
facility. Therefore, it can inherit the attributes of a facility. Fur-
thermore, serveList is a set containing the user requests which are
satisfied by the event.
We define serve(e, r ) which means an event e can serve a user
request r if the following is satisfied.
• typer = typee ∧ locationr = locatione ∧ startTimer
≤ startTimee ∧ endTimee ≤ endTimer
We then say that event e serves a set of user request R, written
as e |= R, if and only if the following are satisfied.
• ∀r ∈ R. serve(e, r );
• ∀e ∈ E. | R |≥ mine∧ | R |≤ maxe ;
where | X | is the cardinality of a set X .
Given a set of Facilities and a set of user request R, we say that
the user requests are fully served if and only if there exists a set
of events E such that R can be partitioned into R1,R2, · · · ,Rk such
that
∃e1, e2, · · · , ek . e1 |= R1 ∧ e2 |= R2 ∧ · · · ∧ ek |= Rk
and for all Facilities , there is at most one event at any time. We say
that the user requests are partially served if and only if there exists
a proper subset R′ ⊂ R such that R′ is fully served.
Definition 2.1 (The Satisfiability Problem). Given a set of Facilities
and a set of user request R, the problem of satisfiability is thus to
check whether there exists a set of events E such that R are fully
served.
Definition 2.2 (The Synthesis Problem). Given a set of Facilities
and a set of user request R which are satisfiable, the synthesis
problem is to automatically synthesize a set of events E such that R
are fully served.
If however it is not possible to satisfy all the user requests, we
must turn the problem into an optimization problem so that certain
user requests are prioritized. Intuitively, the overall idea is to try
to “satisfy” more committed users. Note that the commitmentr for
each user request indicates how committed the user is to participate
in an event.
Given an event e , we can compute the likelihood of e taking
place based on the amount of commitment the users put in. Let
prob be a function which maps a commitment commitmentr (which
ranges from 1 to 100) to a probability.
prob(commitmentr ) = commitmentr /100
The probability of an event, written as prob(e), can be defined as
follows. LetRe be the set of requests served by e . Event e is cancelled
if and only if the number of users who participate in the event are
less than the minimum number of participates required for the
event. Let P be the set of P , and P be any subset of R such that
| P |≥ mine .
prob(e) = ΣP ∈P(Πr ∈P (prob(commitmentr )) ∗ Πr<P (1−
prob(commitmentr )))
Our problem can then be defined as follows.
Definition 2.3 (Problem Definition). Given a set of Facilities and
a set of user requests R, automatically synthesize a set of events E
to fully or partially serve R such that the overall expectation
expectation(E) = Σ | Re | ∗prob(e)
is maximum among all possible sets of events.
3 THE MATCHING ALGORITHM
Based on the definition of the matching problem, an algorithm
should be prepared to search and select the optimal events set with
the highest expectation in the whole search space composed of
the user requests and the facilities. However, as the search scale
grows (i.e., more user requests and more facilities), the complex-
ity of conventional search algorithms may increase dramatically,
resulting in reduced efficiency. In the field of searching, the Hungar-
ian Algorithm[21] or Ant Colony Algorithm[16][17] is proposed to
solve the optimization problems. Either of the algorithms is able to
solve the assignment problem in polynomial time. In our setting,
we pursue the maximal expectation with a latent requirement that
as many people as possible are matched successfully to partici-
pate in the event. Under the goal, a solution is hardly work out by
the Hungarian Algorithm or the Ant Colony Algorithm because
they are mostly applied for one-to-one assignment problem, thus
not suitable for one-to-many problem. Therefore, we propose a
‘greedy’ algorithm derived from Ant Colony Algorithm to compute
the events set in iterative steps. In each step, the algorithm follows
the local optimization goal to increase the number of user request
involved or to increase the probability of an event. Therefore, we
expect the algorithm to approximate to the global optimization
83
Internetware’20, May 12–14, 2021, Singapore, Singapore Tianyi and Liwei, et al.
while reducing the computational cost. The algorithm is detailed in
Algorithm 1. Note that it works for a specific activity type, therefore
all the involved ingredients are assumed to be type specific. Taking
a list of user requests (R) and a list of facilities (F ) as input, the
algorithm solves the problem as follows.
First, we initialize the output E from F by attaching serveListe
for each e ∈ E in line2. In addition, we sort R by the commitmentr
of each r ∈ R. Let Ra be the list of user requests that have not been
served by any event. We further filter E to preserve the events e
that have the chance to serve a set of user requests R′ ∈ R that
e |= R′ in line3, i.e., remove e from E that | serveListe |≤ mine .
The algorithm then considers whether each user request can be
served by an event in an iterative manner. In the loop from line5 to
line7, three subsets of E are first identified.
• Enec contains the events each requires r to meet the mini-
mum number of users, otherwise the event is canceled. For
example, there are three user requests (r1, r2, r3) and two pos-
sible events (e1, e2), and serve(e1, r1), serve(e2, r1), serve(e1,
r2), serve(e1, r3), i.e., r1 can be served by e1 and e2, but r2
and r3 can only be served by e1. In addition, the minimum
number of users for e1 (mine1 ) is 3. In this case, e1 belongs
to Enec when considering r1 because e1 will be canceled if
r1 relates to e2. Meanwhile, serveListe1 can be determined.
• E<min contains the events other than Enec each e of which
satisfies serve(e, r ) and the current number of served users of
e is less than the minimum requirement, i.e., | serveListe |<
mine .
• E≥min contains the events each e ofwhich satisfies serve(e, r )
and the current number of served users of each e is greater or
equal to the minimum requirement and the addition of r will
not exceed the maximum limit, i.e.,mine ≤| serveListe |≤
(maxe − 1).
Based on the three subsets of E, we follow different strategies to
decide the event that can serve r according to the local optimization
goal. We discuss the strategies separately.
• If Enec is not empty (line8− 9), we find e from this set which
can compute the highest probability using the function prob
defined in Section 2.2. The strategy can contribute to the
global optimization goal because more user requests can be
served. In addition, we choose the event with the highest
probability to increase expectation(E).
• If E<min is not empty and Enec is empty (line10 − 11), we
find e from E<min which has the maximal total commitment
amount put in by the served users. This strategy aims to
construct an event with the higher total commitment so that
expectation(E) can be increased.
• If only E≥min is not empty out of the three sets (line12 −
13), we find e from E≥min which can compute the highest
probability when putting r into serveListe . This strategy
contributes to increase the final expectation(E).
If e is found, we append r to serveListe , i.e., r can be served by
e (line16). Since the status of r has been determined, r is excluded
from Ra which maintains the user requests that have not been
served (line17). Subsequently, E can be filtered again by applying
the f ilterE function to remove the events that will be canceled
since the number of undecided user requests is decreased (line18).
Algorithm 1 Greedy Algorithm for Matching
Require: R (a list of user requests), F (a list of facilities)
Ensure: E (a list of events)
1: function matching(R, F )
2: E ← init(F ),R ← sortcommitment (R),Ra ← R
3: E ← f ilterE (E,R)
4: for each r ∈ R do
5: Enec ← f indNecessary(E, r )
6: E<min ← f indToMin(E, r )
7: E≥min ← f indReachMin(E, r )
8: if Enec is not null then
9: find e ∈ Enec ,where max(prob(e))
10: else if E<min is not null then
11: find e ∈ E<min ,where max(sum(commitmentr ))
12: else if E≥min is not null then
13: find e ∈ E≥min ,where max(prob(e))
14: end if
15: if e is not null then
16: serveListe .put(r )
17: Ra ← Ra \ r
18: E ← f ilterE (E,Ra )
19: end if
20: end for
21: return E
22: end function
Note that all the three subsets can be empty which means a
specific r cannot be served. Under this circumstance, we take no
action and skip to the next user request.
When all the user requests have been traversed, E is output as
the solution containing a set of events each serves a subset of user
requests.
Figure 2 shows an example for matching tennis events by ap-
plying the algorithm above. Four facilities (i.e., four tennis courts)
located in the same area are provided for events illustrated in the
right side of the figure. They are assigned with different time range
but the minimum and maximum number of users keep the same. A
list of eight user requests is shown in the left side. The expected
locations of the requests are the same with the facilities for sim-
plicity. Each user request differentiates with others in the time and
commitment.
By applying the algorithm, the event corresponding to f1 is
first excluded since the constraint about the minimum number
of users cannot be supported by the current user requests. The
algorithm finally results in three events serving two, two and three
users respectively. The results can reflect the different strategies
in the algorithm. First, e2 belongs to Enec when considering r2.
Therefore, r2 and r3 are appended into serveListe2 . Second, r6 can
be originally served by e3 and e4. When entering the round of
considering r6, e3 has reached its minimum number of anticipated
users (r4 and r5). Then r6 is appended into serveListe4 . Third, r8
can be originally served by e3 and e4 similarly. However, in its
round, both e3 and e4 have reached the minimum requirement. By
computing the probability, r8 is appended into serveListe3 .
84
Group Activity Matching with Blockchain Backed Credible Commitment Internetware’20, May 12–14, 2021, Singapore, Singapore
Figure 2: Matching Example for Tennis Activities
Figure 3: Matching Platform based on Blockchain
4 BLOCKCHAIN-BASED PLATFORM
This section presents the matching platform backed by blockchain.
The architecture of the platform is first introduced and then a
platform prototype including the backend blockchain and the user
interface is described.
4.1 Architecture of the Platform
We design the matching platform based on blockchain whose ar-
chitecture is illustrated in Figure 3. The figure shows the blockchain
network in the lower part which follows the structure ofHyperledдer
Fabric[15]. The upper part of the figure, on the other hand, shows
the internal structure of a peer node in Fabric .
Hyperledдer Fabric is a decentralized ledger project within
Hyperledдer [15] hosted by Linux Foundation. Fabric is an open
source block chain project with a permissons control modular[2].
So mutual distrusted parties can send transactions with each other
by using Fabric MSP[23]. Fabric is equiped with a pluggable con-
sensus protocol such as Byzantine fault-tolerant consensus[6]. The
consensus function is to keep all transactions recorded in a same
order and to reject some invalid transactions.
In a Fabric network, a peer node, presented by a hexagon, is the
fundamental ingredient. Each node hosts a leger (L in the figure) to
preserve transactions, and a set of smart contracts (S in the figure) to
implement business behavior. After endorsement and validation by
peer nodes, all the transactions are noted in the distributed ledgers.
A ledger is intrinsically known as a key-value database with all
transaction history andWorldState of the network. Furthermore,
a smart contract is an application of blockchain that trusted codes
run upon the network with transactions recorded by the ledger.
Smart contract defines business logic to generate new facts. Each
peer node will execute smart contract (chaincode in fabric) in order
to reach a consensus. It can implement the rules for any type of
business process when the smart contract code is executed[15][5].
Fabric SDK empowers users to send transactions to the network.
In our implementation, we choose the release 1.4 of Fabric along
with the same version of SDK.
In the peer level, the Fabric CA is used to provide users digital
certificates so that users can get access to the network. A ledger is
used to keep the transactions generated throughout the matching
process, including the user requests, the facilities and the computed
events. Besides them, we leverage smart contracts to support the
matching transactions. The smart contracts are divided into three
categories according to their usage stages and objects.
• Contracts for preparing user requests and facilities. These
contracts are executed before the matching. For example, the
QueryIn f o contract enables users to retrieve the status of
user request from reading the ledger. The Request contract
allows users to register their requests for activities. The pro-
cess of requesting is then turned to a transaction recorded
by the ledger. The data in the request, including the commit-
ment is credibly recorded as unchangeable history. Other
contracts including Cancel and Update can be invoked by
users to manage their request before it is served. Besides,
there is ProvideFac contract for facility providers to register
the available facilities for activities.
• Contract for matching. TheMatchinд contract is responsi-
ble for activating the matching process based on the algo-
rithm introduced in Section 3. In order to reduce the load of
blockchain contract execution, we design the execution of
the algorithm as a separate service which can be invoked by
the contract. Therefore, the matching contract serves as a
85
Internetware’20, May 12–14, 2021, Singapore, Singapore Tianyi and Liwei, et al.
bridge to transfer input data by reading user requests and
facilities from the ledger, and then to obtain and consistently
record the derived events. In addition, the smart contract is
responsible for transferring the user’s commitment to the
platform account, also recorded as a transaction.
• Contract for confirming. TheConf irm contract is used to re-
turn the commitment to a user when she actually participates
in the activity she committed. Otherwise, the commitment
will be confiscated (i.e., retained on the platform account) if
she violates the promise.
The treatment for the confiscated deposit is mentioned in chapter
2, wherewe assume that half of the confiscated deposit is withdrawn
by the blockchain platform. The smart contracts running on the
blockchain platform provide matchmaking services which require
massive computing power. Similar to the mechanism of Ethereum,
the confiscated deposit can be used as the gas of blockchain. The
gas is regarded as the cost for smart contract execution.
4.2 Platform Prototype
Wehave implemented a platform prototype composed of a blockchain-
based backend as well as a user interface.
The backend was built based on Fabric release 1.4. In the net-
work, we created three peer nodes deployed in Docker contain-
ers. An orderer node was deployed in another container, provid-
ing the ordering service for the network. In addition, we utilized
couchDB as the database for the ledger so that rich text query is
available when smart contract executes. The smart contracts were
programmed in Go language. Each contract is implemented by a
Go method which is called a chain code in Fabric . Table 1 lists the
methods for the smart contracts designed in Figure 3. In the method
signatures, stub is a parameter which provides the interface to op-
erate on the database. arдs can be another parameter responsible
for transferring scenario-related data. In addition, sc .Response is
the standard return value for all smart contracts.
Table 1: Go methods for Smart Contracts
Smart Contract Go Method
Request func createRequest(stub, args) sc.Response
Cancel func cancelRequest(stub, args) sc.Response
Update func updateRequest(stub, args) sc.Response
QueryInfo func queryAllRequest(stub) sc.Response
Matching func doMatching(stub, args) sc.Response
func updateRequestsUponMatchGroups(stub, args) sc.Response
Confirm func confirmRequest(stub, args) sc.Response
ProvideFac func createFacility(stub, args) sc.Response
All the smart contracts can be implemented by a single method
exceptMatchinд which is implemented by doMatchinд and update
RequestsUponMatchGroups . ThedoMatchinдmethod gets the user
requests as well as the facilities from the ledger and then invokes
the matching service. Once the doMatchinд method finishes, the
updateRequestsUponMatchGroups method is activated to update
the state of involved user requests.
The user interface we implemented can be seen in Figure 4.
It is embedded in a social application, and includes two main
pages which are Request Paдe (the first page in the figure) and
Request Status Paдe (the last three pages in the figure) respectively.
Once a user registers to the blockchain network, she can get access
to the pages.
In the Request Paдe , a user needs to fill in a form detailing her
intention for an activity. She can select the activity type, decide
a location, specify the date with the start time and end time, and
put in deposit by means of the token under her account. Note that
our platform will verify whether the user can afford the token by
querying the ledger. The platform currently limits the amount of
deposit between 1 and 100 tokens for each request. When decid-
ing the date of the anticipated activity, the interface will list the
number of existing requests group by hours. The user can complete
the requesting by clicking the Conf orm button. After then, she
can wait the notification of the matching decision or turn to the
Request Status Paдe .
In the Request Status Paдe , there are three tag pages called In −
Matchinд,Matched and Completed . The requests which have not
been matched are listed as separate cards in the In −Matchinд tag
page. Users can update or cancel the requests by clicking the option
menus. Once a request is matched, the card is removed from the
page. The subsequential upcoming event is then appended into
theMatched tag page also shown in card style. Furthermore, there
are two option menus at the bottom of each upcoming event card,
i.e., I Attended and I Missed . They are used to notify the backend
blockchain whether the user has attended the event or violated
her promise. Note that this is so far a simplified design that relies
primarily on human integrity in the platform prototype. Advanced
techniques can be applied to automatically check the users’ status in
the future. TheCompleted tag page lists the history of the requests
that have been attended or missed.
5 EVALUATION
To evaluate BC-GAM, we conducted an experimental study and a
user study to answer the following three research questions:
• RQ1(Effectiveness and Efficiency): How is the effective-
ness and the efficiency of the greedy algorithm compared
with a search algorithm when coping with different scales
of matching scenarios?
• RQ2(Scalability): Can the greedy algorithm scale well with
the increasing of the user requests and the facilities?
• RQ3(Usability): Can the commitment motivates users to
participate in the events rather than violating their promise?
How do the users think of the matching platform as well as
the commitment mechanism?
5.1 RQ1: Effectiveness and Efficiency
To evaluate the effectiveness and the efficiency of the greedy algo-
rithm, we conducted an experimental study which compared the
algorithm with a backtracking algorithm in terms of the overall
expectation (defined in 2.2) and the execution time.
A backtracking algorithm is a kind of searching algorithm which
constructs the solutions in the search space and selects the one
conforming to the optimal goal. We implemented such an algorithm
in which the solution is composed of a set of fri . Each fri represents
the facility serving the ith user request in the list. if fri equals to
fr j , we say the two requests i and j locate in the same event group.
Furthermore, if a user request rk cannot be served by any available
86
Group Activity Matching with Blockchain Backed Credible Commitment Internetware’20, May 12–14, 2021, Singapore, Singapore
Figure 4: User Interface of the Platform Prototype
facility, frk is not included in the solution. Based on the definition of
the solution, the backtracking algorithm constructs all the possible
combinations of the requests and facilities taking into account the
constraints between the two parts, computes the overall expectation
of every solution, and selects the one with the highest expectation
as the optimal solution.
The experimental study compares the two algorithms in match-
ing scenarios with different scales of user requests. Given three
facilities with their specific setting on the range of time and allowed
users (i.e., 8 to 10 users), we simulated the user requests according
to the following heuristics.
• The activity type and the location of the user requests and
the facilities are assumed to be same.
• Each user request can be randomly served by at least one
facility, i.e., the time range of the user request is randomly
specified but needs to cover at least one facility so that the
requests cannot be served are pre-removed.
• The commitment amount of each user request is randomly
assigned between 1 to 100.
We planned the experiment on four levels of scales that involved
20, 30, 40 and 50 user requests respectively. On each scale level, we
randomly generated twenty sets of simulated requests. The greedy
algorithm (noted as GA) and the backtracking search algorithm
(noted as BSA) were executed towards each set of data and the aver-
age was subsequently computed. The experiments were conducted
in Windows 10 on a machine with a Intel(R) Core(TM) i5-7200U,
running with a dual core 2.50GHz CPU and 8 GB RAM.
Figure 5 shows the comparison on the execution time (left part)
and the expectation(right part). From the effectiveness perspective,
it can be seen that the overall expectation increases when the user
requests increase for both GA and BSA. Although BSA can compute
the optimal solution with the highest expectation, GA is basically
close to BSA. From the efficiency perspective, GA’s average execu-
tion time can always be kept within one millisecond along with
the increasing of user requests. On the contrary, the average execu-
tion time of BSA increases dramatically due to the rapidly growing
search space. The results shows the greedy algorithm performs
Figure 5: Comparison of the Effectiveness and Efficiency
better than the search algorithm especially when the scale of the
matching scenario becomes larger.
5.2 RQ2: Scalability
We evaluate the scalability of the greedy algorithm by analyzing
its execution time with different numbers of user requests and
facilities. We set up two group experiments with different control
variables. One group experiment increases the number of user
requests from 100 to 10,000 with unit of one hundred in a fixed 1,000
facilities. Another group experiment, on the contrary, increases the
number of facilities from 10 to 1,000 with unit of ten in a fixed
10,000 user requests. The rules for generating the random data
refer to the previous subsection. At each scale, we executed the
greedy algorithm for ten times and computed the average execution
time in millisecond. The experiments were conducted on the same
environment as that in RQ1.
The results are shown in Figure 6. The left chart shows the result
of the former group experiment. Y axis of the chart represents the
execution time in millisecond while the value after multiplying 100
in X axis is the number of the user requests. Totally, the overall
trend of the execution time of the greedy algorithm increases as
the number of requests increases. There exist sharp fluctuations
on the curve due to the random nature of the request attributes
at each scale. Considering the constraints of facilities, different
87
Internetware’20, May 12–14, 2021, Singapore, Singapore Tianyi and Liwei, et al.
Figure 6: Evaluation of Scalability with Number of Requests
and Facilities in Different Scale
user requests will affect the permutations complexity which is
related with the solution space. Therefore, randomly generated
user requests of different sizes may affect the execution time in a
random manner.
The right chart shows the result of the latter group experiment.
X axis is the number of facilities while Y axis is the execution time
in millisecond. From the chart, we can get a similar conclusion
that the execution time increases with the number of facilities
going up. However, there still exists difference. For example, at the
beginning, the execution time increases slowly. The reason is that if
the number of requests is pretty larger than the number of facilities,
the algorithm will terminate early because the available events are
few and will be run out rapidly. After the number of facilities comes
to a larger scale, the execution time will increase faster.
To sum up, the results show that the greedy algorithm has a
quite acceptable scalability, generally under 200 seconds in any
scale. Even if we take into account the exceptions, the worst exe-
cution time is 400 seconds and it is acceptable for the infrequently
matching tasks.
5.3 RQ3: Usability
We conducted a user study to evaluate the usability of BC-GAM and
the platform prototype. The study was performed by inviting users
to request for different kinds of activities and then by observing
whether they attended the events if they had been matched. We
invited 42 students from the school of computer science and guided
them how to use the platform. The platform was deployed in the
campus network that could be accessed by the users. Seven daily
popular activities including Soccer, Lunch/Dinner were preset in
the platform. In addition, we preset a series of available facilities
according to the actual situation of the campus. For example, a
soccer field was converted into a group of facilities with different
time range in order to serve more users. In particular, the activity
types such as Lunch/Dinner generally do not need facility support.
We then assumed that such activities depended on virtual facilities,
e.g., enough dining tables.
We set the platform to assign 1,000 tokens to the initial user by
default once the user registered. 1,000 tokens equals to 15USD in
the real world. In order to encourage the users to request for events,
we also published the reward mechanism as well as the punishment
mechanism, i.e., when a user request had been matched, she could
receive a cash reward (1.5USD) equivalent to the deposit (100 tokens)
put in if she actually attended the event, otherwise she would be
fined the same amount of cash (1.5USD).
The experiment planned to support the group activity matching
for three days. Therefore the users were encouraged to propose
their requests for anticipated activities in the next three days. The
backend matching platform was set to work three times per day, at
10:00, 15:00 and 20:00.
5.3.1 Overall Statistic Results. Table 2 shows the group activity
matching results in the three days of the experiment. Each line
lists the relevant statistics for a specific activity type. The sta-
tistics columns represent respectively the number of the user re-
quests (NR), the number of the matched events (NE), the number
of the user requests which were not matched (UM), the number of
the users actually attending events (NP ), the mean deposit of NP
(PDmean ), the maximum deposit of NP (PDmax ), the minimum
deposit of NP (PDmin ), the number of the users violating com-
mitment (NV ), the mean deposit of NV (VDmean ), the maximum
deposit of NV (VDmax ), and the minimum deposit of NV (VDmin ).
We can see from the table that five out of the seven activity
types have events matched. Among them, Lunch/Dinner is themost
popular. It is reasonable that this type of activity could best cater
to the actual needs of users. The remaining two activities types
(Badminton and Basketball) were unable to form events due to
insufficient requests. Furthermore, four activity types contains the
cases of violating commitment except Pinд Ponд. By comparison,
deposit of users who actually participate in events (PDmean ) is
generally at a higher level, which means the users put in high
deposit were more inclined to keep their commitment. On the
contrary, deposit of users who violate the promise (VDmean ) is
generally lower exceptOutinдToдether , indicating that these users
would still have a higher probability of not attending events. On
the other hand, there exist user requests that cannot be matched
mainly due to the limitation of the number boundary.
5.3.2 User Feedback. We analyzed the user feedback by a ques-
tionnaire and interviews. The questionnaire is composed of four
questions. The first two are scoring questions, inquiring users their
satisfaction with the matchmaking platform, and their intention to
use the platform for future activities. Users are required to respond
to the five-point scale from 1 to 5, representing ”strongly disagree”,
”disagree”, ”neutral”, ”agree” and ”strongly agree” respectively. The
last two questions are subjective questions inquring the factors
considered when setting the deposit, and the effect of the platform
on participating in group activities. Face-to-face interviews with
selected users were followed by the questionnaire. The interviews
aims to obtain detailed comments and suggestions from users on
the matchmaking platform.
From the questionnaire results, about 80% of users gave 4 or 5
(average score is 4.1) on their satisfaction on the platform, which
means they are basically satisfied with the matching results. About
three-quarters of users also gave 4 or 5 (average score is 4.0) on their
willingness to continue to use the platform for their future activity
planning. On the other hand, most of the users determine their
amount of deposit depending on their own willing and schedule.
If they are interested in some activities, they will put in appro-
priate deposit to make themselves credible enough but avoiding
undertaking big loss. Among them, some of the users are glad to
find partners who have common interests as the statements in the
88
Group Activity Matching with Blockchain Backed Credible Commitment Internetware’20, May 12–14, 2021, Singapore, Singapore
Table 2: Statistics of User Study
AType UR NE UM
Users Actually Attended Users Violating Commitment
NP MeanD MaxD MinD NNP MeanD MaxD MinD
Soccer 13 1 3 8 91.25 100 50 2 30 50 10
Badminton 1 0 1 0 - - - 0 - - -
Basketball 2 0 2 0 - - - 0 - - -
Board Game 7 1 1 5 100 100 100 1 10 10 10
Launch/Dinner 81 24 7 66 91.12 100 10 8 61.67 100 10
Outing Together 14 4 2 10 100 100 100 2 100 100 100
Ping Pong 6 3 0 6 96.67 100 80 0 - - -
Total 124 33 16 95 - - - 13 - - -
questionnaire. The said "we can make new friends and expand our
social networks".
From the interviews, group activity matching is generally ac-
cepted by users and they think it has positive impacts on their lives.
One user noted, "Quite satisfied. Relatively novel and inexplicable
matches make life full of unknown pleasures." With the constraint
of the deposit, some users keep their commitment in mind, which
is reasonable that money is regarded as an important fact by them.
In addition, some users think the mechanism of deposit can help
them to schedule their daily life with an event that should be at-
tended. One of the users said, "If you will definitely go, just bet
as much as you like. If it is possible to be absent, bet less. For the
matching request made by others, when it is not easy to refuse,
set deposit very few. The deposit indicates the intense willingness
of the participation of the activity and the possibility." Some users
find they can easily be enrolled in activities rather than organizing
activities which may be time-consuming. It further motivates them
to actively participate in the future social activities.
Besides, some problems and suggestions are proposed. Some
users may have negative opinions that they are not willing to at-
tend events with unfamiliar persons, or with different persons for
each matching. It is a common idea in a small social circle composed
of acquaintances. In addition, some users complain the unclear and
not timely notification due to the imperfections of the prototype.
More users expect the platform to expose in the user interface more
information including the distribution of the deposit from exist-
ing requests in order to assist them to decide the suitable deposit
or to promote the events by paying higher deposit. Furthermore,
they also expect the platform to provide interfaces to propose new
activities types.
6 RELATEDWORK
Credibility (or the close related term Trust) in Social Networks
has been focused over the past many years [1][31]. The research
work in this field emphasized the credibility assessment towards
the users and the generated content as the issue of trusting users
and their content is rooted in credibility for social network visitors
[34]. Interest-based group activity usually gathers people offline
through online group coalescing utilizing social websites or appli-
cations. The absence of participants may influence the success of an
activity. We claim the credibility in this situation as the confidence
on whether the participants will attend activities. However, as far
as we know, there is no work yet focusing on this type of credibility.
Given a set of users and a set of activities, how to assign users to
activities is highlighted in several research work. Around the Group
Activity Selection Problem (GASP), a series of work [13][8][20][12]
models situations where a group of agents are to be assigned to ac-
tivities by taking into account the agents’ preferences on activities
and the number of participants. The goal of these work is to find the
stable activity assignment that can maximize the overall satisfac-
tion from the standard situation[13][8], to the simplified situation
taking the bounds of groups[20], and to the problem on a social
network [12]. Darmann et al. proposed that agents have prefer-
ences over the number of participants of the activity[10][14][9][11].
Ganian et al. focused on the number of types of agents to estab-
lish the complexity map for GASP, sGASP and gGASP[18]. Bilò
et al. consider that every agent has a separate valuation for each
activity based on generalized GASP[4]. There are other work con-
centrating on recommending activities to users based on contextual
information. For example, Badami et al. proposed a framework to
recommend relevant events to social media users with different pref-
erences by means of feature engineering, storytelling and modeling
[3]. Ogundele et al. introduced EventRec to generate personalized
event recommendations based on the geographical, social and tem-
poral influences of events on users [25]. They further proposed
a personalized event recommendation framework called SoCaST
taking into account users’ different degrees of importance to dif-
ferent influences [26]. Different from the above work, we design a
new situation that users have specified their intentions for specific
activity types. The problem turns into how we can maximize the
probability that users will eventually participate in events. In addi-
tion, the information we depend on mainly focuses on the location,
time range and the commitment users put in.
Event-based social networks (EBSNs) provide users the oppor-
tunity to search and join in group activities. However, users some-
times hesitate to become the group organizers mainly due to the
unknown returns on the effort to initiate groups, hindering the for-
mation of emerging activity groups especially in small communities
[30]. Empirical studies have pointed out the reasons on the uncer-
tainty about the critical mass of people who are interested in the
activities [30][29]. Researchers therefore designed awareness-of-
others user interface helping to establish user confidence to coalesce
groups of available individuals with same interests [36][35]. Our
work also focuses on the group coalescing towards a specific ac-
tivity type supported by facilities. The difference is that we do not
need to initiate a group for activities. The users can be coalesced
89
Internetware’20, May 12–14, 2021, Singapore, Singapore Tianyi and Liwei, et al.
in an event especially considering the commitment they put in to
express their confidence in attending activities.
7 CONCLUSION
In this paper, we propose an approach for group activities matching
based on blockchain backed credible commitment, which is called
BC-GAM. With the approach a user can make a commitment of
group activity participation by paying deposit. The deposit con-
cretizes the commitment and can be refunded if the user fulfills
the commitment of participation. Given a set of group activity par-
ticipation commitments BC-GAM uses an optimization method to
match the participation requests into planned events based on a
list of facilities available. To ensure the credibility of participation
commitments, we design a blockchain based platform to perform
credible commitments using smart contracts and develop an imple-
mentation of the platform using hyperledger. We conduct a series of
empirical studies to evaluate the effectiveness, efficiency, scalability,
and usability of BC-GAM in group activity matching. The results
show that BC-GAM can significantly improve the credibility of
participation commitments and the success rate of group activities.
Our future work will further improve the usability of BC-GAM and
explore its application in more scenarios such as crowdsourcing.
ACKNOWLEDGMENTS
This work was supported by the National Key Research and De-
velopment Program under the grant number 2018YFB1004803, the
Shanghai Science and Technology Development Funds under the
grant number 18DZ1112100 and 18DZ1112102.
REFERENCES
[1] Majed Alrubaian, Muhammad Al-Qurishi, Atif Alamri, Mabrook Al-Rakhami,
Mohammad Mehedi Hassan, and Giancarlo Fortino. 2019. Credibility in Online
Social Networks: A Survey. IEEE Access 7 (2019), 2828–2855.
[2] Elli Androulaki, Artem Barger, Vita Bortnikov, Christian Cachin, Konstantinos
Christidis, Angelo De Caro, David Michael Enyeart, Christopher Ferris, Gennady
Laventman, Yacov Manevich, et al. 2018. Hyperledger fabric: a distributed op-
erating system for permissioned blockchains. european conference on computer
systems (2018), 30.
[3] Mahsa Badami, Faezeh Tafazzoli, and Olfa Nasraoui. 2018. A case study for
intelligent event recommendation. International Journal of Data Science and
Analytics 5, 4 (2018), 249–268.
[4] Vittorio Bilò, Angelo Fanelli, Michele Flammini, Gianpiero Monaco, and Luca
Moscardelli. 2019. Optimality and Nash stability in additively separable general-
ized group activity selection problems. In Proceedings of the 28th International
Joint Conference on Artificial Intelligence. AAAI Press, 102–108.
[5] Christian Cachin. 2016. Architecture of the hyperledger blockchain fabric. In
Workshop on distributed cryptocurrencies and consensus ledgers, Vol. 310.
[6] Christian Cachin and Marko Vukolic. 2017. Blockchains Consensus Protocols in
the Wild. (2017).
[7] James S Coleman. 1966. Foundations for a theory of collective decisions. Amer. J.
Sociology 71, 6 (1966), 615–627.
[8] Andreas Darmann. 2015. Group activity selection from ordinal preferences. In
International Conference on Algorithmic DecisionTheory. Springer, 35–51.
[9] Andreas Darmann. 2018. A social choice approach to ordinal group activity
selection. Mathematical Social Sciences 93 (2018), 57–66.
[10] Andreas Darmann. 2018. Stable and Pareto optimal group activity selection
from ordinal preferences. International Journal of Game Theory 47, 4 (2018),
1183–1209.
[11] Andreas Darmann. 2019. Manipulability in a group activity selection problem.
Social Choice and Welfare 52, 3 (2019), 527–557.
[12] Andreas Darmann, Janosch Döcker, Britta Dorn, Jérôme Lang, and Sebastian
Schneckenburger. 2017. On simplified group activity selection. In International
Conference on Algorithmic DecisionTheory. Springer, 255–269.
[13] Andreas Darmann, Edith Elkind, Sascha Kurz, Jérôme Lang, Joachim Schauer,
and Gerhard Woeginger. 2012. Group activity selection problem. In International
Workshop on Internet and Network Economics. Springer, 156–169.
[14] Andreas Darmann, Edith Elkind, Sascha Kurz, Jérôme Lang, Joachim Schauer,
and Gerhard Woeginger. 2018. Group activity selection problem with approval
preferences. International Journal of Game Theory 47, 3 (2018), 767–796.
[15] Vikram Dhillon, David Metcalf, and Max Hooper. 2017. The Hyperledger Project.
(2017).
[16] Marco Dorigo, Mauro Birattari, and Thomas Stützle. 2006. Ant colony optimiza-
tion. IEEE Comput. Intell. Mag. 1, 4 (2006), 28–39. https://doi.org/10.1109/MCI.
2006.329691
[17] Marco Dorigo, Vittorio Maniezzo, and Alberto Colorni. 1996. Ant system: opti-
mization by a colony of cooperating agents. IEEE Trans. Syst. Man Cybern. Part B
26, 1 (1996), 29–41. https://doi.org/10.1109/3477.484436
[18] Robert Ganian, Sebastian Ordyniak, and C. S. Rahul. 2019. Group Activity
Selection with Few Agent Types. In 27th Annual European Symposium on Al-
gorithms (ESA 2019) (Leibniz International Proceedings in Informatics (LIPIcs),
Vol. 144), Michael A. Bender, Ola Svensson, and Grzegorz Herman (Eds.). Schloss
Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany, 48:1–48:16.
https://doi.org/10.4230/LIPIcs.ESA.2019.48
[19] Joey Chiao-Yin Hsiao and Tawanna R Dillahunt. 2017. People-nearby applica-
tions: How newcomers move their relationships offline and develop social and
cultural capital. In Proceedings of the 2017 ACM Conference on Computer Supported
Cooperative Work and Social Computing. ACM, 26–40.
[20] Ayumi Igarashi, Dominik Peters, and Edith Elkind. 2017. Group activity selection
on social networks. In Thirty-First AAAI Conference on Artificial Intelligence.
[21] HaroldW. Kuhn. 2010. The Hungarian Method for the Assignment Problem. In 50
Years of Integer Programming 1958-2008 - From the Early Years to the State-of-the-
Art, Michael Jünger, Thomas M. Liebling, Denis Naddef, George L. Nemhauser,
William R. Pulleyblank, Gerhard Reinelt, Giovanni Rinaldi, and Laurence A.
Wolsey (Eds.). Springer, 29–47. https://doi.org/10.1007/978-3-540-68279-0_2
[22] Xingjie Liu, Qi He, Yuanyuan Tian, Wang-Chien Lee, John McPherson, and
Jiawei Han. 2012. Event-based social networks: linking the online and offline
social worlds. In Proceedings of the 18th ACM SIGKDD international conference on
Knowledge discovery and data mining. ACM, 1032–1040.
[23] Yacov Manevich, Artem Barger, and Yoav Tock. 2018. Service Discovery for
Hyperledger Fabric. (2018).
[24] Julia M Mayer, Starr Roxanne Hiltz, and Quentin Jones. 2015. Making social
matching context-aware: Design concepts and open challenges. In Proceedings of
the 33rd Annual ACM Conference on Human Factors in Computing Systems. ACM,
545–554.
[25] Tunde J Ogundele, Chi-Yin Chow, and Jia-Dong Zhang. 2017. Eventrec: Personal-
ized event recommendations for smart event-based social networks. In 2017 IEEE
International Conference on Smart Computing (SMARTCOMP). IEEE, 1–8.
[26] Tunde Joseph Ogundele, Chi-Yin Chow, and Jia-Dong Zhang. 2018. SoCaST*:
Personalized Event Recommendations for Event-Based Social Networks: A Multi-
Criteria Decision Making Approach. IEEE Access 6 (2018), 27579–27592.
[27] Pamela Oliver, Gerald Marwell, and Ruy Teixeira. 1985. A theory of the critical
mass. I. Interdependence, group heterogeneity, and the production of collective
action. American journal of Sociology 91, 3 (1985), 522–556.
[28] Robert D Putnam. 2000. Bowling alone: American declining social capital. In
Culture and politics. Springer, 223–234.
[29] Stephen Ricken, Louise Barkhuus, and Quentin Jones. 2017. Going online to
meet offline: Organizational practices of social activities through meetup. In
Proceedings of the 8th International Conference on Communities and Technologies.
ACM, 139–148.
[30] Stephen Ricken, Sukeshini Grandhi, Doug Zytko, Starr Roxanne Hiltz, and
Quentin Jones. 2014. Anyone for Bowling?: Coalescing for Shared Activities. In
Proceedings of the 18th International Conference on Supporting Group Work. ACM,
122–130.
[31] Wanita Sherchan, Surya Nepal, and Cecile Paris. 2013. A survey of trust in social
networks. ACM Computing Surveys (CSUR) 45, 4 (2013), 47.
[32] Loren Terveen and David W McDonald. 2005. Social matching: A framework
and research agenda. ACM transactions on computer-human interaction (TOCHI)
12, 3 (2005), 401–434.
[33] Chad Van De Wiele and Stephanie Tom Tong. 2014. Breaking boundaries: The
uses & gratifications of Grindr. In Proceedings of the 2014 ACM international joint
conference on pervasive and ubiquitous computing. ACM, 619–630.
[34] Wouter Weerkamp and Maarten de Rijke. 2012. Credibility-inspired ranking for
blog post retrieval. Information retrieval 15, 3-4 (2012), 243–277.
[35] Douglas Zytko, Stephen Ricken, Brian Butler, and Quentin Jones. 2019. Bowling
Together Again: Facilitating the Initiation of Collective Action throughAwareness
of Others. In Proceedings of the 52nd Hawaii International Conference on System
Sciences.
[36] Douglas Zytko, Stephen Ricken, and Quentin Jones. 2018. Group-Activity Or-
ganizing Through an Awareness-of-Others Interface. In Companion of the 2018
ACM Conference on Computer Supported Cooperative Work and Social Computing.
ACM, 361–364.
90
https://doi.org/10.1109/MCI.2006.329691
https://doi.org/10.1109/MCI.2006.329691
https://doi.org/10.1109/3477.484436
https://doi.org/10.4230/LIPIcs.ESA.2019.48
https://doi.org/10.1007/978-3-540-68279-0_2
	Abstract
	1 Introduction
	2 Concept Model and Formalization
	2.1 Concept Model
	2.2 Formalization
	3 The Matching Algorithm
	4 Blockchain-based Platform
	4.1 Architecture of the Platform
	4.2 Platform Prototype
	5 Evaluation
	5.1 RQ1: Effectiveness and Efficiency
	5.2 RQ2: Scalability
	5.3 RQ3: Usability
	6 Related Work
	7 Conclusion
	Acknowledgments
	References