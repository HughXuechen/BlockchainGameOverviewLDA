CCOM: Cost-Efficient and Collusion-Resistant Oracle Mechanism for Smart Contracts
CCOM : Cost-Efficient
and Collusion-Resistant Oracle
Mechanism for Smart Contracts
Xiaofei Wu1, Hao Wang1, Chunpeng Ge1(B), Lu Zhou1, Qiong Huang2,
Lanju Kong3, Lizhen Cui3, and Zhe Liu1
1 Nanjing University of Aeronautics and Astronautics, Nanjing, China
{wuxiaofei,wangh24,gecp,lu.zhou,zhe.liu}@nuaa.edu.cn
2 South China Agricultural University, Guangzhou, China
qhuang@scau.edu.cn
3 Shandong University, Jinan, China
{klj,clz}@sdu.edu.cn
Abstract. Smart contracts, that allow parties to establish agreements
based onpredefined ruleswithout a trusted third-party, have been explored
in various applications. However, the main drawback of smart contracts is
that they cannot access the external data required to trigger the execution
of inner logic. The Oracle technology is an interactive bridge between on-
chain smart contracts and off-chain data, which is designed to introduce
external data into the blockchain system. A superior oracle mechanism
should achieve reliable data acquisition with easy data parsing, deployable
services, high system efficiency, and cost-effectiveness. The current smart
contracts oracle mechanisms either rely on a trusted third-party or intro-
duce high computation overhead and difficulty in deployment. This paper,
for the first time, proposes a decentralized and efficient on-chain oracle
mechanism CCOM . In our scheme, a prisoner’s contract is introduced for
users who want to obtain specific information. The user introduces two ora-
cles to complete the same task of obtaining data, and the contract can pre-
vent oracles from collusion. Rational oracles will not collude but honestly
submit the correct result to increase self-interest.Wealso demonstrate that
the proposed scheme can resist a single potentially malicious oracle service
and prevent collusion from occurring. Finally, we perform experiments on
Ethereum test network Rinkeby and show that our scheme is time-efficient
and cost-effective.
Keywords: Oracle · Smart contract · Collusion-resistant · Game
theory
1 Introduction
A blockchain system is a separate “information island” where data is transmitted
between blockchain participants. It can only access data within the blockchain
and lacks a reliable mechanism to query information outside (i.e., off-chain data)
[2]. However, the execution of blockchain smart contracts relies on reliable exter-
nal data [8]. Consider a smart contract that allows betting on the score of a
c© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022
K. Nguyen et al. (Eds.): ACISP 2022, LNCS 13494, pp. 449–468, 2022.
https://doi.org/10.1007/978-3-031-22301-3_22
http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-031-22301-3_22&domain=pdf
https://doi.org/10.1007/978-3-031-22301-3_22
450 X. Wu et al.
football match. Designing a smart contract that defrays the reward based on the
game’s result is simple. While getting a reliable game score from the real world
to trigger the smart contract is challenging. Therefore, it is essential to efficiently
obtain reliable data to trigger the correct execution of smart contracts.
Oracles (also known as data feeds) [5,10,13,18,29] that get data from off-
chain and feed it into the smart contract is a promising technique to bridge the
smart contracts and the real world data. A straightforward approach is involv-
ing a trusted third-party oracle service to obtain the outside data. However,
a malicious oracle service may provide manipulated data according to its own
profit. Data reliability entirely relies on the trusted third-party oracle service.
Another possible approach is leveraging decentralized oracle service where mul-
tiple oracles collaborate to obtain data. Decentralized oracles also are considered
as consensus oracles, in which the oracle nodes reach an agreement through the
consensus mechanism. Nevertheless, this approach is inefficient and increases
resource consumption and overhead. Moreover, the decentralized oracle services
cannot achieve high economic security [18], which means that if the financial ben-
efits do not outweigh the costs, compromising a network would not be beneficial.
Additionally, decentralized oracle schemes are difficult to deploy.
To overcome the above issues, we propose an efficient and low-overhead on-
chain oracle mechanism that is resistant to a single potentially malicious oracle
service, called CCOM . Our scheme constructs a prisoner’s contract between
the client and two oracles, which adopts cryptographic commitment and game
theory. The key idea is to leverage smart contracts to implement a collusion-
resistant payment protocol. (1) By requiring the oracle to pay the deposit in
advance as a security guarantee for delivering the correct result. If the oracle
delivers the incorrect result, it will be punished and lose the deposit. Such a mean
weakens the oracle’s incentive to collude. (2) Incentivize oracles to act honestly
by redistributing confiscated deposits, which rewards honest oracles that submit
correct results. (3) By requiring the oracle to submit the commitment to bid for
the task, which once again weakens the oracle’s motivation for collusion after
successful bidding. Because in the next stage of delivering the original data,
changing the result will cause the hash verification to fail.
Contributions. To summarize, we make the following contributions in this
paper.
1. We propose a cost-efficient and collusion-resistant blockchain oracle mecha-
nism, CCOM , which uses hash commitment and game theory-based methods
to resist collusion. Detailed game theory analysis proves that two oracles sub-
mitting correct results are the only sequential equilibrium of the game (see
Sect. 2.2).
2. The proposed CCOM can resist to a single potentially malicious oracle service
while taking into account the efficiency and overhead on the basis of ensuring
the degree of decentralization.
CCOM : Cost-Efficient and Collusion-Resistant Oracle Mechanism 451
3. We implement a lightweight smart contract scheme based on Ethereum and
conduct detailed tests on Rinkeby. The results show that our scheme is time-
efficient and cost-effective.
2 Preliminaries
2.1 Games and Strategies
Strategic Game [17] is a model of interaction between decision-makers (also
known as players). Each player has a set of possible actions. This model captures
the interaction between players by allowing each player to be affected by all
player actions, not just his own actions.
Definition 1. A strategic game (with ordinal preferences) consists of the
following three elements.
– Players: a set of players.
– Actions: for each player, a set of actions.
– Preferences: for each player, preferences over the set of action profiles.
The preferences defined as the payoff function, which associates a number
with each action in such a way that actions with higher numbers are preferred.
More precisely, the payoff function u represents a decision-maker’s preferences
if, for any actions a and b in A, u(a) > u(b) if and only if the decision-maker
prefers a to b.
The Prisoner’s Dilemma [16] is one of the well-known situations of strategic
games. The players of the game are two prisoners suspected of major crimes
rather than two Internet users. The two prisoners were locked up in different
interrogation rooms. However, there was enough evidence to convict each of
them of minor crimes, but there was not enough evidence to convict any of them
of major crimes unless one of them informed the public. Everyone can admit or
deny their crime while being silent or betraying each other. If they both remain
silent, everyone will be sentenced to a misdemeanor and go to prison for one
year. If only one of them informs, the informant will be released and the other
will spend four years in prison. If they betray each other, each of them will spend
three years in prison.
This situation may be modeled as a strategic game:
– Players: The two suspects.
– Actions: Each player’s set of actions is Silent, Betray.
– Preferences: Suspect A’s action profiles, from best to worst, are (Betray,
Silent) (A is freed), (Silent, Silent) (A gets one year in prison), (Betray,
Betray) (A gets three years in prison), (Silent, Betray) (A gets four years
in prison). Suspect B’s action profiles are also similar.
We choose payoff functions that represent the suspects’ preference orderings.
For suspect A we let function u1(Betray, Silent)=3 > u1(Silent, Silent) = 2 >
452 X. Wu et al.
u1(Betray, Betray) = 1 > u1(Silent, Betray) = 0. For suspect B we similarly
choose the function u2 for which u2(Silent, Betray) = 3 > u2(Silent, Silent) = 2
> u2(Betray, Betray) = 1 > u2(Betray, Silent) = 0. Using such payout functions,
the game can be presented in the form of Table 1, where the rows correspond to
player A’s actions, the columns correspond to player B’s actions, and the content
of the box is the payoff function for the selected action configuration.
Table 1. The example of prisoner’s dilemma.
Suspect A Suspect B
Silent Betray
Silent (2, 2) (0, 3)
Betray (3, 0) (1, 1)
The Prisoner’s Dilemma simulates a situation in which cooperation will bring
benefits (that is, each player remains silent instead of choosing to betray), but
no matter what the other party does, each player has the incentive to choose to
betray to gain higher returns.
Perfect Information Game: [15] The player specifies the action they will take
at each choice node of the game, and the player knows the node where they are in
and all previous choices, including the choices of other agents. However, in more
realistic situations, such assumptions are too strong, and many scenarios need
to simulate agents that partially or completely do not know the actions taken
by others, or even agents with limited knowledge of their own past actions.
The Imperfect-Information Game [15] is an extended form of a game
that solves this limitation.
In the extensive form, a game is captured as a game tree. Each node repre-
sents a player’s choice, each edge represents a possible action, the leaves represent
the final result, and each player has a utility function. Formally, we define it as
follows.
Definition 2. An imperfect-information game in extensive form is a tuple
(N,A,H,Z, χ, ρ, σ, u) where:
1. N is a set of n players;
2. A is a (single) set of actions;
3. H is a set of non-terminal choice nodes;
4. Z is a set of terminal nodes, disjoint from H;
5. χ: H �→ 2A is the action function, which assigns to each choice node a set of
possible actions;
6. ρ: H �→ N is the player function, which assigns to each non-terminal node a
player i ∈ N who chooses an action at that node;
7. σ: H × A �→ H ∪ Z is the successor function, which maps a choice node and
an action to a new choice node or terminal node such that for all h1, h2 ∈ H
and a1, a2 ∈ A, if σ(h1, a1) = σ(h2, a2) then h1 = h2 and a1 = a2;
CCOM : Cost-Efficient and Collusion-Resistant Oracle Mechanism 453
8. u = (u1, ..., un), where ui : Z �→ R is a real-valued utility function for player
i on the terminal nodes Z.
9. I = (I1, ..., In), where is an equivalence relation that partitions player i′s
choice nodes {h ∈ H : ρ(h) = i} into ki information sets Ii,1, ..., Ii,ki with the
property that χ(h) = χ(h′) and ρ(h) = ρ(h′) whenever there exists a j for
which h ∈ Ii,j and h′ ∈ Ii,j.
In the definition, the tuple (N,A,H,Z, χ, ρ, σ, u) captures the setting and
rules of the game, which same as the perfect-information game, and I captures
the imperfection of information. The strategy set A captures the actions that
players will take at any stage of the game. This paper considers mixed behavior
strategies that are more common than pure strategies.
Definition 3 (Behavior strategies). Let G = (N,A,H,Z, χ, ρ, σ, u) be an
imperfect-information extensive-form game. Then the behavior strategies si of
player i is a function that assigns each information set Ii,j ∈ Ii a probability
distribution over the actions in χ(Ii,j), with the property that each probability
distribution is independent of the others. A completely mixed behavior strat-
egy is a behavior strategy in which every action is assigned a positive probability.
A strategy profile is a list of all players’ strategies s = (si)i∈N . A strategy
profile without player i′s strategy is defined as s−i = (s1, ..., si−1, si+1, ..., sn).
We can also write s = (si, s−i).
2.2 Sequential Equilibrium
The state of the stable optimal solution in game theory is called a Nash equi-
librium [17]. Informally, in a Nash equilibrium, each player’s strategy is the
best given the other players’ strategies, and no one can do better by changing
their strategies if the other players do not change their strategies. However, the
player’s strategy may include irrational behavior that leads to his own lower
payoff, thus forming a weaker Nash equilibrium.
We employ an improvement scheme that excludes unreasonable equilibrium-
sequential equilibrium [17] -consisting of a behavior strategy profile and a
belief system. The equilibrium should not only specify the players’ strategies,
and the belief system should also specify their beliefs about each set of informa-
tion about the history that occurred. They must move according to the set of
information about the history that happened. We refer to such a pair (s, β) as
an assessment, in which s is a behavior strategy profile and β is a belief
system.
Definition 4. In a game G, a (belief system) β = (βi)i∈N is as follows: for
each player i, βi assigns each information set Ii,j ∈ Ii a probability distribution
over the nodes in Ii,j. For each node h ∈ Ii,j, the belief βi (h) = Pr[h|Ii,j ], i.e.
the probability that player i is at h given that he is at Ii,j.
Definition 5. In a game G, the player i’s expected payoff at h,given the play
of the game is at node h when the players implement the strategy profile s, is the
454 X. Wu et al.
sum of the utility of each terminal nodes, weighted by the probability of reaching
the node:
ui (s;h) =
∑
z∈Z
Pr[z| (s, h)] · ui (z) (1)
The player i’s expected payoff at Ii,j is the sum of expected payoff at each h ∈ Ii,j,
weighted by the belief βi (h):
ui (s; Ii,j , β) =
∑
h∈Ii,j
βi (h) · ui (s;h) (2)
Definition 6. In a game G, (s, β) be an assessment, the strategy profile s =
(si, s−i) is called rational at information set Ii,j, relative to β, if for each behav-
ior strategy si
′ �= si of player i:
ui (s; Ii,j , β) ≥ ui ((si′, s−i) ; Ii,j , β) (3)
The assessment is called sequentially rational if for each player i and each
information set Ii,j ∈ I, the strategy profile s is rational at Ii,j relative to β.
Definition 7. An assessment (s, β) is said to be consistent if there exists a
sequence of fully mixed behavior strategy profiles (sk)k∈N satisfying the following
conditions:
(1) The profile (sk)k∈N converges to s, which is limk→∞(sk) → s;
(2) The sequence of beliefs (βk)k∈N induced (sk)k∈N (by Bayes’ rule) converges
to the belief system β , which is limk→∞(βk) → β.
Definition 8. An assessment (s, β) is called a sequential equilibrium if it is
sequentially rational and consistent.
Due to imperfect information, players must make decisions under uncertainty.
When a player is asked to make a decision, the belief system allows the player
to construct the strategy that is optimal at every point in the tree.
2.3 Smart Contract and Oracle
Blockchain is a new type of distributed ledger paradigm that integrates mul-
tiple existing technologies. It uses distributed consensus algorithms to generate
and update data and peer-to-peer networks for data transmission between nodes.
The distributed ledger that combines cryptography principles and time stamp-
ing technologies ensures that the stored data cannot be tampered with and uses
automated script codes or smart contracts to implement upper-level application
logic. Smart contracts are programs with specific addresses that are executed
on the blockchain, which are event-driven, self-executing, and tamper-resistant.
They consume transaction fees based on the complexity of the code (for exam-
ple, Gas consumed by deployment in the Ethereum blockchain) and use the
CCOM : Cost-Efficient and Collusion-Resistant Oracle Mechanism 455
resources available on the blockchain network. The introduction of smart con-
tracts to the blockchain has increased the programmability of the blockchain
and revolutionized the software ecosystem.
Although the prospects are promising, smart contracts that perform specific
functions need to access data about real-world state and events from outside
the blockchain system [30,31]. However, since the blockchain system is isolated
from the external world [25], the blockchain and smart contracts cannot access
off-chain data (outside the p2p network). The availability of smart contracts
in terms of performance and programmability will be limited to data on the
chain. To overcome this limitation of smart contracts, the Oracle (also known
as Data Feed) [4,14,28] represented by smart contracts on the blockchain came
into being. Oracles act as agents, servicing data requests from other smart con-
tracts, discovering and validating real-world events, and feeding the data to
smart contracts. Lack of reliable data feeding mechanism limits the applicability
of smart contracts.
3 The Architechture of CCOM
3.1 Adversary Model and Assumption
In our system model, the client who publishes a data request task and introduces
two oracles to get the required data is thought to be honest. The client’s goal
is to get the correct data it wants while minimizing the cost. A single oracle
may behave in-honestly and return incorrect data so as to get extra profit. Each
oracle is thought to be a separate rational adversary, which means that the oracle
always considers all possible outcomes and rationally chooses the strategy that
will maximize its profits. The parties involved are risk-neutral. For other risk
profiles (i.e., risk-seeking or risk-averse), the utility function can be adjusted to
the risk profile, and equilibrium is maintained by choosing deposits based on the
risk profile. Beyond that, we have the following assumptions:
• We assume that oracles can provide incorrect but reasonable results with no
cost.
• For simplicity, we also assume that different oracles consume the same cost
to complete the task, and the cost is public.
• Combined with real-world scenarios, we assume that the data required by
the smart contract is not complicated. Considering the high cost and low
demand of uploading large amounts of data to the blockchain, complex data
acquisition tasks are beyond the scope of this paper for the time being.
3.2 The System Architecture of CCOM
The CCOM involves two types of participants as shown in Fig 1.
• Users (Clients): A user wants to access the specific data which service
provided by oracles, then he creates and distributes the prisoner’s contract
on blockchain to publish a task.
456 X. Wu et al.
Fig. 1. System architecture of CCOM .
• Oracles: An oracle who wants to accept the task needs to bid and sign the
prisoner’s contract with the client.
When on-chain users need to access off-chain data sources to complete some
interactions, the client instantiates a prisoner’s contract according to the specific
requirements and distributes the smart contract on the blockchain. Two oracles
which are selected randomly, sign the contract with the client. Then oracles fetch
data from data sources and deliver it to the contract. If there is any dispute, the
trusted third oracle(TTO) will be introduced, which is served by a reputable
oracle service provider. This oracle can provide results and resolve disputes.
However, if the oracle is rational, TTO will never be called.
To incentivize honest behavior, oracles are required to prepay deposit, which
is stated in the contract in advance. If the oracle acts honestly, the deposit will be
refunded; if the oracle is detected cheating, the client will confiscate the deposit.
In addition, in the case where one oracle is honest and the other cheats, the
honest oracle will get extra profits from the cheating oracle’s deposit. Although,
collusion may bring higher profits than both parties acting honestly. However,
there will be a higher profit if one person can induce the other party to cheat
while being honest with himself. Once both oracles understand that collusion
is unstable, the other oracle always tries to deviate from it. Any attempt to
persuade the other party to collude without a credible and enforceable promise
will be considered a trap, therefore, will not succeed.
3.3 Monetary Variables
We use some non-negative currency variables in the contract — see Table 2.
Obviously, there are some relationships between these currency variables.
• w ≥ c: Oracle will not accept low-paying jobs at a loss.
CCOM : Cost-Efficient and Collusion-Resistant Oracle Mechanism 457
Table 2. Summary of monetary notations.
Notation Description
c The essential cost of an oracle completes the task of obtaining specific data
th The cost of calling TTO to re-complete the task of obtaining specific data and resolving disputes
d The deposit an oracle needs to pay to the client for a job
w The amount the client agrees to pay to an oracle to complete the task of obtaining specific data
• th > 2 ∗ w: Otherwise, the oracle service will not be needed. The client can
directly select the TTO, which is slightly more expensive, to complete the
task of obtaining specific data.
• d > c + th: In order to establish an ideal Nash equilibrium, d is set by the
client in the prisoner’s contract.
In addition, th will be paid by the oracle that submitted the wrong result.
Honest customers pay no more than the cost of requesting two oracle services
plus the gas cost of initiating the transaction.
3.4 The Prisoner’s Contract
The prisoner’s contract is established between a user (client) and two oracles (o1
and o2), the contract is summarized in Algorithm 1, and the specific protocol is
as follows:
Init: The client instantiates the prisoner’s contract according to the specific
data service request (including content and format, etc.) and sets the deadline
T1 < T2 < T3. Then he publishes it on the blockchain.
Create: The client creates a task through the contract, declares the data he
wants to access, and sets the d that oracle needs to pay. Agree to pay the w to
each oracle who completes the task honestly and select o1 and o2 that provide
corresponding services randomly to prevent oracle collusion in advance to a
certain extent. Determine TTO and the th, if any disputes will be resolved by
TTO. In addition, the client pays (2 ∗ w) + th) to the contract when publishing
the task.
Bid: The o1 and o2 assigned the task need to bid within T1. Oracle accepts the
task to pay the d to the contract and upload the HASH of the data required by
the client, namely hash(data). If any oracle fails to do so, the contract will be
terminated, and any deposit paid will be refunded.
458 X. Wu et al.
Deliver: The o1 and o2 must submit the original data before T2. The contract
verifies whether the result submitted by oracle is consistent with those submitted
during the Bid period. If they are the same, the submission is successful.
Pay: If the time exceeds T2, o1 and o2 have not delivered the results, the d will
be forfeited in full. If both o1 and o2 deliver the results and the results are equal,
the w will be paid and the d will be refunded. Otherwise, a dispute will be raised
with TTO.
Only when there is an obvious problem, that is, no oracle delivers the result,
or the client is satisfied with the result, can the contract be directly terminated.
Dispute: After TTO receives the dispute, it completes the task of obtaining
specific data and submits the result0 to the contract, and the contract deter-
mines it.
(1) If both oracles fail to submit the results correctly within the deadline, their
deposits will be forfeited in total, and th will be paid to TTO.
(2) If the result submitted by one oracle is correct and the other oracle is wrong,
the dishonest oracle will be charged for the deposit in total, and the contract
will pay the honest oracle the w, additional bonus (bonus = d−th) and the d.
When only one result is received successfully, or the results do not match, the
contract will determine the cheating behavior and settle the amount based on
the result of TTO. If the client is honest, disputes will only be raised when there
is a problem, and the th will be paid by the cheating oracle’s d.
Liquidate: If after T3, the client neither pays nor raises a dispute, for the oracle
that delivers the result before T2, the client must pay the w and refund the d to
the oracle, and all the remaining balance of the contract will be transferred to
the client.
The client is honest in theory, but if the client maliciously manipulates-
neither pays nor raises a dispute, the oracle can call the Timer function in the
contract to ensure that its funds are not locked.
Reset: After a task ends, the client can call the reset function to reset the
contract parameters before releasing a new task. There is no need to redeploy
contracts frequently, saving gas consumption.
The contract has three deadlines to enforce timeliness and avoid locking
up funds when some parties refuse to advance the contract. The contract may
permanently lock the balances if the code does not specify what to do after the
deadline. So the deadline is crucial for smart contracts.
CCOM : Cost-Efficient and Collusion-Resistant Oracle Mechanism 459
Algorithm 1. The Prisoner’s Contract pseudocode.
Init:
Set state := Init, T1, T2, T3, Do := false;
Create:
Upon receiving (“create”, w, d, th, o1, o2 ,
TTO) from client:
if state := Init and T < T1 < T2 < T3 and
bal[client] ≥ $(2 ∗ w + th) then
state := Created;
bal[ledger] := $(2 ∗ w + th);
worker = {o1, o2};
Bid:
Upon receiving (“bid”, hash(data)i) from oi:
if state := Created and T < T1 and
oi ∈ worker and bal[oi] ≥ $d then
bal[ledger] := bal[ledger]+$d;
hashi := hash(data)i;
hasBid[oi] := true;
else
hasBid[oi] := false;
if hasBid[o1] and hasBid[o2] then
state := GetData;
Deliver:
Upon receiving (“deliver”, datai) from oi:
if state := GetData and T < T2 and
oi ∈ worker then
resulti := datai;
if hash(datai) := hashi then
hasDeliver[oi] := true;
else
hasDeliver[oi] := false;
state := Pay;
Pay:
Upon receiving (“pay”) from client:
while state := Pay and T > T2 do
if hasDeliver[o1] and hasDeliver[o2] then
bal[client] := bal[client] + $(2 ∗ w +
th + 2 ∗ d);
state := Done;
Do := false;
else if hasDeliver[o1] and hasDeliver[o2]
and result1 := result2 then
bal[o1] := bal[o1] + $(w + d);
bal[o2] := bal[o2] + $(w + d);
bal[client] := bal[client] + $(th);
state := Done;
Do := true;
else
state := Error;
Do := false;
return Do;
Dispute:
Upon receiving (“Dispute”, result) from
TTO:
while state := Error do
for i =1 to 2 do
if hasDeliver[oi] and result = resulti
then
hasCheat[oi] := false;
else
hasCheat[oi] := true;
if hasCheat[o1] and hasCheat[o2] then
bal[o2] := bal[o2] + $(w + 2 ∗ d − th);
bal[client] := bal[client] + $(w + th);
else if hasCheat[o1] and hasCheat[o2]
then
bal[o1] := bal[o1] + $(w + 2 ∗ d − th);
bal[client] := bal[client] + $(w + th);
else if hasCheat[o1] and hasCheat[o2]
then
bal[client] := bal[client] + $(2 ∗ (w +
d));
bal[TTO] := bal[TTO] + $(th);
state := Done;
Liquidate:
Upon receiving (“Timer”):
while state := Created and T > T1 do
bal[client] := bal[client] + $(2 ∗ w + th);
for i =1 to 2 do
if hasBid[oi] then
bal[oi] := bal[oi] + $(d);
state := Aborted;
while state := GetData and T > T2 do
state := Pay;
while state := Pay and T > T3 do
for i =1 to 2 do
if hasDeliver[oi] then
bal[oi] := bal[oi] + $(w + d);
bal[client] := bal[client] + bal[ledger];
state := Done;
Reset:
Upon receiving (“reset”):
if state := Done or state := Aborted then
clear cache of all parameters;
state := Init;
4 Discussion and Analysis
An imperfect information game created by the above prisoner’s contract is shown
in Fig. 2. In the game, the players are two oracles. Although the contract also
involves the client and TTO, who are honest and have only one deterministic
strategy, we exclude them from the players. We formalize the game. The player
set is N = {o1, o2}. The action set A = {T − result, F − result, other}, where
460 X. Wu et al.
T −result means that the participant sent the correct result before the deadline,
and F − result means that the participant sent the wrong result before the
deadline. Other refers to other behaviors that submit incorrect data or fail to
submit data within the specified time. The game has two information sets: I1 =
{v0} belongs to o1, and I2 = {v1, v2, v3} belongs to o2. (H,Z, χ, ρ, σ) are captured
by the tree structure. We use u1 and u2 to denote the utility functions of o1 and
o2, respectively. Both parties’ payoff (utilities) are listed below the terminal
nodes.
Fig. 2. The game created by the prisoner’s contract. Bold edges indicate the actions
that parties will play in the unique sequential equilibrium.
Next, we prove that the game has a unique sequential equilibrium. To be
precise, if d > c + th, the probability of both parties of the game submitting the
correct data T − result is 1, and the only achievable node of the game is v4.
The significance of balance is that for each oracle node, submitting the correct
data will always bring itself the highest payoff. In detail, we see the decision
point v1 of o2: if o2 chooses T − result, it will go to the terminal node v4, the
game is over, and the payoff of o2 is w − c; while choosing F − result or other
will go to v5 and v6 respectively, o2’s payoff is all −d. Since w − c is positive,
it’s a better choice than −d anyway. Similarly, for the decision point v2 of o2,
if o2 chooses T − result, it will go to the terminal node v7, and the payoff is
w + d − c + bonus, that is w + 2 ∗ d − c − th. If o2 chooses F − result or other,
it will go to v8 and v9, and the payoff is w and −d, respectively. Obviously, if
d > c+ th, the payoff in v7 is higher than that in v8 and v9. Correspondingly, at
decision point v3, if o2 chooses T − result, it will go to terminal node v10, and
the payoff is w−c+bonus, which is better than the payoff of choosing F −result
or other which is −d. Regardless of how o1 chooses his actions, o2 will prefer
to submit the correct result, and terminal nodes will only be spawned in v4, v7,
CCOM : Cost-Efficient and Collusion-Resistant Oracle Mechanism 461
and v10. From the payoff of o1 in these three nodes, it is obvious that the oracle
will choose to execute T − result to get the best payoff, so if the oracles are all
rational, v4 is the only outcome of the game.
From the definition in Sect. 2.2, we can draw the following conclusions.
Lemma 1. If d > c+th, then Game in Fig. 2 has a unique sequential equilibrium
((s1, s2), (β1, β2)) where
⎧
⎪⎪⎨
⎪⎪⎩
s1 = ([1(T − result), 0(F − result), 0(other)]);
s2 = ([1(T − result), 0(F − result), 0(other)]);
β1 = ([1(v0)]);
β2 = ([1(v1), 0(v2), 0(v3)]);
(4)
Theorem 1. If d > c + th and o1, o2 are rational, Game in Fig. 2 will always
terminate at v4.
Lemma 1 states that for o1 and o2, the best strategy is to always submit
correct results T − result in time (with a probability 1). Informally, beliefs can
be reasoned like this: for o1, since I1 has only one node, o1 knows that it is
always at v0 when it reaches I1 (that is β1 = ([1(v0)])); foro2, knowing that o1’s
strategy is always select to send T − result and it always reaches v1 and not the
other two nodes in I2 (that is β2 = ([1(v1), 0(v2), 0(v3)])).
Given Lemma 1, Theorem 1 can be easily proved: if both parties always send
T − result with a probability 1, the game always ends at v4.
In the above analysis, when both parties submit the same incorrect result at
the deadline, the contract cannot distinguish the authenticity. It will still offer
the incorrect result to the client. At this time, we assume that both oracles have
intentionally reached collusion. The probability of such a situation occurring in
the absence of collusion is extremely low and can be ignored.
Next, we consider the case of collusion. From a rational point of view, in
the game created by our prisoner’s contract, the oracles participating in the
collusion earn less than the payoff for submitting the correct result. However,
there is also the possibility that colluding oracles may obtain extra benefits
from other channels. For example, after the oracle reaches collusion, the result
is manipulated so that the client suffers a loss when using the incorrect data to
execute other smart contracts, and the loss makes the collusion oracle obtain a
higher profit.
Considering that oracles are rational and selfish adversaries, collusion is unre-
liable unless credible and enforceable commitments are made in the form of smart
contracts that explicitly regulate the rewards of collusion and the penalties for
the betrayal of collusion. In addition, if collusion is reached, the oracle also can
betray the collusion and report to the client to obtain higher profits. Therefore,
collusion is unstable.
Moreover, the above collusion is difficult to achieve in CCOM. First of all,
our scheme adopts the principle of randomness to select two oracles. The oracle
node that receives the task cannot determine who also received the task because
anyone can serve as an oracle node on the p2p network to provide data. Then,
462 X. Wu et al.
our prisoner’s contract has a clear deadline for the oracle to submit the result.
The deadline is within a few minutes, and it is almost difficult for a potentially
malicious oracle to quickly find another oracle and sign a collusion contract to do
evil together. It is tantamount to finding a needle in a haystack in a short period.
When the oracle accepting the task pays the deposit for bidding, the identity
of the oracle that issued the transaction is disclosed. However, the hash of the
result has been submitted simultaneously in bidding and cannot be changed in
delivering, so collusion cannot be realized.
To summarise, in the scenario where oracles obtain off-chain data for smart
contracts, CCOM can resist collusion in the face of rational and selfish oracles.
5 Implementation
The experiments is conducted on a ThinkBook 13X with a CPU of 11th Gen
Intel(R)Core(TM) i5-1130G7@ 2.90 GHz and 16 GB RAM. The contract was
implemented in Solidity 0.4.10 [23] and tested on the Ethereum testnet Rinkeby.
Simultaneously, we use the built-in hash function—Keccak256 of solidity to
upload encrypted information to the smart contract. Contracts are loosely cou-
pled with external services provided by oracles. The task of fetching the data
can be viewed as a black box, and the contract does not need to know their
internal details. The contract is only called before/during/after executing the
task. The source code of our scheme’s contracts can be found at https://github.
com/job00001/CCOM.
5.1 Cryptographic Primitives - HASH Function
Hash function is a one-way irreversible and input-sensitive algorithm that is
cryptographically secure. It is precisely that input a random v yields a unique
c = H(v) which is uniformly distributed and unpredictable. The hash algorithm
has the following two characteristics: (1) One-Way: it is difficult to deduce the
sensitive data v through the hash value H(v); (2) Collision-Resistant: it is diffi-
cult to find different sensitive data v′ produces the same hash value H(v).
Cryptographic commitments allow one to commit to a chosen value (or cho-
sen statement) while keeping it hidden to others, with the ability to reveal the
committed value later. The receiver cannot know the chosen value at that time
(which provides hiding property). The chosen value in the commit phase must be
the only one that the sender can compute and validate during the reveal phase
(which provides binding property). Hash function is simple in construction and
easy to use, satisfying the essential characteristics of cryptographic commitments
– hiding and binding. In our experiments, we use solidity’s built-in keccak256
function, which is briefly described below for what it does for our contracts.
Select Oracles Randomly: In the create phase of the prisoner’s contract,
the client uses the keccak256 algorithm to select two oracles randomly. It is too
expensive for solidity to generate random numbers through complex algorithms.
https://github.com/job00001/CCOM
https://github.com/job00001/CCOM
CCOM : Cost-Efficient and Collusion-Resistant Oracle Mechanism 463
We use one of the most commonly used algorithms–“Linear Congruence Genera-
tor (LCG)”. Enter the current timestamp and the client’s address as parameters
to obtain a hash value of type uint256, and then modulo the total number
of oracles n to obtain a random number. Although this method is not secure
enough on Ethereum, in practice, nodes generally do not have enough resources
to launch an attack. Attacks are unprofitable unless we have a ton of money on
our random function, so we decided to accept this shortcoming.
Encrypt Information: The oracle converts the result into a keccak value and
then feeds it to the contract so that other nodes cannot replicate or initiate
acollusion. When two oracles have delivered their original data, the contract
can verify whether the results are consistent with the previous bidding to judge
whether they act honestly. Hashing is a commitment scheme that is strongly
collision-resistant while providing verifiability of results. We replace the actual
input/output values that should be placed on the blockchain with hash values,
temporarily hiding the information of the input/output and avoiding collusion
well (see Sect. 5).
We implement contracts on the blockchain (such as Ethereum) to assist in
realizing a cost-efficient and collusion-resistant oracle mechanism by using a
collision-resistant hash function. Blockchain has limited space for storing data,
and nodes in the network need to verify all transactions. The size and complexity
of transactions are limited, so such an approach is efficient and has very little
overhead (see Sect. 5.2 for details).
5.2 Overhead and Cost
Cryptography Overhead and Gas Cost: We use the built-in hash function
of solidity. Each oracle only needs to generate one keccak value, each client needs
to generate two keccak values, and each prisoner’s contract requires to verify at
most two keccak values. So the additional overhead caused by cryptography
primitives is small. In Table 3, we show the cost of setting up and executing
our contracts on the Ethereum testnet Rinkeby. The cost is in the amount of
gas consumed by each function. In all transactions, the gas price was 1 gas =
0.0000000025 ether.
The cost is roughly related to the computational and storage complexity of
the function. For example, In our prisoner’s contract, Init (deploying the contract
on the blockchain), Create (publishing specific tasks), and Dispute (calling the
third oracle to resolve disputes) cost more than other functions. Deploying our
contract costs 2.96 × 106 gas, but if the reset function is called to reset the
parameters, the contract can be reused without deploying again. Then each task
can save about 2.87 × 106 gas, and the cost can be further reduced. If there is
no dispute for a task, the total cost (client and two oracles) is about 0.57 × 106
gas, and if there is a dispute to be resolved, the total cost is about 0.76 × 106
gas. It can be seen that the cost of using our constructed prisoner’s contract on
Ethereum is very cheap, CCOM is cost-effective.
464 X. Wu et al.
T
a
b
le
3
.
T
h
e
co
st
o
f
u
si
n
g
th
e
sm
a
rt
co
n
tr
a
ct
s
o
n
R
in
k
eb
y.
(a
)
T
h
e
ex
a
m
p
le
w
it
h
d
is
p
u
te
tr
ea
tm
en
t
F
u
n
c
ti
o
n
G
a
s
T
x
n
F
e
e
(E
th
er
)
T
im
e
-c
o
n
su
m
in
g
(s
)
T
x
n
H
a
sh
In
it
2
9
6
2
4
7
7
0
.0
0
7
4
0
6
1
9
2
1
4
.8
9
0
x
5
9
e1
4
b
a
a
b
5
d
2
2
6
9
f3
2
7
6
0
f1
2
b
b
a
e0
d
d
5
2
a
7
ec
3
3
6
9
5
c3
b
0
fe
2
a
6
9
ec
1
3
f8
7
fb
2
3
1
C
re
a
t
2
7
1
1
0
8
0
.0
0
0
6
7
7
7
7
0
1
8
.1
3
0
x
f9
3
2
b
f6
3
f5
9
d
b
6
3
b
4
b
9
9
6
b
2
e9
6
5
3
6
d
a
c2
a
4
0
4
f1
6
8
2
c8
8
3
a
0
0
6
5
ec
1
ea
0
2
d
c4
5
8
b
B
id
8
0
2
2
2
0
.0
0
0
2
0
0
5
5
5
8
.5
3
0
x
c5
4
7
9
e5
d
3
7
6
a
5
0
ca
f6
fb
cc
ca
2
3
6
d
1
0
3
3
f0
e9
9
4
c5
3
4
b
6
5
7
3
1
0
a
f0
1
a
c6
0
1
5
0
6
5
7
d
D
el
iv
er
8
3
5
0
6
0
.0
0
0
2
0
8
7
6
5
5
.9
3
0
x
1
f2
e8
8
7
6
c6
4
e3
0
9
d
1
a
5
d
1
e2
4
e9
a
d
fa
f5
0
6
8
e8
4
5
e9
6
6
4
9
a
5
5
3
b
7
8
3
2
6
a
3
8
7
2
e0
4
a
P
a
y
4
2
4
2
0
0
.0
0
0
1
0
6
0
5
0
1
4
.1
3
0
x
6
fe
6
3
9
3
3
4
f7
7
3
f7
4
a
b
8
4
7
1
c2
3
9
a
9
cd
7
0
3
7
0
f9
0
9
d
9
5
f2
1
7
2
0
d
8
a
b
4
4
0
d
f7
ff
d
d
8
5
D
is
p
u
te
1
2
6
7
4
9
0
.0
0
0
3
1
6
8
7
2
1
6
.2
5
0
x
e7
eb
3
f3
6
0
d
ef
5
2
c2
ca
6
3
d
c0
3
4
7
2
7
a
ed
6
4
6
7
5
9
a
e3
8
5
cc
6
6
b
f3
ef
8
7
2
c6
b
a
b
8
8
e7
e
T
im
er
2
7
7
8
0
0
.0
0
0
0
6
9
4
5
0
1
5
.6
4
0
x
b
1
cb
2
eb
5
7
7
b
7
8
a
3
d
c6
b
6
cf
2
9
6
e2
c7
a
b
e4
2
b
4
9
0
8
3
e0
0
b
4
4
c7
8
3
a
9
8
8
0
c2
9
5
7
9
1
eb
R
es
et
8
6
9
9
5
0
.0
0
0
2
1
7
4
8
7
5
.4
6
0
x
5
f5
4
e2
e5
0
6
e1
2
1
0
c3
b
8
8
a
1
4
c5
3
e3
f6
d
0
3
1
3
6
3
fa
a
c7
9
0
7
5
8
9
a
0
e8
7
3
2
a
2
5
5
5
7
ea
c
(b
)
T
h
e
ex
a
m
p
le
w
it
h
o
u
t
d
is
p
u
te
tr
ea
tm
en
t
F
u
n
c
ti
o
n
G
a
s
T
x
n
F
e
e
(E
th
er
)
T
im
e
-c
o
n
su
m
in
g
(s
)
T
x
n
H
a
sh
C
re
a
t
2
5
3
4
6
5
0
.0
0
0
6
3
3
6
6
2
1
7
.2
8
0
x
5
0
2
0
2
f0
b
d
5
1
3
9
d
8
4
c4
b
8
a
4
d
6
9
7
0
4
b
8
b
0
3
c8
1
8
a
4
a
1
9
f2
8
a
d
a
4
ce
7
b
b
d
0
0
4
8
3
3
8
6
a
B
id
6
0
3
2
2
0
.0
0
0
1
5
0
8
0
5
6
.3
3
0
x
a
6
0
9
b
cf
2
0
4
5
0
f4
4
8
5
9
3
3
2
9
9
d
2
4
2
2
1
d
e5
6
fb
9
5
8
5
7
f8
4
fc
7
b
c1
d
3
7
4
a
0
3
1
9
a
2
a
9
7
3
D
el
iv
er
6
0
5
1
9
0
.0
0
0
1
5
1
2
9
7
1
6
.0
2
0
x
c1
9
9
9
7
0
2
8
4
3
3
6
d
1
5
4
d
d
f2
8
4
7
b
0
6
6
e1
0
6
c6
f8
9
c8
4
8
0
ca
f9
6
1
1
3
d
9
5
f8
5
5
6
1
0
2
2
f1
P
a
y
7
7
0
7
1
0
.0
0
0
1
9
2
6
7
7
1
7
.0
1
0
x
9
7
5
c2
d
5
9
1
ff
d
b
5
1
ec
b
eb
b
4
cc
5
3
6
a
6
7
b
b
9
3
c2
f4
a
b
2
9
d
b
4
b
5
6
2
b
2
6
9
d
e0
b
b
2
b
8
ce
0
R
es
et
8
4
7
5
5
0
.0
0
0
2
1
1
8
8
7
1
1
.8
2
0
x
9
e2
e4
0
9
6
0
4
9
4
f2
a
9
6
7
d
2
1
e6
2
4
ce
d
b
f9
e2
c7
3
8
0
7
b
8
8
8
5
ea
5
9
3
b
e3
c3
b
1
8
7
c8
ec
0
1
CCOM : Cost-Efficient and Collusion-Resistant Oracle Mechanism 465
Time Cost: We also consider the time-consuming of CCOM . Since our oracle
mechanism is wholly based on the modeling of Ethereum smart contracts, the
time-consuming cost does not involve the setting of initial parameters, writing
solidity contracts, and other preprocesses. We only consider the time consumed
by the CCOM mechanism to execute transactions on Ethereum.
We recorded the time consumption of each transaction made on Rinkeby,
as shown in Table 3. For an example of interaction without dispute treatment,
the total time consumption for six transactions is about 79 s. For an example of
interaction with dispute treatment, the total time consumption for seven trans-
actions is 77.5 s. If the time exceeds T3 and the client has not settled, the contract
may involve another liquidating transaction. The current network situation of
Ethereum has affected our results to a certain extent, so the transaction time is
irregular, but a single transaction basically does not exceed 20 s. To sum up, the
time cost of CCOM is also very small.
6 Related Work
Scholars around the world have conducted extensive research on blockchain ora-
cles. The earliest smart contracts use the secure HTTP connection supported
by the Transport Layer Security protocol (TLS) to obtain information. Still, the
TLS protocol cannot fully guarantee that the content of the HTTP session has
not been tampered with. TLS-N [21] is a more general approach to provide non-
repudiation to the TLS protocol. However, to achieve this, significant changes
were made to the TLS protocol, and the scheme was poorly deployable. These
schemes are dedicated to achieving safe and reliable data transmission.
Provable [3] (previously known as Oraclize) is a pioneering centralized oracle
service (operating since 2015) that fetches external data from a Web API and
uses TLSNotary/SafetyNet to build proofs of authenticity to provide security.
Provable is based on a Trusted Execution Environment (TEE) and an auditable
virtual machine. Although the supply of audit data is guaranteed, the perfor-
mance of Provable is not good enough. In 2016, Zhang F et al. [31] proposed
Town Crier (TC), a framework based on Intel Software Extensions Protection
(SGX), and the Enclave instance of SGX acts as a link between HTTPS-enabled
data source websites and Ethereum blockchain smart contracts. TC’s security
relies on the SGX framework’s security and authentication infrastructure. How-
ever, Intel CPU and SGX have been severely attacked and damaged [24,27],
which link security is weak. Furthermore, TC only supports limited APIs and
data feeds dedicated to the Ethereum mainnet. PriceGeth [7] is implemented
as a smart contract for trusted entities to publish real-time price pairs to the
Ethereum blockchain and keep all historical prices on-chain so that prices can
be accessed without gas. The solution is centralized, there is no incentive mecha-
nism for oracles that publish and store price pairs, and the application scenarios
are relatively limited. The above three solutions are typical of centralized oracles,
providing off-chain solutions connected to on-chain smart contracts to transmit
data.
466 X. Wu et al.
Augur [20] utilizes the trust decentralization of blockchain to provide a low-
cost oracle platform for prediction markets of online transactions. Witnet [19]
is a reputation-based decentralized oracle network (DON) protocol that con-
nects smart contracts with external data providers. Witnet’s reputation system
maintains the credibility and honesty of participants by rewarding successful
majority-consistent provers and punishing contradictory provers. ChainLink [22]
is the first decentralized oracle solution proposed on Ethereum, which pushes
data between smart contracts and Web-API, maintaining the integrity, confi-
dentiality, and authenticity of smart contract data and both providing on-chain
and off-chain components. All three schemes select oracle nodes based on repu-
tation, which can easily lead to Matthew Effect and are prone to collusion and
targeted attacks. Aeternity [11] is an open-source, decentralized application plat-
form utilizing public blockchain technology, using Bitcoin-NG as the consensus
mechanism to agree on the state of the outside world.
Bitcoin-NG enables high transaction throughput, making Aeternity a viable
platform for data-intensive oracles. Nevertheless, adopting the consensus mech-
anism as the authentication mechanism wastes many resources. ASTRAEA [6]
is a decentralized blockchain oracle that runs on the public chain and relies
on the voting-based game strategy. ASTREA assumes that all rational players
act honestly, analyzes the game-theoretic incentive structure, and proves that
an ideal Nash equilibrium exists. However, external data feeds can still break
the Nash equilibrium by generating off-chain collusion attacks, and there is still
a risk of Sybil attacks. Dos Network [1] is a decentralized oracle service net-
work that supports multiple mainstream public chains, such as Ethereum, EOS,
TRON, and Zilliqa. The scheme adopts Verifiable Random Function (VRF) and
zero-knowledge proof (zkSNARK) to select working groups safely and randomly.
The chosen node obtains the data and uses the threshold signature algorithm to
synergistically generate the proof of data integrity.
The above solutions [1,6,11,19,20,22] are decentralized oracle platforms, in
which Chainlink and Dos Network provide both on-chain and off-chain compo-
nents, while others only provide on-chain components. Our scheme, CCOM ,
mainly provides on-chain components and is implemented as lightweight smart
contracts. It can resist a single potentially malicious oracle, is more secure than
the centralized oracle service, and has no single point of failure. At the same
time, compared with the decentralized oracle service, it can save resources and
have a lower cost. In short, CCOM balances efficiency and decentralization.
After that, many oracle research schemes realize specific properties, but
they are not comprehensive. The PDFS [9] scheme focuses on achieving non-
repudiation, the zk-AuthFeed [26] scheme uses zero-knowledge proof to achieve
good privacy protection, and GRUB [12] considers the problem of saving gas
overhead.
7 Conclusion
Smart contracts are programs that can be executed autonomously on the
blockchain. In recent years, research on smart contracts has played an indispens-
CCOM : Cost-Efficient and Collusion-Resistant Oracle Mechanism 467
able role in the prosperity and development of the blockchain field. The oracle
technology is crucial for solving the need for blockchain and smart contracts to
access data about real-world state and events from the outside. This paper pro-
posed a cost-effective and collusion-resistant oracle mechanism CCOM , which
constructs a prisoner’s contract between the clients and oracles, and adopts cryp-
tographic commitment and game theory to resist collusion deception. For rational
oracles, always being honest can maximize their benefits. Under the umbrella of
our scheme, the malicious behavior of a single oracle service in the case of central-
ization can be resolved while considering both efficiency and overhead.
Acknowledgements. This work was supported by the National Key R&D Program
of China (Grant No. 2020YFB1005900, 2020B0101090002), the National Key R&D Pro-
gram of Guangdong Province (Grant No. 2020B0101090002), the National Natural Sci-
ence Foundation of China (Grant No. 62032025, 62071222, U21A201710, U20A201092),
and the Natural Science Foundation of Jiangsu Province (Grant No.BK20200418).
References
1. Dos network: a decentralized oracle service boosting blockchain usability with off-
chain data & verifiable computing power. https://s3.amazonaws.com/whitepaper.
dos/DOS (2019)
2. Ethereum blockchain. https://ethereum.org/en/whitepaper/ (2020)
3. Provable documentation. https://docs.provable.xyz/. January 2020
4. Al Breiki, H., Al Qassem, L., Salah, K., Rehman, M.H.U., Sevtinovic, D.: Decen-
tralized access control for IoT data using blockchain and trusted oracles. In: 2019
IEEE International Conference on Industrial Internet (ICII), pp. 248–257. IEEE
(2019)
5. Al-Breiki, H., Rehman, M.H.U., Salah, K., Svetinovic, D.: Trustworthy blockchain
oracles: review, comparison, and open research challenges. IEEE Access 8, 85675–
85685 (2020)
6. Berryhill, R., Veneris, A.: Astraea: A decentralized blockchain oracle. IEEE
Blockchain Tech. Briefs 2(2) (2019)
7. Eskandari, S., Clark, J., Sundaresan, V., Adham, M.: On the feasibility of decen-
tralized derivatives markets. In: Brenner, M., et al. (eds.) FC 2017. LNCS, vol.
10323, pp. 553–567. Springer, Cham (2017). https://doi.org/10.1007/978-3-319-
70278-0 35
8. Greenspan, G.: Why many smart contract use cases are simply impossible. https://
www.coindesk.com/three-smart-contract-misconceptions (2016)
9. Guarnizo, J., Szalachowski, P.: Pdfs: practical data feed service for smart contracts
(2018)
10. Heiss, J., Eberhardt, J., Tai, S.: From oracles to trustworthy data on-chaining
systems. In: 2019 IEEE International Conference on Blockchain (Blockchain), pp.
496–503. IEEE (2019)
11. Hess, Z., Malahov, Y., Pettersson, J.: Æternity blockchain. https://aeternity.com/
aeternity-blockchainwhitepaper.pdf (2017)
12. Li, K., Tang, Y., Chen, J., Yuan, Z., Xu, C., Xu, J.: Cost-effective data feeds to
blockchains via workload-adaptive data replication (2019)
https://s3.amazonaws.com/whitepaper.dos/DOS
https://s3.amazonaws.com/whitepaper.dos/DOS
https://ethereum.org/en/whitepaper/
https://docs.provable.xyz/
https://doi.org/10.1007/978-3-319-70278-0_35
https://doi.org/10.1007/978-3-319-70278-0_35
https://www.coindesk.com/three-smart-contract-misconceptions
https://www.coindesk.com/three-smart-contract-misconceptions
https://aeternity.com/aeternity-blockchainwhitepaper.pdf
https://aeternity.com/aeternity-blockchainwhitepaper.pdf
468 X. Wu et al.
13. Mammadzada, K., Iqbal, M., Milani, F., Garćıa-Bañuelos, L., Matulevičius, R.:
Blockchain oracles: a framework for blockchain-based applications. In: Asatiani,
A., et al. (eds.) BPM 2020. LNBIP, vol. 393, pp. 19–34. Springer, Cham (2020).
https://doi.org/10.1007/978-3-030-58779-6 2
14. Moudoud, H., Cherkaoui, S., Khoukhi, L.: An IoT blockchain architecture using
oracles and smart contracts: the use-case of a food supply chain. In: 2019 IEEE
30th Annual International Symposium on Personal, Indoor and Mobile Radio Com-
munications (PIMRC), pp. 1–6. IEEE (2019)
15. Myerson, R.: Game Theory: Analysis of Conflict. Harvard University Press, Cam-
bridge (1991)
16. Osborne, M.J.: An Introduction to Game Theory. New York vol. 3 (2004)
17. Osborne, M.J., Rubinstein, A.: A Course in Game Theory. MIT Press, Cambridge
(1994)
18. Pasdar, A., Dong, Z., Lee, Y.C.: Blockchain oracle design patterns. arXiv preprint
arXiv:2106.09349 (2021)
19. de Pedro, A.S., Levi, D., Cuende, L.I.: Witnet: a decentralized oracle network
protocol. arXiv preprint arXiv:1711.09756 (2017)
20. Peterson, J., Krug, J., Zoltu, M., Williams, A.K., Alexander, S.: Augur: a decen-
tralized oracle and prediction market platform. arXiv preprint arXiv:1501.01042
(2015)
21. Ritzdorf, H., Wüst, K., Gervais, A., Felley, G., Capkun, S.: Tls-n: non-repudiation
over tls enabling-ubiquitous content signing for disintermediation. Cryptology
ePrint Archive (2017)
22. Ellis, S., Juels, A., Nazarov, S.: Chainlink: a decentralized oracle network, March
2017
23. Solidity, E.: Solidity documentation (2017)
24. Van Bulck, J., et al.: Foreshadow: extracting the keys to the intel {SGX} kingdom
with transient out-of-order execution. In: 27th {USENIX} Security Symposium
({USENIX} Security 18), pp. 991–1008 (2018)
25. Van Mölken, R.: Blockchain across Oracle: Understand the details and Implications
of the Blockchain for Oracle Developers and Customers. Packt Publishing Ltd,
Birmingham (2018)
26. Wan, Z., Guan, Z., Zhou, Y., Ren, K.: zk-authfeed: how to feed authenticated data
into smart contract with zero knowledge. In: 2019 IEEE International Conference
on Blockchain (Blockchain) (2019)
27. Weisse, O., et al.: Foreshadow-ng: breaking the virtual memory abstraction with
transient out-of-order execution (2018)
28. Xu, X., et al.: The blockchain as a software connector. In: 2016 13th Working
IEEE/IFIP Conference on Software Architecture (WICSA), pp. 182–191. IEEE
(2016)
29. Xu, X., Weber, I., Staples, M.: Blockchain Patterns. In: Architecture for Blockchain
Applications, pp. 113–148. Springer, Cham (2019). https://doi.org/10.1007/978-
3-030-03035-3 7
30. Yamashita, K., Nomura, Y., Zhou, E., Pi, B., Jun, S.: Potential risks of hyperledger
fabric smart contracts. In: 2019 IEEE International Workshop on Blockchain Ori-
ented Software Engineering (IWBOSE), pp. 1–10. IEEE (2019)
31. Zhang, F., Cecchetti, E., Croman, K., Juels, A., Shi, E.: Town crier: an authen-
ticated data feed for smart contracts. In: Proceedings of the 2016 aCM sIGSAC
Conference on Computer and Communications Security, pp. 270–282 (2016)
https://doi.org/10.1007/978-3-030-58779-6_2
http://arxiv.org/abs/2106.09349
http://arxiv.org/abs/1711.09756
http://arxiv.org/abs/1501.01042
https://doi.org/10.1007/978-3-030-03035-3_7
https://doi.org/10.1007/978-3-030-03035-3_7
	CCOM: Cost-Efficient and Collusion-Resistant Oracle Mechanism for Smart Contracts*-12pt
	1 Introduction
	2 Preliminaries
	2.1 Games and Strategies
	2.2 Sequential Equilibrium
	2.3 Smart Contract and Oracle
	3 The Architechture of CCOM
	3.1 Adversary Model and Assumption
	3.2 The System Architecture of CCOM
	3.3 Monetary Variables
	3.4 The Prisoner's Contract
	4 Discussion and Analysis
	5 Implementation
	5.1 Cryptographic Primitives - HASH Function
	5.2 Overhead and Cost
	6 Related Work
	7 Conclusion
	References