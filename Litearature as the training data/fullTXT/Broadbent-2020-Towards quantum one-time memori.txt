Towards Quantum One-Time Memories from Stateless Hardware
Towards Quantum One-Time Memories from
Stateless Hardware
Anne Broadbent
Department of Mathematics and Statistics, University of Ottawa, Canada
abroadbe@uottawa.ca
Sevag Gharibian
Department of Computer Science, Paderborn University, Germany
Department of Computer Science, Virginia Commonwealth University, Richmond, VA, USA
sevag.gharibian@upb.de
Hong-Sheng Zhou
Department of Computer Science, Virginia Commonwealth University, Richmond, VA, USA
hszhou@vcu.edu
Abstract
A central tenet of theoretical cryptography is the study of the minimal assumptions required to
implement a given cryptographic primitive. One such primitive is the one-time memory (OTM),
introduced by Goldwasser, Kalai, and Rothblum [CRYPTO 2008], which is a classical functionality
modeled after a non-interactive 1-out-of-2 oblivious transfer, and which is complete for one-time
classical and quantum programs. It is known that secure OTMs do not exist in the standard model in
both the classical and quantum settings. Here, we propose a scheme for using quantum information,
together with the assumption of stateless (i.e., reusable) hardware tokens, to build statistically
secure OTMs. Via the semidefinite programming-based quantum games framework of Gutoski
and Watrous [STOC 2007], we prove security for a malicious receiver, against a linear number of
adaptive queries to the token, in the quantum universal composability framework, but leave open
the question of security against a polynomial amount of queries. Compared to alternative schemes
derived from the literature on quantum money, our scheme is technologically simple since it is of the
“prepare-and-measure” type. We also show our scheme is “tight” according to two scenarios.
2012 ACM Subject Classification Theory of computation → Cryptographic protocols
Keywords and phrases quantum cryptography, one-time memories, semi-definite programming
Digital Object Identifier 10.4230/LIPIcs.TQC.2020.6
Related Version A full version of the paper is available at https://arxiv.org/abs/1810.05226.
Funding Anne Broadbent: U.S. Air Force Office of Scientific Research under award number FA9550-
17-1-0083, Canada’s NSERC, Ontario ERA, and the University of Ottawa’s Research Chairs program.
Sevag Gharibian: NSF grants CCF-1526189 and CCF-1617710.
Acknowledgements We thank referees for pointing out the impossibility result against quantum
queries applies only if we model the token as a reversible process, as well as for finding an error in a
prior version of this work. We thank Kai-Min Chung and Jamie Sikora for related discussions.
1 Introduction
Theoretical cryptography centers around building cryptographic primitives secure against
adversarial attacks. In order to allow a broader set of such primitives to be implemented,
one often considers restricting the power of the adversary. For example, one can limit the
computing power of adversaries to be polynomial bounded [68, 7], restrict the storage of
adversaries to be bounded or noisy [49, 11, 22], or make trusted setups available to honest
players [39, 6, 14, 16, 36, 55, 42, 46, 47, 48, 41, 40], to name a few. One well-known trusted
© Anne Broadbent, Sevag Gharibian, and Hong-Sheng Zhou;
licensed under Creative Commons License CC-BY
15th Conference on the Theory of Quantum Computation, Communication and Cryptography (TQC 2020).
Editor: Steven T. Flammia; Article No. 6; pp. 6:1–6:25
Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany
mailto:abroadbe@uottawa.ca
mailto:sevag.gharibian@upb.de
mailto:hszhou@vcu.edu
https://doi.org/10.4230/LIPIcs.TQC.2020.6
https://arxiv.org/abs/1810.05226
https://creativecommons.org/licenses/by/3.0/
https://www.dagstuhl.de/lipics/
https://www.dagstuhl.de
6:2 Quantum OTMs from Stateless Hardware
setup is tamper-proof hardware [38, 30], which is assumed to provide a specific input-output
functionality, and which can only be accessed in a “black box” fashion. The hardware
can maintain a state (i.e., is stateful) and possibly carry out complex functionality, but
presumably may be difficult or expensive to implement or manufacture. This leads to an
interesting research direction: Building cryptography primitives using the simplest (and
hence easiest and cheapest to manufacture) hardware.
In this respect, two distinct simplified notions of hardware have captured considerable
interest. The first is the notion of a one-time memory (OTM) [30], which is arguably the
simplest possible notion of stateful hardware. An OTM, modeled after a non-interactive
1-out-of-2 oblivious transfer, behaves as follows: first, a player (called the sender) embeds
two values s0 and s1 into the OTM, and then gives the OTM to another player (called
the receiver). The receiver can now read his choice of precisely one of s0 or s1; after
this “use” of the OTM, however, the unread bit is lost forever. Interestingly, OTMs are
complete for implementing one-time use programs (OTPs): given access to OTMs, one can
implement statistically secure OTPs for any efficiently computable program in the universal
composability (UC) framework [32]. (OTPs, in turn, have applications in software protection
and one-time proofs [30].) In the quantum UC model, OTMs enable quantum one-time
programs [9]. (This situation is analogous to the case of oblivious transfer being complete for
two-party secure function evaluation [39, 36].) Unfortunately, OTMs are inherently stateful,
and thus represent a very strong cryptographic assumption – any physical implementation of
such a device must somehow maintain internal knowledge between activations, i.e., it must
completely “self-destruct” after a single use.
This brings us to a second important simplified notion of hardware known as a stateless
token [17], which keeps no record of previous interactions. On the positive side, such hardware
is presumably easier to implement. On the negative side, an adversary can run an experiment
with stateless hardware as many times as desired, and each time the hardware is essentially
“reset”. (Despite this, stateless hardware has been useful in achieving computationally secure
multi-party computation [17, 32, 19], and statistically secure commitments [23].) It thus
seems impossible for stateless tokens to be helpful in implementing any sort of “self-destruct”
mechanism. Indeed, classically stateful tokens are trivially more powerful than stateless ones,
as observed in, e.g., [32]. This raises the question:
Can quantum information, together with a classical stateless token, be used to simulate
“self destruction” of a hardware token?
In particular, a natural question along these lines is whether quantum information can help
implement an OTM. Unfortunately, it is known that quantum information alone cannot
implement an OTM (or, more generally, any one-time program) [9]; see also Section 4 below.
We thus ask the question: What are the minimal cryptographic assumptions required in a
quantum world to implement an OTM?
1.1 Contributions and summary of techniques
We propose what is, to our knowledge, the first prepare-and-measure quantum protocol that
constructs OTMs from stateless hardware tokens. For this protocol, we are able to rigorously
prove information theoretic security against an adversary making a linear (in n, the security
parameter) number of adaptive queries to the token. While we conjecture that security holds
also for polynomially many queries, note that already in this setting of linearly many adaptive
queries, our protocol achieves something impossible classically (i.e., classically, obtaining
security against a linear number of queries is impossible). We also show stand-alone security
against a malicious sender.
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:3
Historical Note. We proposed the concept that quantum information could provide a
“stateless to stateful” transformation in a preliminary version of this work [8]; however, that
work claimed security against a polynomial number of token queries, obtained via a reduction
from the interactive to the non-interactive setting. We thank an anonymous referee for
catching a subtle, but important bug which ruled out the proof approach of [8]. The current
paper employs a different proof approach, which models interaction with the token as a
“quantum game” via semidefinite programming. Since our original paper was posted, recent
work [20] has shown an alternate quantum “stateful to stateless” transformation via quantum
money constructions [3]. Specifically, in [20], security against a polynomial number of queries
is achieved, albeit with respect to a new definition of “OTMs relative to an oracle” (while the
security results of the present paper are with respect to the well-established simulation-based
definition of [32, 38]). Furthermore, [20] directly applies known quantum money constructions,
which require difficult-to-prepare highly entangled states. Our focus here, in contrast, is to
take a “first-principles” approach and build a technologically simple-to-implement scheme
which requires no entanglement, but rather the preparation of just one of four single qubit
states, |0〉, |1〉, |+〉, |−〉. Indeed, the two works are arguably complementary in that the former
focuses primarily on applications of “stateful” single-use tokens, while our focus is on the
most technologically simple way to implement such “stateful” tokens.
Construction. Our construction is inspired by Wiesner’s conjugate coding [65]: the quantum
portion of the protocols consists in n quantum states chosen uniformly at random from
{|0〉, |1〉, |+〉, |−〉} (note this encoding is independent of the classical bits of the OTM func-
tionality). We then couple this n-qubit quantum state, |ψ〉 (the quantum key) with a classical
stateless hardware token, which takes as inputs a choice bit b, together with an n-bit string y.
If b = 0, the hardware token verifies that the bits of y that correspond to rectilinear (|0〉
or |1〉, i.e., Z basis) encoded qubits of |ψ〉 are consistent with the measurement of |ψ〉 in
the computational basis, in which case the bit s0 is returned. If b = 1, the hardware token
verifies that the bits of y that correspond to diagonal (|+〉 or |−〉, i.e., X basis) encoded
qubits of |ψ〉 are consistent with the measurement of |ψ〉 in the diagonal basis, in which case
the bit s1 is returned.1 The honest use of the OTM is thus intuitive: for choice bit b = 0,
the user measures each qubit of the quantum key in the rectilinear basis to obtain an n-bit
string y, and inputs (b, y) into the hardware token. If b = 1, the same process is applied, but
with measurements in the diagonal basis.
Assumption. Crucially, we assume the hardware token accepts classical input only (al-
ternatively and equivalently, the token immediately measures its quantum input in the
standard basis), i.e., it cannot be queried in superposition. Although this may seem a strong
assumption, in Section 4 we show that any token which can be queried in superposition in a
reversible way, cannot be used to construct a secure OTM (with respect to our setting in
which the adversary is allowed to apply arbitrary quantum operations). Similar classical-input
hardware has previously been considered in, e.g., [60, 9].
Security and intuition. Stand-alone security against a malicious sender is relatively simple
to establish, since the protocol consists in a single message from the sender to the receiver,
and stand-alone security only requires simulation of the local view of the adversary.
1 We note that a simple modification using a classical one-time pad could be used to make both the
quantum state and hardware token independent of s0 and s1: the token would output one of two
uniformly random bits r0 and r1, which could each be used to decrypt a single bit, s0 or s1.
TQC 2020
6:4 Quantum OTMs from Stateless Hardware
The intuition underlying security against a malicious receiver is clear: in order for a
receiver to extract a bit sb as encoded in the OTM, she must perform a complete measurement
of the qubits of |ψ〉 in order to obtain a classical key for sb (since, otherwise, she would likely
fail the test as imposed by the hardware token). But such a measurement would invalidate the
receiver’s chance of extracting the bit s1−b! This is exactly the “self-destruct”-like property
we require in order to implement an OTM. This intuitive notion of security was present in
Wiesner’s proposal for quantum money [65], and is often given a physical explanation in
terms of the no-cloning theorem [67] or Heisenberg uncertainty relation [35].
Formally, we work in the statistical (i.e., information-theoretic) setting of the quantum
Universal Composability (UC) framework [59], which allows us to make strong security
statements that address the composability of our protocol within others. As a proof technique,
we describe a simulator, such that for any “quantum environment” wishing to interact with
the OTM, the environment statistically cannot tell whether it is interacting with the ideal
OTM functionality or the real OTM instance provided by our scheme. The security of this
simulator requires a statement of the following form: Given access to a (randomly chosen)
“quantum key” |ψk〉 and corresponding stateless token Vk, it is highly unlikely for an adversary
to successfully extract keys for both the secret bits s0 and s1 held by Vk. We are able to
show this statement for any adversary which makes a linear number of queries, by which we
mean an adversary making m queries succeeds with probability at most O(22m−0.228n) (for
n the number of quantum key bits in |ψk〉). In other words, if the adversary makes at most
m = cn queries with c < 0.114, then its probability of cheating successfully is exponentially
small in n. We conjecture, however, that a similar statement holds for any m ∈ poly(n), i.e.,
that the protocol is secure against polynomially many queries.
To show security against linearly many queries, we exploit the semidefinite programming-
based quantum games framework of Gutoski and Watrous (GW) [33] to model interaction
with the token. Intuitively, GW is useful for our setting, since it is general enough to model
multiple rounds of adaptive queries to the token, even when the receiver holds quantum “side
information” in the form of |ψ〉. We describe this technique in Sections 2.1 and 3.4, and
provide formal details in the full version. Summarizing, we show the following.
I Main Theorem (informal). There exists a protocol Π, which together with a classical
stateless token and the ability to randomly prepare single qubits in one of four pure states,
implements the OTM functionality with statistical security in the UC framework against a
corrupted receiver making a linear number of adaptive queries.
As stated above, we conjecture that our protocol is actually secure against polynomially
many adaptive queries. However, we are unable to show this claim using our present proof
techniques, and hence leave this question open. Related to this, we make the following
comments: (1) As far as we are aware, the Main Theorem above is the only known formal
proof of any type of security for conjugate coding in the interactive setting with Ω(1) queries.
Moreover, as stated earlier, classically security against Ω(1) queries is trivially impossible. (2)
Our proof introduces the GW semidefinite programming framework from quantum interactive
proofs to the study of conjugate coding-based schemes. This framework allows handling
multiple challenges in a unified fashion: arbitrary quantum operations by the user, classical
queries to the token, and the highly non-trivial assumption of quantum side information for
the user (the “quantum key” state sent to the user.)
Towards security against polynomially many queries. Regarding the prospects of proving
security against polynomially many adaptive queries, we generally believe it requires a
significant new insight into how to design a “good” feasible solution to the primal semidefinite
program (SDP) obtained via GW. However, in addition to our proof for linear security, in the
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:5
full version we give evidence potentially supporting our conjecture for polynomial security.
Namely, we first simplify the SDPs obtained from GW, and derive the corresponding dual
SDPs. These derivations apply for any instantiation of the GW framework, i.e. they are
not specific to our setting, and hence may prove useful elsewhere. We then give a feasible
solution Y to the dual SDP. While Y is simple to state, it is somewhat involved to analyze.
A heuristic analysis suggests Y ’s dual objective function value has precisely the behavior
needed to show security, i.e. the value scales as m/
√
2n, for m queries and n key bits. If Y
were to be the optimal solution to the dual SDP, this would strongly suggest the optimal
cheating probability is essentially m/
√
2n. However, we explicitly show Y is not optimal,
and so m/
√
2n is only a lower bound on the optimal cheating probability. Nevertheless, we
conjecture that while Y is not optimal, it is approximately optimal; this would imply the
desired polynomial security claim. Unfortunately, the only techniques we are aware of to show
approximate optimality require a better primal SDP solution, which appears challenging.
Further related work. Our work contributes to the growing list of functionalities achievable
with quantum information, yet unachievable classically. This includes: unconditionally
secure key expansion [4], physically uncloneable money [65, 51, 53], a reduction from obli-
vious transfer to bit commitment [5, 21] and to other primitives such as “cut-and choose”
functionality [27], and revocable time-release quantum encryption [61]. Importantly, these
protocols all make use of the technique of conjugate coding [65], which is also an important
technique used in protocols for OT in the bounded quantum storage and noisy quantum
storage models [22, 63] (see [10] for a survey).
Various proof techniques have been developed in the context of conjugate coding, including
entropic uncertainty relations [64]. In the context of QKD, another technique is the use of
de Finetti reductions [58] (which exploit the symmetry of the scheme in order to simplify
the analysis). Recently, semidefinite programming (SDP) approaches have been applied to
analyze security of conjugate coding [51] for quantum money, in the setting of one round of
interaction with a “stateful” bank. SDPs are also the technical tool we adopt for our proof
(Section 3.4), though here we require the more advanced quantum games SDP framework of
Gutoski and Watrous [33] to deal with multiple adaptive interactions with stateless tokens.
Reference [53] has also made use of Gavinsky’s [28] quantum retrieval games framework.
Somewhat similar to [53], Aaronson and Christiano [1] have studied quantum money
schemes in which one interacts with a verifier. They introduce an “inner product adversary
method” to lower bound the number of queries required to break their scheme.
We remark that [53] and [51] have studied schemes based on conjugate coding similar to
ours, but in the context of quantum money. In contrast to our setting, the schemes of [53]
and [51] (for example) involve dynamically chosen random challenges from a verifier to the
holder of a “quantum banknote”, whereas in our work here the “challenges” are fixed (i.e.,
measure all qubits in the Z or X basis to obtain secret bit s0 or s1, respectively), and the
verifier is replaced by a stateless token. Thus, [51], for example, may be viewed as using a
“stateful” verifier, whereas our focus here is on a “stateless” verifier (i.e., a token).
Also, prior work has achieved oblivious transfer using quantum information, together with
some assumption (e.g., bit commitment [5], bounded quantum storage [22]). These protocols
typically use an interaction phase similar to the “commit-and-open” protocol of [5]; because
we are working in the non-interactive setting, these techniques appear to be inapplicable.
Finally, Liu [43, 44, 45] has given stand-alone secure OTMs using quantum information
in the isolated-qubit model. Liu’s approach is nice in that it avoids the use of trusted setups.
In return, however, Liu must use the isolated-qubit model, which restricts the adversary to
TQC 2020
6:6 Quantum OTMs from Stateless Hardware
perform only single-qubit operations (no entangling gates are permitted); this restriction
is, in some sense, necessary if one wants to avoid trusted setups, as a secure OTM in the
plain quantum model cannot exist (see Section 4). In contrast, in the current work we
allow unbounded and unrestricted quantum adversaries, but as a result require a trusted
setup. In addition, we remark the security notion of OTMs of [43, 44, 45] is weaker than the
simulation-based notion studied in this paper, and it remains an interesting open question
whether the type of OTM in [43, 44, 45] is secure under composition (in the current work,
the UC framework gives us security under composition for free).
Significance. Our results show a strong separation between the classical and quantum
settings, since classically, stateless tokens cannot be used to securely implement OTMs. To
the best of our knowledge, our work is the first to combine conjugate coding with stateless
hardware tokens. Moreover, while our protocol shares similarities with prior work in the
setting of quantum money, building OTMs appears to be a new focus here 2.
Our protocol has a simple implementation, fitting into the single-qubit prepare-and-
measure paradigm, which is widely used as the “benchmark” for a “physically feasible”
quantum protocol (in this model, one needs only the ability to prepares single-qubit states
|0〉, |1〉, |+〉, |−〉, and to perform single-qubit projective measurements. In particular, no
entangled states are required, and in principle no quantum memory is required, since qubits
can be measured one-by-one as they arrive). In addition, from a theoretical cryptographic
perspective, our protocol is attractive in that its implementation requires an assumption of a
stateless hardware token, which is easier and cheaper to mass produce than a stateful token.
In terms of security guarantees, we allow arbitrary operations on behalf of a malicious
quantum receiver in our protocol (i.e., all operations allowed by quantum mechanics), with
the adversary restricted in that the stateless token is assumed only usable as a black box.
The security we obtain is statistical, with the only computational assumption being on the
number of queries made to the token (recall we show security for a linear number of queries,
and conjecture security for polynomially many queries). Finally, our security analysis is in
the quantum UC framework against a corrupted receiver; this means our protocol can be
easily composed with many others; for example, combining our results with [9]’s protocol
immediately yields UC-secure quantum OTPs against a dishonest receiver.
Finally, our scheme is “tight” with respect to two impossibility results (Section 4), both of
which assume the adversary has black-box access to both the token and its inverse operation3.
First, the assumption that the token be queried only in the computational basis cannot be
relaxed: If the token can be queried in superposition, then an adversary can easily break an
OTM scheme. Second, our scheme has the property that corresponding to each secret bit si
held by the token, there are exponentially many valid keys one can input to the token to
extract si. We show that for any “measure-and-access” OTM (i.e., an OTM in which one
measures a given quantum key and uses the classical measurement result to access a token
to extract data, of which our protocol is an example), a polynomial number of keys implies
the ability to break the scheme with inverse polynomial probability (more generally, ∆ keys
allows probability at least 1/∆2 of breaking the scheme).
2 We remark, however, that a reminiscent concept of single usage of quantum “tickets” in the context of
quantum money is very briefly mentioned in Appendix S.4.1 of [53].
3 This is common in the oracle model of quantum computation, where a function f : {0, 1}n 7→ {0, 1} is
implemented via the (self-inverse) unitary mapping Uf |x〉|y〉 = |x〉|y ⊕ f(x)〉.
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:7
Open Questions. While our work shows the fundamental advantage that quantum inform-
ation yields in a stateful to stateless reduction, it does leave a number of open questions:
1. Security against polynomially many queries. Can our security proof be streng-
thened to show information theoretic security against a polynomial number of queries to
the token? We conjecture this to be the case, but finding a formal proof has been elusive.
2. Composable security against a malicious sender. While we show composable
security against a malicious receiver, our protocol can achieve standalone security against
a malicious sender. Could an adaptation of our protocol ensure composable security
against a malicious sender as well?4
3. Non-reversible token. Our impossibility result for quantum one-time memories with
quantum queries (Section 4) assumes the adversary has access to reversible tokens; can a
similar impossibility result be shown for non-reversible tokens? In Section 4, we briefly
discuss why it may be difficult to extend the techniques of our impossibility results
straightforwardly when the adversary does not have access to the inverse of the token.
4. Imperfect devices. While our prepare-and-measure scheme is technologically simple, it
is still unrealizable with current technology, due to the requirement of perfect quantum
measurements. We leave open the question of tolerance to a small amount of noise.
Organization. Section 2 covers preliminaries, including ideal functionalities for an OTM
and stateless token, background on quantum channels, semidefinite programming, and the
Gutoski-Watrous (GW) framework for quantum games. Section 3 gives our construction for
an OTM based on a stateless hardware token; the proof ideas for security are also provided.
Section 4 discusses “tightness” of our construction by showing two impossibility results for
“relaxations” of our scheme. In the Appendix, we discuss classical UC and quantum UC
(Appendix A); Appendix B establishes notation required in the definition of stand-alone
security against a malicious sender. Due to space constraints, our formal security proof
against a linear number of queries to the token (used to finish the security proof in Section 3)
is deferred to the full version, along with simplifications of the GW SDP, derivation of its
dual, and a dual feasible solution which we conjecture to be approximately optimal.
2 Preliminaries
Notation. Two binary distributions X and Y are indistinguishable, denoted X ≈ Y, if
|Pr(Xn = 1)− Pr(Yn = 1)| ≤ negl(n). We define single-qubit |0〉+ = |0〉 and |1〉+ = |1〉, so
that {|0〉+, |1〉+} form the rectilinear basis. We define |0〉× = 1√
2 (|0〉+|1〉) and |1〉× = 1√
2 (|0〉−
|1〉), so that {|0〉×, |1〉×} form the diagonal basis. For strings x = x1, x2, . . . xn ∈ {0, 1}n and
θ = θ1, θ2, . . . , θn ∈ {+,×}n, define |x〉θ =
⊗n
i=1 |xi〉θi
. For X a finite dimensional complex
Hilbert space, L(X ), Herm(X ), Pos(X ), and D(X ) denote the sets of linear, Hermitian,
positive semidefinite, and density operators acting on X , respectively. Notation A � B
means A−B is positive semidefinite.
Quantum universal composition (UC) framework. We study simulation-based security in
this paper. In particular, we prove security of our construction against a malicious receiver in
the quantum universal composition (UC) framework [59]. See Appendix A for a description
of classical UC [14] and quantum UC [59]. In the next two paragraphs, we introduce the
ideal functionalities of one-time memory and stateless hardware token.
4 We note that this would require a different protocol, since in our current construction, a cheating sender
could program the token to abort based on the user’s input.
TQC 2020
6:8 Quantum OTMs from Stateless Hardware
One-time memory (OTM). The one-time memory (OTM) functionality FOTM involves two
parties, the sender and the receiver, and consists of two phases, “Create” and “Execute”.
Please see Functionality 1 below for details; for the sake of simplicity, we have omitted the
session/party identifiers as they should be implicitly clear from the context. We sometimes
refer to this functionality FOTM as an OTM token.
Functionality 1 Ideal functionality FOTM.
1. Create: Upon input (s0, s1) from the sender, with s0, s1 ∈ {0, 1}, send create to the
receiver and store (s0, s1).
2. Execute: Upon input b ∈ {0, 1} from the receiver, send sb to receiver. Delete any trace
of this instance.
Stateless hardware. The original work of Katz [38] introduces the ideal functionality Fwrap
to model stateful tokens in the UC-framework. In the ideal model, a party that wants to
create a token, sends the Turing machine to Fwrap. Fwrap will then run the machine (keeping
the state), when the designated party will ask for it. The same functionality can be adapted to
model stateless tokens. It is sufficient that the functionality does not keep the state between
two executions. A simplified version of the Fwrap functionality as shown in [17] (that is very
similar to the Fwrap of [38]) is described below. Note that, again for the sake of simplicity,
we have omitted the session/party identifiers as they should be implicitly clear from the
context. Although the environment and adversary are unbounded, we specify that stateless
Functionality 2 Ideal functionality Fwrap.
The functionality is parameterized by a polynomial p(·), and implicit security parameter n.
1. Create: Upon input (create,M) from the sender, where M is a Turing machine, send
create to the receiver and store M .
2. Execute: Upon input (run,msg) from the receiver, execute M(msg) for at most p(n)
steps, and let out be the response. Let out := ⊥ if M does not halt in p(n) steps. Send
out to the receiver.
hardware can be queried only a polynomial number of times. This is necessary; otherwise the
hardware token model is vacuous (with unbounded queries, the entire input-output behavior
of stateless hardware can be extracted).
Quantum channels. A linear map Φ : L(X ) 7→ L(Y) is a quantum channel if Φ is trace-
preserving and completely positive (TPCP). Such maps take density operators to density
operators. A useful representation of linear maps (or “superoperators”) Φ : L(X ) 7→ L(Y)
is the Choi-Jamiołkowski representation, J(Φ) ∈ L(Y ⊗ X ). The latter is defined (with
respect to some choice of orthonormal basis {|i〉} for X ) as J(Φ) =
∑
i,j Φ(|i〉〈j|) ⊗ |i〉〈j|.
The following properties of J(Φ) hold [18, 37]: (1) Φ is completely positive if and only if
J(Φ) � 0, and (2) Φ is trace-preserving if and only if TrY(J(Φ)) = IX . In a nutshell, the
Gutoski-Watrous (GW) framework generalizes this definition to interacting strategies [33].
Semidefinite programs. We review semidefinite programs (SDPs) from the perspective of
quantum information, as done e.g., in the notes of Watrous [62] or [51]. Given any 3-tuple
(A,B,Φ) for operators A ∈ Herm(X ) and B ∈ Herm(Y), and Hermiticity-preseving linear
map Φ : L(X ) 7→ L(Y), one can state a primal and dual semidefinite program:
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:9
ρ0
Φ1
Ψ1
Φ2
Ψ2
Φm
Ψm
X1
W0 W1
Y1 X2
Z1
Ym
Zm
Wm
Figure 1 A general interaction between two quantum parties.
Primal problem (P)
sup Tr(AX)
s.t. Φ(X) = B,
X ∈ Pos(X ),
Dual problem (D)
inf Tr(BY )
s.t. Φ∗(Y ) � A
Y ∈ Herm(Y),
where Φ∗ denotes the adjoint of Φ, which is the unique map satisfying Tr(A†Φ(B)) =
Tr((Φ∗(A))†B) for all A ∈ L(Y) and B ∈ L(X ). Not all SDPs have feasible solutions (i.e. a
solution satisfying all constraints); in this case, optimal values are −∞ for P and ∞ for D.
2.1 The Gutoski-Watrous framework for quantum games
We now recall the Gutoski-Watrous (GW) framework for quantum games [33], which can be
used to model quantum interactions between spatially separated parties. The setup most
relevant to our protocol here is depicted in Figure 1. Here, we imagine one party, A, prepares
an initial state ρ0 ∈ D(X1 ⊗ W0). Register X1 is then sent to the second party (W0 is
kept as private memory), B, who applies some quantum channel Φi : L(X1) 7→ L(Y1 ⊗Z1).
B keeps register Z1 as private memory, and sends Y1 back to A, who applies channel
Ψ1 : L(W0 ⊗Y1) 7→ L(X2 ⊗W1), and sends X2 to B. The protocol continues for m messages
back and forth, until the final operation Ψm : L(Wm ⊗ Ym) 7→ C, in which A performs
a two-outcome measurement (specifically, a POVM Λ = {Λ0,Λ1}, meaning Λ0,Λ1 � 0,
Λ0 + Λ1 = I) in order to decide whether to reject (Λ0) or accept (Λ1). As done in [33],
without loss of generality (by the Stinespring dilation theorem) all channels are given by linear
isometries Ak, i.e. Φk(X) = AkXA
†
k. Reference [33] refers to (Φ1, . . . ,Φm) as a strategy and
(ρ0,Ψ1, . . . ,Ψm) as a co-strategy. In our setting, the former is “non-measuring”, meaning it
makes no final measurement after Φm is applied, whereas the latter is “measuring”, since we
will apply a final measurement on space Wm (not depicted in Figure 1).
Intuitively, since our protocol (Section 3.1) begins with the token sending the user a
quantum key |x〉θ, we will model the token as a measuring co-strategy, and the user as
a strategy. The advantage to doing so is that the GW framework allows one to (recurs-
ively) characterize any such strategy (resp., co-strategy) via a set of linear (in)equalities
and positive semi-definite constraints. (In this sense, the GW framework generalizes the
Choi-Jamiołkowski representation for channels to a “Choi-Jamiołkowski” representation
for strategies/co-strategies.) To state these constraints, we first write down the Choi-
Jamiołkowski (CJ) representation of a strategy (resp., measuring co-strategy) from [33].
CJ representation of (non-measuring) strategy. The CJ representation of a strategy
(A1, . . . , Am) is given by matrix [33]
TrZm
(vec(A) vec(A)†), (1)
TQC 2020
6:10 Quantum OTMs from Stateless Hardware
where A ∈ L(X1 ⊗ · · · ⊗ Xm,Y1 ⊗ · · · ⊗ Ym ⊗Zm) is the product of the isometries Ai,
A := (IY1⊗···⊗Ym−1 ⊗Am) · · · (A1 ⊗ IX2⊗···⊗Xm
), (2)
and the vec : L(S, T ) 7→ T ⊗ S mapping is the linear extension of the map |i〉〈j| 7→ |i〉|j〉
defined on all standard basis states |i〉, |j〉.
CJ representation of (measuring) co-strategy. Let P := {Λ0,Λ1} denote a POVM with
reject and accept measurement operators Λ0 and Λ1, respectively. A measuring strategy
which ends with a measurement via POVM Λ replaces, for Λa ∈ Λ, Equation (1) with [33]
Qa := TrZm((Λa ⊗ IY1⊗···⊗Ym) vec(A) vec(A)†) = TrZm(vec(Ba) vec(Ba)†), (3)
for Ba := (
√
Λa ⊗ IY1⊗···⊗Ym
)A. To convert this to a co-strategy, one takes the transpose of
the operators defined above (with respect to the standard basis).
Optimization characterization over strategies and co-strategies. With CJ representations
for strategies and co-strategies in hand, one can formulate [33] the optimal probability with
which a strategy can force a corresponding co-strategy to output a desired result as follows.
Fix any Qa from a measuring co-strategy {Q0, Q1}, as in Equation (3). Then, Corollary 7
and Theorem 9 of [33] show that the maximum probability with which a (non-measuring)
strategy can force the co-strategy to output result a is given by
min: p (4)
subject to: Qa � pRm (5)
Rk = Pk ⊗ IYk
for 1 ≤ k ≤ m (6)
TrXk
(Pk) = Rk−1 for 1 ≤ k ≤ m (7)
R0 = 1 (8)
Rk ∈ Pos(Y1,...,k ⊗X1,...,k) for 1 ≤ k ≤ m (9)
Pk ∈ Pos(Y1,...,k−1 ⊗X1,...,k) for 1 ≤ k ≤ m (10)
p ∈ [0, 1] (11)
Intuition. The minimum p denotes the optimal “success” probability, meaning the optimal
probability of forcing the co-strategy to output a (Theorem 9 of [33]). The variables above,
in addition to p, are {Ri} and {Pi}, where the optimization is happening over all m-round
co-strategies Rm satisfying Equation (5). How do we enforce that Rm encodes such an
m-round co-strategy? This is given by the (recursive) Equations (6)-(10). Specifically,
Corollary 7 of [33] states that Rm is a valid m-round co-strategy if and only if all of the
following hold: (1) Rm � 0, (2) Rm = Pm ⊗ IYm
for Pm � 0 and Ym the last incoming
message register to the co-strategy, (3) TrXm
(Pm) is a valid m− 1 round co-strategy (this
is the recursive part of the definition). An intuitive sense as to why conditions (2) and (3)
should hold is as follows: For any m-round co-strategy Rm, let Rm−1 denote Rm restricted
to the first m − 1 rounds. Then, to operationally obtain Rm−1 from Rm, the co-strategy
first ignores the last incoming message in register Ym. This is formalized via a partial trace
over Ym, which (once pushed through the CJ formalism5) translates into the ⊗IYk
term
5 Recall that the CJ representation of the trace map is the identity matrix (up to scaling).
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:11
in Equation (6). Since the co-strategy is now ignoring the last incoming message Ym, any
measurement it makes after m− 1 rounds is independent of the last outgoing message Xm.
Thus, we can trace out Xm as well, obtaining a co-strategy Rm−1 on just the first m − 1
rounds; this is captured by Equation (7).
3 Feasibility of Quantum OTMs using Stateless Hardware
In this section, we present a quantum construction for one-time memories by using stateless
hardware (Section 3.1). We also state our main theorem (Theorem 1). In Section 3.3, we
describe the Simulator and prove Theorem 1 using the technical results of the full version.
The intuition and techniques behind the proofs in the full version are sketched in Section 3.4.
3.1 Construction
We now present the OTM protocol Π in the Fwrap hybrid model, between a sender Ps and a
receiver Pr. Here the security parameter is n.
Upon receiving input (s0, s1) from the environment where s0, s1 ∈ {0, 1}, the sender:
The sender chooses uniformly random x ∈R {0, 1}n and θ ∈R {+,×}n, and pre-
pares |x〉θ. Based on (s0, s1, x, θ), the sender prepares program M as in Program 1.
Program 1 Program for hardware token.
Hardcoded values: s0, s1 ∈ {0, 1}, x ∈ {0, 1}n, and θ ∈ {+,×}n
Inputs: y ∈ {0, 1}n and b ∈ {0, 1}, where y is a claimed measured value for the quantum
register, and b the evaluator’s choice bit
1. If b = 0, check that the θ = + positions return the correct bits in y according to x. If
Accept, output s0. Otherwise output ⊥.
2. If b = 1, check that the θ = × positions return the correct bits in y according to x. If
Accept, output s1. Otherwise output ⊥.
The sender sends |x〉θ to the receiver.
The sender sends (create,M) to functionality Fwrap, and the functionality sends create
to notify the receiver.
The receiver Pr operates as follows:
Upon input b from the environment, and |x〉θ from the receiver, and create notification
from Fwrap,
If b = 0, measure |x〉θ in computational basis to get y. Input (run, (y, b)) into Fwrap.
If b = 1, apply H⊗n to |x〉θ, then measure in computational basis to get y. Input
(run, (y, b)) into Fwrap.
Return the output of Fwrap to the environment.
It is easy to see that the output of Fwrap is sb for both b = 0 and b = 1.
Note again that the hardware token, as defined in Program 1, accepts only classical input
(i.e., it cannot be queried in superposition). As mentioned earlier, relaxing this assumption
yields impossibility of a secure OTM implementation (assuming the receiver also has access
to the token’s inverse operation), as shown in Section 4.
TQC 2020
6:12 Quantum OTMs from Stateless Hardware
3.2 Stand-Alone Security Against a Malicious Sender
We note that in protocol Π of Section 3.1, once the sender prepares and sends the token, she is
no longer involved (and in particular, the sender does not receive any further communication
from the receiver). We call such a protocol a one-way protocol. Because of this simple
structure, and because the ideal functionality Fwrap also does not return any message to the
sender, we can easily establish stand-alone security against a malicious sender (Appendix B).
3.3 UC-Security against a corrupt receiver
Our main theorem, which establishes security against a corrupt receiver is now stated.
I Theorem 1. Construction Π above quantum-UC-realizes FOTM in the Fwrap hybrid model
with statistical security against an actively-corrupted receiver making at most cn number of
adaptive queries to the token, for any fixed constant c < 0.114.
To prove Theorem 1, we now construct and analyze an appropriate simulator.
3.3.1 The simulator
In order to prove Theorem 1, for an adversary A that corrupts the receiver, we build a
simulator S (having access to the OTM functionality FOTM), such that for any unbounded
environment Z, the executions in the real model and that in simulation are statistically
indistinguishable. Our simulator S is given below:
The simulator emulates an internal copy of the adversary A who corrupts the receiver.
The simulator emulates the communication between A and the external environment Z
by forwarding the communication messages between A and Z.
The simulator S needs to emulate the whole view for the adversary A. First, S picks
dummy inputs s̃0 = 0 and s̃1 = 0, and randomly chooses x ∈ {0, 1}n, and θ ∈ {+,×}n,
and generates program M̃ . Then the simulator plays the role of the sender to send |x〉θ
to the adversary A (who controls the corrupted receiver). The simulator also emulates
Fwrap to notify A by sending create to indicate the hardware is ready for queries.
For each query (run, (b, y)) to Fwrap from the adversary A, the simulator evaluates program
M̃ (created based on s̃0, s̃1, x, θ) as in the construction, and then acts as follows:
1. If this is a rejecting input, output ⊥.
2. If this is the first accepting input, call the external FOTM with input b, and learn the
output sb from FOTM. Output sb.
3. If this is a subsequent accepting input, output sb (as above).
3.3.2 Analysis
We now show that the simulation and the real model execution are statistically indistinguish-
able. There are two cases in an execution of the simulation which we must consider:
Case 1: In all its queries to Fwrap, the accepting inputs of A have the same choice bit b.
In this case, the simulation is perfectly indistinguishable.
Case 2: In its queries to Fwrap, A produces accepting inputs for both b = 0 and b = 1. In
this case, it is possible that the simulation fails (the environment can distinguish the real
model from the ideal model), since the simulator is only able to retrieve a single bit from
the external OTM functionality FOTM (either corresponding to b = 0 or b = 1).
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:13
Thus, whereas in Case 1 the simulator behaves perfectly, in Case 2 it is in trouble. Fortunately,
in Theorem 2 we show that the probability that Case 2 occurs is exponentially small in n,
the number of qubits comprising |x〉θ, provided the number of queries to the token is at
most cn for any c < 0.114. Specifically, we show that for an arbitrary m-query strategy (i.e.,
any quantum strategy allowed by quantum mechanics, whether efficiently implementable
or not, which queries the token at most m times), the probability of Case 2 occurring is at
most O(22m−0.228n). This concludes the proof.
3.4 Security analysis for the token: Intuition
Our simulation proof showing statistical security of our Quantum OTM construction of
Section 3.1 relies crucially on Theorem 2, stated below. For this, we now introduce notation
in line with the formal analysis of the full version.
With respect to the construction of Section 3.1, let us replace each two-tuple (x, θ) ∈
{0, 1}n × {+,×}n by a single string z ∈ {0, 1}2n, which we denote the secret key. Bits 2i
and 2i + 1 of z specify the basis and value of conjugate coding qubit i for i ∈ {1, . . . , n}
(i.e., z2i = θi and z2i+1 = xi). Also, rename the “quantum key” (or conjugate coding key)
|ψz〉 := |x〉θ ∈ (C2)⊗n. Thus, the protocol begins by having the sender pick a secret key
z ∈ {0, 1}2n uniformly at random, and preparing a joint state
|ψ〉 = 1
2n
∑
z∈|0,1〉2n
|ψz〉R|z〉T . (12)
The first register, R, is sent to the receiver, while the second register, T , is kept by the token.
(Thus, the token knows the secret key z, and hence also which |ψz〉 the receiver possesses.)
The mixed state describing the receiver’s state of knowledge at this point is given by
ρR := 1
22n
∑
z∈{0,1}2n
|ψz〉〈ψz|.
I Theorem 2. Given a single copy of ρR, and the ability to make m (adaptive) queries to
the hardware token, the probability that an unbounded quantum adversary can force the token
to output both bits s0 and s1 scales as O(22m−0.228n).
Thus, the probability of an unbounded adversary (i.e., which applies arbitrary trace-preserving
completely positive (TPCP) maps, which are not necessarily efficiently implementable) to
successfully cheat using m = cn for c < 0.114 queries is exponentially small in the quantum
key size, n. The proof of Theorem 2 is in the full version; here, we give intuition.
Proof intuition. The challenge in analyzing security of the protocol is the fact that the
receiver (a.k.a. the user) is not only given adaptive query access to the token, but also a copy
of the quantum “resource state” ρR, which it may arbitrarily tamper with (in any manner
allowed by quantum mechanics) while making queries. Luckily, the GW framework [33]
(Section 2.1)) is general enough to model such “queries with quantum side information”. The
framework outputs an SDP, Γ (Equation (13)), the optimal value of which will encode the
optimal cheating probability for a cheating user of our protocol. Giving a feasible solution
for Γ will hence suffice to upper bound this cheating probability, yielding Theorem 2.
Coherently modeling quantum queries to the token. To model the interaction between the
token and user, we first recall that all queries to the token must be classical by assumption.
To model this process coherently in the GW framework, we hence imagine (solely for the
purposes of the security analysis) that the token behaves as follows:
TQC 2020
6:14 Quantum OTMs from Stateless Hardware
1. It first sends state ρR to the user.
2. When it receives as ith query a quantum state ρi from the user, it sends response string
ri to the user, and “copies” ρi via transversal CNOT gates to a private memory register
Wi, along with ri. It does not access ρi again throughout the protocol, and only accesses
ri again in Step 3. For clarity, the token runs a classical circuit, and conditions each
response ri solely on the current incoming message, ρi.
3. After all communication, the token “measures” its responses (r1, . . . , rm) in the Z-basis
to decide whether to accept (user successfully cheated) or reject (user failed to cheat).
The “copying” phase of Step 2 accomplishes two tasks: First, since the token will never read
the “copies” of ρi again, the principle of deferred measurement [52] implies the transversal
CNOT gates effectively simulate measuring ρi in the standard basis. In other words, without
loss of generality the user is reduced to feeding a classical string ỹ to the token. Second, we
would like the entire security analysis to be done in a unified fashion in a single framework,
the GW framework. To this end, we want the token itself to “decide” at the end of the
protocol whether the user has successfully cheated (i.e. extracted both secret bits). Storing all
responses ri in Step 2 allows us to simulate such a final measurement in Step 3. We reiterate
that, crucially, once the token “copies” ρi and ri to Wi, it (1) never accesses (i.e. reads or
writes to) ρi again and (2) only accesses ri again in the final standard basis measurement of
Step 3. Together, these ensure all responses ri are independent, as required..
Formalization in GW framework. To place the discussion thus far into the formal GW
framework, we return to Figure 1. The bottom “row” of Figure 1 will depict the token’s
actions, and the top row the user’s actions. As outlined above, the protocol begins by
imagining the token sends initial state ρ0 = ρR to the user via register X1. The user then
applies an arbitrary sequence of TPCP maps Φi to its private memory (modeled by register
Zi in round i), each time sending a query ỹi (which is, as discussed above a classical string
without loss of generality) to the token via register Yi. Given any such query ỹi in round
i, the token applies its own TPCP map Ψi to determine how to respond to the query. In
our protocol, the Ψi correspond to coherently applying a classical circuit, i.e. a sequence
of unitary gates mapping the standard basis to itself. Specifically, their action is fully
determined by Program 1, and in principle all Ψi are identical since the token is stateless
(i.e., the action of the token in round i is unaffected by previous rounds {1, . . . , i− 1}). (We
use the term “in principle”, as recall from above that in the security analysis we model each
Ψi as classically copying (ỹi, ri) to a distinct private register Wi.) Finally, after receiving the
mth query ỹm in register Ym, we imagine the token makes a measurement (not depicted in
Fig. 1) based on the query responses (r1, . . . , rm) it returned; if the user managed to extract
both s0 and s1 via queries, then the token “accepts”; otherwise it “rejects”. (Again, we are
using the fact that in our security analysis, the token keeps a history of all its responses ri,
solely for the sake of this final measurement.)
With this high-level setup, the output of the GW framework is a semidefinite program, Γ:
min: p (13)
subject to: Q1 � Rm+1 (14)
Rk = Pk ⊗ IYk
for 1 ≤ k ≤ m+ 1 (15)
TrXk
(Pk) = Rk−1 for 1 ≤ k ≤ m+ 1 (16)
R0 = p (17)
Rk ∈ Pos(Y1,...,k ⊗X1,...,k) for 1 ≤ k ≤ m+ 1 (18)
Pk ∈ Pos(Y1,...,k−1 ⊗X1,...,k) for 1 ≤ k ≤ m+ 1 (19)
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:15
Above, Q1 encodes the actions of the token, i.e. the co-strategy in the bottom row of Figure 1.
The variable p denotes the “cheating probability” (i.e., the probability with which both s0
and s1 are extracted), subject to linear constraints (Equations (15)-(19)) which enforce that
operator Rm+1 encodes a valid co-strategy (see Section 2.1). Theorem 9 of [33] now says
that the minimum p above encodes precisely the optimal cheating probability for a user
which is constrained only by the laws of quantum mechanics. Since Γ is a minimization
problem, to upper bound the the cheating probability it hence suffices to give a feasible
solution (p,R1, . . . , Rm+1, P1, . . . , Pm+1) for Γ, which will be our approach.
Intuition for Q1 and an upper bound on p. It remains to give intuition as to how
one derives Q1 in Γ, and how an upper bound on the optimal p is obtained. Without
loss of generality, one may assume that each of the token’s TPCP maps Ψi are given
by isometries Ai : Yi ⊗ Wi−1 7→ Xi+1 ⊗ Wi, meaning A†iAi = IYi⊗Wi−1 (due to the
Stinespring dilation theorem). (We omit the first isometry which prepares state ρ0 in
our discussion here for simplicity.) Let us denote their sequential application by a single
operator A := Am · · ·A1. Then, the Choi-Jamiołkowski representation of A is given by [33]
(Section 2.1) TrZm(vec(A) vec(A)†), where we trace out the token’s private memory register
Zm. However, since in our security analysis, we imagine the token also makes a final
measurement via some POVM Λ = {Λ0,Λ1}, whereupon obtaining outcome Λ1 the token
“accepts”, and upon outcome Λ0 the token rejects, we require a slightly more complicated
setup. Letting B1 := Λ1A, we define Q1 as [33] Q1 = TrZm
(vec(B1) vec(B1)†).
The full derivation of Q1 is deferred to the full version; here, we state Q1 with intuition:
Q1 = 1
4n
∑
s∈T
|tmstm〉〈tmstm |Xm+1
⊗ · · · ⊗ |t1st1〉〈t1st1 |X2
⊗ ∑
(ỹ,z)∈Yt
|ỹm〉〈ỹm|Ym
⊗ · · · ⊗ |ỹ1〉〈ỹ1|Y1
⊗ |ψz〉〈ψz|X1
 .
Intuitively, each string tisti ∈ {0, 1}
3 encodes the response ri of the token given the ith query
from the user; hence, the corresponding projectors in Q1 act on spaces X2 through Xm+1.
Each string ỹi ∈ {0, 1}n+1 denotes the ith query sent from the user to the token, where each
ỹi = bi ◦ yi in the notation of Program 1, i.e. bi ∈ {0, 1} is the choice bit for each query.
Each such message is passed via register Yi. The states |ψz〉 and strings z are defined as in
the beginning of Section 3.4; recall z ∈ {0, 1}2n and |ψz〉 ∈ (C2)⊗n denote the secret key and
corresponding quantum key, respectively. Finally, the relation Yt encodes the constraint that
for all i ∈ {1, . . . ,m}, the tuple (ỹi, z) (i.e. the ith message to the token, ỹi, and secret key
z) is consistent with the response returned by the token, ti.
Upper bounding p. To now upper bound p, we give a feasible solution Rm+1 satisfying
the constraints of Γ. Note that giving even a solution which attains p = 1 for all n and m
is non-trivial – such a solution is given in the full version. Here, we give a solution which
attains p ∈ O(22m−0.228n), as claimed in Theorem 2. Namely, we set
Rm+1 = 1
|T |
∑
t∈T
|tmstm〉〈tmstm |Xm+1
⊗ · · · ⊗ |t1st1〉〈t1st1 |X2
⊗ IY1⊗···⊗Ym
⊗ I
2nX1
.
This satisfies constraint (15) of Γ due to the identity term IY1⊗···⊗Ym
. The renormalization
factor (|T | 2n)−1 above ensures that tracing out all Xi registers yields R0 = 1 in constraint (17)
of Γ. We are thus reduced to choosing the minimum p satisfying constraint (14).
TQC 2020
6:16 Quantum OTMs from Stateless Hardware
Now, observe we have chosen Rm+1 to align with the block-diagonal structure of Q1 on
registers X2, . . . ,Xm. Since registers Y1 ⊗ · · · ⊗ Ym and X1 of Rm+1 are proportional to
the identity matrix, it thus suffices to characterize the largest eigenvalue of Q1, λmax(Q1).
This is done in the full version, which shows λmax(Q1) = 2
4n
(
1 + 1√
2
)n
. Combining this
bound on λmax(Q1) with the parameters of Rm+1 above now yields the desired claim that
p ∈ O(22m−0.228n). For m < 0.114n queries, this implies that the probability that a user of
the token successfully cheats and thus that the simulation fails is exponentially small in the
key size, n. Simplifications of the GW SDP, the derivation of its dual SDP, and a conjectured
approximately optimal dual feasible solution are given in the full version.
4 Impossibility Results
We now discuss “tightness” of our protocol with respect to impossibility results. To begin, it is
easy to argue that OTMs cannot exist in the plain model (i.e., without additional assumptions)
in both the classical and quantum settings: in the classical setting, impossibility holds, since
software can always be copied. Quantumly, this follows by a rewinding argument [9]. Here,
we give two no-go results for the quantum setting which support the idea that our scheme is
“tight” in terms of the minimality of the assumptions it uses. Both results assume the token
is reversible, meaning the receiver can run both the token and its inverse operation. Note
that if the receiver is not given access to the token’s inverse operation, it is unlikely for our
no-go techniques to go through. This is because, in the most general case where the token is
an arbitrary unitary U , which the receiver may apply as a black box, simulating U−1 = U†
appears difficult [26, 57]; see the full version for a discussion.
Result 1: Tokens which can be queried in superposition. In our construction, we require
that all queries to the token be classical strings, i.e., no querying in superposition is allowed.
It is easy to argue via a standard rewinding argument that relaxing this requirement yields
impossibility of a secure OTM, as long as access to the token’s adjoint (inverse) operation
is given, as we now show. Specifically, let M be a quantum OTM implemented using a
hardware token. Since the token access is assumed to be reversible, we may model it as
an oracle Of realizing a function f : {0, 1}n 7→ {0, 1}m in the standard way, i.e., for all
y ∈ {0, 1}n and b ∈ {0, 1}m, Of |y〉|b〉 = |y〉|b ⊕ f(y)〉. Now, suppose our OTM stores two
secret bits s0 and s1, and provides the receiver with an initial state |ψ〉 ∈ A⊗B ⊗ C, where
A, B, and C are the algorithm’s workspace, query (i.e., input to Of ), and answer (i.e., Of ’s
answers) registers, respectively. By definition, an honest receiver must be able to access
precisely one of s0 or s1 with certainty, given |ψ〉. Thus, for any i ∈ {0, 1}, there exists a
quantum query algorithm Ai = UmOf · · ·OfU2OfU1 for unitaries Ui ∈ U(A⊗B ⊗ C) such
that Ai|ψ〉 = |ψ′〉AB |si〉C . For any choice of i, however, this implies a malicious receiver
can now classically copy si to an external register, and then “rewind” by applying A†i to
|ψ′〉AB |si〉C to recover |ψ〉. Applying Ai′ for i′ 6= i to |ψ〉 now yields the second bit i′ with
certainty as well. We conclude that a quantum OTM which allows superposition queries to a
reversible stateless token is insecure.
I Remark 3. Above, the OTM outputs si with certainty. A similar argument holds if si is
output with probability at least 1− ε for small ε > 0 via the Gentle Measurement Lemma [66].
Result 2: Tokens with a bounded number of keys. We observed superposition queries to
the token prevent an OTM from being secure. One can also ask how simple a hardware
token with classical queries can be, while still allowing a secure OTM. Below, we consider
such a strengthening in which the token is forced to have a bounded number of keys.
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:17
To formalize this, we define the notion of a “measure-and-access (MA)” OTM, i.e., an
OTM in which given an initial state |ψ〉, an honest receiver applies a prescribed measurement
to |ψ〉, and feeds the resulting classical string (i.e., key) y into the token Of to obtain si.
Our construction is an example of a MA memory in which each bit si has an exponential
number of valid keys y such that f(y) = si. Can the construction can be strengthened such
that each si has a bounded number (e.g., a polynomial number) of keys? We now show that
such a strengthening would preclude security, assuming the token is reversible.
I Lemma 4. Let M be an MA memory with oracle Of , such that Of cannot be queried in
superposition. If a secret bit si has at most ∆ keys yi such that f(yi) = si, then given a
single copy of |ψ〉, one can extract both s0 and s1 from M with probability at least 1/∆2.
Thus, if a secret bit bi has at most polynomially many keys, then any measure-and-access
OTM can be broken with at least inverse polynomial probability. The proof is in the full
version. In this sense,in the setting of measure-and-access memories, our construction is tight
– in order to bound the adversary’s success probability of obtaining both secret bits by an
inverse exponential, we require each secret bit to have exponentially many valid keys.
References
1 Scott Aaronson and Paul Christiano. Quantum money from hidden subspaces. In Proc. 44th
Symposium on Theory of Computing (STOC) 2012, pages 41–60, 2012. Full version available
as arXiv:1203.4740. doi:10.1145/2213977.2213983.
2 Donald Beaver. Secure multiparty protocols and zero-knowledge proof systems tolerating a
faulty minority. Journal of Cryptology, 4(2):75–122, 1991.
3 Shalev Ben-David and Or Sattath. Quantum tokens for digital signatures. arXiv:1609.09047,
2018.
4 Charles H. Bennett and Gilles Brassard. Quantum cryptography: Public key distribution and
coin tossing. International Conference on Computers, Systems and Signal Processing, pages
175–179, 1984.
5 Charles H. Bennett, Gilles Brassard, Claude Crépeau, and Marie-Hélène Skubiszewska. Prac-
tical quantum oblivious transfer. In Joan Feigenbaum, editor, CRYPTO’91, volume 576 of
LNCS, pages 351–366. Springer, August 1992.
6 Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its
applications. In 20th ACM STOC, pages 103–112. ACM Press, May 1988.
7 Manuel Blum and Silvio Micali. How to generate cryptographically strong sequences of pseudo
random bits. In 23rd FOCS, pages 112–117. IEEE Computer Society Press, November 1982.
8 Anne Broadbent, Sevag Gharibian, and Hong-Sheng Zhou. Quantum one-time memories from
stateless hardware. arXiv:1511.01363, November 2015.
9 Anne Broadbent, Gus Gutoski, and Douglas Stebila. Quantum one-time programs. In Ran
Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages
344–360. Springer, August 2013. doi:10.1007/978-3-642-40084-1_20.
10 Anne Broadbent and Christian Schaffner. Quantum cryptography beyond quantum key
distribution. Designs, Codes and Cryptography, 78(1):351–382, 2016.
11 Christian Cachin and Ueli Maurer. Unconditional security against memory-bounded adversaries.
In Advances in Cryptology - CRYPTO 1997, LNCS, pages 292–306. Springer, 1997. doi:
10.1007/BFb0052243.
12 Ran Canetti. Security and composition of multiparty cryptographic protocols. Journal of
Cryptology, 13(1):143–202, 2000.
13 Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols.
Cryptology ePrint Archive, Report 2000/067, 2000. URL: http://eprint.iacr.org/2000/
067.
14 Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols.
In 42nd FOCS, pages 136–145. IEEE Computer Society Press, October 2001.
TQC 2020
http://arxiv.org/abs/1203.4740
https://doi.org/10.1145/2213977.2213983
https://arxiv.org/abs/1609.09047
https://doi.org/10.1007/978-3-642-40084-1_20
https://doi.org/10.1007/BFb0052243
https://doi.org/10.1007/BFb0052243
http://eprint.iacr.org/2000/067
http://eprint.iacr.org/2000/067
6:18 Quantum OTMs from Stateless Hardware
15 Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish. Universally composable
security with global setup. In Salil P. Vadhan, editor, TCC 2007, volume 4392 of LNCS, pages
61–85. Springer, February 2007.
16 Ran Canetti, Yehuda Lindell, Rafail Ostrovsky, and Amit Sahai. Universally composable
two-party and multi-party secure computation. In 34th ACM STOC, pages 494–503. ACM
Press, May 2002.
17 Nishanth Chandran, Vipul Goyal, and Amit Sahai. New constructions for UC secure computa-
tion using tamper-proof hardware. In Nigel P. Smart, editor, EUROCRYPT 2008, volume
4965 of LNCS, pages 545–562. Springer, April 2008.
18 Man-Duen Choi. Completely positive linear maps on complex matrices. Linear Alg. Appl.,
10:285, 1975.
19 Seung Geol Choi, Jonathan Katz, Dominique Schröder, Arkady Yerukhimovich, and Hong-
Sheng Zhou. (efficient) universally composable oblivious transfer using a minimal number of
stateless tokens. In Yehuda Lindell, editor, TCC 2014, volume 8349 of LNCS, pages 638–662.
Springer, February 2014. doi:10.1007/978-3-642-54242-8_27.
20 Kai-Min Chung, Marios Georgiou, Ching-Yi Lai, and Vassilis Zikas. Cryptography with
disposable backdoors. eprint:2018/352, 2018.
21 Ivan Damgård, Serge Fehr, Carolin Lunemann, Louis Salvail, and Christian Schaffner. Im-
proving the security of quantum protocols via commit-and-open. In Shai Halevi, editor,
CRYPTO 2009, volume 5677 of LNCS, pages 408–427. Springer, August 2009.
22 Ivan Damgård, Serge Fehr, Louis Salvail, and Christian Schaffner. Cryptography in the
bounded quantum-storage model. In Symposium on Foundations of Computer Science - FOCS
2005, pages 449–458. IEEE, 2005. doi:10.1109/SFCS.2005.30.
23 Ivan Damgård and Alessandra Scafuro. Unconditionally secure and universally compos-
able commitments from physical assumptions. In Kazue Sako and Palash Sarkar, editors,
ASIACRYPT 2013, Part II, volume 8270 of LNCS, pages 100–119. Springer, December 2013.
doi:10.1007/978-3-642-42045-0_6.
24 Frédéric Dupuis, Jesper Buus Nielsen, and Louis Salvail. Secure two-party quantum evaluation
of unitaries against specious adversaries. In Advances in Cryptology – Proc. CRYPTO 2010,
LNCS, pages 685–706. Springer, 2010.
25 Frédéric Dupuis, Jesper Buus Nielsen, and Louis Salvail. Actively secure two-party evaluation
of any quantum operation. In Advances in Cryptology – Proc. CRYPTO 2012, volume 7417 of
LNCS, pages 794–811. Springer, 2012. doi:10.1007/978-3-642-32009-5_46.
26 Bill Fefferman and Shelby Kimmel. Quantum vs. Classical Proofs and Subset Verification.
In Igor Potapov, Paul Spirakis, and James Worrell, editors, 43rd International Symposium
on Mathematical Foundations of Computer Science (MFCS 2018), volume 117 of Leibniz
International Proceedings in Informatics (LIPIcs), pages 22:1–22:23, Dagstuhl, Germany, 2018.
Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik. doi:10.4230/LIPIcs.MFCS.2018.22.
27 Serge Fehr, Jonathan Katz, Fang Song, Hong-Sheng Zhou, and Vassilis Zikas. Feasibility
and completeness of cryptographic tasks in the quantum world. In Amit Sahai, editor,
TCC 2013, volume 7785 of LNCS, pages 281–296. Springer, March 2013. doi:10.1007/
978-3-642-36594-2_16.
28 Dmitry Gavinsky. Quantum money with classical verification. In Computational Complexity
(CCC), 2012 IEEE 27th Annual Conference on, pages 42–52, June 2012. doi:10.1109/CCC.
2012.10.
29 Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or A
completeness theorem for protocols with honest majority. In Alfred Aho, editor, 19th ACM
STOC, pages 218–229. ACM Press, May 1987.
30 Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. One-time programs. In David
Wagner, editor, CRYPTO 2008, volume 5157 of LNCS, pages 39–56. Springer, August 2008.
https://doi.org/10.1007/978-3-642-54242-8_27
https://doi.org/10.1109/SFCS.2005.30
https://doi.org/10.1007/978-3-642-42045-0_6
https://doi.org/10.1007/978-3-642-32009-5_46
https://doi.org/10.4230/LIPIcs.MFCS.2018.22
https://doi.org/10.1007/978-3-642-36594-2_16
https://doi.org/10.1007/978-3-642-36594-2_16
https://doi.org/10.1109/CCC.2012.10
https://doi.org/10.1109/CCC.2012.10
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:19
31 Shafi Goldwasser and Leonid A. Levin. Fair computation of general functions in presence of
immoral majority. In Alfred J. Menezes and Scott A. Vanstone, editors, CRYPTO’90, volume
537 of LNCS, pages 77–93. Springer, August 1991.
32 Vipul Goyal, Yuval Ishai, Amit Sahai, Ramarathnam Venkatesan, and Akshay Wadia. Founding
cryptography on tamper-proof hardware tokens. In Daniele Micciancio, editor, TCC 2010,
volume 5978 of LNCS, pages 308–326. Springer, February 2010.
33 Gus Gutoski and John Watrous. Toward a general theory of quantum games. In Proceedings
of the 39th ACM Symposium on Theory of Computing (STOC 2007), pages 565–574, 2007.
arXiv:quant-ph/0611234v2.
34 Sean Hallgren, Adam Smith, and Fang Song. Classical cryptographic protocols in a quantum
world. In Phillip Rogaway, editor, CRYPTO 2011, volume 6841 of LNCS, pages 411–428.
Springer, August 2011.
35 Werner Heisenberg. Schwankungserscheinungen und quantenmechanik. Zeitschrift fuer Physik,
40(7):501–506, July 1927. doi:10.1007/BF01440827.
36 Yuval Ishai, Manoj Prabhakaran, and Amit Sahai. Founding cryptography on oblivious transfer
- efficiently. In David Wagner, editor, CRYPTO 2008, volume 5157 of LNCS, pages 572–591.
Springer, August 2008.
37 Andrzej Jamiołkowski. Linear transformations which preserve trace and positive semi-
definiteness of operators. Rep. Math. Phys., 3:275, 1972.
38 Jonathan Katz. Universally composable multi-party computation using tamper-proof hardware.
In Moni Naor, editor, EUROCRYPT 2007, volume 4515 of LNCS, pages 115–128. Springer,
May 2007.
39 Joe Kilian. Founding cryptography on oblivious transfer. In 20th ACM STOC, pages 20–31.
ACM Press, May 1988.
40 Daniel Kraschewski, Hemanta K. Maji, Manoj Prabhakaran, and Amit Sahai. A full charac-
terization of completeness for two-party randomized function evaluation. In Phong Q. Nguyen
and Elisabeth Oswald, editors, EUROCRYPT 2014, volume 8441 of LNCS, pages 659–676.
Springer, May 2014. doi:10.1007/978-3-642-55220-5_36.
41 Daniel Kraschewski and Jörn Müller-Quade. Completeness theorems with constructive proofs
for finite deterministic 2-party functions. In Yuval Ishai, editor, TCC 2011, volume 6597 of
LNCS, pages 364–381. Springer, March 2011.
42 Huijia Lin, Rafael Pass, and Muthuramakrishnan Venkitasubramaniam. A unified framework
for concurrent security: universal composability from stand-alone non-malleability. In Michael
Mitzenmacher, editor, 41st ACM STOC, pages 179–188. ACM Press, 2009.
43 Yi-Kai Liu. Building one-time memories from isolated qubits. In Moni Naor, editor, ITCS
2014, pages 269–286. ACM, January 2014.
44 Yi-Kai Liu. Single-shot security for one-time memories in the isolated qubits model. In Juan A.
Garay and Rosario Gennaro, editors, CRYPTO 2014, Part II, volume 8617 of LNCS, pages
19–36. Springer, August 2014. doi:10.1007/978-3-662-44381-1_2.
45 Yi-Kai Liu. Privacy amplification in the isolated qubits model. In Elisabeth Oswald and Marc
Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 785–814. Springer,
April 2015. doi:10.1007/978-3-662-46803-6_26.
46 Hemanta K. Maji, Manoj Prabhakaran, and Mike Rosulek. Complexity of multi-party
computation problems: The case of 2-party symmetric secure function evaluation. In Omer
Reingold, editor, TCC 2009, volume 5444 of LNCS, pages 256–273. Springer, March 2009.
47 Hemanta K. Maji, Manoj Prabhakaran, and Mike Rosulek. A zero-one law for cryptographic
complexity with respect to computational UC security. In Tal Rabin, editor, CRYPTO 2010,
volume 6223 of LNCS, pages 595–612. Springer, August 2010.
48 Ueli Maurer and Renato Renner. Abstract cryptography. In Bernard Chazelle, editor, ICS
2011, pages 1–21. Tsinghua University Press, January 2011.
TQC 2020
https://doi.org/10.1007/BF01440827
https://doi.org/10.1007/978-3-642-55220-5_36
https://doi.org/10.1007/978-3-662-44381-1_2
https://doi.org/10.1007/978-3-662-46803-6_26
6:20 Quantum OTMs from Stateless Hardware
49 Ueli M. Maurer. Protocols for secret key agreement by public discussion based on common
information. In Advances in Cryptology - CRYPTO 1992, volume 740 of LNCS, pages 461–470.
Springer, 1992. doi:10.1007/3-540-48071-4_32.
50 Silvio Micali and Phillip Rogaway. Secure computation (abstract). In Joan Feigenbaum, editor,
CRYPTO’91, volume 576 of LNCS, pages 392–404. Springer, August 1992.
51 Abel Molina, Thomas Vidick, and John Watrous. Optimal counterfeiting attacks and general-
izations for Wiesner’s quantum money. In Kazuo Iwama, Yasuhito Kawano, and Mio Murao,
editors, Theory of Quantum Computation, Communication, and Cryptography, volume 7582 of
Lecture Notes in Computer Science, pages 45–64, 2013.
52 M. A. Nielsen and I. L. Chuang. Quantum Computation and Quantum Information. Cambridge
University Press, 2000.
53 Fernando Pastawski, Norman Y Yao, Liang Jiang, Mikhail D Lukin, and J Ignacio Cirac.
Unforgeable noise-tolerant quantum tokens. Proceedings of the National Academy of Sciences,
109(40):16079–16082, 2012.
54 Birgit Pfitzmann and Michael Waidner. A model for asynchronous reactive systems and its
application to secure message transmission. In Proc. 22nd IEEE Symposium on Security &
Privacy (S&P) 2001, pages 184–200. IEEE, 2001. Full version available at http://eprint.
iacr.org/2000/066. doi:10.1109/SECPRI.2001.924298.
55 Manoj Prabhakaran and Mike Rosulek. Cryptographic complexity of multi-party computation
problems: Classifications and separations. In David Wagner, editor, CRYPTO 2008, volume
5157 of LNCS, pages 262–279. Springer, August 2008.
56 Manoj Prabhakaran and Amit Sahai. New notions of security: Achieving universal composab-
ility without trusted setup. In László Babai, editor, 36th ACM STOC, pages 242–251. ACM
Press, June 2004.
57 Marco Túlio Quintino, Qingxiuxiong Dong, Atsushi Shimbo, Akihito Soeda, and Mio Murao.
Reversing unknown quantum transformations: Universal quantum circuit for inverting general
unitary operations. Phys. Rev. Lett., 123:210502, November 2019. doi:10.1103/PhysRevLett.
123.210502.
58 Renato Renner. Security of Quantum Key Distribution. PhD thesis, ETH Zürich (Switzerland),
September 2008. doi:10.1142/S0219749908003256.
59 Dominique Unruh. Universally composable quantum multi-party computation. In Henri
Gilbert, editor, EUROCRYPT 2010, volume 6110 of LNCS, pages 486–505. Springer, May
2010.
60 Dominique Unruh. Everlasting multi-party computation. In Ran Canetti and Juan A. Garay,
editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 380–397. Springer, August 2013.
doi:10.1007/978-3-642-40084-1_22.
61 Dominique Unruh. Revocable quantum timed-release encryption. In Phong Q. Nguyen and
Elisabeth Oswald, editors, EUROCRYPT 2014, volume 8441 of LNCS, pages 129–146. Springer,
May 2014. doi:10.1007/978-3-642-55220-5_8.
62 John Watrous. Lecture 7: Semidefinite programming, 2011. Latest version available at:
https://cs.uwaterloo.ca/~watrous/CS766/LectureNotes/07.pdf.
63 Stephanie Wehner, Christian Schaffner, and Barbara M. Terhal. Cryptography from noisy
storage. Physical Review Letters, 100(22):220502, June 2008. doi:10.1103/PhysRevLett.100.
220502.
64 Stephanie Wehner and Andreas Winter. Entropic uncertainty relations—a survey. New J.
Phys., 12(2):025009, February 2010. doi:10.1088/1367-2630/12/2/025009.
65 Stephen Wiesner. Conjugate coding. ACM SIGACT News, 15(1):78–88, 1983. Original article
written circa 1970. doi:10.1145/1008908.1008920.
66 Andreas Winter. Coding theorem and strong converse for quantum channels. IEEE Transac-
tions on Information Theory, 45:2481–2485, 1999.
67 William K. Wootters and Wojciech H. Zurek. A single quantum cannot be cloned. Nature,
299(5886):802–803, 1982 . doi:10.1038/299802a0.
68 Andrew Chi-Chih Yao. Theory and applications of trapdoor functions. In 23rd FOCS, pages
80–91. IEEE Computer Society Press, November 1982.
https://doi.org/10.1007/3-540-48071-4_32
http://eprint.iacr.org/2000/066
http://eprint.iacr.org/2000/066
https://doi.org/10.1109/SECPRI.2001.924298
https://doi.org/10.1103/PhysRevLett.123.210502
https://doi.org/10.1103/PhysRevLett.123.210502
https://doi.org/10.1142/S0219749908003256
https://doi.org/10.1007/978-3-642-40084-1_22
https://doi.org/10.1007/978-3-642-55220-5_8
https://cs.uwaterloo.ca/~watrous/CS766/LectureNotes/07.pdf
https://doi.org/10.1103/PhysRevLett.100.220502
https://doi.org/10.1103/PhysRevLett.100.220502
https://doi.org/10.1088/1367-2630/12/2/025009
https://doi.org/10.1145/1008908.1008920
https://doi.org/10.1038/299802a0
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:21
A Universal Composition (UC) Framework
We consider simulation-based security. The Universal Composability (UC) framework was
proposed by Canetti [14, 13], culminating a long sequence of simulation-based security
definitions (c.f. [29, 31, 50, 2, 12]); please see also [54, 56, 15, 42, 48] for alternative/extended
frameworks. Recently Unruh [59] extend the UC framework to the quantum setting. Next,
we provide a high-level description of the original classical UC model by Canetti [14, 13],
and then the quantum UC model by Unruh [59].
A.1 Classical UC Model ([14, 13])
Machines. The basic entities involved in the UC model are players P1, . . . , Pk where k is
polynomial of security parameter n, an adversary A, and an environment Z. Each entity
is modeled as a interactive Turing machine (ITM), where Z could have an additional non-
uniform string as advice. Each Pi has identity i assigned to it, while A and Z have special
identities idA := adv and idZ := env.
Protocol Execution. A protocol specifies the programs for each Pi, which we denote as
π = (π1, . . . , πk). The execution of a protocol is coordinated by the environment Z. It starts
by preparing inputs to all players, who then run their respective programs on the inputs and
exchange messages of the form (idsender, idreceiver, msg). A can corrupt an arbitrary set of
players and control them later on. In particular, A can instruct a corrupted player sending
messages to another player and also read messages that are sent to the corrupted players.
During the course of execution, the environment Z also interacts with A in an arbitrary way.
In the end, Z receives outputs from all the other players and generates one bit output. We
use EXEC[Z,A, π] denote the distribution of the environment Z’s (single-bit) output when
executing protocol π with A and the Pi’s.
Ideal Functionality and Dummy Protocol. Ideal functionality F is a trusted party, modeled
by an ITM again, that perfectly implements the desired multi-party computational task. We
consider an “dummy protocol”, denoted PF , where each party has direct communication
with F, who accomplishes the desired task according to the messages received from the
players. The execution of PF with environment Z and an adversary, usually called the
simulator S, is defined analogous as above, in particular, S monitors the communication
between corrupted parties and the ideal functionality F. Similarly, we denote Z’s output
distribution as EXEC[Z,S, PF ].
I Definition 5 (Classical UC-secure Emulation). We say π (classically) UC-emulates π′ if
for any adversary A, there exists a simulator S such that for all environments Z,
EXEC[Z,A, π] ≈ EXEC[Z,S, π′] (20)
We here consider that A and Z are computationally unbounded, and we call it statistical
UC-security. We require the running time S is polynomial in that of A. We call this property
Polynomial Simulation.
Let F be a well-formed two party functionality. We say π (classically) UC-realizes
F if for all adversary A, there exists a simulator S such that for all environments Z,
EXEC[Z,A, π] ≈ EXEC[Z,S, PF ]. We also write EXEC[Z,A, π] ≈ EXEC[Z,S,F ] if the
context is clear.
TQC 2020
6:22 Quantum OTMs from Stateless Hardware
UC-secure protocols admit a general composition property, demonstrated in the following
universal composition theorem.
I Theorem 6 (UC Composition Theorem [13]). Let π, π′ and σ be n-party protocols. Assume
that π UC-emulates π′. Then σπ UC-emulates σπ′ .
A.2 Quantum UC Model ([59])
Now, we give a high-level description of quantum UC model by Unruh [59].
Quantum Machine. In the quantum UC model, all players are modeled as quantum
machines. A quantum machine is a sequence of quantum circuits {Mn}n∈N, for each
security parameter n. Mn is a completely positive trace preserving operator on space
Hstate ⊗Hclass ⊗Hquant, where Hstate represents the internal workspace of Mn and Hclass
and Hquant represent the spaces for communication, where for convenience we divide the
messages into classical and quantum parts. We allow a non-uniform quantum advice6 to the
machine of the environment Z, while all other machines are uniformly generated.
Protocol Execution. In contrast to the communication policy in classical UC model, we
consider a network N which contains the spaceHN := Hclass⊗Hquant⊗iHstate
i . Namely, each
machine maintains individual internal state space, but the communication space is shared
among all . We assume Hclass contains the message (idsender, idreceiver, msg) which specifies
the sender and receiver of the current message, and the receiver then processes the quantum
state on Hquant. Note that this communication model implicitly ensures authentication. In a
protocol execution, Z is activated first, and at each round, one player applies the operation
defined by its machine Mn on Hclass ⊗Hquant ⊗Hstate. In the end Z generates a one-bit
output. Denote EXEC[Z,A,Π] the output distribution of Z.
Ideal Functionality. All functionalities we consider in this work are classical, i.e., the inputs
and outputs are classical, and its program can be implemented by an efficient classical
Turing machine. Here in the quantum UC model, the ideal functionality F is still modeled
as a quantum machine for consistency, but it only applies classical operations. Namely, it
measures any input message in the computational basis to get a classical bit-string, and
implements the operations specified by the classical computational task.
We consider an “dummy protocol”, denoted PF , where each party has direct communic-
ation with F, who accomplishes the desired task according to the messages received from
the players. The execution of PF with environment Z and an adversary, usually called the
simulator S, is defined analogous as above, in particular, S monitors the communication
between corrupted parties and the ideal functionality F. Similarly, we denote Z’s output
distribution as EXEC[Z,S, PF ]. For simplicity, we also write it as EXEC[Z,S,F ].
I Definition 7 (Quantum UC-secure Emulation). We say Π quantum-UC-emulates Π′ if for
any quantum adversary A, there exists a (quantum) simulator S such that for all quantum
environments Z,
EXEC[Z,A,Π] ≈ EXEC[Z,S,Π′] (21)
6 Unruh’s model only allows classical advice, but we tend to take the most general model. It is easy to
justify that almost all results remain unchanged, including the composition theorem. See [34, Section 5]
for more discussion.
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:23
We consider here that A and Z are computationally unbounded, we call it (quantum) statistical
UC-security. We require the running time S is polynomial in that of A. We call this property
Polynomial Simulation.
Similarly, (quantum) computational UC-security can be defined. Let F be a well-
formed two party functionality. We say Π quantum-UC-realizes F if for all quantum
adversary A, there exists a (quantum) simulator S such that for all quantum environments
Z, EXEC[Z,A,Π] ≈ EXEC[Z,S, PF ].
Quantum UC-secure protocols also admit general composition:
I Theorem 8 (Quantum UC Composition Theorem [59, Theorem 11]). Let Π,Π′ and Σ be
quantum-polynomial-time protocols. Assume that Π quantum UC-emulates Π′. Then ΣΠ
quantum UC-emulates ΣΠ′ .
I Remark 9. Out of the two protocol parties (the sender and the receiver), we consider
security only in the case of the receiver being a corrupted party. Note that we are only
interested in cases where the same party is corrupted with respect to all composed protocol.
Furthermore, we only consider static corruption.
B Stand-Alone Security in the case of a Malicious Sender
In order to define stand-alone security against a malicious sender (Definition 11), in our
context, we closely follow definitions given in prior work [24], which we now recall. (Note that,
instead of considering the approximate case for security, we are able to use the exact one.)
I Definition 10. An n-step quantum two-party protocol with oracle calls, denoted ΠO =
(A ,B,O, n) consists of:
1. input space A0 and B0 for parties A and B respectively.
2. memory spaces A1, . . .An and B1, . . .Bn for A and B, respectively.
3. An n-tuple of quantum operations (A1, . . .An) for A , Ai : L(Ai−1) 7→ L(Ai), (1 ≤ i ≤ n).
4. An n-tuple of quantum operations (B1, . . .Bn) for B, Bi : L(Bi−1) 7→ L(Bi), (1 ≤ i ≤ n).
5. Memory spaces A1, . . . ,An and B1, . . . ,Bn can be written as Ai = AiO ⊗Ai′ and Bi =
BiO ⊗ Bi′, (1 ≤ i ≤ n) and O = (O1, . . . ,On) is an n-tuple of quantum operations:
Oi : L(AOi ⊗ BOi ) 7→ L(AOi ⊗ BOi ), (1 ≤ i ≤ n).
If ΠO = (A ,B,O, n) is an n-turn two-party protocol, then the final state of the interaction
upon input ρin ∈ D(A0 ⊗ B0 ⊗R) where R is a system of dimension dimA0 dimB0, is:
[A ©∗ B](ρin) = (1L(A′n⊗B′n⊗R)⊗On)(An⊗Bn⊗1R) . . . (1L(A′1⊗B
′
1⊗R)⊗O1)(A1⊗B1⊗1R)(ρin) .
(22)
As in [24], we specify that an oracle O can be a communication oracle or an ideal functionality
oracle.
An adversary Ã for an honest party A in ΠO = (A ,B,O, n) is an n-tuple of quantum
operations matching the input and outputs spaces of A . A simulator for Ã is a sequence of
quantum operations (Si)ni=1 where Si has the same input-output spaces as the maps of Ã at
step i. In addition, S has access to the ideal functionality for the protocol Π.
I Definition 11. An n-step quantum two-party protocol with oracle calls, ΠO = (A ,B,O, n)
is statistically stand-alone secure against a corrupt A if for every adversary Ã there exists
a simulator S such that for every input ρin,
TrBn⊗R(Ã ©∗ B) = TrBn⊗R(S ©∗ B) . (23)
TQC 2020
6:24 Quantum OTMs from Stateless Hardware
We note that Definition 11 is weaker than some other definitions for active security used
in the literature, e.g., [25], because we ask only that the local view of the adversary be
simulated.
Given the simple structure of our protocol and ideal functionality, the construction and
proof of the simulator is straightforward as shown below.
I Theorem 12. Protocol Π is statistically stand-alone secure against a corrupt sender.
Proof. Since Π consists in a single message from the sender to the receiver (together with a
call to the ideal functionality for the token), we have that A = (A1). Furthermore, since
the ideal functionality Fwrap does not return anything to the sender, there is no need for our
simulator S to call an ideal functionality.
We thus build S that runs A on the input in register A0. When A calls the Fwrap ideal
functionality, the simulator does nothing. Since Π is a one-way protocol, and since the ideal
functionality also does not allow communication from the receiver to the sender,
TrBn⊗R(Ã ©∗ B) = A (TrB0⊗R(ρin)) = S(TrB0⊗R(ρin)) . (24)
This concludes the proof. J
C Proof of Lemma 4
For clarity, implicitly in our proof below, we model the oracle Of as having three possible
outputs: 0, 1, or 2, where 2 is output whenever Of is fed an invalid key y. This is required
for the notion of having “few” keys to make sense (i.e., there are 2n candidate keys, and only
two secret bits, each of which is supposed to have a bounded number of keys). Note that our
construction indeed fits into this framework.
Proof. Observe first that an honest receiver Alice wishing to extract si acts as follows. She
applies a unitary Ui ∈ U(A⊗B) to get state
|φ1〉 := Ui|ψ〉AB |0〉C . (25)
She then measures B in the computational basis and postselects on result y ∈ {0, 1}n,
obtaining state
|φ2〉 := |φy〉A|y〉B |0〉C . (26)
She now treats y as a “key” for si, i.e., she applies Of to B ⊗ C to obtain her desired bit si,
i.e.,
|φ3〉 := |φy〉A|y〉B |si〉C . (27)
A malicious receiver Bob wishing to extract s0 and s1 now acts similarly to the rewinding
strategy for superposition queries. Suppose without loss of generality that s0 has at most ∆
keys. Then, Bob first applies U0 to prepare |φ1〉 from Equation (25), which we can express
as
|φ1〉 =
∑
y∈{0,1}n
αy|ψy〉A|y〉B |0〉C . (28)
for
∑
y |αy|
2 = 1. Since measuring B next would allow us to retrieve s0 in register C with
certainty, we have that all y appearing in the expansion above satisfy f(y) = s0. Moreover,
A. Broadbent, S. Gharibian, and H.-S. Zhou 6:25
since s0 has at most ∆ keys, there exists a key y′ such that |αy′ |2 ≥ 1/∆. Bob now measures B
in the computational basis to obtain |φ2〉 from Equation (26), obtaining y′ with probability at
least 1/∆. Feeding y′ into Of yields s0. Having obtained y′, we have that |〈φ1|φ2〉|2 ≥ 1/∆,
implying∣∣∣〈ψ|U†0 |φy′〉|y′〉∣∣∣2 ≥ 1/∆, (29)
i.e., Bob now applies U†0 to recover a state with “large” overlap with initial state |ψ〉.
To next recover s1, define |ψgood〉 := U1|ψ〉 and |ψapprox〉 := U1U
†
0 |φy′〉|y′〉. Bob applies
U1 to obtain
|ψapprox〉 = β1|ψgood〉+ β2|ψ⊥good〉, (30)
where
∑
i |βi|
2 = 1, 〈ψgood|ψ⊥good〉 = 0, and |β1|2 ≥ 1/∆. Define
Πgood :=
∑
y∈{0,1}n s.t. f(y)=s1
|y〉〈y|.
Then, the probability that measuring B in the computational basis now yields a valid key
for s1 is
〈ψapprox|Πgood|ψapprox〉 ≥ |β1|2 ≥
1
∆ , (31)
where we have used the fact that Πgood|ψgood〉 = |ψgood〉 (since an honest receiver can extract
s1 with certainty). We conclude that Bob can extract both s0 and s1 with probability at
least 1/∆2. J
TQC 2020
	Introduction
	Contributions and summary of techniques
	Preliminaries
	The Gutoski-Watrous framework for quantum games
	Feasibility of Quantum OTMs using Stateless Hardware
	Construction
	Stand-Alone Security Against a Malicious Sender
	UC-Security against a corrupt receiver
	The simulator
	Analysis
	Security analysis for the token: Intuition
	Impossibility Results
	Universal Composition (UC) Framework
	Classical UC Model ([14,13])
	Quantum UC Model ([59])
	Stand-Alone Security in the case of a Malicious Sender
	Proof of Lemma 4