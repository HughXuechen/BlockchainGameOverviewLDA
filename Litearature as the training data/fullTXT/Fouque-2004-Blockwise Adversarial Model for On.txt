LNCS 3357 - Blockwise Adversarial Model for On-line Ciphers and Symmetric Encryption Schemes
Blockwise Adversarial Model for On-line Ciphers
and Symmetric Encryption Schemes
Pierre-Alain Fouque1, Antoine Joux2, and Guillaume Poupard2
1 École normale supérieure, Département d’Informatique, 45 rue d’Ulm,
75230 Paris 5, France
Pierre-Alain.Fouque@ens.fr
2 DCSSI CryptoLab, 51, rue de Latour-Maubourg, 75007 Paris SP, France
{Antoine.Joux, Guillaume.Poupard}@m4x.org
Abstract. This paper formalizes the security adversarial games for on-
line symmetric cryptosystems in a unified framework for deterministic
and probabilistic encryption schemes. On-line encryption schemes allow
to encrypt messages even if the whole message is not known at the begin-
ning of the encryption. The new introduced adversaries better capture
the on-line properties than classical ones. Indeed, in the new model, the
adversaries are allowed to send messages block-by-block to the encryp-
tion machine and receive the corresponding ciphertext blocks on-the-fly.
This kind of attacker is called blockwise adversary and is stronger than
standard one which treats messages as atomic objects.
In this paper, we compare the two adversarial models for on-line en-
cryption schemes. For probabilistic encryption schemes, we show that
security is not preserved contrary to for deterministic schemes. We prove
in appendix of the full version that in this last case, the two models are
polynomially equivalent in the number of encrypted blocks. Moreover in
the blockwise model, a polynomial number of concurrent accesses to en-
cryption oracles have to be taken into account. This leads to the strongest
security notion in this setting. Furthermore, we show that this notion is
valid by exhibiting a scheme secure under this security notion.
1 Introduction
In 2002, Joux, Martinet and Valette introduce the blockwise adaptive attacks
(BA) in [17], in order to better model attackers in the real world. This adversarial
model is particularly relevant to study the security of on-line schemes where
output blocks are viewed gradually by the adversary since for example the whole
encrypted message cannot be stored by the encryption machine. Indeed, usually
in order to encrypt a message M with a symmetric scheme, M is first split into
blocks of the length of the block cipher: M = M [1]M [2] . . . M [l]. An encryption
scheme is said to be on-line if the encryption of the block M [i] only depends
on the previous blocks M [1], M [2], . . . , M [i] and not on the next ones M [i +
1] . . . M [l]. Consequently, the encryption function can compute and return C[i]
before the introduction of M [i+1] . . . M [l]. There exist a lot of on-line encryption
H. Handschuh and A. Hasan (Eds.): SAC 2004, LNCS 3357, pp. 212–226, 2005.
c© Springer-Verlag Berlin Heidelberg 2005
mailto:Pierre-Alain.Fouque@ens.fr
Blockwise Adversarial Model for On-line Ciphers 213
schemes such as ECB, CBC, OFB, CFB [19] or OCB [1]. However, some schemes
require a pre-treatment on the whole plaintext before the encryption process [20]
or require two encryption passes in two directions [16], and thus are not on-line.
In this paper, we propose to study the relations between the security notions
in the standard and blockwise models for probabilistic and deterministic on-line
encryption schemes.
1.1 Standard Versus Blockwise Adversarial Model
The standard attack model for the CPA security is message oriented : i.e. the
messages are viewed as atomic object which cannot be split into blocks. Thus,
adversaries can only be adaptive between the messages. This model correctly cap-
tures the interactions of an adversary with an encryption machine for schemes
which require the whole plaintext before to start the encryption process or im-
plementations that can record the entire plaintext before the beginning of the
encryption.
However, sometimes the encryption process has to be started even if the entire
plaintext is not known. For example, in real-time applications, the cryptographic
device cannot store the whole plaintext before the starting of the encryption.
Consequently, on-line encryption schemes are useful in such scenario. Moreover,
in many practical applications, cryptographic devices (smart cards) are memory
restricted. Then, if messages are too large, they cannot be stored in the crypto-
graphic module before the beginning of the encryption process. Therefore, the
message must be sent block by block to the cryptographic module which returns
on-the-fly the output block C[i], say just after the query of the input block M [i]
in some implementations. As a consequence, the adversary model needs to be
changed to take into account attackers querying messages block by block. In
the BA model, attackers are more adaptive than standard adversaries: they are
adaptive during the encryption query, i.e. between each block of messages, and
not only between the encryption queries, i.e. between the messages. Hence the
name of “blockwise” adversaries. Obviously the BA model is stronger than the
standard one. In the sequel, we respectively denote BCPA and CPA adversaries
in the BA and standard models.
It is important to thwart such adversaries since they can lead to theoretical
attacks on traditional cryptosystems, such as on the CBC encryption mode or
on the authenticated encryption mode presented by Jutla [17]. In [3], Bellare
et al. have proved that the CBC encryption scheme is secure in the standard
model up to the encryption of 2n/2 blocks, where n denotes the block length
of a block cipher. However, in [17], Joux, Martinet and Valette have presented
a new simple attack showing that the CBC encryption scheme is not secure in
the BA model after only two encrypted blocks. This kind of adversary is mainly
meaningful in the private-key setting when long messages are encrypted. It is
worth noticing that blockwise adversaries are not only of theoretical interest
as the attacks in [17] seem to show. In [17], the attacks invalidate the security
proof by building distinguisher but do not allow to recover the secret key or
to totally break the scheme. However, it is easy to show that for example the
214 P.-A. Fouque, A. Joux, and G. Poupard
CBC encryption scheme in the BA model is as sensible as the ECB mode in the
standard model against a key recovery attack since the adversary can adapt his
queries to the block cipher by xoring its queries to the previous output blocks.
1.2 Backgrounds and Previous Results
Usually, in cryptography, security notions are defined by combining a security
goal and an attack model [4]. Different security goals have been proposed so far,
such as indistinguishability of ciphertexts (IND), one-wayness, non-malleability,...
For example, semantic security [14] formalizes the adversary’s inability to learn
any information about a plaintext M underlying a challenge ciphertext C. This
captures a strong notion of privacy and is also defined as indistinguishability of
ciphertexts. In the symmetric setting of interest to us, IND has been redefined
as left-or-right (LOR), real-or-random (ROR), and find-then-guess (FTG) indis-
tinguishability. All these latter notions, described in [3], encompass the same
security definition. Bellare et al. in [3] have defined several security goals, while
Katz and Yung, in [18], present a complete characterization of the security no-
tions for encryption scheme in the standard model. Based on these two works,
we examine the relations between the standard and the blockwise models.
The blockwise model has been introduced at Crypto 2002 by Joux, Martinet
and Valette in [17]. They show that several encryption schemes such as the CBC
and IACBC are not secure in the BA model. At FSE 2003, Fouque, Martinet
and Poupard in [10] show that a slight variant of the on-line CBC encryption
scheme, and the CFB mode of operation can be proved secure against blockwise
chosen plaintext attack. For this, they introduce a strong security model. We
show here that this model is the strongest one. At SAC 2003, Fouque et al. in [9]
study the security of authenticated on-line encryption mode against blockwise
chosen ciphertext attacks. Finally, at RSA Conf 2004, Boldyreva and Taesombut
introduced new security notions for chosen-ciphertext attacks in [6]. We will not
here take into account such adversaries due to lack of places.
1.3 Our Results
Several papers have considered blockwise adversaries either in order to attack
some schemes such as in [17] or in order to prove security against such adversaries
as in [10, 9, 7]. Our aim is to study the relations between the security notions
in the standard model and in the blockwise model. Therefore, in section 2 we
define more formally several security notions in order to study the relationship
between these notions and the related notions in the standard attacker model.
Then, in section 3, we study relations between the FTG and LOR security goals
for blockwise adaptive chosen plaintext attacks (BCPA) and standard chosen
plaintext attacks (CPA). First of all, in theorem 1, we generalize the result stat-
ing that security in the standard model does not imply security in the blockwise
model. We also show that an equivalence for probabilistic schemes does not hold
for on-line encryption schemes against the new adversarial model. In [18], Katz
and Yung have mainly analyzed the relations between the non-malleability and
Blockwise Adversarial Model for On-line Ciphers 215
the FTG notions for different adversaries having access or not to encryption or
decryption oracles. For the FTG security game, they have proved that oracle
accesses only before the challenge phase is equivalent to oracle accesses before
and after this phase. We show in theorems 2 and 3 that this equivalence no
longer holds in the BA model.
Furthermore, the equivalence of the LOR and FTG security goal is not security
preserving. In fact, the main results of Bellare et al. in [3] of interest for us about
probabilistic schemes are that LOR is the strongest security notion and that
LOR and FTG are not security preserving but are polynomially-equivalent in the
number of messages. We show in theorem 5 (section 3) that LOR and FTG are
not security preserving in the BA model. We show that in the BA model two
definitions of LOR exist. The stronger one corresponds to adversaries which can
concurrently access the oracles. This is the strongest security notion we define.
Moreover, we also exhibit in section 4 a special class of encryption schemes
for which the weakest LOR definition and FTG are exactly equivalent in both
models and not only polynomially related (theorems 4 and 6). This allows better
reductions for these schemes since security is preserved once we have a security
proof under the FTG security notion. Finally, in section 5, we show that the
security under concurrent blockwise adversarial can be achieved with the counter
mode for example.
In appendix A of the full version [11], we fully characterize the relations
between the security of ciphers in the BA model and in the standard one and
prove that for on-line ciphers, also known as deterministic schemes, the two
models are polynomially-equivalent in the number of encrypted blocks. However,
this reduction does not preserve the security since it is quadratic in the number of
encrypted blocks. Furthermore, we show that the bound is tight by exhibiting an
on-line cipher for which the security in the BA adversary model is not guaranteed
if the cipher encrypts more than N blocks although the security in the standard
model is preserved up to the encryption of (N − 1)(N − 2)/2 blocks.
1.4 Notations
In the rest of this paper, we use standard notations and conventions for writing
probabilistic algorithms and experiments. If A is a probabilistic algorithm, then
A(x1, x2, . . . ; r) is the result of running A on inputs x1, x2, . . . and coins r. We let
y ← A(x1, x2, . . . ; r) denote the experiment of picking r at random and letting y
be A(x1, x2, . . . ; r). If S is a finite set then x← S is the operation of picking an
element uniformly from S. We say that y can be output by A(x1, x2, . . .) if there is
some r such that A(x1, x2, . . . ; r) = y. If p(x1, x2, . . .) is a predicate, the notation
Pr[x1 ← S; x2 ← A(x1, y2, . . .); . . . : p(x1, x2, . . .)] denotes the probability that
p(x1, x2, . . .) is true after ordered execution of the listed experiments. In the
sequel, q denotes the number of message queries and µ denotes the total number
of blocks queried. We note by Dd,n the set of d-bit strings, where d is a multiple
of n, and by Permn, the set of permutations on n-bit blocks.
216 P.-A. Fouque, A. Joux, and G. Poupard
2 Security Notions for On-line Encryption Schemes
2.1 Description of On-line Encryption Schemes
We assume that if C = C[0] . . . C[l] is the encryption of M = M [1]M [2] . . ., then
C[0] represents some information used to randomize the encryption process such
as the initialization vector in the CBC encryption mode. Encryption of M [i] is
denoted by C[i]. This formalism is not restrictive and most of the encryption
schemes satisfy it. Moreover, it can be adapted to more exotic schemes.
A (symmetric) on-line encryption scheme SE = (K, E ,D) consists in three
algorithms.
– The randomized key generation algorithm K takes as input a security pa-
rameter k ∈ N and returns a key k; we write k R← K(k).
– The encryption algorithm E can be randomized or stateful. It takes the key
k and a plaintext M and returns a ciphertext C; we write C
R← Ek(M). (If
randomized it flips new coins on each invocations. If stateful, it uses and then
updates a state that is maintained across invocations such as a counter.)
Moreover, on-line encryption schemes can encrypt block M [i] using only
M [1], M [2], . . . , M [i].
– The decryption algorithm D is deterministic and stateless. It takes the key
k and a string C and returns either the corresponding plaintext M or the
symbol ⊥; we write x ← Dk(C) where x ∈ {0, 1}∗ ∪ {⊥}. We require that
Dk(Ek(M)) = M for all M ∈ {0, 1}∗. Moreover, on-line decryption can de-
crypt C[i] only using C[0], . . . , C[i].
2.2 Security Notions for On-line Encryption Schemes
In this section, we adapt the standard security notions for symmetric encryption
schemes to the BA model. Find-Then-Guess. Semantic security captures the
intuitive notion of privacy for an encrypted text. The formulation of semantic
security stipulates that given a ciphertext, a polynomially-bounded adversary
cannot gain any information about the corresponding plaintext (except maybe
its length). The Find-Then-Guess (FTG) goal is an equivalent security notion, as
shown in [3]. The adversary A, viewed as three sub-adversaries A = (A1, Ac, A2),
tries to win the following game: in the find phase, A1 tries to get some infor-
mation and returns some state information in s0. Then in the challenge phase,
Ac gradually submits two messages M0 and M1 to the encryption oracle which
chooses a random bit b at the beginning of the encryption process, encrypts the
blocks of Mb and returns the corresponding blocks Cb to Ac in an interactive
manner. Finally in the guess phase, A2 tries to distinguish whether Cb is the
encryption of M0 or M1. In the standard model, the adversary A1 chooses the
messages M0 and M1. In the BA model, we need to assume that in some cases,
the two messages are chosen by the adversary Ac since this new attacker is more
adaptive and can choose the two messages either at the beginning of the chal-
lenge phase or during it. We add the adversary Ac in order to take into account
the two adversarial models in a single definition.
Blockwise Adversarial Model for On-line Ciphers 217
In the FTG game, A may have access to different oracles during each phase. To
avoid obfuscating security notions, we only define the three most representative
notions: if A is blockwise adaptive in the find phase, then we write BCPA-P1, or in
the find and guess phases, then we write BCPA-P2, or during the challenge phase
and in the find and guess phases, and then we write BCPA-D. The adversary
advantage in winning the FTG game in these different settings for a symmetric
scheme Π is given by:
Advftg−atk
Π,A (k) def=
∣
∣
∣
∣
∣
∣
2 · Pr
⎡
⎣
k← K(1k); b← {0, 1}; s0 ← AO1
1 (1k);
(M0, M1, s1, C)← AOc
c (s0) :
AO2
2 (s1, M0, M1, C) = b
⎤
⎦− 1
∣
∣
∣
∣
∣
∣
where
if atk=BCPA-P1, then O1 = Ebl
k (.) and Oc = Ek(., ., b) and O2 = ε
if atk=BCPA-P2, then O1 = Ebl
k (.) and Oc = Ek(., ., b) and O2 = Ebl
k (.)
if atk=BCPA-D, then O1 = Ebl
k (.) and Oc = Ebl
k (., ., b) and O2 = Ebl
k (.)
We measure as Advftg−atk
Π (k, t, q, µ) = max
A
{Advftg−atk
Π,A (k)} the security of the
scheme Π, where the maximum is over all legitimate A having time-complexity t,
making to the oracle at most q encryption queries totaling µ blocks. A secret-key
encryption scheme is said to be FTG -secure against blockwise adaptive chosen
plaintext attack in the FTG sense if for all polynomial-time probabilistic adver-
saries, the advantage in this guessing game is negligible as a function of the
security parameter k.
Left-Or-Right Indistinguishability. In the LOR security goal, the adver-
sary is allowed to make queries of the form (M0, M1) where M0 and M1 are
equal-length messages. Two experiments are considered. In the first one, each
query is answered with the encryption of the left message; in the second, the
right message is encrypted. Formally, the adversary has access to the left-or-
right oracle EK(LR(., ., b)), where b ∈ {0, 1}: it takes as input pairs of messages
(M0, M1) and, if b = 0, it computes C ← EK(M0) and returns C; else it computes
C ← EK(M1) and returns C. We consider an encryption scheme to be “good” if
a “reasonable” adversary cannot obtain “significant” advantage in distinguishing
the cases b = 0 and b = 1 given access to the left-or-right oracle.
In the BA model, adversaries are allowed to feed the oracle block by block.
This introduces new interactions since the adversary can interleave encryption
blocks for different messages. Consequently, we present two LOR games. In the
first game, called LORS, for LOR with sequential message queries, the adversary
has to finish an encryption query before requesting the next message. In the
second game, called LORC, for LOR with concurrent accesses, the adversary can
interleaved the block queries of different messages.
The Ebl,s
k (M0[i], M1[i], b) oracle is a LOR-block encryption oracle: the adver-
sary is allowed to query multiple pairs of messages (M j
0 , M j
1 ) with the restriction
that it begins the encryption of a new pair of messages only if it has finished
218 P.-A. Fouque, A. Joux, and G. Poupard
the encryption of the previous pair. In the Ebl,c
k (M j
0 [i], M j
1 [i], b) oracle, we add
a session identifier sid since the adversary is not limited to sequence its pairs of
messages but can interleaved the session queries. The session identifier will be
the first element in the query. Equivalently, we can say that the adversary can
run multiple Ebl,c
k (sid, M j
0 [i], M j
1 [i], b) oracles concurrently.
Advlors−bcpa
Π,A (k) =
∣
∣
∣2 · Pr
[
k← K(1k); b← {0, 1} : AEbl,s
k (LR(.,.,b))(k) = b
]
− 1
∣
∣
∣
Advlorc−bcpa
Π,A (k) =
∣
∣
∣2 · Pr
[
k← K(1k); b← {0, 1} : AEbl,c
k (LR(.,.,.,b))(k) = b
]
− 1
∣
∣
∣
Therefore, we define the Advlors−bcpa
Π (k, t, q, µ) = max
A
{Advlors−bcpa
Π,A (k)}, where
the maximum is over all legitimate A having time-complexity t, making to
the concurrent oracles at most q encryption queries totaling µ blocks (resp.
Advlorc−bcpa
Π (k, t, q, µ) = max
A
{Advlorc−bcpa
Π,A (k)}). A secret-key encryption scheme
is said to be LOR-secure against blockwise adaptive chosen plaintext attack in
the LORS sense (resp. LORC) if, for all polynomial-time probabilistic adversaries,
the advantage in this guessing game is negligible as a function of the security
parameter k.
3 Relations Between the Standard and Blockwise Models
In this section, we study relations between the BA and standard models for
probabilistic schemes. Figure 1 presents the main relations we prove in the sequel.
First, it is easy to see that FTG-BCPA-P1 implies FTG-CPA-P1, FTG-BCPA-
P2 implies FTG-CPA-P2, and LORS-BCPA implies LOR-CPA since the standard
model can be easily simulated in the BA model. Secondly, it is also clear from the
definitions of FTG-BCPA-P1, FTG-BCPA-P2, FTG-BCPA-D, LORC and LORS,
that FTG-BCPA-P2 implies FTG-BCPA-P1, FTG-BCPA-D implies FTG-BCPA-
P2, and LORC-BCPA implies LORS-BCPA. Thirdly, using hybrid arguments, it
is easy to prove the implication between LORS-BCPA and FTG-BCPA-D (see in
appendix of the full version).
In a lot of counterexamples, we use encryption schemes Π that treat the
blocks such that there is no way to distinguish an input block from an output
(in particular no redundancy is added on the input blocks): ∀i ≥ 1, n = |C[0]| =
|M [i]| = |C[i]|.
We use the notation A⇒ B to indicate a security-preserving reduction from
notion A to notion B. A
q→ B indicates a reduction (not necessarily security-
preserving) from A to B. We also assume that E is a symmetric encryption
scheme operating on n-bit blocks with a k-bit secret key k.
3.1 Blockwise Adversaries are Stronger Than Standard Ones
The following theorem shows the separation between BCPA and CPA adversaries
for the goals FTG-P1, FTG-P2 and LORS. It is a generalization of a result of
paper [17] which only state that FTG-CPA-P2 	⇒ FTG-BCPA-P2.
Blockwise Adversarial Model for On-line Ciphers 219
�
�
�
�
�
�
�
�
�
�
�
�
�
�
�
�
�
�
FTG-BCPA-P1
FTG-CPA-P1
FTG-BCPA-P2
FTG-CPA-P2
FTG-BCPA-D LORS-BCPA
LOR-CPA
LORC-BCPA
[18] [3]
Th 1 Th 1 Th 1
Th 2 Th 3 Th 4,6
Th 5
Fig. 1. Relations between the FTG and LOR security goals in the standard and BA mod-
els. In the figure, a plain arrow means that security in the first notion implies security
in the second, a hatched arrow means that the first notion does not imply the second,
and a dashed arrow indicates that the security between the two notions is not preserved
Theorem 1. [FTG-CPA-P1 	⇒ FTG-BCPA-P1 and FTG-CPA-P2 	⇒ FTG-BCPA-
P2 and LOR-CPA	⇒ LORS-BCPA] If there exists an on-line encryption scheme Π
which is secure in the sense of FTG-CPA-P1 (resp. FTG-CPA-P2 or LOR-CPA),
then there exists an on-line encryption scheme Π ′ which is also secure in the
sense of FTG-CPA-P1 (resp. FTG-CPA-P2 or LOR-CPA) but which is not FTG-
BCPA-P1 secure (resp. FTG-BCPA-P2 or BCPA-LORS) assuming the existence
of pseudo-random permutations.
Proof. Assume that there exists some FTG-CPA-P1 secure on-line encryption
scheme Π = (K, E ,D), since otherwise the theorem is vacuously true. We now
modify Π to a new on-line encryption scheme Π ′ = (K, E ′,D′) which is also
FTG-CPA-P1 secure but not secure in the FTG-BCPA-P1 sense:
Algorithm E ′
k(M [i]) Algorithm D′
k(C[i]‖v)
If i = 2 and M [2] = C[1] return Dk(C[i])
then return Ek(M [2])‖k
else return Ek(M [i])‖0k
In the description of Π ′, 0k denotes the concatenation of k zeros, and v denotes
a k-bit value.
A BCPA adversary can choose the message blocks so that the relation M [2] =
C[1] holds with probability 1. Hence a BCPA adversary obtains the secret key
and easily wins the FTG game. Thus Π ′ is not FTG-BCPA-P1 secure.
However a CPA adversary cannot choose the blocks. Then the relation holds
with probability 1/2n for each message queried if Ek is a pseudo-random per-
mutation. Indeed, except if the relation M [2] = C[1] holds, the CPA adver-
sary gains no additional advantage in winning the FTG game against Π ′ than
against Π. Therefore, it is easy to show that if Π is secure, then so is Π ′:
Advftg−cpa−p1
Π′ (k, t, q, µ) ≤ Advftg−cpa−p1
Π (k, t, q, µ) + 2q/2n. We can prove this
220 P.-A. Fouque, A. Joux, and G. Poupard
result using different games as in [21]. The first game G0 is the real security
game and in the next game G1, the simulation is stopped as soon as the relation
M [2] = C[1] holds. The difference between the two games can be analyzed using
the probability of collision. Let F be the event M [2] = C[1], S be the event of
the adversary wins the FTG security game against Π and S′ be the event the
adversary wins the FTG security game against Π ′. As long as F does not occur,
Pr[S] = Pr[S′] so Pr[S∧¬F ] = Pr[S′∧¬F ]. Therefore, |Pr[S]−Pr[S′]| ≤ Pr[F ] as
a lemma in [21] shows. Then, it is easy to upper bound Pr[F ] by q/2n since each
call will be independent (a new random value is used for each message query)
and Advftg−cpa−p1
Π′ (k, t, q, µ) ≤ Advftg−cpa−p1
Π (k, t, q, µ) + 2q/2n. The factor of 2
comes from the fact that the advantage is twice the probability of success minus
1. Consequently, Π ′ is FTG-CPA-P1 secure but is not FTG-BCPA-P1 secure. This
conversion can be adapted to prove the separation between FTG-BCPA-P2 and
FTG-CPA-P2, and between LORS-BCPA and LOR-CPA.
3.2 Adaptive Adversaries Can be More Powerful in the Blockwise
Model
Adaptive adversaries. Katz and Yung show in [18] that accesses to an adap-
tive encryption oracle after the challenge phase do not help an CPA adversary.
Formally, they show that FTG-CPA-P1 is polynomially-equivalent in the num-
ber of message queries to FTG-CPA-P2. In the BA model, this equivalence is no
longer valid and we prove that BCPA-P2 adversaries are strictly stronger than
BCPA-P1 ones since the CBC encryption mode is FTG-BCPA-P1 but not FTG-
BCPA-P2 according to [17]. Finally, it is worth noticing in the following proof
that if the condition M [4] = C[3] is not present, the scheme Π ′ is not FTG-CPA-
P1. Thus, as one could believe at first glance, the counterexample we use in the
proof cannot be applied in the standard model.
Theorem 2. [FTG-BCPA-P1 	⇒ FTG-BCPA-P2] If there exists an on-line en-
cryption scheme Π which is FTG-BCPA-P1 secure, then there exists an on-line
encryption scheme Π ′ which is also secure FTG-BCPA-P1 secure but not FTG-
BCPA-P2 secure assuming the existence of pseudo-random permutations.
Proof. Assume that there exists some FTG-BCPA-P1 secure on-line encryption
scheme Π = (K, E ,D), since otherwise the theorem is vacuously true. We now
modify Π to a new on-line encryption scheme Π ′ = (K, E ′,D′) which is also
FTG-BCPA-P1 secure but not secure in the FTG-BCPA-P2 sense. The new on-
line encryption scheme Π ′ = (K, E ′,D′) is defined as follows:
Algorithm E ′
k(M [i]) Algorithm D′
k(C[i]‖b′)
If (i = 4) ∧ (M [4] = C[3]) ∧ (Dm
k (M [2]‖M [3]) = M [1]) return Dk(C[i])
then return Ek(M [4])‖1
else return Ek(M [i])‖0
where Dm
k (C) denotes the decryption of the whole ciphertext C using the se-
cret key k and not only as the decryption of one block of the ciphertext. More
precisely, in the above description, the block M [2] is treated for example as the
initialization vector C[0] and M [3] is the encryption of the first block.
Blockwise Adversarial Model for On-line Ciphers 221
Every BCPA adversary can choose the blocks of messages such that the relation
M [4] = C[3] holds with probability 1. We show that a FTG-BCPA-P2 adver-
sary A, can win its FTG game, i.e. distinguish between the encryption of M0
and M1. Now A tries to correctly guess the bit b. In the challenge phase, A
chooses two different random blocks {0, 1}n, M0[1] and M1[1] and sends them
to the encryption oracle which returns Cb[0]‖Cb[1]. In the guess phase, A sends
M [1] = M0[1] and receives C[0]‖C[1]. Then, A sends M [2] = Cb[0], receives
C[2], and sends M [3] = Cb[1] except the last bit and receives C[3]. Finally, A
sends M [4] = C[3] and the encryption oracle returns Ek(M [4])‖d. If d = 1, then
A has correctly guessed the bit b = 0, since Dm
k (M [2]‖M [3]) = M [1] (because
if b = 0, then Dm
k (Cb[0]‖Cb[1]) = M0[1]). Therefore A wins the FTG game with
probability 1. Hence a FTG-BCPA-P1 adversary B, which has not access to a
blockwise encryption oracle after the challenge phase cannot win the game with
significant advantage. Indeed, assume that there exists a FTG-BCPA-P1 adver-
sary A against scheme Π ′, then we will construct a FTG-BCPA-P1 attacker B
against scheme Π. The attacker B will simulate the challenger to the adversary
A. The event Dm
k (M [2]‖M [3]) = M [1] can appear in two situations: either at
random with probability 1/2n for each message, if Ek is a pseudo-random permu-
tation, or since the attacker B knows all encryption queries of A, he can decide
when this event occurs in the second case. Consequently, B is able to simulate
the encryption process to A except in the first case which appears with small
probability. Consequently, Π ′ is FTG-BCPA-P1 secure but is not FTG-BCPA-P2
secure.
Adaptive adversaries during the challenge phase. We also prove that
adversaries adaptive before, during and after the challenge phase, BCPA-D, are
stronger than adversary, BCPA-P2 adaptive before and after. The notion of
BCPA-D adversaries is equivalent to BCPA-P2 in the standard adversarial model
since messages are treated as atomic objects.
Theorem 3. [FTG-BCPA-P2 	⇒ FTG-BCPA-D] If there exists an on-line en-
cryption scheme Π which is FTG-BCPA-P2 secure, then there exists an on-line
encryption scheme Π ′ which is also FTG-BCPA-P2 secure but not FTG-BCPA-D
secure assuming the existence of pseudo-random permutations.
Proof. Assume that there exists some FTG-BCPA-P2 secure on-line encryption
scheme Π = (K, E ,D), since otherwise the theorem is vacuously true. We now
modify Π to a new on-line encryption scheme Π ′ = (K, E ′,D′) which is also
FTG-BCPA-P2 secure but not FTG-BCPA-D secure. The new on-line encryption
scheme Π ′ = (K, E ′,D′) is a slight modification of the encryption function E
defined as follows:
Algorithm E ′
k(M [i]) Algorithm D′
k(C[i])
If i = 3 and M [2] = C[1] If i = 3 and M [2] = C[1]
then return M [3] then return C[3]
else return Ek(M [i]) else return Dk(C[i])
222 P.-A. Fouque, A. Joux, and G. Poupard
Clearly Π ′ is FTG-BCPA-P2 secure as Π as shown in the previous proofs. A
BCPA adversary can choose the blocks of messages such that the relation M [2] =
C[1] holds with probability 1 during the challenge phase. Therefore a FTG-
BCPA-D adversary A can distinguish between the encryption of M0 and M1: A
first sends (M0[1], M1[1]), gets C[0]‖C[1], and then queries (M0[2], M1[2]) where
M0[2] = C[1] and M0[2] 	= C[1]. Finally, he queries (M0[3], M1[3]) such that
M0[3] 	= M1[3]. Consequently, if he receives C[3] = M0[3], then b = 0, otherwise
b = 1. Hence Π ′ is FTG-BCPA-P2 secure but is not FTG-BCPA-D secure.
Relation between FTG and LOR in the BA model. In [3] Bellare et al.
prove that in the standard model FTG and LOR are polynomially-equivalent in
the number of encrypted queries. We prove here in the BA model that this rela-
tion holds between FTG-BCPA-D and LORS-BCPA. The proof is an adaptation
of [3] and uses the same hybrid argument (introduced in [12]) in the blockwise
setting. It is given in appendix of the full version.
Theorem 4. [LORS-BCPA ⇒ FTG-BCPA-D
q→ LORS-BCPA] For any scheme
SE = (K, E ,D),
Advftg−bcpa−d
SE (k, t, q, µ) ≤ Advlors−bcpa
SE (k, t, q, µ) ≤ q × Advftg−bcpa−d
SE (k, t, q, µ)
3.3 Concurrent Adversaries
Finally, we show that LORC-BCPA is the strongest security notion in the block-
wise model. Concurrent adversaries have already been considered in other con-
texts such as zero-knowledge proofs in [8]. According to our knowledge, it is
the first time that concurrent adversaries appear in encryption schemes. In the
BA model and for the LOR game, this notion is natural.
Theorem 5. [LORS-BCPA	⇒ LORC-BCPA] If there exists an on-line encryption
scheme Π which is LORS-BCPA secure, then there exists an on-line encryption
scheme Π ′ which is also LORS-BCPA secure but not LORC-BCPA secure assum-
ing the existence of pseudo-random permutations.
Proof. Assume that there exists some LORS-BCPA secure on-line encryption
scheme Π = (K, E ,D), since otherwise the theorem is vacuously true. We now
modify Π to a new on-line encryption scheme Π ′ = (K′, E ′,D′) which is also
LORS-BCPA secure but not secure in the LORC-BCPA sense. The new on-line
encryption scheme Π ′ = (K, E ′,D′) is a slight modification of the functions E
and D :
Algorithm E ′
k(M [i])
If i = 3 and C[1] = Dm
k (M [2]‖M [3])
then return M [3]
else return Ek(M [i])
where Dm
k (M) denotes the decryption of the whole message M using the key k
and the decryption can be easily adapted.
Blockwise Adversarial Model for On-line Ciphers 223
Clearly Π ′ is LORS-BCPA secure as the initial scheme Π. Indeed, assume for
the sake of contradiction that there exists a LORS-BCPA adversary A′ against
Π ′. We must show that there also exists a LORS-BCPA adversary A against Π.
We have to simulate the challenger against A′. The only difference between the
two schemes is in the encryption of the third block if some relation occurs. The
relation can hold either by a correct guess of the adversary which is negligible if
Ek behaves as a pseudo-random permutation or if a collision occurs with previous
encryption queries. The last event is easily detectable by adversary A since all
encryption queries goes through A which forwards them to its challenger. Hence,
it is easy for A to not encrypt the third block if the relation occurs. In this case,
the simulation is quite perfect.
Any LORC-BCPA adversary can choose the message blocks such that the rela-
tion C[1] = Dm
k (M [2]‖M [3]) holds with probability 1. Indeed, a LORC-BCPA ad-
versary A begins the encryption of a pair of messages (M0, M1) by sending
(M0[1], M1[1]) to a first instance of the LOR-block encryption oracle which re-
turns Cb[0]‖Cb[1]. Then, he sends (M ′
0[1], M ′
1[1]) where M ′
0[1] = Cb[1] to a
second instance running concurrently and gets C ′
b[0]‖C ′
b[1]. He continues the
encryption of (M0, M1) by sending (M0[2], M1[2]) such that M0[2] = C ′
b[0] and
M1[2] is a random block. Finally, he queries (M0[3], M1[3]) with M0[3] = C ′
b[1].
A simple manipulation shows that if b = 0, then C0[1] = Dm
k (C ′
0[0]‖C ′
0[1]) and
consequently Ek(M0[3]) = M0[3]. Therefore Π ′ is LORS-BCPA secure but is not
LORC-BCPA secure.
4 On-line Encryption Schemes with a Special Property
In this section we define a new property for on-line encryption schemes, called
Resettable-Or-Continuous (ROC). For these schemes, the two security notions
LORS-BCPA and FTG-BCPA-D are exactly equivalent.
The Resettable-Or-Continuous property can be defined informally as follows:
it is computationally hard for a polynomial-time adversary to distinguish with
non-negligible advantage between the encryption of the concatenation of a poly-
nomial number of messages, E(M1‖M2‖ . . . ‖M�(k)), and the concatenation of
the encryptions of the same messages E(M1)‖E(M2)‖ . . . ‖E(M�(k)) for state-
ful encryption schemes such as the counter mode or for a stateless encryption
scheme between E(M1‖r1‖M2‖r2 . . . ‖r�(k)−1‖M�(k)), where the ri’s denote ran-
dom blocks such that the length of the two bitstring be the same. This special
class captures many important on-line encryption schemes such as the CBC and
CTR mode [3].
Formally, we define the resettable-or-continuous oracle ROC(Ebl
k (.), b), tak-
ing as input a message M and working as follows for a stateless encryption
scheme such as the CBC. At the beginning of the game, the ROC oracle chooses
a random bit b. The first message M = M [1]M [2] . . . M [l] is encrypted by the
ROC oracle which returns C[0]C[1] . . . C[l]. The adversary is free to stop this
224 P.-A. Fouque, A. Joux, and G. Poupard
encryption by using the stop command or to submit a new message block
by block. When the adversary submits the stop command and if b = 0, the
ROC encryption oracle stops the encryption of M and starts the encryption
of the new message M ′[1], . . . M [l′] under the key k and a new random value
C ′[0] and returns C ′ = C ′[0]C ′[1] . . . C ′[l′]. However if b = 1, the ROC oracle
does not stop the encryption of the first message. He takes a random block
r1 ∈ {0, 1}n, encrypts it into C ′[0] as if r1 was the next block in M . Then, he
encrypts the message M ′[1]M ′[2] . . . M ′[l′] block by block and returns gradu-
ally C ′[0]C ′[1]C ′[2] . . . C ′[l′]. In the case b = 1, the ROC encryption oracle has
encrypted the concatened message M [1] . . . M [l]‖r1‖M ′[1] . . . M ′[l′]. This game
continues for the other queries. This simulation can be made for any stateless
encryption scheme such as the CBC mode. For a stateful encryption scheme such
as the CTR mode, the random block is not present when b = 1. This property
can also be defined in the standard model.
Advind−roc
Π,A (k, t, q, µ) def=
∣
∣
∣2 · Pr
[
k← K(1k); b← {0, 1} : AROC(Ebl
k (.),b)(k)=b
]
−1
∣
∣
∣
Therefore, the security bound for the scheme Π is given by Advind−roc
Π (k, t, q, µ) =
max
A
{Advind−roc
Π,A (k)}, where the maximum is over all legitimate A having time-
complexity t, making to the oracle at most q encryption queries totaling µ blocks.
A secret-key encryption scheme is said to be IND-secure against blockwise adap-
tive chosen plaintext attack in the ROC sense if for all polynomial-time proba-
bilistic adversaries, the advantage in this game is negligible as a function of the
security parameter. The ROC class is the set of encryption schemes satisfying
the ROC property.
Theorem 6. [FTG-BCPA-D ROC⇒ LORS-BCPA] For any ROC scheme SE,
Advlors−bcpa
SE (k, t, q, µ) ≤ Advftg−bcpa−d
SE (k, t, q, µ) + Advind−roc
SE (k, t, q, µ)
Proof. The proof goes by contradiction. Let SE be a ROC encryption scheme.
Assume for the sake of contradiction that a LORS-BCPA adversary A wins the
LORS game against SE with non-negligible advantage. Then it can be used to
build a BCPA-D attacker B winning a FTG game against SE with non-negligible
advantage. The FTG adversary B does not use his find phase and begins the
challenge phase by running A. To simulate the LORS encryption queries of A,
B forwards the pairs of messages block by block and does not send the stop
command at the end of a message query. All messages are chained. The messages
are separated with a random block chosen by B in the case of stateless schemes
and are not separated for stateful schemes. This simulation is perfect for schemes
having the ROC property. Therefore, A wins the LORS game with non-negligible
advantage and B forwards the bit guessed by A and also wins the FTG game
with non-negligible advantage.
Blockwise Adversarial Model for On-line Ciphers 225
5 Security Under Concurrent Adversary
In this section, we prove that security against concurrent adversaries can be
achieved. We prove that the randomized counter mode, called XOR in [3] is se-
cure. We note that encryption with XOR or CTR mode of operation does not
require permutations. Therefore we use only functions. We prove such scheme
and not the standard counter mode where the counter is incremented between
each message since in the concurrent scenario, the adversary can begin the en-
cryption of several messages in parallel.
We consider several attacker games such that the distance between each game
can be easily shown. In the last game, it will be clear that the adversary has no
way to get some information about the random bit b in the LORC security game.
Theorem 7. For any adversary A running within time bound t, with less than
q < 2n/2 calls to the function F , totalling at most µ blocks,
Advlorc−bcpa
XOR,A (k, t, q, µ) ≤ Advprf
F,A(k, t, q) +
q(q − 1)
2n
where n denotes the block length, Advprf
F,A(k, t, q), the advantage of the adversary
A in distinguishing a function taken from F to a random function with at most
q black-box queries within time bounded by t. The same kind of definition can be
given for Advlorc−bcpa
XOR,A (k, t, q, µ).
The proof is in the full version [11].
6 Conclusion
In this paper we have analyzed the relations between the block adversary and the
standard models for probabilistic and deterministic schemes. For probabilistic
schemes, the relations are modified and we introduce new security notions. The
resettable-or-continuous property extends the result of Bellare et al.. Moreover,
we also prove that concurrent accesses lead to the strongest security notion
and we show that some schemes can be secure in this setting. Finally, we show
that the models are equivalent for deterministic schemes in appendix of the full
version.
References
1. M. Bellare, J. Black, T. Krovetz, and P. Rogaway. OCB : A Block-Cipher
Mode of Operation for Efficient Authenticated Encryption. Available at
http : //www.cs.ucdavis.edu/users/~rogaway, 2001.
2. M. Bellare, A. Boldyreva, L. Knudsen, and C. Namprempre. On-Line Ciphers
and the Hash-CBC Constructions. In Crypto ’01, LNCS 2139, pages 292–309.
Springer-Verlag, 2001.
3. M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A Concrete Security Treatment
for Symmetric Encryption. In Proc. 38th of FOCS, pages 394–403. IEEE, 1997.
226 P.-A. Fouque, A. Joux, and G. Poupard
4. M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations Among Notions
of Security for Public-Key Encryption Schemes. In Crypto ’98, LNCS 1462, pages
26–45. Springer-Verlag, 1998.
5. M. Bellare and P. Rogaway. On the Construction of Variable-Input-Length Ciphers.
In FSE ’99, LNCS 1636. Springer-Verlag, 1999.
6. A. Boldyreva and N. Taesombut. On-line Encryption Schemes: New Security No-
tions and Constructions. In RSA Conf 2004, LNCS, pages –. Springer-Verlag,
Berlin, 2003.
7. Y. Dodis and J. H. An. Concealment and Its Applications to Authenticated En-
cryption. In Eurocrypt ’03, LNCS 2656, pages 312–329. Springer-Verlag, 2003.
8. C. Dwork, M. Naor, and A. Sahai. Concurrent Zero-Knowledge. In Proc. of the
30th STOC, pages 409–418. ACM Press, New York, 1998.
9. P. A. Fouque, A. Joux, G. Martinet, and F. Valette. Authenticated On-line En-
cryption. In Selected Areas in Cryptography ’03, LNCS. Springer-Verlag, 2003. To
appear.
10. P. A. Fouque, G. Martinet, and G. Poupard. Practical Symmetric On-line Encryp-
tion. In Fast Software Encryption ’03, LNCS. Springer-Verlag, 2003. To appear.
11. P. A. Fouque, A. Joux, and G. Poupard. Blockwise Adversarial Model for On-line
Ciphers and Symmetric Encryption Schemes. In Selected Areas in Cryptography
’04, LNCS. Springer-Verlag, 2004. http://www.di.ens.fr/~fouque/pubs/.
12. O. Goldreich. Foundations of Cryptography. Cambridge University Press, Weiz-
mann Institute of Science, 2001. Basic Tools.
13. O. Goldreich, S. Goldwasser, and S. Micali. How to Construct Random Functions.
Journal of the ACM, 33(4):210–217, 1986.
14. S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and
System Sciences, 28:270–299, 1984.
15. A. Herzberg, S. Jarecki, H. Krawczyk, and M. Yung. A Tweakable Enciphering
Mode. In Crypto ’03, LNCS. Springer-Verlag, 2003.
16. R. Housley. Cryptographic message syntax. S/MIME Working Group of the IETF,
Internet-draft draft-ietf-smime-cms-12.txt, March 1999.
17. A. Joux, G. Martinet, and F. Valette. Blockwise-Adaptive Attackers: Revisiting
the (in)security of some provably secure Encryptions Modes: CBC, GEM, IACBC.
In Crypto ’02, LNCS 2442, pages 17–31. Springer-Verlag, 2002.
18. J. Katz and M. Yung. Complete characterization of security notions for probabilis-
tic private-key encryption. In STOC ’00. ACM Press, 2000.
19. NBS. FIPS PUB 81 - DES Modes of Operation, December 1980.
20. R. Rivest. All-or-nothing encryption and the package transform. In FSE ’97, LNCS
1267. Springer-Verlag, 1997.
21. V. Shoup. OAEP Reconsidered. In Crypto ’2001, LNCS 2139, pages 239–259.
Springer-Verlag, Berlin, 2001.
	Introduction
	Standard Versus Blockwise Adversarial Model
	Backgrounds and Previous Results
	Our Results
	Notations
	Security Notions for On-line Encryption Schemes
	Description of On-line Encryption Schemes
	Security Notions for On-line Encryption Schemes
	Relations Between the Standard and Blockwise Models
	Blockwise Adversaries are Stronger Than Standard Ones
	Adaptive Adversaries Can be More Powerful in the Blockwise Model
	Concurrent Adversaries
	On-line Encryption Schemes with a Special Property
	Security Under Concurrent Adversary
	Conclusion